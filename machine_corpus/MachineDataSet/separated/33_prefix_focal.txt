void test1 ( ) throws Throwable { JVCRequestContext jVCRequestContext0 = JVCDispatcher . getRC ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JVCRequestContext getRC ( ) { return ctxHolder . get ( ) ; }
void test3 ( ) throws Throwable { JVCDispatcher jVCDispatcher0 = new JVCDispatcher ( ) ; jVCDispatcher0 . destroy ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void destroy ( ) ; }
void test5 ( ) throws Throwable { Throwable throwable0 = new Throwable ( ) ; Log . warn ( ( Object ) null , throwable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void warn ( Object message ) { if ( log4jAvailable ) { Logger . getLogger ( LOG_NAME ) . warn ( message ) ; } else { System . out . println ( LOG_NAME + " warn - " + message ) ; } }
void test7 ( ) throws Throwable { Throwable throwable0 = new Throwable ( ) ; Log . error ( ( Object ) null , throwable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test0 ( ) throws Throwable { NonStandardResponseException nonStandardResponseException0 = new NonStandardResponseException ( 1 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test0 ( ) throws Throwable { String string0 = JVCRequestContext . getCachedBlock ( "dG3OaO : MBz9ju * vy" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCachedBlock ( String key ) { return ( cacheMap = = null ) ? null : cacheMap . get ( key ) ; }
void test0 ( ) throws Throwable { BinaryResponseException binaryResponseException0 = new BinaryResponseException ( ( InputStream ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test0 ( ) throws Throwable { TokenMgrError tokenMgrError0 = new TokenMgrError ( false , 1200 , 1200 , 1200 , "" , '\f' , ( int ) '\f' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test1 ( ) throws Throwable { TokenMgrError tokenMgrError0 = new TokenMgrError ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test2 ( ) throws Throwable { TokenMgrError tokenMgrError0 = new TokenMgrError ( false , 1194 , 1194 , 1194 , "LexicalRerror at line " , '\u0000' , ( int ) '\u0000' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test3 ( ) throws Throwable { String string0 = TokenMgrError . LexicalError ( false , ( - 1268 ) , ( - 1268 ) , ( - 1268 ) , "UM } + * E67_ = #% , " , '\b' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( "Lexical error at line " + errorLine + " , column " + errorColumn + " . Encountered : " + ( EOFSeen ? " < EOF > " : ( "\"" + addEscapes ( String . valueOf ( curChar ) ) + "\"" ) + " ( " + ( int ) curChar + " ) , " ) + "after : \"" + addEscapes ( errorAfter ) + "\"" ) ; }
void test4 ( ) throws Throwable { String string0 = TokenMgrError . LexicalError ( false , ( - 1287 ) , ( - 1287 ) , ( - 1287 ) , "Lexical error at line " , '\t' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( "Lexical error at line " + errorLine + " , column " + errorColumn + " . Encountered : " + ( EOFSeen ? " < EOF > " : ( "\"" + addEscapes ( String . valueOf ( curChar ) ) + "\"" ) + " ( " + ( int ) curChar + " ) , " ) + "after : \"" + addEscapes ( errorAfter ) + "\"" ) ; }
void test5 ( ) throws Throwable { String string0 = TokenMgrError . LexicalError ( false , ( int ) '\f' , ( int ) '\f' , 1200 , "Lexical error at line 1200 , column 1200 . Encountered : \"\f\" ( 12 ) , after : \"\"" , '\f' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( "Lexical error at line " + errorLine + " , column " + errorColumn + " . Encountered : " + ( EOFSeen ? " < EOF > " : ( "\"" + addEscapes ( String . valueOf ( curChar ) ) + "\"" ) + " ( " + ( int ) curChar + " ) , " ) + "after : \"" + addEscapes ( errorAfter ) + "\"" ) ; }
void test7 ( ) throws Throwable { TokenMgrError tokenMgrError0 = new TokenMgrError ( false , 1209 , 1209 , 1209 , "LexicalRerror at line " , '\u0007' , ( int ) '\u0007' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test8 ( ) throws Throwable { String string0 = TokenMgrError . LexicalError ( true , 0 , 0 , 0 , "t" , 'B' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String LexicalError ( boolean EOFSeen , int lexState , int errorLine , int errorColumn , String errorAfter , char curChar ) { return ( "Lexical error at line " + errorLine + " , column " + errorColumn + " . Encountered : " + ( EOFSeen ? " < EOF > " : ( "\"" + addEscapes ( String . valueOf ( curChar ) ) + "\"" ) + " ( " + ( int ) curChar + " ) , " ) + "after : \"" + addEscapes ( errorAfter ) + "\"" ) ; }
void test0 ( ) throws Throwable { ParseException parseException0 = new ParseException ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ParseException ( Token currentTokenVal , int [ ] [ ] expectedTokenSequencesVal , String [ ] tokenImageVal ) { super ( initialise ( currentTokenVal , expectedTokenSequencesVal , tokenImageVal ) ) ; currentToken = currentTokenVal ; expectedTokenSequences = expectedTokenSequencesVal ; tokenImage = tokenImageVal ; }
void test1 ( ) throws Throwable { Token token0 = new Token ( 1132 , " ) iS } 3aENo\"5h`l } Pa" ) ; int [ ] [ ] intArray0 = new int [ 6 ] [ 3 ] ; Token token1 = Token . newToken ( 0 ) ; token0 . next = ( com . pmdesigns . jvc . tools . Token ) token1 ; String [ ] stringArray0 = new String [ 5 ] ; ParseException parseException0 = new ParseException ( token0 , intArray0 , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test2 ( ) throws Throwable { ParseException parseException0 = new ParseException ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMessage ( ) { return super . getMessage ( ) ; }
void test5 ( ) throws Throwable { Token token0 = new Token ( 971 , "" ) ; int [ ] [ ] intArray0 = new int [ 1 ] [ 3 ] ; Token token1 = Token . newToken ( 0 ) ; token0 . next = ( com . pmdesigns . jvc . tools . Token ) token1 ; String [ ] stringArray0 = new String [ 12 ] ; ParseException parseException0 = new ParseException ( token0 , intArray0 , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test6 ( ) throws Throwable { String string0 = ParseException . add_escapes ( "BvuyW ; WmH ! Jr [ 4T & " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 | | ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
void test7 ( ) throws Throwable { String string0 = ParseException . add_escapes ( "z ? < I\n" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 | | ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
void test8 ( ) throws Throwable { String string0 = ParseException . add_escapes ( "\" at liIne " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 | | ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
void test9 ( ) throws Throwable { String string0 = ParseException . add_escapes ( "j'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '\b' : retval . append ( "\\b" ) ; continue ; case '\t' : retval . append ( "\\t" ) ; continue ; case '\n' : retval . append ( "\\n" ) ; continue ; case '\f' : retval . append ( "\\f" ) ; continue ; case '\r' : retval . append ( "\\r" ) ; continue ; case '\"' : retval . append ( "\\\"" ) ; continue ; case '\'' : retval . append ( "\\\'" ) ; continue ; case '\\' : retval . append ( "\\\\" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 | | ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "\\u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; }
void test0 ( ) throws Throwable { FileDescriptor fileDescriptor0 = FileDescriptor . err ; FileReader fileReader0 = new FileReader ( fileDescriptor0 ) ; SimpleCharStream simpleCharStream0 = new SimpleCharStream ( ( Reader ) fileReader0 ) ; JVCParserTokenManager jVCParserTokenManager0 = new JVCParserTokenManager ( simpleCharStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void ReInit ( java . io . InputStream stream ) { ReInit ( stream , null ) ; }
void test1 ( ) throws Throwable { SimpleCharStream simpleCharStream0 = new SimpleCharStream ( ( Reader ) null , ( - 1049 ) , 825 , ( int ) ( byte ) 84 ) ; JVCParserTokenManager jVCParserTokenManager0 = new JVCParserTokenManager ( simpleCharStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setDebugStream ( java . io . PrintStream ds ) { debugStream = ds ; }
void test3 ( ) throws Throwable { StringReader stringReader0 = new StringReader ( "'" ) ; SimpleCharStream simpleCharStream0 = new SimpleCharStream ( ( Reader ) stringReader0 ) ; JVCParserTokenManager jVCParserTokenManager0 = new JVCParserTokenManager ( simpleCharStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test4 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 10 ] ; byteArray0 [ 0 ] = ( byte ) ( - 35 ) ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; DataInputStream dataInputStream0 = new DataInputStream ( ( InputStream ) byteArrayInputStream0 ) ; InputStreamReader inputStreamReader0 = new InputStreamReader ( ( InputStream ) dataInputStream0 ) ; SimpleCharStream simpleCharStream0 = new SimpleCharStream ( ( Reader ) inputStreamReader0 , ( int ) ( byte ) 2 , ( int ) ( byte ) 109 ) ; JVCParserTokenManager jVCParserTokenManager0 = new JVCParserTokenManager ( simpleCharStream0 ) ; Token token0 = jVCParserTokenManager0 . getNextToken ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test5 ( ) throws Throwable { char [ ] charArray0 = new char [ 10 ] ; charArray0 [ 0 ] = 'o' ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 ) ; SimpleCharStream simpleCharStream0 = new SimpleCharStream ( ( Reader ) charArrayReader0 , ( int ) 'S' , ( int ) 'K' , 10 ) ; JVCParserTokenManager jVCParserTokenManager0 = new JVCParserTokenManager ( simpleCharStream0 ) ; jVCParserTokenManager0 . getNextToken ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String GetImage ( ) { if ( bufpos > = tokenBegin ) return new String ( buffer , tokenBegin , bufpos - tokenBegin + 1 ) ; else return new String ( buffer , tokenBegin , bufsize - tokenBegin ) + new String ( buffer , 0 , bufpos + 1 ) ; }
void test6 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 10 ] ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; SimpleCharStream simpleCharStream0 = new SimpleCharStream ( ( InputStream ) byteArrayInputStream0 , ( int ) ( byte ) 0 , 4096 ) ; JVCParserTokenManager jVCParserTokenManager0 = new JVCParserTokenManager ( simpleCharStream0 , ( int ) ( byte ) 0 ) ; jVCParserTokenManager0 . getNextToken ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getBeginColumn ( ) { return bufcolumn [ tokenBegin ] ; }
void test7 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 10 ] ; byteArray0 [ 1 ] = ( byte ) 99 ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; DataInputStream dataInputStream0 = new DataInputStream ( ( InputStream ) byteArrayInputStream0 ) ; InputStreamReader inputStreamReader0 = new InputStreamReader ( ( InputStream ) dataInputStream0 ) ; SimpleCharStream simpleCharStream0 = new SimpleCharStream ( ( Reader ) inputStreamReader0 , ( int ) ( byte ) 2 , ( int ) ( byte ) 104 ) ; JVCParserTokenManager jVCParserTokenManager0 = new JVCParserTokenManager ( simpleCharStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Token getNextToken ( ) { if ( token . next ! = null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; jj_gen + + ; return token ; }
void test8 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 10 ] ; byteArray0 [ 1 ] = ( byte ) 92 ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; DataInputStream dataInputStream0 = new DataInputStream ( ( InputStream ) byteArrayInputStream0 ) ; InputStreamReader inputStreamReader0 = new InputStreamReader ( ( InputStream ) dataInputStream0 ) ; SimpleCharStream simpleCharStream0 = new SimpleCharStream ( ( Reader ) inputStreamReader0 , ( int ) ( byte ) 2 , ( int ) ( byte ) 104 ) ; JVCParserTokenManager jVCParserTokenManager0 = new JVCParserTokenManager ( simpleCharStream0 ) ; jVCParserTokenManager0 . getNextToken ( ) ; jVCParserTokenManager0 . SwitchTo ( ( int ) ( byte ) 0 ) ; jVCParserTokenManager0 . getNextToken ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Token getNextToken ( ) { if ( token . next ! = null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; jj_gen + + ; return token ; }
void test9 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 10 ] ; byteArray0 [ 1 ] = ( byte ) ( - 35 ) ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; DataInputStream dataInputStream0 = new DataInputStream ( ( InputStream ) byteArrayInputStream0 ) ; InputStreamReader inputStreamReader0 = new InputStreamReader ( ( InputStream ) dataInputStream0 ) ; SimpleCharStream simpleCharStream0 = new SimpleCharStream ( ( Reader ) inputStreamReader0 , ( int ) ( byte ) 2 , ( int ) ( byte ) 104 ) ; JVCParserTokenManager jVCParserTokenManager0 = new JVCParserTokenManager ( simpleCharStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Token getNextToken ( ) { if ( token . next ! = null ) token = token . next ; else token = token . next = token_source . getNextToken ( ) ; jj_ntk = - 1 ; jj_gen + + ; return token ; }
void test0 ( ) throws Throwable { Token token0 = Token . newToken ( ( - 1347 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getValue ( ) { return null ; }
void test1 ( ) throws Throwable { Token token0 = Token . newToken ( ( - 1347 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test2 ( ) throws Throwable { Token token0 = new Token ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return toString ( " , " ) ; }
void test3 ( ) throws Throwable { Token token0 = new Token ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Token ( ) { }
void test0 ( ) throws Throwable { HtmlEncoder htmlEncoder0 = new HtmlEncoder ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { String string0 = HtmlEncoder . encode ( "N ) Oc" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" char [ ] encode ( byte [ ] in ) { return encode ( in , in . length ) ; }
void test2 ( ) throws Throwable { String string0 = HtmlEncoder . encode ( "E\" & " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" char [ ] encode ( byte [ ] in ) { return encode ( in , in . length ) ; }
void test3 ( ) throws Throwable { String string0 = HtmlEncoder . encode ( "U , xS < XZ } Cl > T : 8z . 7" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" char [ ] encode ( byte [ ] in ) { return encode ( in , in . length ) ; }
void test1 ( ) throws Throwable { String string0 = Base64Coder . encodeString ( "Iw5P4NA" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String encodeString ( String s ) { return new String ( encode ( s . getBytes ( ) ) ) ; }
void test2 ( ) throws Throwable { String string0 = Base64Coder . decodeString ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String decodeString ( String s ) { return new String ( decode ( s ) ) ; }
void test3 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 10 ] ; char [ ] charArray0 = Base64Coder . encode ( byteArray0 ) ; byte [ ] byteArray1 = Base64Coder . decode ( charArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] decode ( String s ) { return decode ( s . toCharArray ( ) ) ; }
void test1 ( ) throws Throwable { JVCBootstrapGenerator jVCBootstrapGenerator0 = new JVCBootstrapGenerator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test4 ( ) throws Throwable { File file0 = new File ( " ? + ; I" , " ? + ; I" ) ; String string0 = JVCBootstrapGenerator . getGeneratorName ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getGeneratorName ( File f ) { if ( f . isDirectory ( ) ) return null ; String name = f . getName ( ) ; if ( ! name . endsWith ( TEMPLATE_SUFFIX ) ) return null ; name = name . substring ( 0 , name . length ( ) - TEMPLATE_SUFFIX . length ( ) ) ; / / remove ' . java . tpl' return capitalize ( name ) ; }
void test5 ( ) throws Throwable { File file0 = new File ( "" , "" ) ; String string0 = JVCBootstrapGenerator . getGeneratorName ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getGeneratorName ( File f ) { if ( f . isDirectory ( ) ) return null ; String name = f . getName ( ) ; if ( ! name . endsWith ( TEMPLATE_SUFFIX ) ) return null ; name = name . substring ( 0 , name . length ( ) - TEMPLATE_SUFFIX . length ( ) ) ; / / remove ' . java . tpl' return capitalize ( name ) ; }
void test6 ( ) throws Throwable { File file0 = new File ( " ? + ; I" , " ? + ; I" ) ; File file1 = new File ( file0 , "X < Sy\"h C . java . tpl" ) ; String string0 = JVCBootstrapGenerator . getGeneratorName ( file1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getGeneratorName ( File f ) { if ( f . isDirectory ( ) ) return null ; String name = f . getName ( ) ; if ( ! name . endsWith ( TEMPLATE_SUFFIX ) ) return null ; name = name . substring ( 0 , name . length ( ) - TEMPLATE_SUFFIX . length ( ) ) ; / / remove ' . java . tpl' return capitalize ( name ) ; }
void test7 ( ) throws Throwable { String string0 = JVCBootstrapGenerator . capitalize ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String capitalize ( String s ) { if ( s = = null | | s . length ( ) = = 0 ) return s ; return Character . toUpperCase ( s . charAt ( 0 ) ) + s . substring ( 1 ) ; }
void test8 ( ) throws Throwable { String string0 = JVCBootstrapGenerator . capitalize ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String capitalize ( String s ) { if ( s = = null | | s . length ( ) = = 0 ) return s ; return Character . toUpperCase ( s . charAt ( 0 ) ) + s . substring ( 1 ) ; }
void test0 ( ) throws Throwable { char [ ] charArray0 = new char [ 4 ] ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 ) ; JVCParser jVCParser0 = new JVCParser ( ( Reader ) charArrayReader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test1 ( ) throws Throwable { char [ ] charArray0 = new char [ 4 ] ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 ) ; JVCParser jVCParser0 = new JVCParser ( ( Reader ) charArrayReader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test3 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 6 ] ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; JVCParser jVCParser0 = new JVCParser ( ( InputStream ) byteArrayInputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void enable_tracing ( ) { }
void test4 ( ) throws Throwable { char [ ] charArray0 = new char [ 4 ] ; charArray0 [ 1 ] = ' [ ' ; charArray0 [ 2 ] = ' [ ' ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 ) ; JVCParser jVCParser0 = new JVCParser ( ( Reader ) charArrayReader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test5 ( ) throws Throwable { char [ ] charArray0 = new char [ 4 ] ; charArray0 [ 0 ] = ' ] ' ; charArray0 [ 1 ] = ' ] ' ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 ) ; JVCParser jVCParser0 = new JVCParser ( ( Reader ) charArrayReader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test6 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 17 ] ; byteArray0 [ 16 ] = ( byte ) 10 ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; JVCParser jVCParser0 = new JVCParser ( ( InputStream ) byteArrayInputStream0 ) ; String string0 = jVCParser0 . parse ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test7 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 6 ] ; byteArray0 [ 3 ] = ( byte ) 92 ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; JVCParser jVCParser0 = new JVCParser ( ( InputStream ) byteArrayInputStream0 ) ; String string0 = jVCParser0 . parse ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test8 ( ) throws Throwable { char [ ] charArray0 = new char [ 4 ] ; charArray0 [ 2 ] = '\"' ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 ) ; JVCParser jVCParser0 = new JVCParser ( ( Reader ) charArrayReader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test9 ( ) throws Throwable { FileDescriptor fileDescriptor0 = FileDescriptor . err ; FileReader fileReader0 = new FileReader ( fileDescriptor0 ) ; JVCParser jVCParser0 = new JVCParser ( ( Reader ) fileReader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test11 ( ) throws Throwable { FileDescriptor fileDescriptor0 = FileDescriptor . err ; FileReader fileReader0 = new FileReader ( fileDescriptor0 ) ; JVCParser jVCParser0 = new JVCParser ( ( Reader ) fileReader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test12 ( ) throws Throwable { FileDescriptor fileDescriptor0 = FileDescriptor . err ; FileReader fileReader0 = new FileReader ( fileDescriptor0 ) ; JVCParser jVCParser0 = new JVCParser ( ( Reader ) fileReader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test13 ( ) throws Throwable { BufferedInputStream bufferedInputStream0 = new BufferedInputStream ( ( InputStream ) null ) ; JVCParser jVCParser0 = new JVCParser ( ( InputStream ) bufferedInputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test14 ( ) throws Throwable { BufferedInputStream bufferedInputStream0 = new BufferedInputStream ( ( InputStream ) null ) ; JVCParser jVCParser0 = new JVCParser ( ( InputStream ) bufferedInputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String parse ( ) throws ParseException , ParseException , FileNotFoundException { Token t ; label_1 : while ( true ) { switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case START_CODE_TAG : case START_EXPR_TAG : case START_EXPR2_TAG : case START_LOAD_TAG : case START_COMMENT_TAG : case EOL : case START_CACHE_BLOCK : case END_CACHE_BLOCK : case END_TAG : case IMPORT : case OTHER : ; break ; default : jj_la1 [ 0 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk = = - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EOL : t = jj_consume_token ( EOL ) ; addEOL ( t ) ; break ; case START_CODE_TAG : t = jj_consume_token ( START_CODE_TAG ) ; startTag ( t ) ; break ; case START_EXPR_TAG : t = jj_consume_token ( START_EXPR_TAG ) ; startTag ( t ) ; break ; case START_EXPR2_TAG : t = jj_consume_token ( START_EXPR2_TAG ) ; startTag ( t ) ; break ; case START_LOAD_TAG : t = jj_consume_token ( START_LOAD_TAG ) ; startTag ( t ) ; break ; case START_COMMENT_TAG : t = jj_consume_token ( START_COMMENT_TAG ) ; startTag ( t ) ; break ; case END_TAG : t = jj_consume_token ( END_TAG ) ; endTag ( t ) ; break ; case START_CACHE_BLOCK : t = jj_consume_token ( START_CACHE_BLOCK ) ; startCache ( t ) ; break ; case END_CACHE_BLOCK : t = jj_consume_token ( END_CACHE_BLOCK ) ; endCache ( t ) ; break ; case IMPORT : t = jj_consume_token ( IMPORT ) ; addImport ( t ) ; break ; case OTHER : t = jj_consume_token ( OTHER ) ; addOther ( t ) ; break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } jj_consume_token ( 0 ) ; flush ( ) ; { if ( true ) return sb . toString ( ) ; } throw new Error ( "Missing return statement in function" ) ; }
void test15 ( ) throws Throwable { char [ ] charArray0 = new char [ 11 ] ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 ) ; JVCParser jVCParser0 = new JVCParser ( ( Reader ) charArrayReader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 17 ] ; if ( jj_kind > = 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 2 ; i + + ) { if ( jj_la1 [ i ] = = jj_gen ) { for ( int j = 0 ; j < 32 ; j + + ) { if ( ( jj_la1_0 [ i ] & ( 1 < < j ) ) ! = 0 ) { la1tokens [ j ] = true ; } } } } for ( int i = 0 ; i < 17 ; i + + ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i + + ) { exptokseq [ i ] = ( int [ ] ) jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; }
void test1 ( ) throws Throwable { JVCGenerator jVCGenerator0 = new JVCGenerator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test2 ( ) throws Throwable { String string0 = JVCGenerator . capitalize ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String capitalize ( String s ) { if ( s = = null | | s . length ( ) = = 0 ) return s ; return Character . toUpperCase ( s . charAt ( 0 ) ) + s . substring ( 1 ) ; }
void test3 ( ) throws Throwable { String string0 = JVCGenerator . capitalize ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String capitalize ( String s ) { if ( s = = null | | s . length ( ) = = 0 ) return s ; return Character . toUpperCase ( s . charAt ( 0 ) ) + s . substring ( 1 ) ; }
void test4 ( ) throws Throwable { String string0 = JVCGenerator . capitalize ( "7M n" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String capitalize ( String s ) { if ( s = = null | | s . length ( ) = = 0 ) return s ; return Character . toUpperCase ( s . charAt ( 0 ) ) + s . substring ( 1 ) ; }
