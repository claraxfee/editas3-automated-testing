void test0 ( ) throws Throwable { Histogram histogram0 = new Histogram ( 0 , 0 , 8 ) ; CumulativeHistogram cumulativeHistogram0 = new CumulativeHistogram ( histogram0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test1 ( ) throws Throwable { JCheckBoxMenuItem jCheckBoxMenuItem0 = new JCheckBoxMenuItem ( "^ZKq2 < : wg > i & E & N\"$ | M" , ( Icon ) null , false ) ; JPasswordField jPasswordField0 = new JPasswordField ( ) ; DirectColorModel directColorModel0 = ( DirectColorModel ) jPasswordField0 . getColorModel ( ) ; byte [ ] byteArray0 = new byte [ 10 ] ; MemoryImageSource memoryImageSource0 = new MemoryImageSource ( 0 , 0 , ( ColorModel ) directColorModel0 , byteArray0 , 0 , ( int ) ( byte ) ( - 96 ) ) ; Image image0 = jCheckBoxMenuItem0 . createImage ( ( ImageProducer ) memoryImageSource0 ) ; InterpolatedRealGrayImage interpolatedRealGrayImage0 = new InterpolatedRealGrayImage ( image0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { ROI rOI0 = new ROI ( ( - 1 ) , ( - 1 ) , 865 , 0 ) ; int int0 = rOI0 . ux ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int ly ( ) { return m_ly ; }
void test1 ( ) throws Throwable { ROI rOI0 = new ROI ( ) ; int int0 = rOI0 . uy ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int uy ( ) { return m_uy ; }
void test2 ( ) throws Throwable { ROI rOI0 = new ROI ( ) ; int int0 = rOI0 . ly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int ly ( ) { return m_ly ; }
void test3 ( ) throws Throwable { ROI rOI0 = new ROI ( ) ; int int0 = rOI0 . X ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int uy ( ) { return m_uy ; }
void test4 ( ) throws Throwable { ROI rOI0 = new ROI ( ) ; rOI0 . setROI ( 0 , 0 , 0 , 733 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int ux ( ) { return m_ux ; }
void test5 ( ) throws Throwable { ROI rOI0 = new ROI ( ) ; int int0 = rOI0 . Y ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int ly ( ) { return m_ly ; }
void test6 ( ) throws Throwable { ROI rOI0 = new ROI ( ) ; int int0 = rOI0 . lx ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int lx ( ) { return m_lx ; }
void test7 ( ) throws Throwable { ROI rOI0 = new ROI ( 1 , 1 , ( - 1985 ) , ( - 1985 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 9 , 1 ) ; ColorHistogram colorHistogram0 = new ColorHistogram ( ( ColorImage ) interpolatedColorImage0 , ( - 1007 ) , 9 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ColorHistogram ( ColorImage image ) { int a = 0 ; int b = 0 ; Integer [ ] val = new Integer [ 3 ] ; try { m_data = new int [ m_rsize ] [ m_gsize ] [ m_bsize ] ; for ( int h = 0 ; h < m_rsize ; h + + ) { for ( int i = 0 ; i < m_gsize ; i + + ) { for ( int j = 0 ; j < m_bsize ; j + + ) { m_data [ h ] [ i ] [ j ] = 0 ; } } } int rprec = 1 < < ( 8 - m_rbits ) ; int gprec = 1 < < ( 8 - m_gbits ) ; int bprec = 1 < < ( 8 - m_bbits ) ; for ( int x = 0 ; x < image . X ( ) ; x + + ) { for ( int y = 0 ; y < image . Y ( ) ; y + + ) { a = x ; b = y ; val = image . get ( x , y ) ; m_data [ val [ 0 ] / rprec ] [ val [ 1 ] / gprec ] [ val [ 2 ] / bprec ] + + ; } } } catch ( Exception e ) { System . out . println ( "Exception : " + a + " " + b + " " + val [ 0 ] + " " + val [ 1 ] + " " + val [ 2 ] ) ; } }
void test2 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 1018 , 0 ) ; ColorHistogram colorHistogram0 = new ColorHistogram ( ( ColorImage ) interpolatedColorImage0 , 0 , ( - 559 ) , 1092 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ColorHistogram ( ColorImage image ) { int a = 0 ; int b = 0 ; Integer [ ] val = new Integer [ 3 ] ; try { m_data = new int [ m_rsize ] [ m_gsize ] [ m_bsize ] ; for ( int h = 0 ; h < m_rsize ; h + + ) { for ( int i = 0 ; i < m_gsize ; i + + ) { for ( int j = 0 ; j < m_bsize ; j + + ) { m_data [ h ] [ i ] [ j ] = 0 ; } } } int rprec = 1 < < ( 8 - m_rbits ) ; int gprec = 1 < < ( 8 - m_gbits ) ; int bprec = 1 < < ( 8 - m_bbits ) ; for ( int x = 0 ; x < image . X ( ) ; x + + ) { for ( int y = 0 ; y < image . Y ( ) ; y + + ) { a = x ; b = y ; val = image . get ( x , y ) ; m_data [ val [ 0 ] / rprec ] [ val [ 1 ] / gprec ] [ val [ 2 ] / bprec ] + + ; } } } catch ( Exception e ) { System . out . println ( "Exception : " + a + " " + b + " " + val [ 0 ] + " " + val [ 1 ] + " " + val [ 2 ] ) ; } }
void test3 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 9 , 1 ) ; interpolatedColorImage0 . clear ( ) ; ColorHistogram colorHistogram0 = new ColorHistogram ( ( ColorImage ) interpolatedColorImage0 ) ; float [ ] floatArray0 = colorHistogram0 . mean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float [ ] mean ( ) { int count = 0 ; float [ ] total = new float [ 3 ] ; for ( int k = 0 ; k < 3 ; k + + ) total [ k ] = 0 ; for ( int h = 0 ; h < 32 ; h + + ) for ( int i = 0 ; i < 32 ; i + + ) for ( int j = 0 ; j < 32 ; j + + ) if ( m_data [ h ] [ i ] [ j ] ! = 0 ) { count = count + m_data [ h ] [ i ] [ j ] ; total [ 0 ] = total [ 0 ] + h * m_data [ h ] [ i ] [ j ] ; total [ 1 ] = total [ 1 ] + i * m_data [ h ] [ i ] [ j ] ; total [ 2 ] = total [ 2 ] + j * m_data [ h ] [ i ] [ j ] ; } float [ ] results = new float [ 3 ] ; results [ 0 ] = total [ 0 ] / count ; results [ 1 ] = total [ 1 ] / count ; results [ 2 ] = total [ 2 ] / count ; return results ; }
void test0 ( ) throws Throwable { JSeparator jSeparator0 = new JSeparator ( ) ; KernelType kernelType0 = KernelType . D_YY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] absSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . absSum ( ) ; sum [ 1 ] = planes [ 1 ] . absSum ( ) ; sum [ 2 ] = planes [ 2 ] . absSum ( ) ; return sum ; }
void test1 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 6 , 6 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { LevelSetSharpen levelSetSharpen0 = new LevelSetSharpen ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" LevelSetSharpen ( ) { ldg = new LocalDifferentialGeometry ( ) ; }
void test3 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( ) ; LevelSetSharpen levelSetSharpen0 = new LevelSetSharpen ( realColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] absSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . absSum ( ) ; sum [ 1 ] = planes [ 1 ] . absSum ( ) ; sum [ 2 ] = planes [ 2 ] . absSum ( ) ; return sum ; }
void test1 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 7 , 7 ) ; RealColorImage realColorImage1 = ( RealColorImage ) realColorImage0 . clear ( ) ; ROI rOI0 = new ROI ( ) ; realColorImage1 . divide ( realColorImage0 , rOI0 , rOI0 ) ; LevelSetSmooth levelSetSmooth0 = new LevelSetSmooth ( realColorImage1 , ( double ) 7 , ( double ) ( - 1 . 8393067F ) , ( double ) ( - 1 . 8393067F ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" LevelSetSmooth ( ) { }
void test2 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 7 , 7 ) ; RealColorImage realColorImage1 = ( RealColorImage ) realColorImage0 . clear ( ) ; RealColorImage realColorImage2 = realColorImage1 . add ( ( float ) 7 , ( float ) 7 , ( - 1 . 8393067F ) ) ; LevelSetSmooth levelSetSmooth0 = new LevelSetSmooth ( realColorImage2 , ( double ) 7 , ( double ) ( - 1 . 8393067F ) , ( double ) ( - 1 . 8393067F ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" LevelSetSmooth ( ) { }
void test3 ( ) throws Throwable { LevelSetSmooth levelSetSmooth0 = new LevelSetSmooth ( ) ; RealGrayImage realGrayImage0 = new RealGrayImage ( 8 , 8 ) ; levelSetSmooth0 . constrainSigns ( realGrayImage0 , 8 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { LevelSetSmooth levelSetSmooth0 = new LevelSetSmooth ( ) ; RealGrayImage realGrayImage0 = levelSetSmooth0 . constrainTopology ( ( RealGrayImage ) null , ( RealGrayImage ) null , 1481 , 2003 , 1481 , 2003 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage constrainTopology ( RealGrayImage gimage , RealGrayImage wnt , int x1 , int x2 , int y1 , int y2 ) { / / local variables float new_value ; float old_value ; float wnt_value ; float move ; float [ ] n = new float [ 9 ] ; float [ ] w = new float [ 9 ] ; float upper_bound ; float lower_bound ; / / visit each pixel for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y1 ; y + + ) { old_value = gimage . get ( x , y ) ; wnt_value = wnt . get ( x , y ) ; move = old_value - wnt_value ; new_value = old_value ; / / get neighborhood values ( gimage ) n [ 0 ] = gimage . get ( x - 1 , y - 1 ) ; n [ 1 ] = gimage . get ( x , y - 1 ) ; n [ 2 ] = gimage . get ( x + 1 , y - 1 ) ; n [ 3 ] = gimage . get ( x - 1 , y ) ; n [ 4 ] = gimage . get ( x , y ) ; n [ 5 ] = gimage . get ( x + 1 , y ) ; n [ 6 ] = gimage . get ( x - 1 , y + 1 ) ; n [ 7 ] = gimage . get ( x , y + 1 ) ; n [ 8 ] = gimage . get ( x + 1 , y + 1 ) ; / / get neighborhood values ( want ) w [ 0 ] = wnt . get ( x - 1 - x1 , y - 1 - y1 ) ; w [ 1 ] = wnt . get ( x - x1 , y - 1 - y1 ) ; w [ 2 ] = wnt . get ( x + 1 - x1 , y - 1 - y1 ) ; w [ 3 ] = wnt . get ( x - 1 - x1 , y - y1 ) ; w [ 4 ] = wnt . get ( x - x1 , y - y1 ) ; w [ 5 ] = wnt . get ( x + 1 - x1 , y - y1 ) ; w [ 6 ] = wnt . get ( x - 1 - x1 , y + 1 - y1 ) ; w [ 7 ] = wnt . get ( x - x1 , y + 1 - y1 ) ; w [ 8 ] = wnt . get ( x + 1 - x1 , y + 1 - y1 ) ; / / calculate new value if ( move ! = 0 ) { / / find min of wants or olds for olds greater than old_value upper_bound = 256 ; / / for the smallest for ( int i = 0 ; i < 9 ; i + + ) { if ( n [ i ] > old_value ) { upper_bound = ( upper_bound < n [ i ] ) ? upper_bound : n [ i ] ; upper_bound = ( upper_bound < w [ i ] ) ? upper_bound : w [ i ] ; } } / / find max of wants or olds for olds less than old_value lower_bound = - 1 ; / / for the maximum for ( int i = 0 ; i < 9 ; i + + ) { if ( n [ i ] < old_value ) { lower_bound = ( lower_bound > n [ i ] ) ? lower_bound : n [ i ] ; lower_bound = ( lower_bound > w [ i ] ) ? lower_bound : w [ i ] ; } } / / clamp between upper_bound and lower_bound / / if all the values are equal ? ? ? ? ? ? ? ? ? upper_bound - - ; lower_bound + + ; if ( move > 0 ) { new_value = ( wnt_value > upper_bound ) ? upper_bound : wnt_value ; } else if ( move < 0 ) { new_value = ( wnt_value < lower_bound ) ? lower_bound : wnt_value ; } } else { new_value = old_value ; } / / update want gimage if ( new_value ! = old_value ) { / / clamp dynamic range new_value = ( new_value > 255 ) ? 255 : new_value ; new_value = ( new_value < 0 ) ? 0 : new_value ; wnt . set ( x , y , new_value ) ; } } } return wnt ; }
void test6 ( ) throws Throwable { LevelSetSmooth levelSetSmooth0 = new LevelSetSmooth ( ) ; levelSetSmooth0 . copyWant ( ( RealGrayImage ) null , ( - 201 ) , ( - 201 ) , ( - 8 ) , ( - 201 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void copyWant ( RealGrayImage gimage , int x1 , int y1 , int x2 , int y2 ) { for ( int x = x1 ; x < x2 ; x + + ) for ( int y = y1 ; y < y2 ; y + + ) want . set ( x , y , gimage . get ( x , y ) ) ; }
void test0 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_YY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; Open open0 = new Open ( imageKernel0 , ( - 1 ) , ( - 1 ) ) ; BinaryImage binaryImage0 = new BinaryImage ( ( RealGrayImage ) imageKernel0 ) ; Image < Object > image0 = open0 . apply ( binaryImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealColorImage apply ( int x1 , int y1 , int x2 , int y2 , boolean constrainTopology , boolean constrainSigns ) { / / float newAlpha = 0 . 0f ; RealGrayImage gimage , galpha , galpha_change ; for ( int i = 0 ; i < 3 ; i + + ) { gimage = image . plane ( i ) ; galpha = alpha . plane ( i ) ; galpha_change = alpha . plane ( i ) ; / / create Kappa - the isophote curvature map ldg . calcIsophoteFlow ( x1 , y1 , x2 , y2 , gimage , kappa ) ; / / same sign constraint - don't move same sign neighborhoods / / ( sets kappa to 0 if the 8 - conn neighborhood all has same sign ) if ( constrainSigns ) { constrainSigns ( kappa , x2 - x1 , y2 - y1 ) ; } / / create wants ( new + ( alpha * move ) ) - this is how the new image / / should look / / float percent = 0 ; / / float kapp = 0 ; float alphaV = 0 ; float wantV = 0 ; float changeV = 0 ; / / automatic = true ; / / copyWant ( x1 - 1 , y1 - 1 , x2 + 1 , y2 + 1 ) ; for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { alphaV = galpha . get ( x , y ) ; changeV = - galpha_change . get ( x , y ) ; wantV = gimage . get ( x , y ) + ( ( float ) alphaV * ( float ) kappa . get ( x - x1 , y - y1 ) ) ; want . set ( x - x1 , y - y1 , wantV ) ; / / boundV = 0 . 05 if ( alphaV > boundV & & alphaV + changeV > boundV ) galpha . set ( x , y , alphaV + changeV ) ; else galpha . set ( x , y , boundV ) ; } } / / topology constraint - don't let isophotes cross each other if ( constrainTopology ) { constrainTopology ( want , gimage , x1 , y1 , x2 , y2 ) ; } for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { if ( want . get ( x - x1 , y - y1 ) > 255 ) want . set ( x - x1 , y - y1 , 255f ) ; else if ( want . get ( x - x1 , y - y1 ) < 0 ) want . set ( x - x1 , y - y1 , 0f ) ; gimage . set ( x , y , want . get ( x - x1 , y - y1 ) ) ; } } } return image ; }
void test3 ( ) throws Throwable { ImageKernel imageKernel0 = new ImageKernel ( ( - 1 . 0F ) , 15 ) ; GDilate gDilate0 = new GDilate ( imageKernel0 , 15 , 15 ) ; InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 15 , 15 ) ; interpolatedGrayImage0 . clear ( ( Integer ) 15 ) ; Image < Object > image0 = gDilate0 . apply ( ( GrayImage ) interpolatedGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test6 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_XX ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; GDilate gDilate0 = new GDilate ( imageKernel0 , 6 , 0 ) ; Image < Object > image0 = gDilate0 . apply ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_YY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; Dilate dilate0 = new Dilate ( imageKernel0 , ( - 1 ) , ( - 1 ) ) ; BinaryImage binaryImage0 = new BinaryImage ( ( RealGrayImage ) imageKernel0 ) ; Image < Object > image0 = dilate0 . apply ( binaryImage0 ) ; Dilate dilate1 = new Dilate ( imageKernel0 , 1 , 615 ) ; Image < Object > image1 = dilate1 . apply ( image0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealColorImage apply ( int x1 , int y1 , int x2 , int y2 , boolean constrainTopology , boolean constrainSigns ) { / / float newAlpha = 0 . 0f ; RealGrayImage gimage , galpha , galpha_change ; for ( int i = 0 ; i < 3 ; i + + ) { gimage = image . plane ( i ) ; galpha = alpha . plane ( i ) ; galpha_change = alpha . plane ( i ) ; / / create Kappa - the isophote curvature map ldg . calcIsophoteFlow ( x1 , y1 , x2 , y2 , gimage , kappa ) ; / / same sign constraint - don't move same sign neighborhoods / / ( sets kappa to 0 if the 8 - conn neighborhood all has same sign ) if ( constrainSigns ) { constrainSigns ( kappa , x2 - x1 , y2 - y1 ) ; } / / create wants ( new + ( alpha * move ) ) - this is how the new image / / should look / / float percent = 0 ; / / float kapp = 0 ; float alphaV = 0 ; float wantV = 0 ; float changeV = 0 ; / / automatic = true ; / / copyWant ( x1 - 1 , y1 - 1 , x2 + 1 , y2 + 1 ) ; for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { alphaV = galpha . get ( x , y ) ; changeV = - galpha_change . get ( x , y ) ; wantV = gimage . get ( x , y ) + ( ( float ) alphaV * ( float ) kappa . get ( x - x1 , y - y1 ) ) ; want . set ( x - x1 , y - y1 , wantV ) ; / / boundV = 0 . 05 if ( alphaV > boundV & & alphaV + changeV > boundV ) galpha . set ( x , y , alphaV + changeV ) ; else galpha . set ( x , y , boundV ) ; } } / / topology constraint - don't let isophotes cross each other if ( constrainTopology ) { constrainTopology ( want , gimage , x1 , y1 , x2 , y2 ) ; } for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { if ( want . get ( x - x1 , y - y1 ) > 255 ) want . set ( x - x1 , y - y1 , 255f ) ; else if ( want . get ( x - x1 , y - y1 ) < 0 ) want . set ( x - x1 , y - y1 , 0f ) ; gimage . set ( x , y , want . get ( x - x1 , y - y1 ) ) ; } } } return image ; }
void test1 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_YY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; BinaryImage binaryImage0 = new BinaryImage ( ( RealGrayImage ) imageKernel0 ) ; Dilate dilate0 = new Dilate ( imageKernel0 , 615 , 615 ) ; Image < Object > image0 = dilate0 . apply ( binaryImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_XX ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; Erode erode0 = new Erode ( imageKernel0 , 4 , 4 ) ; BinaryImage binaryImage0 = new BinaryImage ( ( RealGrayImage ) imageKernel0 ) ; Image < Object > image0 = erode0 . apply ( binaryImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_XX ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; Erode erode0 = new Erode ( imageKernel0 , 4 , 4 ) ; BinaryImage binaryImage0 = new BinaryImage ( ( RealGrayImage ) imageKernel0 ) ; imageKernel0 . normalize255 ( ) ; ROI rOI0 = new ROI ( ) ; Image < Object > image0 = erode0 . apply ( binaryImage0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test2 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_YY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; BinaryImage binaryImage0 = new BinaryImage ( ( RealGrayImage ) imageKernel0 ) ; Erode erode0 = new Erode ( imageKernel0 , 0 , 0 ) ; Image < Object > image0 = erode0 . apply ( binaryImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { ImageKernel imageKernel0 = new ImageKernel ( ( - 1 . 0F ) , 16 ) ; GClose gClose0 = new GClose ( imageKernel0 , 14 , 14 ) ; Image < Object > image0 = gClose0 . apply ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { ImageKernel imageKernel0 = new ImageKernel ( ( - 1 . 0F ) , 16 ) ; GOpen gOpen0 = new GOpen ( imageKernel0 , 14 , 14 ) ; Image < Object > image0 = gOpen0 . apply ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { ImageKernel imageKernel0 = new ImageKernel ( ( - 1 . 0F ) , 15 ) ; GErode gErode0 = new GErode ( imageKernel0 , 15 , 15 ) ; Image < Object > image0 = gErode0 . apply ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { ImageKernel imageKernel0 = new ImageKernel ( ( - 1 . 0F ) , 15 ) ; GErode gErode0 = new GErode ( imageKernel0 , 15 , 15 ) ; InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 15 , 15 ) ; interpolatedGrayImage0 . clear ( ( Integer ) 15 ) ; Image < Object > image0 = gErode0 . apply ( ( GrayImage ) interpolatedGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test7 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_XX ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; GErode gErode0 = new GErode ( imageKernel0 , 6 , 0 ) ; Image < Object > image0 = gErode0 . apply ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_YY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; Close close0 = new Close ( imageKernel0 , ( - 1 ) , ( - 1 ) ) ; BinaryImage binaryImage0 = new BinaryImage ( ( RealGrayImage ) imageKernel0 ) ; Image < Object > image0 = close0 . apply ( binaryImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealColorImage apply ( int x1 , int y1 , int x2 , int y2 , boolean constrainTopology , boolean constrainSigns ) { / / float newAlpha = 0 . 0f ; RealGrayImage gimage , galpha , galpha_change ; for ( int i = 0 ; i < 3 ; i + + ) { gimage = image . plane ( i ) ; galpha = alpha . plane ( i ) ; galpha_change = alpha . plane ( i ) ; / / create Kappa - the isophote curvature map ldg . calcIsophoteFlow ( x1 , y1 , x2 , y2 , gimage , kappa ) ; / / same sign constraint - don't move same sign neighborhoods / / ( sets kappa to 0 if the 8 - conn neighborhood all has same sign ) if ( constrainSigns ) { constrainSigns ( kappa , x2 - x1 , y2 - y1 ) ; } / / create wants ( new + ( alpha * move ) ) - this is how the new image / / should look / / float percent = 0 ; / / float kapp = 0 ; float alphaV = 0 ; float wantV = 0 ; float changeV = 0 ; / / automatic = true ; / / copyWant ( x1 - 1 , y1 - 1 , x2 + 1 , y2 + 1 ) ; for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { alphaV = galpha . get ( x , y ) ; changeV = - galpha_change . get ( x , y ) ; wantV = gimage . get ( x , y ) + ( ( float ) alphaV * ( float ) kappa . get ( x - x1 , y - y1 ) ) ; want . set ( x - x1 , y - y1 , wantV ) ; / / boundV = 0 . 05 if ( alphaV > boundV & & alphaV + changeV > boundV ) galpha . set ( x , y , alphaV + changeV ) ; else galpha . set ( x , y , boundV ) ; } } / / topology constraint - don't let isophotes cross each other if ( constrainTopology ) { constrainTopology ( want , gimage , x1 , y1 , x2 , y2 ) ; } for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { if ( want . get ( x - x1 , y - y1 ) > 255 ) want . set ( x - x1 , y - y1 , 255f ) ; else if ( want . get ( x - x1 , y - y1 ) < 0 ) want . set ( x - x1 , y - y1 , 0f ) ; gimage . set ( x , y , want . get ( x - x1 , y - y1 ) ) ; } } } return image ; }
void test0 ( ) throws Throwable { Window window0 = new Window ( ( - 1102 ) , 1950 ) ; KernelType kernelType0 = KernelType . D_YY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; window0 . apply ( ( RealGrayImage ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long [ ] sqrSum ( ) { long [ ] sum = new long [ 3 ] ; sum [ 0 ] = planes [ 0 ] . sqrSum ( ) ; sum [ 1 ] = planes [ 1 ] . sqrSum ( ) ; sum [ 2 ] = planes [ 2 ] . sqrSum ( ) ; return sum ; }
void test3 ( ) throws Throwable { Window window0 = new Window ( ( - 840 . 1558F ) , ( - 840 . 1558F ) ) ; InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 0 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 136 , 11 , 0 ) ; ROI rOI0 = new ROI ( ) ; Image < Object > image0 = window0 . apply ( grayImage0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { Window window0 = new Window ( ( - 1 . 0F ) , ( - 1 . 0F ) ) ; KernelType kernelType0 = KernelType . UNIFORM ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; ROI rOI0 = new ROI ( 0 , 0 , 0 , 0 ) ; window0 . apply ( ( Image ) imageKernel0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long [ ] sqrSum ( ) { long [ ] sum = new long [ 3 ] ; sum [ 0 ] = planes [ 0 ] . sqrSum ( ) ; sum [ 1 ] = planes [ 1 ] . sqrSum ( ) ; sum [ 2 ] = planes [ 2 ] . sqrSum ( ) ; return sum ; }
void test6 ( ) throws Throwable { Window window0 = new Window ( 0 . 0F , 812 . 9572F ) ; ImageKernel imageKernel0 = new ImageKernel ( 16 . 571148F , 22 ) ; ROI rOI0 = new ROI ( ) ; window0 . apply ( ( Image ) imageKernel0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long [ ] sqrSum ( ) { long [ ] sum = new long [ 3 ] ; sum [ 0 ] = planes [ 0 ] . sqrSum ( ) ; sum [ 1 ] = planes [ 1 ] . sqrSum ( ) ; sum [ 2 ] = planes [ 2 ] . sqrSum ( ) ; return sum ; }
void test7 ( ) throws Throwable { Window window0 = new Window ( 0 . 0F , 812 . 9572F ) ; ImageKernel imageKernel0 = new ImageKernel ( 16 . 571148F , 22 ) ; ImageKernel imageKernel1 = ( ImageKernel ) imageKernel0 . clear ( ) ; window0 . apply ( ( RealGrayImage ) imageKernel1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] absSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . absSum ( ) ; sum [ 1 ] = planes [ 1 ] . absSum ( ) ; sum [ 2 ] = planes [ 2 ] . absSum ( ) ; return sum ; }
void test9 ( ) throws Throwable { Window window0 = new Window ( 0 . 0F , 812 . 9572F ) ; InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 22 , 22 ) ; interpolatedColorImage0 . clear ( ) ; Image < Object > image0 = window0 . apply ( ( Image ) interpolatedColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test10 ( ) throws Throwable { Window window0 = new Window ( 0 . 0F , 812 . 9572F ) ; InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 22 , 22 ) ; InterpolatedColorImage interpolatedColorImage1 = ( InterpolatedColorImage ) interpolatedColorImage0 . clear ( ) ; int [ ] intArray0 = new int [ 9 ] ; intArray0 [ 0 ] = 22 ; ROI rOI0 = new ROI ( ) ; interpolatedColorImage1 . add ( intArray0 ) ; Image < Object > image0 = window0 . apply ( ( Image ) interpolatedColorImage0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test11 ( ) throws Throwable { Window window0 = new Window ( ( float ) 320 , ( float ) 342 ) ; InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( ) ; InterpolatedRealColorImage interpolatedRealColorImage1 = ( InterpolatedRealColorImage ) interpolatedRealColorImage0 . copy ( ) ; float [ ] floatArray0 = new float [ 7 ] ; RealColorImage realColorImage0 = interpolatedRealColorImage1 . addbuffer ( 380 , 1 , 342 , 0 , floatArray0 ) ; Image < Object > image0 = window0 . apply ( realColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test12 ( ) throws Throwable { Window window0 = new Window ( ( float ) 335 , ( float ) 335 ) ; InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( ) ; InterpolatedRealColorImage interpolatedRealColorImage1 = ( InterpolatedRealColorImage ) interpolatedRealColorImage0 . copy ( ) ; float [ ] floatArray0 = new float [ 7 ] ; floatArray0 [ 0 ] = ( float ) 335 ; RealColorImage realColorImage0 = interpolatedRealColorImage1 . addbuffer ( 335 , 1 , 380 , 335 , floatArray0 ) ; Image < Object > image0 = window0 . apply ( realColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { ClipNeg clipNeg0 = new ClipNeg ( ) ; KernelType kernelType0 = KernelType . D_XY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; clipNeg0 . apply ( ( RealGrayImage ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test5 ( ) throws Throwable { ClipNeg clipNeg0 = new ClipNeg ( ) ; int [ ] [ ] intArray0 = new int [ 2 ] [ 10 ] ; GrayImage grayImage0 = new GrayImage ( intArray0 ) ; ROI rOI0 = new ROI ( ) ; Image < Object > image0 = clipNeg0 . apply ( grayImage0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { Clip clip0 = new Clip ( 0 . 0F , 0 . 0F ) ; KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; Image < Object > image0 = clip0 . apply ( ( RealGrayImage ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { Threshold threshold0 = new Threshold ( ( - 1 . 0F ) ) ; KernelType kernelType0 = KernelType . D_XY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; threshold0 . apply ( ( RealGrayImage ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long [ ] sqrSum ( ) { long [ ] sum = new long [ 3 ] ; sum [ 0 ] = planes [ 0 ] . sqrSum ( ) ; sum [ 1 ] = planes [ 1 ] . sqrSum ( ) ; sum [ 2 ] = planes [ 2 ] . sqrSum ( ) ; return sum ; }
void test4 ( ) throws Throwable { Threshold threshold0 = new Threshold ( ( - 1 . 0F ) ) ; KernelType kernelType0 = KernelType . D_XY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; ImageKernel imageKernel1 = ( ImageKernel ) imageKernel0 . add ( ( - 1385 . 3325F ) ) ; threshold0 . apply ( ( RealGrayImage ) imageKernel1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long [ ] sqrSum ( ) { long [ ] sum = new long [ 3 ] ; sum [ 0 ] = planes [ 0 ] . sqrSum ( ) ; sum [ 1 ] = planes [ 1 ] . sqrSum ( ) ; sum [ 2 ] = planes [ 2 ] . sqrSum ( ) ; return sum ; }
void test0 ( ) throws Throwable { float [ ] floatArray0 = new float [ 10 ] ; LookupTable lookupTable0 = new LookupTable ( floatArray0 , 9 , 9 , ( - 1473 ) ) ; InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 71 , 9 ) ; interpolatedGrayImage0 . clear ( ( Integer ) 71 ) ; lookupTable0 . apply ( ( Image ) interpolatedGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long [ ] sqrSum ( ) { long [ ] sum = new long [ 3 ] ; sum [ 0 ] = planes [ 0 ] . sqrSum ( ) ; sum [ 1 ] = planes [ 1 ] . sqrSum ( ) ; sum [ 2 ] = planes [ 2 ] . sqrSum ( ) ; return sum ; }
void test1 ( ) throws Throwable { float [ ] floatArray0 = new float [ 10 ] ; LookupTable lookupTable0 = new LookupTable ( floatArray0 , 9 , 9 , ( - 1473 ) ) ; InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 71 , 9 ) ; InterpolatedGrayImage interpolatedGrayImage1 = ( InterpolatedGrayImage ) interpolatedGrayImage0 . clear ( ( Integer ) 71 ) ; InterpolatedGrayImage interpolatedGrayImage2 = ( InterpolatedGrayImage ) interpolatedGrayImage1 . add ( ( - 753 ) ) ; lookupTable0 . apply ( ( Image ) interpolatedGrayImage2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test3 ( ) throws Throwable { float [ ] floatArray0 = new float [ 1 ] ; LookupTable lookupTable0 = new LookupTable ( floatArray0 , 1745 , 1944 , 1745 ) ; KernelType kernelType0 = KernelType . UNSHARP ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; ROI rOI0 = new ROI ( ) ; lookupTable0 . apply ( ( RealGrayImage ) imageKernel0 , rOI0 ) ; lookupTable0 . apply ( ( Image ) imageKernel0 ) ; Image < Object > image0 = lookupTable0 . apply ( ( Image ) imageKernel0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { ImageInputStream imageInputStream0 = new ImageInputStream ( " . jpg" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" jigl . image . Image read ( ) throws ImageNotSupportedException , IllegalPBMFormatException , IOException { if ( img = = null ) { / / the different possible image types to return GrayImage g_im = null ; RealGrayImage rg_im = null ; ColorImage c_im = null ; RealColorImage rc_im = null ; / / ComplexImage cx_im = null ; switch ( type ) { case PBM_ASCII : case PBM_RAW : case PGM_RAW : case PGM_ASCII : g_im = new GrayImage ( X , Y ) ; break ; case PPM_ASCII : case PPM_RAW : c_im = new ColorImage ( X , Y ) ; break ; case PRGM_RAW : rg_im = new RealGrayImage ( X , Y ) ; break ; case PRCM_RAW : rc_im = new RealColorImage ( X , Y ) ; break ; default : throw new ImageNotSupportedException ( ) ; } int / * col , * / r , g , b ; float rf , gf , bf ; char c ; int value ; Integer [ ] color = new Integer [ 3 ] ; Float [ ] colorf = new Float [ 3 ] ; / / read image data for ( int y = 0 ; y < Y ; y + + ) { for ( int x = 0 ; x < X ; x + + ) { switch ( type ) { case PBM_ASCII : c = readChar ( data ) ; if ( c = = '1' ) { value = 0 ; } else if ( c = = '0' ) { value = 0xff ; } else { throw new IllegalPBMFormatException ( ) ; } g_im . set ( x , y , value ) ; break ; case PGM_ASCII : g = readInt ( data ) ; g_im . set ( x , y , g ) ; break ; case PPM_ASCII : r = readInt ( data ) ; g = readInt ( data ) ; b = readInt ( data ) ; color [ 0 ] = r ; color [ 1 ] = g ; color [ 2 ] = b ; c_im . set ( x , y , color ) ; break ; case PBM_RAW : if ( readBit ( data ) ) { value = 0 ; } else { value = 0xff ; } g_im . set ( x , y , value ) ; break ; case PGM_RAW : g = readByte ( data ) ; if ( maxval ! = 255 ) { g = fixDepth ( g ) ; } g_im . set ( x , y , g ) ; break ; case PRGM_RAW : gf = readBytef ( data ) ; if ( maxvalf ! = 255 ) { gf = fixDepth ( gf ) ; } rg_im . set ( x , y , gf ) ; break ; case PPM_RAW : r = readByte ( data ) ; g = readByte ( data ) ; b = readByte ( data ) ; if ( maxval ! = 255 ) { r = fixDepth ( r ) ; g = fixDepth ( g ) ; b = fixDepth ( b ) ; } color [ 0 ] = r ; color [ 1 ] = g ; color [ 2 ] = b ; c_im . set ( x , y , color ) ; break ; case PRCM_RAW : rf = readBytef ( data ) ; gf = readBytef ( data ) ; bf = readBytef ( data ) ; if ( maxvalf ! = 255 ) { rf = fixDepth ( rf ) ; gf = fixDepth ( gf ) ; bf = fixDepth ( bf ) ; } colorf [ 0 ] = rf ; colorf [ 1 ] = gf ; colorf [ 2 ] = bf ; rc_im . set ( x , y , colorf ) ; break ; } } } / / return the right image type switch ( type ) { case PBM_ASCII : case PBM_RAW : case PGM_RAW : case PGM_ASCII : return g_im ; case PPM_ASCII : case PPM_RAW : return c_im ; case PRGM_RAW : return rg_im ; case PRCM_RAW : return rc_im ; default : throw new ImageNotSupportedException ( ) ; } } else { ColorImage image = new ColorImage ( img ) ; return image ; } }
void test1 ( ) throws Throwable { ImageInputStream imageInputStream0 = new ImageInputStream ( "P6 . jpg" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { ImageInputStream imageInputStream0 = new ImageInputStream ( " . gif" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test3 ( ) throws Throwable { ImageInputStream imageInputStream0 = new ImageInputStream ( " . jpeg" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int ndims ( ) { return ndims ; }
void test5 ( ) throws Throwable { ImageInputStream imageInputStream0 = new ImageInputStream ( " . gif" ) ; imageInputStream0 . close ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void close ( ) throws IOException { data . close ( ) ; }
void test0 ( ) throws Throwable { ImageOutputStreamJAI imageOutputStreamJAI0 = new ImageOutputStreamJAI ( ) ; imageOutputStreamJAI0 . writeJPEG ( ( Image ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void writeJPEG ( jigl . image . Image im , float quality ) throws ImageNotSupportedException { JPEGEncodeParam param = new JPEGEncodeParam ( ) ; param . setQuality ( quality ) ; writeImage ( im , JPEG , param ) ; }
void test2 ( ) throws Throwable { ImageOutputStreamJAI imageOutputStreamJAI0 = new ImageOutputStreamJAI ( ) ; KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; imageOutputStreamJAI0 . writePPM ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void writePPM ( jigl . image . Image im , boolean raw ) throws ImageNotSupportedException { PNMEncodeParam param = new PNMEncodeParam ( ) ; param . setRaw ( raw ) ; writeImage ( im , PPM , param ) ; }
void test3 ( ) throws Throwable { ImageOutputStreamJAI imageOutputStreamJAI0 = new ImageOutputStreamJAI ( ) ; ImageOutputStreamJAI imageOutputStreamJAI1 = new ImageOutputStreamJAI ( imageOutputStreamJAI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { ImageOutputStreamJAI imageOutputStreamJAI0 = new ImageOutputStreamJAI ( ) ; int int0 = imageOutputStreamJAI0 . X ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { ImageOutputStreamJAI imageOutputStreamJAI0 = new ImageOutputStreamJAI ( ) ; int int0 = imageOutputStreamJAI0 . Y ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test6 ( ) throws Throwable { ImageOutputStreamJAI imageOutputStreamJAI0 = new ImageOutputStreamJAI ( ) ; KernelType kernelType0 = KernelType . LAPLACIAN ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; imageOutputStreamJAI0 . writeJPEG ( ( Image ) imageKernel0 , 1142 . 3772F ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void writeJPEG ( jigl . image . Image im , float quality ) throws ImageNotSupportedException { JPEGEncodeParam param = new JPEGEncodeParam ( ) ; param . setQuality ( quality ) ; writeImage ( im , JPEG , param ) ; }
void test8 ( ) throws Throwable { ImageOutputStreamJAI imageOutputStreamJAI0 = new ImageOutputStreamJAI ( ) ; KernelType kernelType0 = KernelType . LAPLACIAN ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; imageOutputStreamJAI0 . writePGM ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void writePGM ( jigl . image . Image im , boolean raw ) throws ImageNotSupportedException { PNMEncodeParam param = new PNMEncodeParam ( ) ; param . setRaw ( raw ) ; writeImage ( im , PGM , param ) ; }
void test9 ( ) throws Throwable { ImageOutputStreamJAI imageOutputStreamJAI0 = new ImageOutputStreamJAI ( ) ; KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; imageOutputStreamJAI0 . writeTIFF ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void writeTIFF ( jigl . image . Image im ) throws ImageNotSupportedException { writeImage ( im , TIFF , null ) ; }
void test10 ( ) throws Throwable { ImageOutputStreamJAI imageOutputStreamJAI0 = new ImageOutputStreamJAI ( ) ; KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; imageOutputStreamJAI0 . writeBMP ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void writeBMP ( jigl . image . Image im ) throws ImageNotSupportedException { writeImage ( im , BMP , null ) ; }
void test11 ( ) throws Throwable { ImageOutputStreamJAI imageOutputStreamJAI0 = new ImageOutputStreamJAI ( ) ; KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; imageOutputStreamJAI0 . writePNG ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void writePNG ( jigl . image . Image im ) throws ImageNotSupportedException { writeImage ( im , PNG , null ) ; }
void test0 ( ) throws Throwable { ImageInputStreamJAI imageInputStreamJAI0 = new ImageInputStreamJAI ( ) ; int int0 = imageInputStreamJAI0 . Y ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { ImageInputStreamJAI imageInputStreamJAI0 = new ImageInputStreamJAI ( ) ; int int0 = imageInputStreamJAI0 . X ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { ImageOutputStream imageOutputStream0 = new ImageOutputStream ( ) ; int int0 = imageOutputStream0 . Y ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { ImageOutputStream imageOutputStream0 = new ImageOutputStream ( ) ; int int0 = imageOutputStream0 . X ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test7 ( ) throws Throwable { ImageOutputStream imageOutputStream0 = new ImageOutputStream ( ) ; ImageOutputStream imageOutputStream1 = new ImageOutputStream ( imageOutputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int ndims ( ) { return ndims ; }
void test10 ( ) throws Throwable { ImageOutputStream imageOutputStream0 = new ImageOutputStream ( ) ; int int0 = imageOutputStream0 . ndims ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int ndims ( ) { return ndims ; }
void test0 ( ) throws Throwable { MagnitudeImage magnitudeImage0 = new MagnitudeImage ( 0 , 0 ) ; MagnitudeImage magnitudeImage1 = new MagnitudeImage ( magnitudeImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 0 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 10 , 10 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test3 ( ) throws Throwable { JFormattedTextField jFormattedTextField0 = new JFormattedTextField ( ( Object ) "rolloverEnabled" ) ; int [ ] intArray0 = new int [ 3 ] ; Hashtable < String , Integer > hashtable0 = new Hashtable < String , Integer > ( ) ; MemoryImageSource memoryImageSource0 = new MemoryImageSource ( 8 , 8 , intArray0 , 8 , 0 , ( Hashtable < ? , ? > ) hashtable0 ) ; java . awt . Image image0 = jFormattedTextField0 . createImage ( ( ImageProducer ) memoryImageSource0 ) ; InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( image0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { short [ ] shortArray0 = new short [ 18 ] ; GrayImage grayImage0 = new GrayImage ( 0 , 0 , shortArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test5 ( ) throws Throwable { JFormattedTextField jFormattedTextField0 = new JFormattedTextField ( ( Object ) "rolloverEnabled" ) ; int [ ] intArray0 = new int [ 17 ] ; Hashtable < String , Integer > hashtable0 = new Hashtable < String , Integer > ( ) ; MemoryImageSource memoryImageSource0 = new MemoryImageSource ( 8 , 8 , intArray0 , 8 , 0 , ( Hashtable < ? , ? > ) hashtable0 ) ; java . awt . Image image0 = jFormattedTextField0 . createImage ( ( ImageProducer ) memoryImageSource0 ) ; InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( image0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test6 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 0 ) ; InterpolatedGrayImage interpolatedGrayImage1 = ( InterpolatedGrayImage ) interpolatedGrayImage0 . add ( ( - 228 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" InterpolationMethod getInterpolationMethod ( ) { return interpolationMethod ; }
void test7 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 0 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 10 , 10 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] absSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . absSum ( ) ; sum [ 1 ] = planes [ 1 ] . absSum ( ) ; sum [ 2 ] = planes [ 2 ] . absSum ( ) ; return sum ; }
void test8 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 0 ) ; InterpolatedGrayImage interpolatedGrayImage1 = ( InterpolatedGrayImage ) interpolatedGrayImage0 . multiply ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test9 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 0 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 10 , 10 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test10 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 0 ) ; int int0 = interpolatedGrayImage0 . addSum ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test11 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 657 , 1 ) ; InterpolatedGrayImage interpolatedGrayImage1 = ( InterpolatedGrayImage ) interpolatedGrayImage0 . clear ( ) ; int int0 = interpolatedGrayImage1 . absSum ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test13 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 977 ) ; InterpolatedGrayImage interpolatedGrayImage1 = ( InterpolatedGrayImage ) interpolatedGrayImage0 . diff ( ( Image < Integer > ) interpolatedGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" InterpolationMethod getInterpolationMethod ( ) { return interpolationMethod ; }
void test14 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 0 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 10 , 10 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test15 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 657 , 1 ) ; String string0 = interpolatedGrayImage0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test17 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 0 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 10 , 10 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test19 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 0 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 10 , 10 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test23 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 0 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 10 , 10 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 283 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Float interp ( float x , float y ) { int intx , inty ; float fracx , fracy ; switch ( interpolationMethod ) { case NEIGHBOR : intx = ( int ) Math . round ( x ) ; inty = ( int ) Math . round ( y ) ; return ( float ) data [ inty ] [ intx ] ; case LINEAR : intx = ( int ) x ; inty = ( int ) y ; fracx = x - intx ; fracy = y - inty ; if ( intx > = data [ 0 ] . length - 1 | | inty > = data . length - 1 ) / / edge case { if ( intx > = data [ 0 ] . length - 1 & & inty > = data . length - 1 ) { return ( float ) data [ inty ] [ intx ] ; / / corner } if ( intx > = data [ 0 ] . length - 1 ) { return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracy ) + data [ inty + 1 ] [ intx ] * fracy ) ; } else if ( inty > = data . length - 1 ) { return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracx ) + data [ inty ] [ intx + 1 ] * fracx ) ; } else throw new ArrayIndexOutOfBoundsException ( ) ; } return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracx ) * ( 1 - fracy ) + data [ inty ] [ intx + 1 ] * fracx * ( 1 - fracy ) + data [ inty + 1 ] [ intx ] * ( 1 - fracx ) * fracy + data [ inty + 1 ] [ intx + 1 ] * fracx * fracy ) ; case CUBIC : intx = ( int ) x ; inty = ( int ) y ; fracx = x - intx ; fracy = y - inty ; / / if the point is on the border and would cause an ArrayIndexOutOfBoundsException / / use linear interpolation instead if ( intx < 1 | | inty < 1 | | intx > data [ 0 ] . length - 3 | | inty > data . length - 3 ) { if ( intx > = data [ 0 ] . length - 1 | | inty > = data . length - 1 ) / / edge case { if ( intx > = data [ 0 ] . length - 1 & & inty > = data . length - 1 ) { return ( float ) data [ inty ] [ intx ] ; / / corner } if ( intx > = data [ 0 ] . length - 1 ) { return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracy ) + data [ inty + 1 ] [ intx ] * fracy ) ; } else if ( inty > = data . length - 1 ) { return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracx ) + data [ inty ] [ intx + 1 ] * fracx ) ; } else throw new ArrayIndexOutOfBoundsException ( ) ; } return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracx ) * ( 1 - fracy ) + data [ inty ] [ intx + 1 ] * fracx * ( 1 - fracy ) + data [ inty + 1 ] [ intx ] * ( 1 - fracx ) * fracy + data [ inty + 1 ] [ intx + 1 ] * fracx * fracy ) ; } float y0 , y1 , y2 , y3 ; float x0 , x1 , x2 , x3 ; float t = fracx ; y0 = data [ inty - 1 ] [ intx - 1 ] ; y1 = data [ inty - 1 ] [ intx ] ; y2 = data [ inty - 1 ] [ intx + 1 ] ; y3 = data [ inty - 1 ] [ intx + 2 ] ; x0 = CatMull ( t , y0 , y1 , y2 , y3 ) ; y0 = data [ inty ] [ intx - 1 ] ; y1 = data [ inty ] [ intx ] ; y2 = data [ inty ] [ intx + 1 ] ; y3 = data [ inty ] [ intx + 2 ] ; x1 = CatMull ( t , y0 , y1 , y2 , y3 ) ; y0 = data [ inty + 1 ] [ intx - 1 ] ; y1 = data [ inty + 1 ] [ intx ] ; y2 = data [ inty + 1 ] [ intx + 1 ] ; y3 = data [ inty + 1 ] [ intx + 2 ] ; x2 = CatMull ( t , y0 , y1 , y2 , y3 ) ; y0 = data [ inty + 2 ] [ intx - 1 ] ; y1 = data [ inty + 2 ] [ intx ] ; y2 = data [ inty + 2 ] [ intx + 1 ] ; y3 = data [ inty + 2 ] [ intx + 2 ] ; x3 = CatMull ( t , y0 , y1 , y2 , y3 ) ; t = fracy ; return CatMull ( t , x0 , x1 , x2 , x3 ) ; } return 0f ; }
void test4 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void accum ( float x , float y , float value ) { int intx , inty ; float fracx , fracy ; switch ( interpolationMethod ) { case NEIGHBOR : intx = ( int ) Math . round ( x ) ; inty = ( int ) Math . round ( y ) ; data [ inty ] [ intx ] + = ( float ) value ; case CUBIC : case LINEAR : intx = ( int ) x ; inty = ( int ) y ; fracx = x - intx ; fracy = y - inty ; try { data [ inty ] [ intx ] + = ( float ) ( value * ( 1 - fracx ) * ( 1 - fracy ) ) ; data [ inty ] [ intx + 1 ] + = ( float ) ( value * fracx * ( 1 - fracy ) ) ; data [ inty + 1 ] [ intx ] + = ( float ) ( value * ( 1 - fracx ) * fracy ) ; data [ inty + 1 ] [ intx + 1 ] + = ( float ) ( value * ( 1 - fracx ) * ( 1 - fracy ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { data [ inty ] [ intx ] + = ( float ) ( value * ( 1 - fracx ) * ( 1 - fracy ) ) ; try { data [ inty ] [ intx + 1 ] + = ( float ) ( value * fracx * ( 1 - fracy ) ) ; } catch ( ArrayIndexOutOfBoundsException ee ) { } try { data [ inty + 1 ] [ intx ] + = ( float ) ( value * ( 1 - fracx ) * fracy ) ; } catch ( ArrayIndexOutOfBoundsException ee ) { } } break ; } }
void test7 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test9 ( ) throws Throwable { ColorImage colorImage0 = new ColorImage ( 0 , 422 ) ; InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( colorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { KernelType kernelType0 = KernelType . LAPLACIAN_8 ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test1 ( ) throws Throwable { KernelType kernelType0 = KernelType . UNIFORM ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test2 ( ) throws Throwable { KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test3 ( ) throws Throwable { KernelType kernelType0 = KernelType . SOBEL_Y ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long [ ] sqrSum ( ) { long [ ] sum = new long [ 3 ] ; sum [ 0 ] = planes [ 0 ] . sqrSum ( ) ; sum [ 1 ] = planes [ 1 ] . sqrSum ( ) ; sum [ 2 ] = planes [ 2 ] . sqrSum ( ) ; return sum ; }
void test4 ( ) throws Throwable { KernelType kernelType0 = KernelType . PREWITT_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long [ ] sqrSum ( ) { long [ ] sum = new long [ 3 ] ; sum [ 0 ] = planes [ 0 ] . sqrSum ( ) ; sum [ 1 ] = planes [ 1 ] . sqrSum ( ) ; sum [ 2 ] = planes [ 2 ] . sqrSum ( ) ; return sum ; }
void test5 ( ) throws Throwable { KernelType kernelType0 = KernelType . PREWITT_Y ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test6 ( ) throws Throwable { KernelType kernelType0 = KernelType . LAPLACIAN ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test7 ( ) throws Throwable { KernelType kernelType0 = KernelType . UNSHARP ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test8 ( ) throws Throwable { KernelType kernelType0 = KernelType . UNSHARP_8 ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long [ ] sqrSum ( ) { long [ ] sum = new long [ 3 ] ; sum [ 0 ] = planes [ 0 ] . sqrSum ( ) ; sum [ 1 ] = planes [ 1 ] . sqrSum ( ) ; sum [ 2 ] = planes [ 2 ] . sqrSum ( ) ; return sum ; }
void test9 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_XX ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test10 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_YY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test11 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_XY ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] absSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . absSum ( ) ; sum [ 1 ] = planes [ 1 ] . absSum ( ) ; sum [ 2 ] = planes [ 2 ] . absSum ( ) ; return sum ; }
void test13 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_XX ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] absSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . absSum ( ) ; sum [ 1 ] = planes [ 1 ] . absSum ( ) ; sum [ 2 ] = planes [ 2 ] . absSum ( ) ; return sum ; }
void test4 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 316 , 0 ) ; int [ ] intArray0 = new int [ 9 ] ; InterpolatedColorImage interpolatedColorImage1 = ( InterpolatedColorImage ) interpolatedColorImage0 . add ( intArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void add ( Image image ) throws ImageNotSupportedException { if ( image instanceof GrayImage | | image instanceof RealGrayImage ) sequence . add ( image ) ; else throw new ImageNotSupportedException ( ) ; }
void test6 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 0 , 0 ) ; InterpolatedColorImage interpolatedColorImage1 = ( InterpolatedColorImage ) interpolatedColorImage0 . add ( 0 , 1298 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test15 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 0 , 0 ) ; int [ ] intArray0 = interpolatedColorImage0 . addSum ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test16 ( ) throws Throwable { JRadioButtonMenuItem jRadioButtonMenuItem0 = new JRadioButtonMenuItem ( "" , ( Icon ) null , true ) ; int [ ] intArray0 = new int [ 4 ] ; MemoryImageSource memoryImageSource0 = new MemoryImageSource ( 16 , 13 , intArray0 , 16 , 0 ) ; Image image0 = jRadioButtonMenuItem0 . createImage ( ( ImageProducer ) memoryImageSource0 ) ; ColorImage colorImage0 = new ColorImage ( image0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void subtract ( int x , int y , int [ ] value ) { planes [ 0 ] . subtract ( x , y , value [ 0 ] ) ; planes [ 1 ] . subtract ( x , y , value [ 1 ] ) ; planes [ 2 ] . subtract ( x , y , value [ 2 ] ) ; }
void test17 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 0 , 5 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 1800 , 0 ) ; MIPMap mIPMap0 = new MIPMap ( realColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 0 , 0 ) ; MIPMap mIPMap0 = new MIPMap ( realColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { PowerImage powerImage0 = new PowerImage ( 0 , 1466 ) ; RealGrayImage realGrayImage0 = ( RealGrayImage ) powerImage0 . copy ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { ComplexImage complexImage0 = new ComplexImage ( ) ; MagnitudeImage magnitudeImage0 = new MagnitudeImage ( complexImage0 ) ; RealGrayImage realGrayImage0 = magnitudeImage0 . addbuffer ( 0 , 10 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { ComplexImage complexImage0 = new ComplexImage ( ) ; MagnitudeImage magnitudeImage0 = new MagnitudeImage ( complexImage0 ) ; RealGrayImage realGrayImage0 = magnitudeImage0 . addbuffer ( 10 , 0 , 1327 , 10 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test3 ( ) throws Throwable { KernelType kernelType0 = KernelType . LAPLACIAN ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { ComplexImage complexImage0 = new ComplexImage ( ) ; MagnitudeImage magnitudeImage0 = new MagnitudeImage ( complexImage0 ) ; float float0 = magnitudeImage0 . addSum ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test5 ( ) throws Throwable { KernelType kernelType0 = KernelType . PREWITT_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] absSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . absSum ( ) ; sum [ 1 ] = planes [ 1 ] . absSum ( ) ; sum [ 2 ] = planes [ 2 ] . absSum ( ) ; return sum ; }
void test6 ( ) throws Throwable { KernelType kernelType0 = KernelType . PREWITT_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test7 ( ) throws Throwable { KernelType kernelType0 = KernelType . PREWITT_Y ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test8 ( ) throws Throwable { KernelType kernelType0 = KernelType . LAPLACIAN ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test9 ( ) throws Throwable { PowerImage powerImage0 = new PowerImage ( 0 , 1466 ) ; PowerImage powerImage1 = ( PowerImage ) powerImage0 . multiply ( ( RealGrayImage ) powerImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test10 ( ) throws Throwable { KernelType kernelType0 = KernelType . LAPLACIAN ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test11 ( ) throws Throwable { KernelType kernelType0 = KernelType . LAPLACIAN ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test12 ( ) throws Throwable { KernelType kernelType0 = KernelType . PREWITT_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test13 ( ) throws Throwable { KernelType kernelType0 = KernelType . LAPLACIAN ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long [ ] sqrSum ( ) { long [ ] sum = new long [ 3 ] ; sum [ 0 ] = planes [ 0 ] . sqrSum ( ) ; sum [ 1 ] = planes [ 1 ] . sqrSum ( ) ; sum [ 2 ] = planes [ 2 ] . sqrSum ( ) ; return sum ; }
void test14 ( ) throws Throwable { KernelType kernelType0 = KernelType . PREWITT_Y ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test16 ( ) throws Throwable { KernelType kernelType0 = KernelType . UNIFORM ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { PhaseImage phaseImage0 = new PhaseImage ( 0 , 1998 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] absSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . absSum ( ) ; sum [ 1 ] = planes [ 1 ] . absSum ( ) ; sum [ 2 ] = planes [ 2 ] . absSum ( ) ; return sum ; }
void test1 ( ) throws Throwable { InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( 4 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Float interp ( float x , float y ) { int intx , inty ; float fracx , fracy ; switch ( interpolationMethod ) { case NEIGHBOR : intx = ( int ) Math . round ( x ) ; inty = ( int ) Math . round ( y ) ; return ( float ) data [ inty ] [ intx ] ; case LINEAR : intx = ( int ) x ; inty = ( int ) y ; fracx = x - intx ; fracy = y - inty ; if ( intx > = data [ 0 ] . length - 1 | | inty > = data . length - 1 ) / / edge case { if ( intx > = data [ 0 ] . length - 1 & & inty > = data . length - 1 ) { return ( float ) data [ inty ] [ intx ] ; / / corner } if ( intx > = data [ 0 ] . length - 1 ) { return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracy ) + data [ inty + 1 ] [ intx ] * fracy ) ; } else if ( inty > = data . length - 1 ) { return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracx ) + data [ inty ] [ intx + 1 ] * fracx ) ; } else throw new ArrayIndexOutOfBoundsException ( ) ; } return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracx ) * ( 1 - fracy ) + data [ inty ] [ intx + 1 ] * fracx * ( 1 - fracy ) + data [ inty + 1 ] [ intx ] * ( 1 - fracx ) * fracy + data [ inty + 1 ] [ intx + 1 ] * fracx * fracy ) ; case CUBIC : intx = ( int ) x ; inty = ( int ) y ; fracx = x - intx ; fracy = y - inty ; / / if the point is on the border and would cause an ArrayIndexOutOfBoundsException / / use linear interpolation instead if ( intx < 1 | | inty < 1 | | intx > data [ 0 ] . length - 3 | | inty > data . length - 3 ) { if ( intx > = data [ 0 ] . length - 1 | | inty > = data . length - 1 ) / / edge case { if ( intx > = data [ 0 ] . length - 1 & & inty > = data . length - 1 ) { return ( float ) data [ inty ] [ intx ] ; / / corner } if ( intx > = data [ 0 ] . length - 1 ) { return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracy ) + data [ inty + 1 ] [ intx ] * fracy ) ; } else if ( inty > = data . length - 1 ) { return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracx ) + data [ inty ] [ intx + 1 ] * fracx ) ; } else throw new ArrayIndexOutOfBoundsException ( ) ; } return ( float ) ( data [ inty ] [ intx ] * ( 1 - fracx ) * ( 1 - fracy ) + data [ inty ] [ intx + 1 ] * fracx * ( 1 - fracy ) + data [ inty + 1 ] [ intx ] * ( 1 - fracx ) * fracy + data [ inty + 1 ] [ intx + 1 ] * fracx * fracy ) ; } float y0 , y1 , y2 , y3 ; float x0 , x1 , x2 , x3 ; float t = fracx ; y0 = data [ inty - 1 ] [ intx - 1 ] ; y1 = data [ inty - 1 ] [ intx ] ; y2 = data [ inty - 1 ] [ intx + 1 ] ; y3 = data [ inty - 1 ] [ intx + 2 ] ; x0 = CatMull ( t , y0 , y1 , y2 , y3 ) ; y0 = data [ inty ] [ intx - 1 ] ; y1 = data [ inty ] [ intx ] ; y2 = data [ inty ] [ intx + 1 ] ; y3 = data [ inty ] [ intx + 2 ] ; x1 = CatMull ( t , y0 , y1 , y2 , y3 ) ; y0 = data [ inty + 1 ] [ intx - 1 ] ; y1 = data [ inty + 1 ] [ intx ] ; y2 = data [ inty + 1 ] [ intx + 1 ] ; y3 = data [ inty + 1 ] [ intx + 2 ] ; x2 = CatMull ( t , y0 , y1 , y2 , y3 ) ; y0 = data [ inty + 2 ] [ intx - 1 ] ; y1 = data [ inty + 2 ] [ intx ] ; y2 = data [ inty + 2 ] [ intx + 1 ] ; y3 = data [ inty + 2 ] [ intx + 2 ] ; x3 = CatMull ( t , y0 , y1 , y2 , y3 ) ; t = fracy ; return CatMull ( t , x0 , x1 , x2 , x3 ) ; } return 0f ; }
void test0 ( ) throws Throwable { PowerImage powerImage0 = new PowerImage ( 0 , 1998 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long [ ] sqrSum ( ) { long [ ] sum = new long [ 3 ] ; sum [ 0 ] = planes [ 0 ] . sqrSum ( ) ; sum [ 1 ] = planes [ 1 ] . sqrSum ( ) ; sum [ 2 ] = planes [ 2 ] . sqrSum ( ) ; return sum ; }
void test0 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 5 ] ; BinaryImage binaryImage0 = new BinaryImage ( 1175 , 0 , byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( ) ; BinaryImage binaryImage1 = new BinaryImage ( binaryImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test3 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 1 , 1 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 1 , 1 , 1 , 1 , 0 ) ; BinaryImage binaryImage0 = new BinaryImage ( grayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( ) ; Byte byte0 = binaryImage0 . min ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test6 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test7 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 5 ] ; BinaryImage binaryImage0 = new BinaryImage ( ( int ) ( byte ) 0 , 804 , byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test9 ( ) throws Throwable { byte [ ] [ ] byteArray0 = new byte [ 1 ] [ 2 ] ; BinaryImage binaryImage0 = new BinaryImage ( byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test10 ( ) throws Throwable { byte [ ] [ ] byteArray0 = new byte [ 8 ] [ 4 ] ; BinaryImage binaryImage0 = new BinaryImage ( byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test11 ( ) throws Throwable { byte [ ] [ ] byteArray0 = new byte [ 1 ] [ 2 ] ; byte [ ] byteArray1 = new byte [ 5 ] ; byteArray1 [ 0 ] = ( byte ) 74 ; byteArray0 [ 0 ] = byteArray1 ; BinaryImage binaryImage0 = new BinaryImage ( byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test12 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 17 , 17 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 17 , 17 , 17 , 17 , 1 ) ; BinaryImage binaryImage0 = new BinaryImage ( grayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test13 ( ) throws Throwable { KernelType kernelType0 = KernelType . D_XX ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; BinaryImage binaryImage0 = new BinaryImage ( ( RealGrayImage ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test14 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( ) ; Byte [ ] [ ] byteArray0 = binaryImage0 . getData ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test15 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] getData ( ) { return values . clone ( ) ; }
void test16 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 1 , 1 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 1 , 1 , 1 , 1 , 0 ) ; BinaryImage binaryImage0 = new BinaryImage ( grayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test17 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test18 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( ) ; Byte byte0 = binaryImage0 . max ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test19 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( ( int ) ( byte ) 74 , ( int ) ( byte ) 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test20 ( ) throws Throwable { byte [ ] [ ] byteArray0 = new byte [ 1 ] [ 2 ] ; BinaryImage binaryImage0 = new BinaryImage ( ( int ) ( byte ) 74 , ( int ) ( byte ) 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" BinaryImage union ( BinaryImage image ) { for ( int y = 0 ; y < Y ; y + + ) for ( int x = 0 ; x < X ; x + + ) if ( image . get ( x , y ) ! = data [ y ] [ x ] ) data [ y ] [ x ] = 1 ; return this ; }
void test21 ( ) throws Throwable { byte [ ] [ ] byteArray0 = new byte [ 1 ] [ 2 ] ; BinaryImage binaryImage0 = new BinaryImage ( byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test22 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test23 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test24 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test25 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 1 , 1 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 1 , 1 , 1 , 1 , 0 ) ; BinaryImage binaryImage0 = new BinaryImage ( grayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test26 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 1 , 1 ) ; GrayImage grayImage0 = interpolatedGrayImage0 . addbuffer ( 1 , 1 , 1 , 1 , 0 ) ; BinaryImage binaryImage0 = new BinaryImage ( grayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test27 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test28 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( 921 , ( int ) ( byte ) 60 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { RotateTransform rotateTransform0 = new RotateTransform ( 1071 . 5192F ) ; WarpedGrayImage warpedGrayImage0 = new WarpedGrayImage ( ( InterpolatedGrayImage ) null , ( PointMapper ) rotateTransform0 ) ; int int0 = warpedGrayImage0 . get ( 1071 . 5192F , 3 . 4028235E38F ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Image get ( int index ) { return sequence . get ( index ) ; }
void test0 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 0 , 0 ) ; IdentityTransform identityTransform0 = new IdentityTransform ( ) ; WarpedColorImage warpedColorImage0 = new WarpedColorImage ( interpolatedColorImage0 , ( PointMapper ) identityTransform0 ) ; Integer [ ] integerArray0 = warpedColorImage0 . get ( ( float ) 16 , 9 . 0F ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Image get ( int index ) { return sequence . get ( index ) ; }
void test3 ( ) throws Throwable { RotateAboutTransform rotateAboutTransform0 = new RotateAboutTransform ( 255 . 0F , 1629 . 7079F , 1629 . 7079F ) ; InterpolationMethod interpolationMethod0 = InterpolationMethod . LINEAR ; Mapper mapper0 = new Mapper ( ( PointMapper ) rotateAboutTransform0 , interpolationMethod0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { RotateAboutTransform rotateAboutTransform0 = new RotateAboutTransform ( 950 . 22754F , 950 . 22754F , 950 . 22754F ) ; InterpolationMethod interpolationMethod0 = InterpolationMethod . LINEAR ; Mapper mapper0 = new Mapper ( ( PointMapper ) rotateAboutTransform0 , interpolationMethod0 ) ; InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( 1555 , 0 ) ; Image < Object > image0 = mapper0 . apply ( ( RealColorImage ) interpolatedRealColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { WarpedRealColorImage warpedRealColorImage0 = new WarpedRealColorImage ( ( InterpolatedRealColorImage ) null , ( PointMapper ) null ) ; Float [ ] floatArray0 = warpedRealColorImage0 . get ( 1 . 0F , ( - 1 . 0F ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Image get ( int index ) { return sequence . get ( index ) ; }
void test0 ( ) throws Throwable { ImageOps imageOps0 = new ImageOps ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { KdTree kdTree0 = new KdTree ( 1092 ) ; KdTree kdTree1 = kdTree0 . getLeft ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" KdTree getLeft ( ) { return left ; }
void test1 ( ) throws Throwable { KdTree kdTree0 = new KdTree ( 1812 ) ; Vector < Object > vector0 = kdTree0 . getValues ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Vector getValues ( ) { return values ; }
void test2 ( ) throws Throwable { KdTree kdTree0 = new KdTree ( 1812 ) ; KdTree kdTree1 = kdTree0 . getRoot ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" KdTree getRoot ( ) { return root ; }
void test3 ( ) throws Throwable { KdTree kdTree0 = new KdTree ( 1802 ) ; KdTree kdTree1 = kdTree0 . getRight ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" KdTree getRight ( ) { return right ; }
void test4 ( ) throws Throwable { KdTree kdTree0 = new KdTree ( 1802 ) ; Float [ ] floatArray0 = kdTree0 . getValue ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Float [ ] getValue ( ) { return value ; }
void test5 ( ) throws Throwable { KdTree kdTree0 = new KdTree ( 1092 ) ; RealColorImage realColorImage0 = new RealColorImage ( ) ; kdTree0 . buildTreePalette ( realColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ColorModel getColorModel ( ) { return colorModel ; }
void test1 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; RealGrayImage realGrayImage1 = localDifferentialGeometry0 . calcIsophoteStore ( 0 , 0 , ( - 1254 ) , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcIsophoteStore ( ) throws ImageNotSupportedException { if ( IxImage = = null ) IxImage = calcIx ( ) ; if ( IyImage = = null ) IyImage = calcIy ( ) ; if ( IxxImage = = null ) IxxImage = calcIxx ( ) ; if ( IyyImage = = null ) IyyImage = calcIyy ( ) ; if ( IxyImage = = null ) IxyImage = calcIxy ( ) ; int X = image . X ( ) ; int Y = image . Y ( ) ; double Iso = 0 ; float Ix , Iy , Ixx , Iyy , Ixy ; IsophoteCurvature = new RealGrayImage ( X , Y ) ; for ( int x = 0 ; x < X ; x + + ) { for ( int y = 0 ; y < Y ; y + + ) { / / calculate Iso Ix = IxImage . get ( x , y ) ; Iy = IyImage . get ( x , y ) ; Ixx = IxxImage . get ( x , y ) ; Iyy = IyyImage . get ( x , y ) ; Ixy = IxyImage . get ( x , y ) ; Iso = ( ( Iy * Iy * Ixx ) - ( 2 * Ix * Ixy * Iy ) + ( Iyy * Ix * Ix ) ) / Math . sqrt ( ( ( Ix * Ix ) + ( Iy * Iy ) ) * ( ( Ix * Ix ) + ( Iy * Iy ) ) * ( ( Ix * Ix ) + ( Iy * Iy ) ) ) ; / / put the result floato output image IsophoteCurvature . set ( x , y , ( float ) Iso ) ; } } return IsophoteCurvature ; }
void test2 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; RealGrayImage realGrayImage1 = localDifferentialGeometry0 . calcIsophoteStore ( ( - 1314 ) , 2019 , ( - 164 ) , ( - 441 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( ) ; localDifferentialGeometry0 . calcIsophote ( ( - 580 ) , ( - 580 ) , ( - 580 ) , ( - 580 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcIsophote ( int x1 , int y1 , int x2 , int y2 ) { / / check for null images if ( image = = null ) return null ; / / input image dimensions int X = image . X ( ) ; int Y = image . Y ( ) ; if ( IsophoteCurvature = = null ) IsophoteCurvature = new RealGrayImage ( X , Y ) ; / / variables for calculating Isophote float Iso ; float Ix ; float Iy ; float Ixx ; float Ixy ; float Iyy ; float c ; float n ; float ne ; float e ; float se ; float s ; float sw ; float w ; float nw ; / / calculate derivatives for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { try { c = image . get ( x , y ) ; n = image . get ( x , y - 1 ) ; ne = image . get ( x + 1 , y - 1 ) ; e = image . get ( x + 1 , y ) ; se = image . get ( x + 1 , y + 1 ) ; s = image . get ( x , y + 1 ) ; sw = image . get ( x - 1 , y + 1 ) ; w = image . get ( x - 1 , y ) ; nw = image . get ( x - 1 , y - 1 ) ; / / calculate Ix Ix = ( - w + e ) / 2 ; / / calculate Iy Iy = ( - n + s ) / 2 ; / / calculate Ixx Ixx = w + ( - 2 * c ) + e ; / / calculate Iyy Iyy = n + ( - 2 * c ) + s ; / / calculate Ixy Ixy = ( nw + - ne + - sw + se ) / 4 ; / / calculate Iso Iso = ( float ) ( ( ( Iy * Iy * Ixx ) - ( 2 * Ix * Ixy * Iy ) + ( Iyy * Ix * Ix ) ) / Math . sqrt ( ( double ) ( ( ( Ix * Ix ) + ( Iy * Iy ) ) * ( ( Ix * Ix ) + ( Iy * Iy ) ) * ( ( Ix * Ix ) + ( Iy * Iy ) ) ) ) ) ; / / put the result float to output image IsophoteCurvature . set ( x , y , Iso ) ; } catch ( Exception ex ) { } } } return IsophoteCurvature ; }
void test5 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; RealGrayImage realGrayImage1 = localDifferentialGeometry0 . calcIsophoteStore ( 0 , 0 , ( - 1254 ) , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcIsophote ( int x1 , int y1 , int x2 , int y2 ) { / / check for null images if ( image = = null ) return null ; / / input image dimensions int X = image . X ( ) ; int Y = image . Y ( ) ; if ( IsophoteCurvature = = null ) IsophoteCurvature = new RealGrayImage ( X , Y ) ; / / variables for calculating Isophote float Iso ; float Ix ; float Iy ; float Ixx ; float Ixy ; float Iyy ; float c ; float n ; float ne ; float e ; float se ; float s ; float sw ; float w ; float nw ; / / calculate derivatives for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { try { c = image . get ( x , y ) ; n = image . get ( x , y - 1 ) ; ne = image . get ( x + 1 , y - 1 ) ; e = image . get ( x + 1 , y ) ; se = image . get ( x + 1 , y + 1 ) ; s = image . get ( x , y + 1 ) ; sw = image . get ( x - 1 , y + 1 ) ; w = image . get ( x - 1 , y ) ; nw = image . get ( x - 1 , y - 1 ) ; / / calculate Ix Ix = ( - w + e ) / 2 ; / / calculate Iy Iy = ( - n + s ) / 2 ; / / calculate Ixx Ixx = w + ( - 2 * c ) + e ; / / calculate Iyy Iyy = n + ( - 2 * c ) + s ; / / calculate Ixy Ixy = ( nw + - ne + - sw + se ) / 4 ; / / calculate Iso Iso = ( float ) ( ( ( Iy * Iy * Ixx ) - ( 2 * Ix * Ixy * Iy ) + ( Iyy * Ix * Ix ) ) / Math . sqrt ( ( double ) ( ( ( Ix * Ix ) + ( Iy * Iy ) ) * ( ( Ix * Ix ) + ( Iy * Iy ) ) * ( ( Ix * Ix ) + ( Iy * Iy ) ) ) ) ) ; / / put the result float to output image IsophoteCurvature . set ( x , y , Iso ) ; } catch ( Exception ex ) { } } } return IsophoteCurvature ; }
void test6 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; RealGrayImage realGrayImage1 = localDifferentialGeometry0 . calcIsophoteFlowStore ( 0 , 1 , 1 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcIsophoteFlowStore ( ) throws ImageNotSupportedException { if ( IxImage = = null ) IxImage = calcIx ( ) ; if ( IyImage = = null ) IyImage = calcIy ( ) ; if ( IxxImage = = null ) IxxImage = calcIxx ( ) ; if ( IyyImage = = null ) IyyImage = calcIyy ( ) ; if ( IxyImage = = null ) IxyImage = calcIxy ( ) ; int X = image . X ( ) ; int Y = image . Y ( ) ; double Iso = 0 ; float Ix , Iy , Ixx , Iyy , Ixy ; IsophoteCurvature = new RealGrayImage ( X , Y ) ; for ( int x = 0 ; x < X ; x + + ) { for ( int y = 0 ; y < Y ; y + + ) { / / calculate Iso Ix = IxImage . get ( x , y ) ; Iy = IyImage . get ( x , y ) ; Ixx = IxxImage . get ( x , y ) ; Iyy = IyyImage . get ( x , y ) ; Ixy = IxyImage . get ( x , y ) ; Iso = ( ( Iy * Iy * Ixx ) - ( 2 * Ix * Ixy * Iy ) + ( Iyy * Ix * Ix ) ) / ( 1 + ( Ix * Ix ) + ( Iy * Iy ) ) ; / / put the result floato output image IsophoteCurvature . set ( x , y , ( float ) Iso ) ; } } return IsophoteCurvature ; }
void test7 ( ) throws Throwable { LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( ) ; localDifferentialGeometry0 . calcIsophoteFlow ( ( - 16 ) , ( - 11 ) , 625 , ( - 11 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcIsophoteFlow ( int x1 , int y1 , int x2 , int y2 ) { / / check for null images if ( image = = null ) return null ; / / input image dimensions int X = image . X ( ) ; int Y = image . Y ( ) ; / / variables for calculating Isophote float Iso ; float Ix ; float Iy ; float Ixx ; float Ixy ; float Iyy ; float c ; float n ; float ne ; float e ; float se ; float s ; float sw ; float w ; float nw ; if ( IsophoteCurvatureFlow = = null ) IsophoteCurvatureFlow = new RealGrayImage ( X , Y ) ; / / calculate derivatives for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { c = image . get ( x , y ) ; if ( y - 1 > 0 ) n = image . get ( x , y - 1 ) ; else n = 0 ; if ( y - 1 > 0 & & x + 1 < X ) ne = image . get ( x + 1 , y - 1 ) ; else ne = 0 ; if ( x + 1 < X ) e = image . get ( x + 1 , y ) ; else e = 0 ; if ( y + 1 < Y & & x + 1 < X ) se = image . get ( x + 1 , y + 1 ) ; else se = 0 ; if ( y + 1 < Y ) s = image . get ( x , y + 1 ) ; else s = 0 ; if ( x - 1 > 0 & & y + 1 < Y ) sw = image . get ( x - 1 , y + 1 ) ; else sw = 0 ; if ( x - 1 > 0 ) w = image . get ( x - 1 , y ) ; else w = 0 ; if ( y - 1 > 0 & & x - 1 > 0 ) nw = image . get ( x - 1 , y - 1 ) ; else nw = 0 ; / / calculate Ix Ix = ( - w + e ) / 2 ; / / calculate Iy Iy = ( - n + s ) / 2 ; / / calculate Ixx Ixx = w + ( - 2 * c ) + e ; / / calculate Iyy Iyy = n + ( - 2 * c ) + s ; / / calculate Ixy Ixy = ( nw + - ne + - sw + se ) / 4 ; / / calculate Iso double temp = ( ( Iy * Iy * Ixx ) - ( 2 * Ix * Ixy * Iy ) + ( Iyy * Ix * Ix ) ) / ( 0 . 01 + ( Ix * Ix ) + ( Iy * Iy ) ) ; Iso = ( float ) temp ; / / put the result floato output image IsophoteCurvatureFlow . set ( x , y , Iso ) ; } } return IsophoteCurvatureFlow ; }
void test8 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; RealGrayImage realGrayImage1 = localDifferentialGeometry0 . calcIsophoteFlowStore ( 0 , 1 , 1 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcIsophoteFlow ( int x1 , int y1 , int x2 , int y2 ) { / / check for null images if ( image = = null ) return null ; / / input image dimensions int X = image . X ( ) ; int Y = image . Y ( ) ; / / variables for calculating Isophote float Iso ; float Ix ; float Iy ; float Ixx ; float Ixy ; float Iyy ; float c ; float n ; float ne ; float e ; float se ; float s ; float sw ; float w ; float nw ; if ( IsophoteCurvatureFlow = = null ) IsophoteCurvatureFlow = new RealGrayImage ( X , Y ) ; / / calculate derivatives for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { c = image . get ( x , y ) ; if ( y - 1 > 0 ) n = image . get ( x , y - 1 ) ; else n = 0 ; if ( y - 1 > 0 & & x + 1 < X ) ne = image . get ( x + 1 , y - 1 ) ; else ne = 0 ; if ( x + 1 < X ) e = image . get ( x + 1 , y ) ; else e = 0 ; if ( y + 1 < Y & & x + 1 < X ) se = image . get ( x + 1 , y + 1 ) ; else se = 0 ; if ( y + 1 < Y ) s = image . get ( x , y + 1 ) ; else s = 0 ; if ( x - 1 > 0 & & y + 1 < Y ) sw = image . get ( x - 1 , y + 1 ) ; else sw = 0 ; if ( x - 1 > 0 ) w = image . get ( x - 1 , y ) ; else w = 0 ; if ( y - 1 > 0 & & x - 1 > 0 ) nw = image . get ( x - 1 , y - 1 ) ; else nw = 0 ; / / calculate Ix Ix = ( - w + e ) / 2 ; / / calculate Iy Iy = ( - n + s ) / 2 ; / / calculate Ixx Ixx = w + ( - 2 * c ) + e ; / / calculate Iyy Iyy = n + ( - 2 * c ) + s ; / / calculate Ixy Ixy = ( nw + - ne + - sw + se ) / 4 ; / / calculate Iso double temp = ( ( Iy * Iy * Ixx ) - ( 2 * Ix * Ixy * Iy ) + ( Iyy * Ix * Ix ) ) / ( 0 . 01 + ( Ix * Ix ) + ( Iy * Iy ) ) ; Iso = ( float ) temp ; / / put the result floato output image IsophoteCurvatureFlow . set ( x , y , Iso ) ; } } return IsophoteCurvatureFlow ; }
void test9 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; RealGrayImage realGrayImage1 = localDifferentialGeometry0 . calcIsophoteFlow ( 0 , 1 , 1 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test10 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; localDifferentialGeometry0 . GradientMagnitude = ( jigl . image . types . RealGrayImage ) realGrayImage0 ; RealGrayImage realGrayImage1 = localDifferentialGeometry0 . calcGradientMagnitude ( 0 , 0 , 0 , 4 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcGradientMagnitude ( int x1 , int y1 , int x2 , int y2 ) { IxImage = calcIx ( x1 , y1 , x2 , y2 ) ; IyImage = calcIy ( x1 , y1 , x2 , y2 ) ; int X = image . X ( ) ; int Y = image . Y ( ) ; double Iso = 0 ; float Ix , Iy ; if ( GradientMagnitude = = null ) GradientMagnitude = new RealGrayImage ( X , Y ) ; for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { / / calculate Iso Ix = IxImage . get ( x , y ) ; Iy = IyImage . get ( x , y ) ; Iso = Math . sqrt ( ( double ) ( ( Iy * Iy ) + ( Ix * Ix ) ) ) ; / / put the result floato output image GradientMagnitude . set ( x , y , ( float ) Iso ) ; } } return GradientMagnitude ; }
void test11 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; RealGrayImage realGrayImage1 = localDifferentialGeometry0 . calcGradientMagnitude ( ( - 1667 ) , 0 , ( - 20 ) , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcGradientMagnitude ( int x1 , int y1 , int x2 , int y2 ) { IxImage = calcIx ( x1 , y1 , x2 , y2 ) ; IyImage = calcIy ( x1 , y1 , x2 , y2 ) ; int X = image . X ( ) ; int Y = image . Y ( ) ; double Iso = 0 ; float Ix , Iy ; if ( GradientMagnitude = = null ) GradientMagnitude = new RealGrayImage ( X , Y ) ; for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { / / calculate Iso Ix = IxImage . get ( x , y ) ; Iy = IyImage . get ( x , y ) ; Iso = Math . sqrt ( ( double ) ( ( Iy * Iy ) + ( Ix * Ix ) ) ) ; / / put the result floato output image GradientMagnitude . set ( x , y , ( float ) Iso ) ; } } return GradientMagnitude ; }
void test13 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; localDifferentialGeometry0 . GradientMagnitude = ( jigl . image . types . RealGrayImage ) realGrayImage0 ; RealGrayImage realGrayImage1 = localDifferentialGeometry0 . calcApproximateGradientMagnitude ( 0 , 0 , 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcApproximateGradientMagnitude ( int x1 , int y1 , int x2 , int y2 ) { IxImage = calcIx ( x1 , y1 , x2 , y2 ) ; IyImage = calcIy ( x1 , y1 , x2 , y2 ) ; int X = image . X ( ) ; int Y = image . Y ( ) ; double Iso = 0 ; float Ix , Iy ; if ( GradientMagnitude = = null ) GradientMagnitude = new RealGrayImage ( X , Y ) ; for ( int x = 0 ; x < X ; x + + ) { for ( int y = 0 ; y < Y ; y + + ) { / / calculate Iso Ix = IxImage . get ( x , y ) ; Iy = IyImage . get ( x , y ) ; Iso = ( Iy + Ix ) ; / / put the result floato output image GradientMagnitude . set ( x , y , ( float ) Iso ) ; } } return GradientMagnitude ; }
void test14 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 1 , 1 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; RealGrayImage realGrayImage1 = localDifferentialGeometry0 . calcApproximateGradientMagnitude ( 1 , 1 , ( - 1970 ) , ( - 1970 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test15 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; RealGrayImage realGrayImage1 = localDifferentialGeometry0 . calcOrientationMap ( 1985 , 136 , 0 , ( - 32768 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test19 ( ) throws Throwable { LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( ) ; localDifferentialGeometry0 . setImage ( ( RealGrayImage ) null , ( - 16 ) , ( - 16 ) , 625 , ( - 133 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setImage ( RealGrayImage im , int x1 , int y1 , int x2 , int y2 ) { for ( int x = x1 ; x < x2 ; x + + ) for ( int y = y1 ; y < y2 ; y + + ) image . set ( x , y , im . get ( x , y ) ) ; }
void test21 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; localDifferentialGeometry0 . calcIy ( realGrayImage0 , realGrayImage0 , 0 , 1 , 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcIy ( ) throws jigl . image . exceptions . ImageNotSupportedException { IyImage = new RealGrayImage ( image . X ( ) , image . Y ( ) ) ; try { ImageKernel ik = new ImageKernel ( KernelType . SOBEL_Y ) ; Convolve c = new Convolve ( ik ) ; IyImage = ( RealGrayImage ) c . apply ( image ) ; } catch ( Exception e ) { System . out . println ( "Internal Jigl ImageKernel error . " ) ; return null ; } IyImage . divide ( 8 ) ; return IyImage ; }
void test24 ( ) throws Throwable { RealGrayImage realGrayImage0 = new RealGrayImage ( 0 , 0 ) ; LocalDifferentialGeometry localDifferentialGeometry0 = new LocalDifferentialGeometry ( realGrayImage0 ) ; localDifferentialGeometry0 . calcIx ( realGrayImage0 , realGrayImage0 , 0 , 1 , 1712 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcIx ( ) throws jigl . image . exceptions . ImageNotSupportedException { IxImage = new RealGrayImage ( image . X ( ) , image . Y ( ) ) ; try { ImageKernel ik = new ImageKernel ( KernelType . SOBEL_X ) ; Convolve c = new Convolve ( ik ) ; IxImage = ( RealGrayImage ) c . apply ( image ) ; } catch ( Exception e ) { System . out . println ( "Internal Jigl ImageKernel error . " ) ; return null ; } IxImage . divide ( 8 ) ; return IxImage ; }
void test2 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 4 , 4 ) ; interpolatedGrayImage0 . clear ( ( Integer ) 4 ) ; ComplexImage complexImage0 = FFT . forward ( ( Image < ? > ) interpolatedGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 4 , 4 ) ; Image < Integer > image0 = interpolatedGrayImage0 . clear ( ( Integer ) 4 ) ; ComplexImage complexImage0 = FFT . reverse ( image0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { Scaler scaler0 = new Scaler ( ) ; GrayImage grayImage0 = scaler0 . getIyy ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage getIyy ( ) { try { if ( IyyImage = = null ) return calcIyy ( ) ; return IyyImage ; } catch ( Exception e ) { return null ; } }
void test1 ( ) throws Throwable { Scaler scaler0 = new Scaler ( ) ; GrayImage grayImage0 = scaler0 . getIxy ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage getIxy ( ) { try { if ( IxImage = = null ) return calcIxy ( ) ; return IxyImage ; } catch ( Exception e ) { return null ; } }
void test2 ( ) throws Throwable { Scaler scaler0 = new Scaler ( ) ; GrayImage grayImage0 = scaler0 . getIxx ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage getIxx ( ) { try { if ( IxxImage = = null ) return calcIxx ( ) ; return IxxImage ; } catch ( Exception e ) { return null ; } }
void test3 ( ) throws Throwable { Scaler scaler0 = new Scaler ( ) ; GrayImage grayImage0 = scaler0 . getIy ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage getIy ( ) { try { if ( IyImage = = null ) return calcIy ( ) ; return IyImage ; } catch ( Exception e ) { return null ; } }
void test4 ( ) throws Throwable { Scaler scaler0 = new Scaler ( ) ; GrayImage grayImage0 = scaler0 . getIx ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage getIx ( ) { try { if ( IxImage = = null ) return calcIx ( ) ; return IxImage ; } catch ( Exception e ) { return null ; } }
void test5 ( ) throws Throwable { Scaler scaler0 = new Scaler ( ) ; InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 46 , 46 ) ; GrayImage grayImage0 = scaler0 . calcIsophoteStore ( ( GrayImage ) interpolatedGrayImage0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test6 ( ) throws Throwable { Scaler scaler0 = new Scaler ( ) ; InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 46 , 46 ) ; GrayImage grayImage0 = scaler0 . calcIsophoteStore ( ( GrayImage ) interpolatedGrayImage0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test7 ( ) throws Throwable { Scaler scaler0 = new Scaler ( ) ; GrayImage grayImage0 = scaler0 . calcIsophoteOnce ( ( GrayImage ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealGrayImage calcIsophoteOnce ( ) { / / check for null images if ( image = = null ) return null ; / / input image dimensions int X = image . X ( ) ; int Y = image . Y ( ) ; / / create output image IsophoteCurvature = new RealGrayImage ( X , Y ) ; / / variables for calculating Isophote float Iso ; float Ix ; float Iy ; float Ixx ; float Ixy ; float Iyy ; / / float aIx ; / / float aIy ; float c ; float n ; float ne ; float e ; float se ; float s ; float sw ; float w ; float nw ; / / calculate derivatives for ( int x = 0 ; x < X ; x + + ) { for ( int y = 0 ; y < Y ; y + + ) { try { c = image . get ( x , y ) ; n = image . get ( x , y - 1 ) ; ne = image . get ( x + 1 , y - 1 ) ; e = image . get ( x + 1 , y ) ; se = image . get ( x + 1 , y + 1 ) ; s = image . get ( x , y + 1 ) ; sw = image . get ( x - 1 , y + 1 ) ; w = image . get ( x - 1 , y ) ; nw = image . get ( x - 1 , y - 1 ) ; / / calculate Ix Ix = ( - w + e ) / 2 ; / / calculate Iy Iy = ( - n + s ) / 2 ; / / calculate Ixx Ixx = w + ( - 2 * c ) + e ; / / calculate Iyy Iyy = n + ( - 2 * c ) + s ; / / calculate Ixy Ixy = ( nw + - ne + - sw + se ) / 4 ; / / calculate Iso Iso = ( float ) ( ( ( Iy * Iy * Ixx ) - ( 2 * Ix * Ixy * Iy ) + ( Iyy * Ix * Ix ) ) / Math . sqrt ( ( ( Ix * Ix ) + ( Iy * Iy ) ) * ( ( Ix * Ix ) + ( Iy * Iy ) ) * ( ( Ix * Ix ) + ( Iy * Iy ) ) ) ) ; / / put the result floato output image IsophoteCurvature . set ( x , y , Iso ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } } } return IsophoteCurvature ; }
void test8 ( ) throws Throwable { Scaler scaler0 = new Scaler ( ) ; InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 46 , 46 ) ; InterpolatedGrayImage interpolatedGrayImage1 = ( InterpolatedGrayImage ) interpolatedGrayImage0 . clear ( ( Integer ) 46 ) ; GrayImage grayImage0 = scaler0 . calcIsophoteOnce ( ( GrayImage ) interpolatedGrayImage1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( ) ; GrayImage grayImage0 = ImageConverter . toGray ( ( Image ) interpolatedColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 0 , 1 ) ; GrayImage grayImage0 = ImageConverter . toGray ( ( Image ) interpolatedGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; GrayImage grayImage0 = ImageConverter . toGray ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test3 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 0 , 0 ) ; ComplexImage complexImage0 = ImageConverter . toComplex ( ( ColorImage ) interpolatedColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( 0 , 0 ) ; GrayImage grayImage0 = ImageConverter . toGray ( ( Image ) interpolatedRealColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( 0 , 0 ) ; RealGrayImage realGrayImage0 = ImageConverter . toRealGray ( ( Image ) interpolatedRealColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ColorImage toColor ( Image img ) throws ColorModelNotSupportedException , ColorModelUnknownException { if ( img instanceof GrayImage ) { return toColor ( img ) ; } else if ( img instanceof RealGrayImage ) { return toColor ( ( RealGrayImage ) img ) ; } else if ( img instanceof ColorImage ) { return toColor ( ( ColorImage ) img ) ; } else if ( img instanceof RealColorImage ) { return toColor ( ( RealColorImage ) img ) ; } else { return toColor ( ( ComplexImage ) img ) ; } }
void test6 ( ) throws Throwable { KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; RealGrayImage realGrayImage0 = ImageConverter . toRealGray ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test7 ( ) throws Throwable { KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; ComplexImage complexImage0 = ImageConverter . toComplex ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test9 ( ) throws Throwable { ComplexImage complexImage0 = new ComplexImage ( ) ; ColorImage colorImage0 = ImageConverter . toColor ( ( Image ) complexImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test10 ( ) throws Throwable { InterpolatedColorImage interpolatedColorImage0 = new InterpolatedColorImage ( 0 , 0 ) ; RealGrayImage realGrayImage0 = ImageConverter . toRealGray ( ( Image ) interpolatedColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test11 ( ) throws Throwable { InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( 0 , 0 ) ; ColorImage colorImage0 = ImageConverter . toColor ( ( Image ) interpolatedRealColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test13 ( ) throws Throwable { InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( ) ; RealColorImage realColorImage0 = ImageConverter . toRealColor ( ( Image ) interpolatedRealColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test17 ( ) throws Throwable { InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( 0 , 0 ) ; ComplexImage complexImage0 = ImageConverter . toComplex ( ( Image ) interpolatedRealColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test20 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( 15 , 15 ) ; GrayImage grayImage0 = ImageConverter . toGray ( binaryImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test21 ( ) throws Throwable { int [ ] [ ] intArray0 = new int [ 1 ] [ 3 ] ; int [ ] intArray1 = new int [ 1 ] ; intArray1 [ 0 ] = 1 ; intArray0 [ 0 ] = intArray1 ; GrayImage grayImage0 = new GrayImage ( intArray0 ) ; BinaryImage binaryImage0 = new BinaryImage ( grayImage0 ) ; GrayImage grayImage1 = ImageConverter . toGray ( binaryImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test24 ( ) throws Throwable { KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; ComplexImage complexImage0 = ImageConverter . toComplex ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test25 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 2 , 2 ) ; InterpolatedGrayImage interpolatedGrayImage1 = ( InterpolatedGrayImage ) interpolatedGrayImage0 . clear ( ( Integer ) 2 ) ; RealGrayImage realGrayImage0 = ImageConverter . toRealGray ( ( GrayImage ) interpolatedGrayImage1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test27 ( ) throws Throwable { KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; ComplexImage complexImage0 = ImageConverter . toComplex ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test28 ( ) throws Throwable { ImageKernel imageKernel0 = new ImageKernel ( 4 . 0F , 0 ) ; RealGrayImage realGrayImage0 = imageKernel0 . addbuffer ( 14 , 14 , 0 ) ; ColorImage colorImage0 = ImageConverter . toColor ( realGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test29 ( ) throws Throwable { KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; ComplexImage complexImage0 = ImageConverter . toComplex ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test30 ( ) throws Throwable { KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; GrayImage grayImage0 = ImageConverter . toGray ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test31 ( ) throws Throwable { ImageKernel imageKernel0 = new ImageKernel ( 4 . 0F , 0 ) ; ComplexImage complexImage0 = ImageConverter . toComplex ( ( RealGrayImage ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test32 ( ) throws Throwable { KernelType kernelType0 = KernelType . UNSHARP ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; RealColorImage realColorImage0 = ImageConverter . toRealColor ( ( RealGrayImage ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test33 ( ) throws Throwable { InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( 2 , 2 ) ; RealColorImage realColorImage0 = ImageConverter . toRealColor ( ( RealColorImage ) interpolatedRealColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test34 ( ) throws Throwable { KernelType kernelType0 = KernelType . SOBEL_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; GrayImage grayImage0 = ImageConverter . toGray ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { ImageGenerator imageGenerator0 = new ImageGenerator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test2 ( ) throws Throwable { RealGrayImage realGrayImage0 = ImageGenerator . stripes ( 0 , 0 , ( float ) 0 , 0 . 0F , 0 , ( - 1388 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test3 ( ) throws Throwable { RealGrayImage realGrayImage0 = ImageGenerator . stripes ( 1080 , 8 , ( - 1200 ) , 8 , 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { RealGrayImage realGrayImage0 = ImageGenerator . gaussian ( 3 , 128 , ( - 592 . 3984F ) , 0 . 0F , ( - 592 . 3984F ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] addSum ( ) { int [ ] sum = new int [ 3 ] ; sum [ 0 ] = planes [ 0 ] . addSum ( ) ; sum [ 1 ] = planes [ 1 ] . addSum ( ) ; sum [ 2 ] = planes [ 2 ] . addSum ( ) ; return sum ; }
void test5 ( ) throws Throwable { ComplexImage complexImage0 = ImageGenerator . buildGaussInFreqDomain ( 2032 . 9004F , 0 , 9 , 1229 , 0 , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test7 ( ) throws Throwable { ComplexImage complexImage0 = ImageGenerator . buildLinearFilter ( 1 . 0F , 1 , 1 , 1 , 1 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test8 ( ) throws Throwable { RealGrayImage realGrayImage0 = ImageGenerator . ngaussian ( 1 , 8 , 255 . 0F , 0 . 0F , 255 . 0F ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test9 ( ) throws Throwable { RealGrayImage realGrayImage0 = ImageGenerator . sinusoid ( 3 , 3 , 3 , ( - 1154 . 2017F ) , 129 . 09813F ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test10 ( ) throws Throwable { RealGrayImage realGrayImage0 = ImageGenerator . sinusoid ( 1 , 1 , 1 , 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { ColorSpace colorSpace0 = new ColorSpace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ColorSpace ( ) { }
void test3 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 15 ] ; Float float0 = new Float ( ( - 836 . 6081F ) ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = ( Float ) ( - 951 . 6899F ) ; Float float1 = new Float ( 146 . 90596F ) ; floatArray0 [ 2 ] = float1 ; Float [ ] floatArray1 = ColorSpace . RGBtoHSV ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test4 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 25 ] ; Float float0 = new Float ( ( - 993 . 9718363923822 ) ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = floatArray0 [ 0 ] ; floatArray0 [ 2 ] = float0 ; Float [ ] floatArray1 = ColorSpace . RGBtoHLS ( floatArray0 ) ; Float [ ] floatArray2 = ColorSpace . HLStoRGB ( floatArray1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test5 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 7 ] ; Float float0 = new Float ( ( - 993 . 9718363923822 ) ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = floatArray0 [ 0 ] ; Float float1 = new Float ( 997 . 0329028045215 ) ; floatArray0 [ 2 ] = float1 ; Float [ ] floatArray1 = ColorSpace . RGBtoHLS ( floatArray0 ) ; Float [ ] floatArray2 = ColorSpace . HSVtoRGB ( floatArray1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test6 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 3 ] ; Float float0 = new Float ( ( - 1820 . 2139429519984 ) ) ; floatArray0 [ 0 ] = float0 ; Float float1 = new Float ( 1 . 0 ) ; floatArray0 [ 1 ] = float1 ; floatArray0 [ 2 ] = float1 ; Float [ ] floatArray1 = ColorSpace . RGBtoHSV ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test7 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 3 ] ; Float float0 = new Float ( ( - 1820 . 2139429519984 ) ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = float0 ; floatArray0 [ 2 ] = float0 ; Float [ ] floatArray1 = ColorSpace . RGBtoHSV ( floatArray0 ) ; Float [ ] floatArray2 = ColorSpace . RGBtoHLS ( floatArray1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test8 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 5 ] ; Float float0 = new Float ( 0 . 0 ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = float0 ; Float float1 = new Float ( ( - 0 . 2716 ) ) ; floatArray0 [ 2 ] = float1 ; Float [ ] floatArray1 = ColorSpace . RGBtoHSV ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test9 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 10 ] ; Float float0 = new Float ( ( - 1 . 0 ) ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = float0 ; floatArray0 [ 2 ] = floatArray0 [ 0 ] ; Float [ ] floatArray1 = ColorSpace . HLStoRGB ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test10 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 3 ] ; Float float0 = new Float ( 754 . 9544F ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = float0 ; floatArray0 [ 2 ] = float0 ; Float [ ] floatArray1 = ColorSpace . HLStoRGB ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test11 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 25 ] ; Float float0 = new Float ( ( - 993 . 9718363923822 ) ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = floatArray0 [ 0 ] ; floatArray0 [ 2 ] = float0 ; Float [ ] floatArray1 = ColorSpace . HLStoRGB ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test12 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 0 , 255 ) ; float [ ] floatArray0 = new float [ 10 ] ; RealColorImage realColorImage1 = realColorImage0 . addbuffer ( 1552 , 0 , floatArray0 ) ; RealColorImage realColorImage2 = ColorSpace . RGBtoHSV ( realColorImage1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test13 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 0 , 255 ) ; float [ ] floatArray0 = new float [ 10 ] ; RealColorImage realColorImage1 = realColorImage0 . addbuffer ( 1552 , 0 , floatArray0 ) ; RealColorImage realColorImage2 = ColorSpace . HSVtoRGB ( realColorImage1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test15 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 0 , 255 ) ; float [ ] floatArray0 = new float [ 10 ] ; RealColorImage realColorImage1 = realColorImage0 . addbuffer ( 1552 , 0 , floatArray0 ) ; RealColorImage realColorImage2 = ColorSpace . RGBtoHLS ( realColorImage1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test17 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 0 , 255 ) ; float [ ] floatArray0 = new float [ 10 ] ; RealColorImage realColorImage1 = realColorImage0 . addbuffer ( 1552 , 0 , floatArray0 ) ; RealColorImage realColorImage2 = ColorSpace . HLStoRGB ( realColorImage1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test19 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 0 , 255 ) ; float [ ] floatArray0 = new float [ 10 ] ; RealColorImage realColorImage1 = realColorImage0 . addbuffer ( 1552 , 0 , floatArray0 ) ; RealColorImage realColorImage2 = ColorSpace . RGBtoCMY ( realColorImage1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test20 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 16 , 0 ) ; RealColorImage realColorImage1 = ColorSpace . CMYtoRGB ( realColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test22 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 0 , 255 ) ; float [ ] floatArray0 = new float [ 10 ] ; RealColorImage realColorImage1 = realColorImage0 . addbuffer ( 1552 , 0 , floatArray0 ) ; RealColorImage realColorImage2 = ColorSpace . RGBtoYIQ ( realColorImage1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test23 ( ) throws Throwable { RealColorImage realColorImage0 = new RealColorImage ( 16 , 0 ) ; RealColorImage realColorImage1 = ColorSpace . YIQtoRGB ( realColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test24 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 7 ] ; Float float0 = new Float ( 1938 . 0227F ) ; floatArray0 [ 0 ] = float0 ; Float float1 = new Float ( ( - 1 . 5361445F ) ) ; floatArray0 [ 1 ] = float1 ; floatArray0 [ 2 ] = floatArray0 [ 1 ] ; Float [ ] floatArray1 = ColorSpace . RGBtoHSV ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test26 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 5 ] ; Float float0 = new Float ( 0 . 0 ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = float0 ; floatArray0 [ 2 ] = floatArray0 [ 0 ] ; Float [ ] floatArray1 = ColorSpace . RGBtoHSV ( floatArray0 ) ; Float [ ] floatArray2 = ColorSpace . HSVtoRGB ( floatArray1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test27 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 5 ] ; Float float0 = new Float ( ( float ) 360 ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = floatArray0 [ 0 ] ; floatArray0 [ 2 ] = floatArray0 [ 1 ] ; Float [ ] floatArray1 = ColorSpace . HSVtoRGB ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test28 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 10 ] ; Float float0 = new Float ( ( - 1 . 0 ) ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = floatArray0 [ 0 ] ; floatArray0 [ 2 ] = floatArray0 [ 0 ] ; Float [ ] floatArray1 = ColorSpace . HSVtoRGB ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test29 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 8 ] ; Float float0 = new Float ( 180 . 0F ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = floatArray0 [ 0 ] ; floatArray0 [ 2 ] = floatArray0 [ 0 ] ; Float [ ] floatArray1 = ColorSpace . RGBtoCMY ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealColorImage HSVtoRGB ( RealColorImage image ) throws NotHSVColorSpaceException { RealColorImage rImage = new RealColorImage ( image . X ( ) , image . Y ( ) ) ; for ( int x = 0 ; x < image . X ( ) ; x + + ) for ( int y = 0 ; y < image . Y ( ) ; y + + ) rImage . set ( x , y , HSVtoRGB ( image . get ( x , y ) ) ) ; return rImage ; }
void test30 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 6 ] ; Float float0 = new Float ( 120 . 0 ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = float0 ; floatArray0 [ 2 ] = floatArray0 [ 1 ] ; Float [ ] floatArray1 = ColorSpace . HSVtoRGB ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test31 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 8 ] ; Float float0 = new Float ( 180 . 0F ) ; floatArray0 [ 0 ] = float0 ; floatArray0 [ 1 ] = floatArray0 [ 0 ] ; floatArray0 [ 2 ] = floatArray0 [ 0 ] ; Float [ ] floatArray1 = ColorSpace . HSVtoRGB ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test32 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 7 ] ; Float float0 = new Float ( 1938 . 0227F ) ; floatArray0 [ 0 ] = float0 ; Float float1 = new Float ( ( - 1 . 5361445F ) ) ; floatArray0 [ 1 ] = float1 ; floatArray0 [ 2 ] = floatArray0 [ 0 ] ; Float [ ] floatArray1 = ColorSpace . RGBtoHSV ( floatArray0 ) ; Float [ ] floatArray2 = ColorSpace . HSVtoRGB ( floatArray1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test33 ( ) throws Throwable { Float [ ] floatArray0 = new Float [ 6 ] ; Float float0 = new Float ( 1509 . 1448563722215 ) ; floatArray0 [ 0 ] = float0 ; Float float1 = new Float ( ( - 960 . 01984F ) ) ; floatArray0 [ 1 ] = float1 ; floatArray0 [ 2 ] = float0 ; Float [ ] floatArray1 = ColorSpace . RGBtoHLS ( floatArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test0 ( ) throws Throwable { DummyObserver dummyObserver0 = new DummyObserver ( ) ; boolean boolean0 = dummyObserver0 . imageUpdate ( ( Image ) null , 1225 , ( - 343 ) , ( - 343 ) , 0 , ( - 1180 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean imageUpdate ( java . awt . Image img , int f , int x , int y , int w , int h ) { return false ; }
void test0 ( ) throws Throwable { PhaseSignal phaseSignal0 = new PhaseSignal ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( ) ; PhaseSignal phaseSignal0 = new PhaseSignal ( complexSignal0 ) ; PhaseSignal phaseSignal1 = new PhaseSignal ( phaseSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PhaseSignal ( ) { super ( ) ; }
void test2 ( ) throws Throwable { PhaseSignal phaseSignal0 = new PhaseSignal ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test3 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 1179 ) ; PhaseSignal phaseSignal0 = new PhaseSignal ( complexSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test0 ( ) throws Throwable { ROI rOI0 = new ROI ( 0 , 0 ) ; int int0 = rOI0 . ubound ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test1 ( ) throws Throwable { ROI rOI0 = new ROI ( ) ; int int0 = rOI0 . lbound ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int ubound ( ) { return m_ubound ; }
void test2 ( ) throws Throwable { ROI rOI0 = new ROI ( 0 , 1922 ) ; int int0 = rOI0 . length ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test3 ( ) throws Throwable { ROI rOI0 = new ROI ( 567 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test4 ( ) throws Throwable { ROI rOI0 = new ROI ( 1481 , 1481 ) ; rOI0 . setROI ( 0 , ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int ubound ( ) { return m_ubound ; }
void test5 ( ) throws Throwable { ROI rOI0 = new ROI ( 1481 , 1481 ) ; rOI0 . setROI ( 1481 , 1886 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test0 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { short [ ] shortArray0 = new short [ 1 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; discreteSignal0 . subtract ( ( int ) ( short ) 0 , 1762 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test2 ( ) throws Throwable { short [ ] shortArray0 = new short [ 5 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; discreteSignal0 . add ( 0 , ( - 1000 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test3 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 944 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void divide ( int x , int y , int [ ] value ) { planes [ 0 ] . divide ( x , y , value [ 0 ] ) ; planes [ 1 ] . divide ( x , y , value [ 1 ] ) ; planes [ 2 ] . divide ( x , y , value [ 2 ] ) ; }
void test5 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 944 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void divide ( int x , int y , int [ ] value ) { planes [ 0 ] . divide ( x , y , value [ 0 ] ) ; planes [ 1 ] . divide ( x , y , value [ 1 ] ) ; planes [ 2 ] . divide ( x , y , value [ 2 ] ) ; }
void test6 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test9 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test11 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test13 ( ) throws Throwable { short [ ] shortArray0 = new short [ 1 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) discreteSignal0 . copy ( rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test14 ( ) throws Throwable { short [ ] shortArray0 = new short [ 27 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = new DiscreteSignal ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test16 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 944 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test17 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test18 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 944 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test20 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test21 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test22 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test23 ( ) throws Throwable { short [ ] shortArray0 = new short [ 10 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = discreteSignal0 . add ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test24 ( ) throws Throwable { short [ ] shortArray0 = new short [ 27 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = discreteSignal0 . addbuffer ( ( int ) ( short ) 1 , ( int ) ( short ) 32767 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test25 ( ) throws Throwable { short [ ] shortArray0 = new short [ 8 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = discreteSignal0 . subtract ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void subtract ( int x , int y , int [ ] value ) { planes [ 0 ] . subtract ( x , y , value [ 0 ] ) ; planes [ 1 ] . subtract ( x , y , value [ 1 ] ) ; planes [ 2 ] . subtract ( x , y , value [ 2 ] ) ; }
void test26 ( ) throws Throwable { short [ ] shortArray0 = new short [ 8 ] ; shortArray0 [ 0 ] = ( short ) 237 ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = new DiscreteSignal ( ( int ) ( short ) 237 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ColorImage diff ( ColorImage im ) { planes [ 0 ] = planes [ 0 ] . diff ( im . plane ( 0 ) ) ; planes [ 1 ] = planes [ 1 ] . diff ( im . plane ( 1 ) ) ; planes [ 2 ] = planes [ 2 ] . diff ( im . plane ( 2 ) ) ; return this ; }
void test27 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test28 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 944 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test29 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1064 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test30 ( ) throws Throwable { short [ ] shortArray0 = new short [ 27 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; discreteSignal0 . clip ( 0 , ( int ) ( short ) ( - 1611 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test31 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test32 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test33 ( ) throws Throwable { short [ ] shortArray0 = new short [ 10 ] ; shortArray0 [ 2 ] = ( short ) ( - 314 ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; discreteSignal0 . median ( 1815 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test35 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test36 ( ) throws Throwable { short [ ] shortArray0 = new short [ 1 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = discreteSignal0 . clear ( ( - 708 ) , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test37 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test38 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test39 ( ) throws Throwable { short [ ] shortArray0 = new short [ 1 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = discreteSignal0 . subtract ( ( int ) ( short ) 0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test40 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test41 ( ) throws Throwable { short [ ] shortArray0 = new short [ 10 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = discreteSignal0 . divide ( ( int ) ( short ) 564 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test42 ( ) throws Throwable { short [ ] shortArray0 = new short [ 5 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = discreteSignal0 . subtract ( discreteSignal0 , rOI0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test43 ( ) throws Throwable { short [ ] shortArray0 = new short [ 1 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = discreteSignal0 . multiply ( discreteSignal0 , rOI0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test44 ( ) throws Throwable { short [ ] shortArray0 = new short [ 10 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = discreteSignal0 . divide ( discreteSignal0 , rOI0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test45 ( ) throws Throwable { short [ ] shortArray0 = new short [ 10 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = discreteSignal0 . add ( discreteSignal0 , rOI0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test46 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test47 ( ) throws Throwable { short [ ] shortArray0 = new short [ 1 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; discreteSignal0 . clip ( ( int ) ( short ) 0 , ( - 1 ) , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test48 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test0 ( ) throws Throwable { float [ ] floatArray0 = new float [ 1 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; signalKernel0 . normalize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test3 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 0 . 0F , 959 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test5 ( ) throws Throwable { float [ ] floatArray0 = new float [ 1 ] ; floatArray0 [ 0 ] = 443 . 94016F ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; signalKernel0 . normalize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { MagnitudeSignal magnitudeSignal0 = new MagnitudeSignal ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test1 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( ) ; MagnitudeSignal magnitudeSignal0 = new MagnitudeSignal ( complexSignal0 ) ; MagnitudeSignal magnitudeSignal1 = new MagnitudeSignal ( magnitudeSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" MagnitudeSignal ( ) { super ( ) ; }
void test2 ( ) throws Throwable { MagnitudeSignal magnitudeSignal0 = new MagnitudeSignal ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test3 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 1179 ) ; MagnitudeSignal magnitudeSignal0 = new MagnitudeSignal ( complexSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test0 ( ) throws Throwable { BinarySignal binarySignal0 = new BinarySignal ( 32767 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test1 ( ) throws Throwable { BinarySignal binarySignal0 = new BinarySignal ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test2 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 4 ] ; BinarySignal binarySignal0 = new BinarySignal ( 1 , byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test5 ( ) throws Throwable { float [ ] floatArray0 = new float [ 7 ] ; floatArray0 [ 1 ] = ( float ) 568 ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; BinarySignal binarySignal0 = new BinarySignal ( realSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test6 ( ) throws Throwable { BinarySignal binarySignal0 = new BinarySignal ( 937 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test7 ( ) throws Throwable { BinarySignal binarySignal0 = new BinarySignal ( 937 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test8 ( ) throws Throwable { BinarySignal binarySignal0 = new BinarySignal ( 32767 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test11 ( ) throws Throwable { float [ ] floatArray0 = new float [ 7 ] ; floatArray0 [ 1 ] = ( float ) 568 ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; BinarySignal binarySignal0 = new BinarySignal ( realSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" BinaryImage difference ( BinaryImage image ) { for ( int y = 0 ; y < Y ; y + + ) for ( int x = 0 ; x < X ; x + + ) if ( ( data [ y ] [ x ] = = 1 ) & & ( image . get ( x , y ) = = 0 ) ) data [ y ] [ x ] = 1 ; else if ( ( data [ y ] [ x ] = = 1 ) & & ( image . get ( x , y ) = = 0 ) ) data [ y ] [ x ] = 1 ; else data [ y ] [ x ] = 0 ; return this ; }
void test12 ( ) throws Throwable { BinarySignal binarySignal0 = new BinarySignal ( 32767 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test13 ( ) throws Throwable { BinarySignal binarySignal0 = new BinarySignal ( 32767 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test14 ( ) throws Throwable { short [ ] shortArray0 = new short [ 5 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; BinarySignal binarySignal0 = new BinarySignal ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test1 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( ) ; complexSignal0 . magnitude ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test2 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 1275 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test3 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 587 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 488 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 1275 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test6 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 496 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test11 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 496 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test12 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 496 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test13 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 587 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test15 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 1288 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setReal ( RealGrayImage pl ) { real = pl ; }
void test1 ( ) throws Throwable { float [ ] floatArray0 = new float [ 9 ] ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; ROI rOI0 = new ROI ( 1 , 0 ) ; RealSignal realSignal1 = realSignal0 . clear ( rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 900 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test3 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 740 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test6 ( ) throws Throwable { float [ ] floatArray0 = new float [ 10 ] ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; realSignal0 . convolve ( realSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test7 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 1387 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test9 ( ) throws Throwable { float [ ] floatArray0 = new float [ 1 ] ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; float [ ] floatArray1 = realSignal0 . getData ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Complex z ) { return ( ( real = = z . real ) & & ( imaginary = = z . imaginary ) ) ; }
void test11 ( ) throws Throwable { float [ ] floatArray0 = new float [ 10 ] ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; realSignal0 . subtract ( 0 , 0 . 0F ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test12 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 1387 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test14 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 1302 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test15 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void divide ( int x , int y , int [ ] value ) { planes [ 0 ] . divide ( x , y , value [ 0 ] ) ; planes [ 1 ] . divide ( x , y , value [ 1 ] ) ; planes [ 2 ] . divide ( x , y , value [ 2 ] ) ; }
void test17 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 1387 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test18 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test19 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test21 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 1302 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test22 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test23 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 740 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test24 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 1387 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test25 ( ) throws Throwable { float [ ] floatArray0 = new float [ 10 ] ; floatArray0 [ 0 ] = ( - 1418 . 9004F ) ; RealSignal realSignal0 = new RealSignal ( 1387 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test0 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( ) ; PowerSignal powerSignal0 = new PowerSignal ( complexSignal0 ) ; PowerSignal powerSignal1 = new PowerSignal ( powerSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { PowerSignal powerSignal0 = new PowerSignal ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { PowerSignal powerSignal0 = new PowerSignal ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test3 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 1179 ) ; PowerSignal powerSignal0 = new PowerSignal ( complexSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; Convolve convolve0 = new Convolve ( signalKernel0 ) ; RealSignal realSignal0 = ( RealSignal ) convolve0 . apply ( ( RealSignal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; Convolve convolve0 = new Convolve ( signalKernel0 ) ; short [ ] shortArray0 = new short [ 6 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) convolve0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test3 ( ) throws Throwable { float [ ] floatArray0 = new float [ 12 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; Convolve convolve0 = new Convolve ( signalKernel0 ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( 42 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) convolve0 . apply ( discreteSignal0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test5 ( ) throws Throwable { float [ ] floatArray0 = new float [ 5 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; Convolve convolve0 = new Convolve ( signalKernel0 ) ; ROI rOI0 = new ROI ( ) ; RealSignal realSignal0 = ( RealSignal ) convolve0 . apply ( ( RealSignal ) signalKernel0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test6 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; Convolve convolve0 = new Convolve ( signalKernel0 ) ; RealSignal realSignal0 = convolve0 . apply_long ( ( RealSignal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { ForwardFFT forwardFFT0 = new ForwardFFT ( ) ; SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; ComplexSignal complexSignal0 = ( ComplexSignal ) forwardFFT0 . apply ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { PoissonNoise poissonNoise0 = new PoissonNoise ( ) ; short [ ] shortArray0 = new short [ 4 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) poissonNoise0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { PoissonNoise poissonNoise0 = new PoissonNoise ( ) ; SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; poissonNoise0 . apply ( ( RealSignal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test1 ( ) throws Throwable { ReverseFFT reverseFFT0 = new ReverseFFT ( ) ; SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; ComplexSignal complexSignal0 = ( ComplexSignal ) reverseFFT0 . apply ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { Shift shift0 = new Shift ( ( - 2008 ) , ( - 172 ) ) ; short [ ] shortArray0 = new short [ 10 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) shift0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test1 ( ) throws Throwable { Shift shift0 = new Shift ( 1 , 1 ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( 603 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) shift0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test3 ( ) throws Throwable { Shift shift0 = new Shift ( 0 , 0 ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( 948 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) shift0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test4 ( ) throws Throwable { Shift shift0 = new Shift ( 155 , 155 ) ; short [ ] shortArray0 = new short [ 4 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) shift0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test5 ( ) throws Throwable { Shift shift0 = new Shift ( ( - 2008 ) , ( - 172 ) ) ; float [ ] floatArray0 = new float [ 1 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; RealSignal realSignal0 = ( RealSignal ) shift0 . apply ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test6 ( ) throws Throwable { Shift shift0 = new Shift ( ( - 1760 ) , 1 ) ; MagnitudeSignal magnitudeSignal0 = new MagnitudeSignal ( 1 ) ; RealSignal realSignal0 = ( RealSignal ) shift0 . apply ( ( RealSignal ) magnitudeSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test7 ( ) throws Throwable { MagnitudeSignal magnitudeSignal0 = new MagnitudeSignal ( 1 ) ; Shift shift0 = new Shift ( 1 , 1 ) ; RealSignal realSignal0 = ( RealSignal ) shift0 . apply ( ( RealSignal ) magnitudeSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test8 ( ) throws Throwable { Shift shift0 = new Shift ( 0 , 0 ) ; SignalKernel signalKernel0 = new SignalKernel ( ( float ) 0 , 339 ) ; RealSignal realSignal0 = ( RealSignal ) shift0 . apply ( ( RealSignal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test9 ( ) throws Throwable { Shift shift0 = new Shift ( 155 , 155 ) ; float [ ] floatArray0 = new float [ 5 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; RealSignal realSignal0 = ( RealSignal ) shift0 . apply ( ( RealSignal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test0 ( ) throws Throwable { UniformNoise uniformNoise0 = new UniformNoise ( 174 ) ; short [ ] shortArray0 = new short [ 4 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; uniformNoise0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test1 ( ) throws Throwable { UniformNoise uniformNoise0 = new UniformNoise ( ( - 859 ) ) ; float [ ] floatArray0 = new float [ 3 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; uniformNoise0 . apply ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { GaussianNoise gaussianNoise0 = new GaussianNoise ( 186 . 50183F ) ; float [ ] floatArray0 = new float [ 10 ] ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; RealSignal realSignal1 = ( RealSignal ) gaussianNoise0 . apply ( ( Signal ) realSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { GaussianNoise gaussianNoise0 = new GaussianNoise ( ( - 832 . 14264F ) ) ; short [ ] shortArray0 = new short [ 10 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; gaussianNoise0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test0 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( ( - 1526 . 2432F ) , 0 ) ; Open open0 = new Open ( signalKernel0 , 129 ) ; BinarySignal binarySignal0 = new BinarySignal ( 1 ) ; ROI rOI0 = new ROI ( ) ; BinarySignal binarySignal1 = ( BinarySignal ) open0 . apply ( binarySignal0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealColorImage apply ( int x1 , int y1 , int x2 , int y2 , boolean constrainTopology , boolean constrainSigns ) { / / float newAlpha = 0 . 0f ; RealGrayImage gimage , galpha , galpha_change ; for ( int i = 0 ; i < 3 ; i + + ) { gimage = image . plane ( i ) ; galpha = alpha . plane ( i ) ; galpha_change = alpha . plane ( i ) ; / / create Kappa - the isophote curvature map ldg . calcIsophoteFlow ( x1 , y1 , x2 , y2 , gimage , kappa ) ; / / same sign constraint - don't move same sign neighborhoods / / ( sets kappa to 0 if the 8 - conn neighborhood all has same sign ) if ( constrainSigns ) { constrainSigns ( kappa , x2 - x1 , y2 - y1 ) ; } / / create wants ( new + ( alpha * move ) ) - this is how the new image / / should look / / float percent = 0 ; / / float kapp = 0 ; float alphaV = 0 ; float wantV = 0 ; float changeV = 0 ; / / automatic = true ; / / copyWant ( x1 - 1 , y1 - 1 , x2 + 1 , y2 + 1 ) ; for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { alphaV = galpha . get ( x , y ) ; changeV = - galpha_change . get ( x , y ) ; wantV = gimage . get ( x , y ) + ( ( float ) alphaV * ( float ) kappa . get ( x - x1 , y - y1 ) ) ; want . set ( x - x1 , y - y1 , wantV ) ; / / boundV = 0 . 05 if ( alphaV > boundV & & alphaV + changeV > boundV ) galpha . set ( x , y , alphaV + changeV ) ; else galpha . set ( x , y , boundV ) ; } } / / topology constraint - don't let isophotes cross each other if ( constrainTopology ) { constrainTopology ( want , gimage , x1 , y1 , x2 , y2 ) ; } for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { if ( want . get ( x - x1 , y - y1 ) > 255 ) want . set ( x - x1 , y - y1 , 255f ) ; else if ( want . get ( x - x1 , y - y1 ) < 0 ) want . set ( x - x1 , y - y1 , 0f ) ; gimage . set ( x , y , want . get ( x - x1 , y - y1 ) ) ; } } } return image ; }
void test3 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; GDilate gDilate0 = new GDilate ( signalKernel0 , 0 ) ; ROI rOI0 = new ROI ( ) ; RealSignal realSignal0 = ( RealSignal ) gDilate0 . apply ( ( RealSignal ) signalKernel0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test0 ( ) throws Throwable { float [ ] floatArray0 = new float [ 9 ] ; floatArray0 [ 0 ] = 626 . 2986F ; floatArray0 [ 8 ] = 2017 . 5233F ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; Dilate dilate0 = new Dilate ( signalKernel0 ) ; BinarySignal binarySignal0 = new BinarySignal ( ( RealSignal ) signalKernel0 ) ; BinarySignal binarySignal1 = ( BinarySignal ) dilate0 . apply ( binarySignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test1 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; Erode erode0 = new Erode ( signalKernel0 , 0 ) ; byte [ ] byteArray0 = new byte [ 5 ] ; byteArray0 [ 0 ] = ( byte ) 46 ; BinarySignal binarySignal0 = new BinarySignal ( 1 , byteArray0 ) ; ROI rOI0 = new ROI ( ) ; BinarySignal binarySignal1 = ( BinarySignal ) erode0 . apply ( binarySignal0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int count ( int value ) { return values [ ( int ) ( ( value - min ) / inc ) ] ; }
void test1 ( ) throws Throwable { PowerSignal powerSignal0 = new PowerSignal ( 0 ) ; SignalKernel signalKernel0 = new SignalKernel ( ( RealSignal ) powerSignal0 ) ; GClose gClose0 = new GClose ( signalKernel0 , 0 ) ; short [ ] shortArray0 = new short [ 5 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) gClose0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test2 ( ) throws Throwable { float [ ] floatArray0 = new float [ 1 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; GClose gClose0 = new GClose ( signalKernel0 , 675 ) ; RealSignal realSignal0 = ( RealSignal ) gClose0 . apply ( ( Signal ) signalKernel0 , ( ROI ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test3 ( ) throws Throwable { float [ ] floatArray0 = new float [ 1 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; GClose gClose0 = new GClose ( signalKernel0 , 675 ) ; ROI rOI0 = new ROI ( ) ; RealSignal realSignal0 = ( RealSignal ) gClose0 . apply ( ( Signal ) signalKernel0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test0 ( ) throws Throwable { float [ ] floatArray0 = new float [ 1 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; GOpen gOpen0 = new GOpen ( signalKernel0 , 675 ) ; ROI rOI0 = new ROI ( ) ; RealSignal realSignal0 = ( RealSignal ) gOpen0 . apply ( ( Signal ) signalKernel0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test1 ( ) throws Throwable { float [ ] floatArray0 = new float [ 1 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; GOpen gOpen0 = new GOpen ( signalKernel0 , 675 ) ; RealSignal realSignal0 = ( RealSignal ) gOpen0 . apply ( ( Signal ) signalKernel0 , ( ROI ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test2 ( ) throws Throwable { PowerSignal powerSignal0 = new PowerSignal ( 0 ) ; SignalKernel signalKernel0 = new SignalKernel ( ( RealSignal ) powerSignal0 ) ; GOpen gOpen0 = new GOpen ( signalKernel0 , 0 ) ; short [ ] shortArray0 = new short [ 5 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) gOpen0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealColorImage apply ( int x1 , int y1 , int x2 , int y2 , boolean constrainTopology , boolean constrainSigns ) { / / float newAlpha = 0 . 0f ; RealGrayImage gimage , galpha , galpha_change ; for ( int i = 0 ; i < 3 ; i + + ) { gimage = image . plane ( i ) ; galpha = alpha . plane ( i ) ; galpha_change = alpha . plane ( i ) ; / / create Kappa - the isophote curvature map ldg . calcIsophoteFlow ( x1 , y1 , x2 , y2 , gimage , kappa ) ; / / same sign constraint - don't move same sign neighborhoods / / ( sets kappa to 0 if the 8 - conn neighborhood all has same sign ) if ( constrainSigns ) { constrainSigns ( kappa , x2 - x1 , y2 - y1 ) ; } / / create wants ( new + ( alpha * move ) ) - this is how the new image / / should look / / float percent = 0 ; / / float kapp = 0 ; float alphaV = 0 ; float wantV = 0 ; float changeV = 0 ; / / automatic = true ; / / copyWant ( x1 - 1 , y1 - 1 , x2 + 1 , y2 + 1 ) ; for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { alphaV = galpha . get ( x , y ) ; changeV = - galpha_change . get ( x , y ) ; wantV = gimage . get ( x , y ) + ( ( float ) alphaV * ( float ) kappa . get ( x - x1 , y - y1 ) ) ; want . set ( x - x1 , y - y1 , wantV ) ; / / boundV = 0 . 05 if ( alphaV > boundV & & alphaV + changeV > boundV ) galpha . set ( x , y , alphaV + changeV ) ; else galpha . set ( x , y , boundV ) ; } } / / topology constraint - don't let isophotes cross each other if ( constrainTopology ) { constrainTopology ( want , gimage , x1 , y1 , x2 , y2 ) ; } for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { if ( want . get ( x - x1 , y - y1 ) > 255 ) want . set ( x - x1 , y - y1 , 255f ) ; else if ( want . get ( x - x1 , y - y1 ) < 0 ) want . set ( x - x1 , y - y1 , 0f ) ; gimage . set ( x , y , want . get ( x - x1 , y - y1 ) ) ; } } } return image ; }
void test0 ( ) throws Throwable { float [ ] floatArray0 = new float [ 1 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; GErode gErode0 = new GErode ( signalKernel0 , 1 ) ; short [ ] shortArray0 = new short [ 4 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) gErode0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test1 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 1 ) ; GErode gErode0 = new GErode ( signalKernel0 , 0 ) ; ROI rOI0 = new ROI ( ) ; short [ ] shortArray0 = new short [ 1 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) gErode0 . apply ( discreteSignal0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test2 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 1 ) ; GErode gErode0 = new GErode ( signalKernel0 , ( - 1 ) ) ; RealSignal realSignal0 = ( RealSignal ) gErode0 . apply ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( ( - 1526 . 2432F ) , 0 ) ; Close close0 = new Close ( signalKernel0 , 129 ) ; BinarySignal binarySignal0 = new BinarySignal ( 1 ) ; ROI rOI0 = new ROI ( ) ; BinarySignal binarySignal1 = ( BinarySignal ) close0 . apply ( binarySignal0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RealColorImage apply ( int x1 , int y1 , int x2 , int y2 , boolean constrainTopology , boolean constrainSigns ) { / / float newAlpha = 0 . 0f ; RealGrayImage gimage , galpha , galpha_change ; for ( int i = 0 ; i < 3 ; i + + ) { gimage = image . plane ( i ) ; galpha = alpha . plane ( i ) ; galpha_change = alpha . plane ( i ) ; / / create Kappa - the isophote curvature map ldg . calcIsophoteFlow ( x1 , y1 , x2 , y2 , gimage , kappa ) ; / / same sign constraint - don't move same sign neighborhoods / / ( sets kappa to 0 if the 8 - conn neighborhood all has same sign ) if ( constrainSigns ) { constrainSigns ( kappa , x2 - x1 , y2 - y1 ) ; } / / create wants ( new + ( alpha * move ) ) - this is how the new image / / should look / / float percent = 0 ; / / float kapp = 0 ; float alphaV = 0 ; float wantV = 0 ; float changeV = 0 ; / / automatic = true ; / / copyWant ( x1 - 1 , y1 - 1 , x2 + 1 , y2 + 1 ) ; for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { alphaV = galpha . get ( x , y ) ; changeV = - galpha_change . get ( x , y ) ; wantV = gimage . get ( x , y ) + ( ( float ) alphaV * ( float ) kappa . get ( x - x1 , y - y1 ) ) ; want . set ( x - x1 , y - y1 , wantV ) ; / / boundV = 0 . 05 if ( alphaV > boundV & & alphaV + changeV > boundV ) galpha . set ( x , y , alphaV + changeV ) ; else galpha . set ( x , y , boundV ) ; } } / / topology constraint - don't let isophotes cross each other if ( constrainTopology ) { constrainTopology ( want , gimage , x1 , y1 , x2 , y2 ) ; } for ( int x = x1 ; x < x2 ; x + + ) { for ( int y = y1 ; y < y2 ; y + + ) { if ( want . get ( x - x1 , y - y1 ) > 255 ) want . set ( x - x1 , y - y1 , 255f ) ; else if ( want . get ( x - x1 , y - y1 ) < 0 ) want . set ( x - x1 , y - y1 , 0f ) ; gimage . set ( x , y , want . get ( x - x1 , y - y1 ) ) ; } } } return image ; }
void test0 ( ) throws Throwable { Window window0 = new Window ( 0 , 0 ) ; short [ ] shortArray0 = new short [ 10 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; window0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { Window window0 = new Window ( 1 , 834 ) ; short [ ] shortArray0 = new short [ 10 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) window0 . apply ( discreteSignal0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { Window window0 = new Window ( 1 , 834 ) ; short [ ] shortArray0 = new short [ 10 ] ; shortArray0 [ 0 ] = ( short ) 255 ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) window0 . apply ( discreteSignal0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { Window window0 = new Window ( ( - 379 . 99493F ) , 914 . 8673F ) ; float [ ] floatArray0 = new float [ 4 ] ; floatArray0 [ 3 ] = 914 . 8673F ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; RealSignal realSignal1 = ( RealSignal ) window0 . apply ( realSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test5 ( ) throws Throwable { Window window0 = new Window ( ( - 379 . 99493F ) , 914 . 8673F ) ; float [ ] floatArray0 = new float [ 4 ] ; floatArray0 [ 0 ] = ( - 379 . 99493F ) ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; RealSignal realSignal1 = ( RealSignal ) window0 . apply ( realSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test0 ( ) throws Throwable { Scale scale0 = new Scale ( 0 . 0F , 0 . 0F ) ; short [ ] shortArray0 = new short [ 10 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) scale0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { Scale scale0 = new Scale ( 0 , 1 ) ; short [ ] shortArray0 = new short [ 4 ] ; shortArray0 [ 0 ] = ( short ) ( - 1691 ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; scale0 . apply ( discreteSignal0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test4 ( ) throws Throwable { Scale scale0 = new Scale ( 1432 , 1432 ) ; float [ ] floatArray0 = new float [ 6 ] ; floatArray0 [ 0 ] = ( float ) 1432 ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; SignalKernel signalKernel1 = ( SignalKernel ) scale0 . apply ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { Exp exp0 = new Exp ( ) ; float [ ] floatArray0 = new float [ 8 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; exp0 . apply ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test1 ( ) throws Throwable { Exp exp0 = new Exp ( ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( 380 ) ; RealSignal realSignal0 = ( RealSignal ) exp0 . apply ( ( Signal ) discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test0 ( ) throws Throwable { Log log0 = new Log ( ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( 380 ) ; RealSignal realSignal0 = ( RealSignal ) log0 . apply ( ( Signal ) discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { Log log0 = new Log ( ) ; float [ ] floatArray0 = new float [ 8 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; log0 . apply ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test0 ( ) throws Throwable { ClipNeg clipNeg0 = new ClipNeg ( ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( 380 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) clipNeg0 . apply ( ( Signal ) discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test1 ( ) throws Throwable { ClipNeg clipNeg0 = new ClipNeg ( ) ; short [ ] shortArray0 = new short [ 7 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; discreteSignal0 . add ( ( int ) ( short ) ( - 470 ) ) ; ROI rOI0 = new ROI ( ) ; clipNeg0 . apply ( discreteSignal0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { ClipNeg clipNeg0 = new ClipNeg ( ) ; float [ ] floatArray0 = new float [ 9 ] ; floatArray0 [ 0 ] = ( - 1060 . 0751F ) ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; clipNeg0 . apply ( realSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test0 ( ) throws Throwable { Clip clip0 = new Clip ( 0 . 0F , 0 . 0F ) ; PhaseSignal phaseSignal0 = new PhaseSignal ( 1 ) ; PhaseSignal phaseSignal1 = ( PhaseSignal ) clip0 . apply ( ( RealSignal ) phaseSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test2 ( ) throws Throwable { Clip clip0 = new Clip ( 0 . 0F , 0 . 0F ) ; short [ ] shortArray0 = new short [ 10 ] ; shortArray0 [ 0 ] = ( short ) 1920 ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; clip0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test3 ( ) throws Throwable { Clip clip0 = new Clip ( 0 , 1 ) ; short [ ] shortArray0 = new short [ 4 ] ; shortArray0 [ 0 ] = ( short ) ( - 1691 ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ROI rOI0 = new ROI ( ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) clip0 . apply ( discreteSignal0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test5 ( ) throws Throwable { Clip clip0 = new Clip ( 0 . 0F , ( - 1 . 0F ) ) ; PhaseSignal phaseSignal0 = new PhaseSignal ( 1 ) ; ROI rOI0 = new ROI ( ) ; PhaseSignal phaseSignal1 = ( PhaseSignal ) clip0 . apply ( ( RealSignal ) phaseSignal0 , rOI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test0 ( ) throws Throwable { Negate negate0 = new Negate ( ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( 380 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) negate0 . apply ( ( Signal ) discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test1 ( ) throws Throwable { Negate negate0 = new Negate ( ) ; float [ ] floatArray0 = new float [ 8 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; negate0 . apply ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test0 ( ) throws Throwable { ByteSize byteSize0 = new ByteSize ( ) ; short [ ] shortArray0 = new short [ 8 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) byteSize0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { ByteSize byteSize0 = new ByteSize ( ) ; SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; byteSize0 . apply ( ( RealSignal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test1 ( ) throws Throwable { Threshold threshold0 = new Threshold ( 1 . 0F ) ; short [ ] shortArray0 = new short [ 5 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; threshold0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test2 ( ) throws Throwable { Threshold threshold0 = new Threshold ( ( - 1 ) ) ; short [ ] shortArray0 = new short [ 8 ] ; shortArray0 [ 2 ] = ( short ) ( - 609 ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; DiscreteSignal discreteSignal1 = ( DiscreteSignal ) threshold0 . apply ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test3 ( ) throws Throwable { Threshold threshold0 = new Threshold ( 32767 ) ; float [ ] floatArray0 = new float [ 9 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; SignalKernel signalKernel1 = ( SignalKernel ) threshold0 . apply ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test0 ( ) throws Throwable { Negative negative0 = new Negative ( ) ; float [ ] floatArray0 = new float [ 8 ] ; SignalKernel signalKernel0 = new SignalKernel ( floatArray0 ) ; SignalKernel signalKernel1 = ( SignalKernel ) negative0 . apply ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test1 ( ) throws Throwable { Negative negative0 = new Negative ( ) ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( 380 ) ; negative0 . apply ( ( Signal ) discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test0 ( ) throws Throwable { SignalOutputStream signalOutputStream0 = new SignalOutputStream ( ) ; int int0 = signalOutputStream0 . ndims ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int ndims ( ) { return ndims ; }
void test3 ( ) throws Throwable { SignalOutputStream signalOutputStream0 = new SignalOutputStream ( ) ; int int0 = signalOutputStream0 . X ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int X ( ) ; / * * Returns the height of the image * / int Y ( ) ; / / - - - Access and Manipulation - - - T get ( int x , int y ) ; void set ( int x , int y , T value ) ; void set ( int x , int y , T value , ROI roi ) ; Image < T > clear ( ) ; Image < T > clear ( T constant ) ; T min ( ) ; T max ( ) ; / * * Returns a string representation of an image * / String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { SignalOutputStream signalOutputStream0 = new SignalOutputStream ( ) ; SignalOutputStream signalOutputStream1 = new SignalOutputStream ( signalOutputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int ndims ( ) { return ndims ; }
void test0 ( ) throws Throwable { BinarySignal binarySignal0 = new BinarySignal ( 512 ) ; ComplexSignal complexSignal0 = FFT . inverse ( ( Signal ) binarySignal0 ) ; ComplexSignal complexSignal1 = FFT . forward ( ( Signal ) complexSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; ComplexSignal complexSignal0 = FFT . forward ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { short [ ] shortArray0 = new short [ 8 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ComplexSignal complexSignal0 = FFT . forward ( ( Signal ) discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { BinarySignal binarySignal0 = new BinarySignal ( 16 ) ; ComplexSignal complexSignal0 = FFT . forward ( ( Signal ) binarySignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test6 ( ) throws Throwable { short [ ] shortArray0 = new short [ 8 ] ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; ComplexSignal complexSignal0 = FFT . inverse ( ( Signal ) discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test7 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 16 ) ; ComplexSignal complexSignal0 = FFT . inverse ( ( Signal ) realSignal0 ) ; ComplexSignal complexSignal1 = FFT . inverse ( ( Signal ) complexSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test0 ( ) throws Throwable { SignalConverter signalConverter0 = new SignalConverter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SignalConverter ( ) { }
void test2 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( 2003 ) ; DiscreteSignal discreteSignal1 = SignalConverter . toDiscrete ( ( Signal ) discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int length ( ) { return values . length ; }
void test3 ( ) throws Throwable { MagnitudeSignal magnitudeSignal0 = new MagnitudeSignal ( ) ; DiscreteSignal discreteSignal0 = SignalConverter . toDiscrete ( ( Signal ) magnitudeSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { DiscreteSignal discreteSignal0 = new DiscreteSignal ( ) ; ComplexSignal complexSignal0 = SignalConverter . toComplex ( ( Signal ) discreteSignal0 ) ; RealSignal realSignal0 = SignalConverter . toReal ( ( Signal ) complexSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test5 ( ) throws Throwable { RealSignal realSignal0 = new RealSignal ( 29 ) ; DiscreteSignal discreteSignal0 = SignalConverter . toDiscrete ( realSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test6 ( ) throws Throwable { MagnitudeSignal magnitudeSignal0 = new MagnitudeSignal ( ) ; RealSignal realSignal0 = SignalConverter . toReal ( ( Signal ) magnitudeSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float max ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmax = 0 ; float max = 0 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = sequence . get ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmax = gimage . max ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmax = rgimage . max ( ) ; } if ( max < tmax ) max = tmax ; } return max ; }
void test8 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; ComplexSignal complexSignal0 = SignalConverter . toComplex ( ( Signal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test9 ( ) throws Throwable { SignalKernel signalKernel0 = new SignalKernel ( 0 ) ; RealSignal realSignal0 = SignalConverter . toReal ( ( RealSignal ) signalKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { SignalOps signalOps0 = new SignalOps ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { SignalGenerator signalGenerator0 = new SignalGenerator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { RealSignal realSignal0 = SignalGenerator . uniform ( 1579 , ( - 9 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { RealSignal realSignal0 = SignalGenerator . sinusoid ( 1579 , 1579 , 1579 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float min ( ) throws ColorModelUnknownException , ColorModelNotSupportedException { / / jigl . image . Image image = null ; GrayImage gimage = null ; RealGrayImage rgimage = null ; float tmin = 0 ; float min = 256 ; for ( Image image : sequence ) { / / for ( int a = 0 ; a < sequence . size ( ) ; a + + ) { / / image = ( jigl . image . Image ) sequence . elementAt ( a ) ; if ( image instanceof GrayImage ) { gimage = ( GrayImage ) ( image ) ; tmin = gimage . min ( ) ; } else if ( image instanceof RealGrayImage ) { rgimage = ( RealGrayImage ) ( image ) ; tmin = rgimage . min ( ) ; } if ( min > tmin ) min = tmin ; } return min ; }
void test0 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; int int0 = jImageCanvas0 . getSelectionBoxExtentY ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorX ( ) { return m_boxux ; }
void test1 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; int int0 = jImageCanvas0 . getSelectionBoxAnchorX ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorY ( ) { return m_boxuy ; }
void test2 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; int int0 = jImageCanvas0 . getSelectionBoxAnchorY ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorX ( ) { return m_boxux ; }
void test3 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; jImageCanvas0 . getJavaImage ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentX ( ) { return m_boxlx ; }
void test4 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 8 , 8 ) ; interpolatedGrayImage0 . clear ( ( Integer ) 8 ) ; JImageCanvas jImageCanvas0 = new JImageCanvas ( ( GrayImage ) interpolatedGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentY ( ) { return m_boxly ; }
void test7 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 8 , 8 ) ; InterpolatedGrayImage interpolatedGrayImage1 = ( InterpolatedGrayImage ) interpolatedGrayImage0 . clear ( ( Integer ) 8 ) ; JImageCanvas jImageCanvas0 = new JImageCanvas ( ( GrayImage ) interpolatedGrayImage1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentY ( ) { return m_boxly ; }
void test8 ( ) throws Throwable { BinaryImage binaryImage0 = new BinaryImage ( ) ; JImageCanvas jImageCanvas0 = new JImageCanvas ( binaryImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void update ( Graphics g ) { java . awt . Image i = image ; g . drawImage ( i , 0 , 0 , this ) ; / / Graphics gr = this . getGraphics ( ) ; }
void test9 ( ) throws Throwable { KernelType kernelType0 = KernelType . PREWITT_X ; ImageKernel imageKernel0 = new ImageKernel ( kernelType0 ) ; JImageCanvas jImageCanvas0 = new JImageCanvas ( ( RealGrayImage ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test12 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 8 , 8 ) ; InterpolatedGrayImage interpolatedGrayImage1 = ( InterpolatedGrayImage ) interpolatedGrayImage0 . clear ( ( Integer ) 8 ) ; JImageCanvas jImageCanvas0 = new JImageCanvas ( ( GrayImage ) interpolatedGrayImage1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setImage ( RealGrayImage im , int x1 , int y1 , int x2 , int y2 ) { for ( int x = x1 ; x < x2 ; x + + ) for ( int y = y1 ; y < y2 ; y + + ) image . set ( x , y , im . get ( x , y ) ) ; }
void test13 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 7 ] ; BinaryImage binaryImage0 = new BinaryImage ( 0 , 0 , byteArray0 ) ; JImageCanvas jImageCanvas0 = new JImageCanvas ( binaryImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Graphics setOffScreen ( ) { java . awt . Image tempSignal ; Graphics g ; tempSignal = image ; image = this . createImage ( image . getWidth ( this ) , image . getHeight ( this ) ) ; g = image . getGraphics ( ) ; g . drawImage ( tempSignal , 0 , 0 , this ) ; return g ; }
void test15 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; Dimension dimension0 = jImageCanvas0 . getPreferredSize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorX ( ) { return m_boxux ; }
void test16 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; jImageCanvas0 . getImage ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorX ( ) { return m_boxux ; }
void test17 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 8 , 8 ) ; interpolatedGrayImage0 . clear ( ( Integer ) 8 ) ; JImageCanvas jImageCanvas0 = new JImageCanvas ( ( GrayImage ) interpolatedGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorY ( ) { return m_boxuy ; }
void test18 ( ) throws Throwable { InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( 1 , 0 ) ; JImageCanvas jImageCanvas0 = new JImageCanvas ( ( RealColorImage ) interpolatedRealColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentY ( ) { return m_boxly ; }
void test19 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 8 , 8 ) ; interpolatedGrayImage0 . clear ( ( Integer ) 8 ) ; JImageCanvas jImageCanvas0 = new JImageCanvas ( ( GrayImage ) interpolatedGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getHeight ( ) { if ( image = = null ) return 0 ; return image . getHeight ( this ) ; }
void test21 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 8 , 8 ) ; interpolatedGrayImage0 . clear ( ( Integer ) 8 ) ; JImageCanvas jImageCanvas0 = new JImageCanvas ( ( GrayImage ) interpolatedGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentY ( ) { return m_boxly ; }
void test22 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; jImageCanvas0 . repaint ( 0 , 0 , 320 , 465 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorX ( ) { return m_boxux ; }
void test23 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; int int0 = jImageCanvas0 . getHeight ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorX ( ) { return m_boxux ; }
void test24 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; jImageCanvas0 . setSelectionBoxAnchor ( ( - 1335 ) , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentY ( ) { return m_boxly ; }
void test25 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; jImageCanvas0 . setSelectionBoxAnchor ( 0 , ( - 1686 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorX ( ) { return m_boxux ; }
void test26 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; jImageCanvas0 . showSelectionBox ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorY ( ) { return m_boxuy ; }
void test27 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; jImageCanvas0 . showSelectionBox ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorX ( ) { return m_boxux ; }
void test28 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; jImageCanvas0 . clearSelectionBox ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentY ( ) { return m_boxly ; }
void test29 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; Rectangle rectangle0 = jImageCanvas0 . getSelectionBox ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorX ( ) { return m_boxux ; }
void test30 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; jImageCanvas0 . setActive ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentY ( ) { return m_boxly ; }
void test31 ( ) throws Throwable { InterpolatedGrayImage interpolatedGrayImage0 = new InterpolatedGrayImage ( 8 , 8 ) ; interpolatedGrayImage0 . clear ( ( Integer ) 8 ) ; JImageCanvas jImageCanvas0 = new JImageCanvas ( ( GrayImage ) interpolatedGrayImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentY ( ) { return m_boxly ; }
void test32 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; jImageCanvas0 . showActiveBox ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentX ( ) { return m_boxlx ; }
void test33 ( ) throws Throwable { JImageCanvas jImageCanvas0 = new JImageCanvas ( ) ; jImageCanvas0 . showActiveBox ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentX ( ) { return m_boxlx ; }
void test0 ( ) throws Throwable { float [ ] floatArray0 = new float [ 5 ] ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; SignalCanvas signalCanvas0 = new SignalCanvas ( realSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { PhaseSignal phaseSignal0 = new PhaseSignal ( 0 ) ; SignalCanvas signalCanvas0 = new SignalCanvas ( ( RealSignal ) phaseSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setVisible ( boolean b ) { setSize ( imWidth ( ) , imHeight ( ) ) ; super . setVisible ( b ) ; }
void test2 ( ) throws Throwable { ComplexSignal complexSignal0 = new ComplexSignal ( 171 ) ; SignalCanvas signalCanvas0 = new SignalCanvas ( complexSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SignalCanvas ( ) { super ( ) ; }
void test4 ( ) throws Throwable { SignalCanvas signalCanvas0 = new SignalCanvas ( ) ; signalCanvas0 . getSignal ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { short [ ] shortArray0 = new short [ 6 ] ; shortArray0 [ 0 ] = ( short ) 1363 ; DiscreteSignal discreteSignal0 = new DiscreteSignal ( shortArray0 ) ; SignalCanvas signalCanvas0 = new SignalCanvas ( discreteSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Graphics setOffScreen ( ) { java . awt . Image tempSignal ; Graphics g ; tempSignal = image ; image = this . createImage ( image . getWidth ( this ) , image . getHeight ( this ) ) ; g = image . getGraphics ( ) ; g . drawImage ( tempSignal , 0 , 0 , this ) ; return g ; }
void test8 ( ) throws Throwable { SignalCanvas signalCanvas0 = new SignalCanvas ( ) ; signalCanvas0 . setSignal ( ( Image ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setSignal ( java . awt . Image sig ) { image = sig ; jsignal = null ; }
void test9 ( ) throws Throwable { SignalCanvas signalCanvas0 = new SignalCanvas ( ) ; signalCanvas0 . getJavaSignal ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test10 ( ) throws Throwable { float [ ] floatArray0 = new float [ 5 ] ; floatArray0 [ 0 ] = 32767 . 0F ; RealSignal realSignal0 = new RealSignal ( floatArray0 ) ; SignalCanvas signalCanvas0 = new SignalCanvas ( realSignal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SignalCanvas ( ) { super ( ) ; }
void test0 ( ) throws Throwable { ImageKernel imageKernel0 = new ImageKernel ( 0 . 0F , 1 ) ; ImageCanvas imageCanvas0 = new ImageCanvas ( ( RealGrayImage ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { InterpolatedRealColorImage interpolatedRealColorImage0 = new InterpolatedRealColorImage ( 0 , 0 ) ; ImageCanvas imageCanvas0 = new ImageCanvas ( ( RealColorImage ) interpolatedRealColorImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ImageCanvas ( ) { super ( ) ; }
void test2 ( ) throws Throwable { ComplexImage complexImage0 = new ComplexImage ( 0 , 0 ) ; ImageCanvas imageCanvas0 = new ImageCanvas ( complexImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test3 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; int int0 = imageCanvas0 . getSelectionBoxAnchorX ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorX ( ) { return m_boxux ; }
void test5 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; int int0 = imageCanvas0 . getSelectionBoxExtentX ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentX ( ) { return m_boxlx ; }
void test6 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; int int0 = imageCanvas0 . getSelectionBoxAnchorY ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorY ( ) { return m_boxuy ; }
void test8 ( ) throws Throwable { float [ ] [ ] floatArray0 = new float [ 1 ] [ 6 ] ; float [ ] floatArray1 = new float [ 1 ] ; floatArray0 [ 0 ] = floatArray1 ; ImageKernel imageKernel0 = new ImageKernel ( floatArray0 ) ; ImageCanvas imageCanvas0 = new ImageCanvas ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test9 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; imageCanvas0 . getImage ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test10 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; imageCanvas0 . getJavaImage ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test11 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; JTextPane jTextPane0 = new JTextPane ( ) ; StyledEditorKit . ItalicAction styledEditorKit_ItalicAction0 = new StyledEditorKit . ItalicAction ( ) ; JMenu jMenu0 = new JMenu ( ( Action ) styledEditorKit_ItalicAction0 ) ; DirectColorModel directColorModel0 = ( DirectColorModel ) jMenu0 . getColorModel ( ) ; byte [ ] byteArray0 = new byte [ 3 ] ; MemoryImageSource memoryImageSource0 = new MemoryImageSource ( 1 , 1 , ( ColorModel ) directColorModel0 , byteArray0 , 735 , ( int ) ( byte ) 0 ) ; java . awt . Image image0 = jTextPane0 . createImage ( ( ImageProducer ) memoryImageSource0 ) ; imageCanvas0 . setImage ( image0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test15 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; int int0 = imageCanvas0 . getSelectionBoxExtentY ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxExtentY ( ) { return m_boxly ; }
void test16 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; Color color0 = Color . DARK_GRAY ; imageCanvas0 . setActiveColor ( color0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test19 ( ) throws Throwable { PhaseImage phaseImage0 = new PhaseImage ( 0 , 1 ) ; ImageCanvas imageCanvas0 = new ImageCanvas ( ( RealGrayImage ) phaseImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test20 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; imageCanvas0 . setSelectionBoxAnchor ( ( - 1013 ) , ( - 1013 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionBoxAnchorX ( ) { return m_boxux ; }
void test21 ( ) throws Throwable { ImageKernel imageKernel0 = new ImageKernel ( 0 . 0F , 1 ) ; ImageCanvas imageCanvas0 = new ImageCanvas ( ( RealGrayImage ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test22 ( ) throws Throwable { float [ ] [ ] floatArray0 = new float [ 1 ] [ 6 ] ; float [ ] floatArray1 = new float [ 1 ] ; floatArray0 [ 0 ] = floatArray1 ; ImageKernel imageKernel0 = new ImageKernel ( floatArray0 ) ; ImageCanvas imageCanvas0 = new ImageCanvas ( ( Image ) imageKernel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test23 ( ) throws Throwable { ComplexImage complexImage0 = new ComplexImage ( 0 , 0 ) ; ImageCanvas imageCanvas0 = new ImageCanvas ( complexImage0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test24 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; imageCanvas0 . showSelectionBox ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test25 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; imageCanvas0 . clearSelectionBox ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test26 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; imageCanvas0 . getSelectionBox ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test27 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; imageCanvas0 . setActive ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test28 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; imageCanvas0 . setActive ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test29 ( ) throws Throwable { ImageCanvas imageCanvas0 = new ImageCanvas ( ) ; imageCanvas0 . showActiveBox ( true ) ; imageCanvas0 . showActiveBox ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { Image < ? > image0 = FileUtil . load ( "xLBWS } 'dr79 . 'a2" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Image < ? > load ( String filename ) { try { ImageInputStream iis = new ImageInputStream ( filename ) ; return iis . read ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } catch ( ImageNotSupportedException e ) { e . printStackTrace ( ) ; } catch ( IllegalPBMFormatException e ) { e . printStackTrace ( ) ; } return null ; }
void test0 ( ) throws Throwable { boolean boolean0 = MathUtil . powerOf2 ( ( - 2040 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean powerOf2 ( int x ) { if ( x = = 0 ) return false ; return ( x & ( x - 1 ) ) = = 0 ; }
void test1 ( ) throws Throwable { boolean boolean0 = MathUtil . powerOf2 ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean powerOf2 ( int x ) { if ( x = = 0 ) return false ; return ( x & ( x - 1 ) ) = = 0 ; }
void test2 ( ) throws Throwable { boolean boolean0 = MathUtil . powerOf2 ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean powerOf2 ( int x ) { if ( x = = 0 ) return false ; return ( x & ( x - 1 ) ) = = 0 ; }
void test0 ( ) throws Throwable { Integer [ ] [ ] integerArray0 = new Integer [ 1 ] [ 3 ] ; Integer [ ] integerArray1 = new Integer [ 6 ] ; Integer integer0 = new Integer ( 0 ) ; integerArray1 [ 0 ] = integer0 ; integerArray1 [ 1 ] = integer0 ; integerArray1 [ 2 ] = integerArray1 [ 1 ] ; integerArray1 [ 3 ] = integerArray1 [ 1 ] ; integerArray1 [ 4 ] = integerArray1 [ 3 ] ; integerArray1 [ 5 ] = integerArray1 [ 4 ] ; integerArray0 [ 0 ] = integerArray1 ; boolean boolean0 = ArrayUtil . arrayEquals ( integerArray0 , integerArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" < T > boolean arrayEquals ( T [ ] [ ] arr1 , T [ ] [ ] arr2 ) { if ( arr1 . length ! = arr2 . length ) return false ; for ( int i = 0 ; i < arr1 . length ; i + + ) { T [ ] subArr1 = arr1 [ i ] ; T [ ] subArr2 = arr2 [ i ] ; if ( ! arrayEquals ( subArr1 , subArr2 ) ) return false ; } return true ; }
void test1 ( ) throws Throwable { Integer [ ] integerArray0 = new Integer [ 5 ] ; Integer [ ] integerArray1 = new Integer [ 6 ] ; boolean boolean0 = ArrayUtil . arrayEquals ( integerArray1 , integerArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" < T > boolean arrayEquals ( T [ ] [ ] arr1 , T [ ] [ ] arr2 ) { if ( arr1 . length ! = arr2 . length ) return false ; for ( int i = 0 ; i < arr1 . length ; i + + ) { T [ ] subArr1 = arr1 [ i ] ; T [ ] subArr2 = arr2 [ i ] ; if ( ! arrayEquals ( subArr1 , subArr2 ) ) return false ; } return true ; }
void test2 ( ) throws Throwable { int [ ] [ ] intArray0 = new int [ 7 ] [ 2 ] ; Integer [ ] [ ] integerArray0 = ArrayUtil . box ( intArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Integer [ ] [ ] box ( int [ ] [ ] data ) { int length = data . length ; int width = width ( data ) ; Integer [ ] [ ] boxed = new Integer [ length ] [ width ] ; for ( int x = 0 ; x < length ; x + + ) { for ( int y = 0 ; y < width ; y + + ) { boxed [ x ] [ y ] = data [ x ] [ y ] ; } } return boxed ; }
void test3 ( ) throws Throwable { int [ ] [ ] intArray0 = new int [ 2 ] [ 1 ] ; int [ ] [ ] intArray1 = ArrayUtil . rowMajorToColumnMajor ( intArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] [ ] rowMajorToColumnMajor ( int [ ] [ ] rowMajor ) { int rowCount = rowMajor . length ; int columnCount = width ( rowMajor ) ; int [ ] [ ] colMajor = new int [ columnCount ] [ rowCount ] ; for ( int row = 0 ; row < rowCount ; row + + ) { for ( int col = 0 ; col < columnCount ; col + + ) { colMajor [ col ] [ row ] = rowMajor [ row ] [ col ] ; } } return colMajor ; }
void test0 ( ) throws Throwable { int [ ] intArray0 = new int [ 2 ] ; ProjectionMatrix projectionMatrix0 = new ProjectionMatrix ( 50 , intArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { ScaleMatrix scaleMatrix0 = new ScaleMatrix ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int nColumns ( ) { if ( mem = = null | | mem [ 0 ] = = null ) return 0 ; else return mem [ 0 ] . length ; }
void test1 ( ) throws Throwable { double [ ] doubleArray0 = new double [ 2 ] ; ScaleMatrix scaleMatrix0 = new ScaleMatrix ( doubleArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int nRows ( ) { if ( mem = = null ) return 0 ; else return mem . length ; }
void test0 ( ) throws Throwable { double [ ] doubleArray0 = new double [ 2 ] ; Vector vector0 = new Vector ( doubleArray0 ) ; TranslationMatrix translationMatrix0 = new TranslationMatrix ( vector0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { Vector vector0 = new Vector ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int dim ( ) { if ( mem = = null ) return 0 ; else return mem . length ; }
void test2 ( ) throws Throwable { Vector vector0 = new Vector ( 1355 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double norm ( int p ) { int n = mem . length ; if ( p = = 0 ) { double max = 0 . 0 ; for ( int i = 0 ; i < n ; + + i ) max = Math . max ( max , Math . abs ( mem [ i ] ) ) ; return max ; } else { double sum = 0 . 0 , x = ( double ) p ; for ( int i = 0 ; i < n ; + + i ) sum + = Math . pow ( Math . abs ( mem [ i ] ) , x ) ; return Math . pow ( sum , 1 . 0 / x ) ; } }
void test3 ( ) throws Throwable { double [ ] doubleArray0 = new double [ 10 ] ; Vector vector0 = new Vector ( doubleArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test4 ( ) throws Throwable { double [ ] doubleArray0 = new double [ 10 ] ; Vector vector0 = new Vector ( doubleArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test5 ( ) throws Throwable { Vector vector0 = new Vector ( 1355 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int dim ( ) { if ( mem = = null ) return 0 ; else return mem . length ; }
void test6 ( ) throws Throwable { Vector vector0 = new Vector ( 1355 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test7 ( ) throws Throwable { double [ ] doubleArray0 = new double [ 10 ] ; Vector vector0 = new Vector ( doubleArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double norm ( int p ) { int n = mem . length ; if ( p = = 0 ) { double max = 0 . 0 ; for ( int i = 0 ; i < n ; + + i ) max = Math . max ( max , Math . abs ( mem [ i ] ) ) ; return max ; } else { double sum = 0 . 0 , x = ( double ) p ; for ( int i = 0 ; i < n ; + + i ) sum + = Math . pow ( Math . abs ( mem [ i ] ) , x ) ; return Math . pow ( sum , 1 . 0 / x ) ; } }
void test8 ( ) throws Throwable { Vector vector0 = new Vector ( 1355 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int dim ( ) { if ( mem = = null ) return 0 ; else return mem . length ; }
void test9 ( ) throws Throwable { Vector vector0 = new Vector ( 1355 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int dim ( ) { if ( mem = = null ) return 0 ; else return mem . length ; }
void test0 ( ) throws Throwable { RotationMatrix rotationMatrix0 = new RotationMatrix ( 1 . 0 , 0 . 0 , 1 . 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test1 ( ) throws Throwable { RotationMatrix rotationMatrix0 = new RotationMatrix ( ( - 1 . 0 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test0 ( ) throws Throwable { Matrix matrix0 = new Matrix ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int nRows ( ) { if ( mem = = null ) return 0 ; else return mem . length ; }
void test1 ( ) throws Throwable { double [ ] [ ] doubleArray0 = new double [ 10 ] [ 5 ] ; Matrix matrix0 = new Matrix ( doubleArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int nColumns ( ) { if ( mem = = null | | mem [ 0 ] = = null ) return 0 ; else return mem [ 0 ] . length ; }
void test2 ( ) throws Throwable { Matrix matrix0 = new Matrix ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int nRows ( ) { if ( mem = = null ) return 0 ; else return mem . length ; }
void test3 ( ) throws Throwable { Matrix matrix0 = new Matrix ( 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int nRows ( ) { if ( mem = = null ) return 0 ; else return mem . length ; }
void test4 ( ) throws Throwable { double [ ] [ ] doubleArray0 = new double [ 4 ] [ 4 ] ; Matrix matrix0 = new Matrix ( 1317 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void add ( Image image ) throws ImageNotSupportedException { if ( image instanceof GrayImage | | image instanceof RealGrayImage ) sequence . add ( image ) ; else throw new ImageNotSupportedException ( ) ; }
void test5 ( ) throws Throwable { Matrix matrix0 = new Matrix ( 41 , 41 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Complex sub ( Complex z ) { real - = z . real ; imaginary - = z . imaginary ; return this ; }
void test6 ( ) throws Throwable { Matrix matrix0 = new Matrix ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test7 ( ) throws Throwable { Matrix matrix0 = new Matrix ( 880 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test8 ( ) throws Throwable { double [ ] [ ] doubleArray0 = new double [ 4 ] [ 4 ] ; Matrix matrix0 = new Matrix ( 1317 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int nRows ( ) { if ( mem = = null ) return 0 ; else return mem . length ; }
void test9 ( ) throws Throwable { Matrix matrix0 = new Matrix ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Matrix gaussj ( Matrix B ) throws ArithmeticException { int m = B . mem [ 0 ] . length ; int n = mem . length ; Matrix A = new Matrix ( this ) ; / / The integer arrays ipiv , indxr , and indxc are used for bookkeeping on the pivoting . int [ ] indxc = new int [ n ] , indxr = new int [ n ] , ipiv = new int [ n ] ; int i , j , k , l , ll , icol = 0 , irow = 0 ; double big , dum , pivinv ; if ( mem [ 0 ] . length ! = n ) throw new ArithmeticException ( "Matrix is not a square matrix" ) ; if ( B . mem . length ! = n ) throw new ArithmeticException ( "Matrix not of the correct size" ) ; for ( j = 0 ; j < n ; + + j ) ipiv [ j ] = 0 ; / / This is the main loop over the columns to be reduced . for ( i = 0 ; i < n ; + + i ) { big = 0 . 0 ; / / This is the outer loop of the search for a pivot element . for ( j = 0 ; j < n ; + + j ) if ( ipiv [ j ] ! = 1 ) for ( k = 0 ; k < n ; + + k ) if ( ipiv [ k ] = = 0 ) if ( Math . abs ( A . mem [ j ] [ k ] ) > = big ) { big = Math . abs ( A . mem [ j ] [ k ] ) ; irow = j ; icol = k ; } else if ( ipiv [ k ] > 1 ) throw new ArithmeticException ( "gaussj : Singular matrix - 1" ) ; + + ipiv [ icol ] ; / * * We now have the pivot element , so we interchange rows , if needed , to put the pivot * element on the diagonal . The columns are not physically interchanged , only relabeled : * indxc [ i ] , the column of the ith pivot element , is the ith column that is reduced , while * indxr [ i ] is the row in which that pivot element was originally located . If indxr [ i ] ! = * indxc [ i ] there is an implied column interchange . With this form of bookkeeping , the * solution B's will end up in the correct order , and the inverse matrix will be scrambled * by columns . * / if ( irow ! = icol ) { for ( l = 0 ; l < n ; + + l ) A . swap ( irow , l , icol , l ) ; for ( l = 0 ; l < m ; + + l ) B . swap ( irow , l , icol , l ) ; } indxr [ i ] = irow ; / / We are now ready to divide the pivot row by the indxc [ i ] = icol ; / / pivot element , located at irow and icol . if ( A . mem [ icol ] [ icol ] = = 0 . 0 ) throw new ArithmeticException ( "gaussj : Singular matrix - 2" ) ; pivinv = 1 . 0 / A . mem [ icol ] [ icol ] ; A . mem [ icol ] [ icol ] = 1 . 0 ; for ( l = 0 ; l < n ; + + l ) A . mem [ icol ] [ l ] * = pivinv ; for ( l = 0 ; l < m ; + + l ) B . mem [ icol ] [ l ] * = pivinv ; for ( ll = 0 ; ll < n ; + + ll ) / / Next , we reduce the rows . . . if ( ll ! = icol ) / / . . . except for the pivot one , of course . { dum = A . mem [ ll ] [ icol ] ; A . mem [ ll ] [ icol ] = 0 . 0 ; for ( l = 0 ; l < n ; + + l ) A . mem [ ll ] [ l ] - = A . mem [ icol ] [ l ] * dum ; for ( l = 0 ; l < m ; + + l ) B . mem [ ll ] [ l ] - = B . mem [ icol ] [ l ] * dum ; } } / * * This is the end of the main loop over columns of the reduction . It only remains to unscramble * the solution in view of the column interchanges . We do this by interchanging pairs of columns * in the reverse order that the permutation was built up . * / for ( l = n - 1 ; l > = 0 ; - - l ) if ( indxr [ l ] ! = indxc [ l ] ) for ( k = 0 ; k < n ; + + k ) A . swap ( k , indxr [ l ] , k , indxc [ l ] ) ; / / And we are done . return A ; }
void test10 ( ) throws Throwable { Matrix matrix0 = new Matrix ( 880 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Matrix gaussj ( Matrix B ) throws ArithmeticException { int m = B . mem [ 0 ] . length ; int n = mem . length ; Matrix A = new Matrix ( this ) ; / / The integer arrays ipiv , indxr , and indxc are used for bookkeeping on the pivoting . int [ ] indxc = new int [ n ] , indxr = new int [ n ] , ipiv = new int [ n ] ; int i , j , k , l , ll , icol = 0 , irow = 0 ; double big , dum , pivinv ; if ( mem [ 0 ] . length ! = n ) throw new ArithmeticException ( "Matrix is not a square matrix" ) ; if ( B . mem . length ! = n ) throw new ArithmeticException ( "Matrix not of the correct size" ) ; for ( j = 0 ; j < n ; + + j ) ipiv [ j ] = 0 ; / / This is the main loop over the columns to be reduced . for ( i = 0 ; i < n ; + + i ) { big = 0 . 0 ; / / This is the outer loop of the search for a pivot element . for ( j = 0 ; j < n ; + + j ) if ( ipiv [ j ] ! = 1 ) for ( k = 0 ; k < n ; + + k ) if ( ipiv [ k ] = = 0 ) if ( Math . abs ( A . mem [ j ] [ k ] ) > = big ) { big = Math . abs ( A . mem [ j ] [ k ] ) ; irow = j ; icol = k ; } else if ( ipiv [ k ] > 1 ) throw new ArithmeticException ( "gaussj : Singular matrix - 1" ) ; + + ipiv [ icol ] ; / * * We now have the pivot element , so we interchange rows , if needed , to put the pivot * element on the diagonal . The columns are not physically interchanged , only relabeled : * indxc [ i ] , the column of the ith pivot element , is the ith column that is reduced , while * indxr [ i ] is the row in which that pivot element was originally located . If indxr [ i ] ! = * indxc [ i ] there is an implied column interchange . With this form of bookkeeping , the * solution B's will end up in the correct order , and the inverse matrix will be scrambled * by columns . * / if ( irow ! = icol ) { for ( l = 0 ; l < n ; + + l ) A . swap ( irow , l , icol , l ) ; for ( l = 0 ; l < m ; + + l ) B . swap ( irow , l , icol , l ) ; } indxr [ i ] = irow ; / / We are now ready to divide the pivot row by the indxc [ i ] = icol ; / / pivot element , located at irow and icol . if ( A . mem [ icol ] [ icol ] = = 0 . 0 ) throw new ArithmeticException ( "gaussj : Singular matrix - 2" ) ; pivinv = 1 . 0 / A . mem [ icol ] [ icol ] ; A . mem [ icol ] [ icol ] = 1 . 0 ; for ( l = 0 ; l < n ; + + l ) A . mem [ icol ] [ l ] * = pivinv ; for ( l = 0 ; l < m ; + + l ) B . mem [ icol ] [ l ] * = pivinv ; for ( ll = 0 ; ll < n ; + + ll ) / / Next , we reduce the rows . . . if ( ll ! = icol ) / / . . . except for the pivot one , of course . { dum = A . mem [ ll ] [ icol ] ; A . mem [ ll ] [ icol ] = 0 . 0 ; for ( l = 0 ; l < n ; + + l ) A . mem [ ll ] [ l ] - = A . mem [ icol ] [ l ] * dum ; for ( l = 0 ; l < m ; + + l ) B . mem [ ll ] [ l ] - = B . mem [ icol ] [ l ] * dum ; } } / * * This is the end of the main loop over columns of the reduction . It only remains to unscramble * the solution in view of the column interchanges . We do this by interchanging pairs of columns * in the reverse order that the permutation was built up . * / for ( l = n - 1 ; l > = 0 ; - - l ) if ( indxr [ l ] ! = indxc [ l ] ) for ( k = 0 ; k < n ; + + k ) A . swap ( k , indxr [ l ] , k , indxc [ l ] ) ; / / And we are done . return A ; }
void test11 ( ) throws Throwable { Matrix matrix0 = new Matrix ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
void test12 ( ) throws Throwable { double [ ] [ ] doubleArray0 = new double [ 10 ] [ 5 ] ; double [ ] doubleArray1 = new double [ 6 ] ; doubleArray1 [ 2 ] = ( - 179 . 32424478834594 ) ; doubleArray0 [ 0 ] = doubleArray1 ; doubleArray0 [ 1 ] = doubleArray0 [ 0 ] ; doubleArray0 [ 2 ] = doubleArray0 [ 1 ] ; Matrix matrix0 = new Matrix ( doubleArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void eigsrt ( double [ ] lambda ) { int n = lambda . length ; int i , j , k ; double p ; for ( i = 0 ; i < n ; + + i ) { p = lambda [ i ] ; k = i ; for ( j = i + 1 ; j < n ; + + j ) if ( lambda [ j ] > = p ) { p = lambda [ j ] ; k = j ; } if ( k ! = i ) { lambda [ k ] = lambda [ i ] ; lambda [ i ] = p ; for ( j = 0 ; j < n ; + + j ) swap ( j , i , j , k ) ; } } }
void test15 ( ) throws Throwable { double [ ] [ ] doubleArray0 = new double [ 1 ] [ 8 ] ; double [ ] doubleArray1 = new double [ 7 ] ; doubleArray1 [ 3 ] = ( - 1947 . 4421960823781 ) ; doubleArray0 [ 0 ] = doubleArray1 ; Matrix matrix0 = new Matrix ( doubleArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void svdcmp ( Matrix U , double [ ] w , Matrix V ) throws ArithmeticException , ArrayStoreException { boolean flag = true ; int i , j , jj = 0 , k , l = 0 , m = mem . length , n = mem [ 0 ] . length , nm = 0 ; double anorm = 0 . 0 , c , f , g = 0 . 0 , h , s , scale = 0 . 0 , x , y , z = 0 . 0 ; double [ ] rv1 = new double [ n ] ; Matrix A = new Matrix ( this ) ; Matrix T = new Matrix ( n , n ) ; / / Householder reduction to bidiagonal form . for ( i = 0 ; i < n ; + + i ) { l = i + 1 ; s = 0 . 0 ; rv1 [ i ] = scale * g ; g = scale = 0 . 0 ; if ( i < m ) { for ( k = i ; k < m ; + + k ) scale + = Math . abs ( A . mem [ k ] [ i ] ) ; if ( scale ! = 0 . 0 ) { for ( k = i ; k < m ; + + k ) { A . mem [ k ] [ i ] / = scale ; s + = A . mem [ k ] [ i ] * A . mem [ k ] [ i ] ; } f = A . mem [ i ] [ i ] ; g = - sign ( Math . sqrt ( s ) , f ) ; h = f * g - s ; A . mem [ i ] [ i ] = f - g ; for ( j = l ; j < n ; + + j ) { s = 0 . 0 ; for ( k = i ; k < m ; + + k ) s + = A . mem [ k ] [ i ] * A . mem [ k ] [ j ] ; f = s / h ; for ( k = i ; k < m ; + + k ) A . mem [ k ] [ j ] + = f * A . mem [ k ] [ i ] ; } for ( k = i ; k < m ; + + k ) A . mem [ k ] [ i ] * = scale ; } } w [ i ] = scale * g ; g = s = scale = 0 . 0 ; if ( i < m & & i ! = n ) { for ( k = l ; k < n ; + + k ) scale + = Math . abs ( A . mem [ i ] [ k ] ) ; if ( scale ! = 0 . 0 ) { for ( k = l ; k < n ; + + k ) { A . mem [ i ] [ k ] / = scale ; s + = A . mem [ i ] [ k ] * A . mem [ i ] [ k ] ; } f = A . mem [ i ] [ l ] ; g = - sign ( Math . sqrt ( s ) , f ) ; h = f * g - s ; A . mem [ i ] [ l ] = f - g ; for ( k = l ; k < n ; + + k ) rv1 [ k ] = A . mem [ i ] [ k ] / h ; for ( j = l ; j < m ; + + j ) { s = 0 . 0 ; for ( k = l ; k < n ; + + k ) s + = A . mem [ j ] [ k ] * A . mem [ i ] [ k ] ; for ( k = l ; k < n ; + + k ) A . mem [ j ] [ k ] + = s * rv1 [ k ] ; } for ( k = l ; k < n ; + + k ) A . mem [ i ] [ k ] * = scale ; } } anorm = Math . max ( anorm , Math . abs ( w [ i ] ) + Math . abs ( rv1 [ i ] ) ) ; } / / Accumulation of right - hand transformations . for ( i = n - 1 ; i > = 0 ; - - i ) { if ( i < n - 1 ) { if ( g ! = 0 . 0 ) { for ( j = l ; j < n ; + + j ) T . mem [ j ] [ i ] = ( A . mem [ i ] [ j ] / A . mem [ i ] [ l ] ) / g ; for ( j = l ; j < n ; + + j ) { s = 0 . 0 ; for ( k = l ; k < n ; + + k ) s + = A . mem [ i ] [ k ] * T . mem [ k ] [ j ] ; for ( k = l ; k < n ; + + k ) T . mem [ k ] [ j ] + = s * T . mem [ k ] [ i ] ; } } for ( j = l ; j < n ; + + j ) T . mem [ i ] [ j ] = T . mem [ j ] [ i ] = 0 . 0 ; } T . mem [ i ] [ i ] = 1 . 0 ; g = rv1 [ i ] ; l = i ; } / / Accumulation of left - hand transformations . for ( i = Math . min ( m , n ) - 1 ; i > = 0 ; - - i ) { l = i + 1 ; g = w [ i ] ; for ( j = l ; j < n ; + + j ) A . mem [ i ] [ j ] = 0 . 0 ; if ( g ! = 0 . 0 ) { g = 1 . 0 / g ; for ( j = l ; j < n ; + + j ) { s = 0 . 0 ; for ( k = l ; k < m ; + + k ) s + = A . mem [ k ] [ i ] * A . mem [ k ] [ j ] ; f = ( s / A . mem [ i ] [ i ] ) * g ; for ( k = i ; k < m ; + + k ) A . mem [ k ] [ j ] + = f * A . mem [ k ] [ i ] ; } for ( j = i ; j < m ; + + j ) A . mem [ j ] [ i ] * = g ; } else for ( j = i ; j < m ; + + j ) A . mem [ j ] [ i ] = 0 . 0 ; + + A . mem [ i ] [ i ] ; } / / Diagonalization of the bidiagonal form : Loop over singular values , and over allowed iterations . for ( k = n - 1 ; k > = 0 ; - - k ) { for ( int its = 0 ; its < 30 ; + + its ) { flag = true ; / / Test for splitting . Note that rv1 [ 0 ] is always zero . for ( l = k ; l > = 0 ; - - l ) { nm = l - 1 ; if ( ( Math . abs ( rv1 [ l ] ) + anorm ) = = anorm ) { flag = false ; break ; } if ( ( Math . abs ( w [ nm ] ) + anorm ) = = anorm ) break ; } if ( flag ) { c = 0 . 0 ; / / Cancellation of rv1 [ l ] if l > 1 . s = 1 . 0 ; for ( i = l ; i < = k ; + + i ) { f = s * rv1 [ i ] ; rv1 [ i ] = c * rv1 [ i ] ; if ( ( Math . abs ( f ) + anorm ) = = anorm ) break ; g = w [ i ] ; h = pythag ( f , g ) ; w [ i ] = h ; h = 1 . 0 / h ; c = g * h ; s = - f * h ; for ( j = 0 ; j < m ; + + j ) { y = A . mem [ j ] [ nm ] ; z = A . mem [ j ] [ i ] ; A . mem [ j ] [ nm ] = y * c + z * s ; A . mem [ j ] [ i ] = z * c - y * s ; } } } z = w [ k ] ; if ( l = = k ) / / Convergence . { if ( z < 0 . 0 ) { w [ k ] = - z ; / / Singular value is made nonnegative . for ( j = 0 ; j < n ; + + j ) T . mem [ j ] [ k ] = - T . mem [ j ] [ k ] ; } break ; } if ( its = = 30 ) throw new ArithmeticException ( "no convergence in 30 svdcom iterations . " ) ; x = w [ l ] ; nm = k - 1 ; y = w [ nm ] ; g = rv1 [ nm ] ; h = rv1 [ k ] ; f = ( ( y - z ) * ( y + z ) + ( g - h ) * ( g + h ) ) / ( 2 . 0 * h * y ) ; g = pythag ( f , 1 . 0 ) ; f = ( ( x - z ) * ( x + z ) + h * ( ( y / ( f + sign ( g , f ) ) ) - h ) ) / x ; c = s = 1 . 0 ; / / Next QR transformation : for ( j = 0 ; j < nm ; + + j ) { i = j + 1 ; g = rv1 [ i ] ; y = w [ i ] ; h = s * g ; g = c * g ; z = pythag ( f , h ) ; rv1 [ j ] = z ; c = f / z ; s = h / z ; f = x * c + g * s ; g = g * c - x * s ; h = y * s ; y * = c ; for ( jj = 0 ; jj < n ; + + jj ) { x = T . mem [ jj ] [ j ] ; z = T . mem [ jj ] [ i ] ; T . mem [ jj ] [ j ] = x * c + z * s ; T . mem [ jj ] [ i ] = z * c - x * s ; } z = pythag ( f , h ) ; w [ j ] = z ; / / Rotation can be arbitrary if z = 0 . if ( z ! = 0 . 0 ) { z = 1 . 0 / z ; c = f * z ; s = h * z ; } f = c * g + s * y ; x = c * y - s * g ; for ( jj = 0 ; jj < m ; + + jj ) { y = A . mem [ jj ] [ j ] ; z = A . mem [ jj ] [ i ] ; A . mem [ jj ] [ j ] = y * c + z * s ; A . mem [ jj ] [ i ] = z * c - y * s ; } } rv1 [ l ] = 0 . 0 ; rv1 [ k ] = f ; w [ k ] = x ; } } V . assign ( T ) ; U . assign ( A ) ; }
void test16 ( ) throws Throwable { double [ ] [ ] doubleArray0 = new double [ 1 ] [ 8 ] ; double [ ] doubleArray1 = new double [ 7 ] ; doubleArray1 [ 0 ] = 2 . 0 ; doubleArray0 [ 0 ] = doubleArray1 ; Matrix matrix0 = new Matrix ( doubleArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void svdcmp ( Matrix U , double [ ] w , Matrix V ) throws ArithmeticException , ArrayStoreException { boolean flag = true ; int i , j , jj = 0 , k , l = 0 , m = mem . length , n = mem [ 0 ] . length , nm = 0 ; double anorm = 0 . 0 , c , f , g = 0 . 0 , h , s , scale = 0 . 0 , x , y , z = 0 . 0 ; double [ ] rv1 = new double [ n ] ; Matrix A = new Matrix ( this ) ; Matrix T = new Matrix ( n , n ) ; / / Householder reduction to bidiagonal form . for ( i = 0 ; i < n ; + + i ) { l = i + 1 ; s = 0 . 0 ; rv1 [ i ] = scale * g ; g = scale = 0 . 0 ; if ( i < m ) { for ( k = i ; k < m ; + + k ) scale + = Math . abs ( A . mem [ k ] [ i ] ) ; if ( scale ! = 0 . 0 ) { for ( k = i ; k < m ; + + k ) { A . mem [ k ] [ i ] / = scale ; s + = A . mem [ k ] [ i ] * A . mem [ k ] [ i ] ; } f = A . mem [ i ] [ i ] ; g = - sign ( Math . sqrt ( s ) , f ) ; h = f * g - s ; A . mem [ i ] [ i ] = f - g ; for ( j = l ; j < n ; + + j ) { s = 0 . 0 ; for ( k = i ; k < m ; + + k ) s + = A . mem [ k ] [ i ] * A . mem [ k ] [ j ] ; f = s / h ; for ( k = i ; k < m ; + + k ) A . mem [ k ] [ j ] + = f * A . mem [ k ] [ i ] ; } for ( k = i ; k < m ; + + k ) A . mem [ k ] [ i ] * = scale ; } } w [ i ] = scale * g ; g = s = scale = 0 . 0 ; if ( i < m & & i ! = n ) { for ( k = l ; k < n ; + + k ) scale + = Math . abs ( A . mem [ i ] [ k ] ) ; if ( scale ! = 0 . 0 ) { for ( k = l ; k < n ; + + k ) { A . mem [ i ] [ k ] / = scale ; s + = A . mem [ i ] [ k ] * A . mem [ i ] [ k ] ; } f = A . mem [ i ] [ l ] ; g = - sign ( Math . sqrt ( s ) , f ) ; h = f * g - s ; A . mem [ i ] [ l ] = f - g ; for ( k = l ; k < n ; + + k ) rv1 [ k ] = A . mem [ i ] [ k ] / h ; for ( j = l ; j < m ; + + j ) { s = 0 . 0 ; for ( k = l ; k < n ; + + k ) s + = A . mem [ j ] [ k ] * A . mem [ i ] [ k ] ; for ( k = l ; k < n ; + + k ) A . mem [ j ] [ k ] + = s * rv1 [ k ] ; } for ( k = l ; k < n ; + + k ) A . mem [ i ] [ k ] * = scale ; } } anorm = Math . max ( anorm , Math . abs ( w [ i ] ) + Math . abs ( rv1 [ i ] ) ) ; } / / Accumulation of right - hand transformations . for ( i = n - 1 ; i > = 0 ; - - i ) { if ( i < n - 1 ) { if ( g ! = 0 . 0 ) { for ( j = l ; j < n ; + + j ) T . mem [ j ] [ i ] = ( A . mem [ i ] [ j ] / A . mem [ i ] [ l ] ) / g ; for ( j = l ; j < n ; + + j ) { s = 0 . 0 ; for ( k = l ; k < n ; + + k ) s + = A . mem [ i ] [ k ] * T . mem [ k ] [ j ] ; for ( k = l ; k < n ; + + k ) T . mem [ k ] [ j ] + = s * T . mem [ k ] [ i ] ; } } for ( j = l ; j < n ; + + j ) T . mem [ i ] [ j ] = T . mem [ j ] [ i ] = 0 . 0 ; } T . mem [ i ] [ i ] = 1 . 0 ; g = rv1 [ i ] ; l = i ; } / / Accumulation of left - hand transformations . for ( i = Math . min ( m , n ) - 1 ; i > = 0 ; - - i ) { l = i + 1 ; g = w [ i ] ; for ( j = l ; j < n ; + + j ) A . mem [ i ] [ j ] = 0 . 0 ; if ( g ! = 0 . 0 ) { g = 1 . 0 / g ; for ( j = l ; j < n ; + + j ) { s = 0 . 0 ; for ( k = l ; k < m ; + + k ) s + = A . mem [ k ] [ i ] * A . mem [ k ] [ j ] ; f = ( s / A . mem [ i ] [ i ] ) * g ; for ( k = i ; k < m ; + + k ) A . mem [ k ] [ j ] + = f * A . mem [ k ] [ i ] ; } for ( j = i ; j < m ; + + j ) A . mem [ j ] [ i ] * = g ; } else for ( j = i ; j < m ; + + j ) A . mem [ j ] [ i ] = 0 . 0 ; + + A . mem [ i ] [ i ] ; } / / Diagonalization of the bidiagonal form : Loop over singular values , and over allowed iterations . for ( k = n - 1 ; k > = 0 ; - - k ) { for ( int its = 0 ; its < 30 ; + + its ) { flag = true ; / / Test for splitting . Note that rv1 [ 0 ] is always zero . for ( l = k ; l > = 0 ; - - l ) { nm = l - 1 ; if ( ( Math . abs ( rv1 [ l ] ) + anorm ) = = anorm ) { flag = false ; break ; } if ( ( Math . abs ( w [ nm ] ) + anorm ) = = anorm ) break ; } if ( flag ) { c = 0 . 0 ; / / Cancellation of rv1 [ l ] if l > 1 . s = 1 . 0 ; for ( i = l ; i < = k ; + + i ) { f = s * rv1 [ i ] ; rv1 [ i ] = c * rv1 [ i ] ; if ( ( Math . abs ( f ) + anorm ) = = anorm ) break ; g = w [ i ] ; h = pythag ( f , g ) ; w [ i ] = h ; h = 1 . 0 / h ; c = g * h ; s = - f * h ; for ( j = 0 ; j < m ; + + j ) { y = A . mem [ j ] [ nm ] ; z = A . mem [ j ] [ i ] ; A . mem [ j ] [ nm ] = y * c + z * s ; A . mem [ j ] [ i ] = z * c - y * s ; } } } z = w [ k ] ; if ( l = = k ) / / Convergence . { if ( z < 0 . 0 ) { w [ k ] = - z ; / / Singular value is made nonnegative . for ( j = 0 ; j < n ; + + j ) T . mem [ j ] [ k ] = - T . mem [ j ] [ k ] ; } break ; } if ( its = = 30 ) throw new ArithmeticException ( "no convergence in 30 svdcom iterations . " ) ; x = w [ l ] ; nm = k - 1 ; y = w [ nm ] ; g = rv1 [ nm ] ; h = rv1 [ k ] ; f = ( ( y - z ) * ( y + z ) + ( g - h ) * ( g + h ) ) / ( 2 . 0 * h * y ) ; g = pythag ( f , 1 . 0 ) ; f = ( ( x - z ) * ( x + z ) + h * ( ( y / ( f + sign ( g , f ) ) ) - h ) ) / x ; c = s = 1 . 0 ; / / Next QR transformation : for ( j = 0 ; j < nm ; + + j ) { i = j + 1 ; g = rv1 [ i ] ; y = w [ i ] ; h = s * g ; g = c * g ; z = pythag ( f , h ) ; rv1 [ j ] = z ; c = f / z ; s = h / z ; f = x * c + g * s ; g = g * c - x * s ; h = y * s ; y * = c ; for ( jj = 0 ; jj < n ; + + jj ) { x = T . mem [ jj ] [ j ] ; z = T . mem [ jj ] [ i ] ; T . mem [ jj ] [ j ] = x * c + z * s ; T . mem [ jj ] [ i ] = z * c - x * s ; } z = pythag ( f , h ) ; w [ j ] = z ; / / Rotation can be arbitrary if z = 0 . if ( z ! = 0 . 0 ) { z = 1 . 0 / z ; c = f * z ; s = h * z ; } f = c * g + s * y ; x = c * y - s * g ; for ( jj = 0 ; jj < m ; + + jj ) { y = A . mem [ jj ] [ j ] ; z = A . mem [ jj ] [ i ] ; A . mem [ jj ] [ j ] = y * c + z * s ; A . mem [ jj ] [ i ] = z * c - y * s ; } } rv1 [ l ] = 0 . 0 ; rv1 [ k ] = f ; w [ k ] = x ; } } V . assign ( T ) ; U . assign ( A ) ; }
void test17 ( ) throws Throwable { Matrix matrix0 = new Matrix ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Vector svbksb ( Matrix U , double [ ] w , Matrix V , Vector b ) throws ArithmeticException { int m = U . mem . length , n = V . mem . length ; if ( U . mem [ 0 ] . length ! = m | | V . mem [ 0 ] . length ! = n | | w . length ! = n | | b . dim ( ) ! = m ) throw new ArithmeticException ( "Arrays , matrrices , or vectors of incompatible dimensions" ) ; int i , j , jj ; double s ; Vector x = new Vector ( n ) , tmp = new Vector ( n ) ; for ( j = 0 ; j < n ; + + j ) { s = 0 . 0 ; if ( w [ j ] ! = 0 . 0 ) { for ( i = 0 ; i < m ; + + i ) s + = U . mem [ i ] [ j ] * b . get ( i ) ; s / = w [ j ] ; } tmp . set ( j , s ) ; } for ( j = 0 ; j < n ; + + j ) { s = 0 . 0 ; for ( jj = 0 ; jj < n ; + + jj ) s + = V . mem [ j ] [ jj ] * tmp . get ( jj ) ; x . set ( j , s ) ; } return x ; }
void test18 ( ) throws Throwable { double [ ] [ ] doubleArray0 = new double [ 1 ] [ 8 ] ; double [ ] doubleArray1 = new double [ 7 ] ; doubleArray1 [ 0 ] = 2 . 0 ; doubleArray1 [ 3 ] = ( - 1947 . 4421960823781 ) ; doubleArray0 [ 0 ] = doubleArray1 ; Matrix matrix0 = new Matrix ( doubleArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void svdcmp ( Matrix U , double [ ] w , Matrix V ) throws ArithmeticException , ArrayStoreException { boolean flag = true ; int i , j , jj = 0 , k , l = 0 , m = mem . length , n = mem [ 0 ] . length , nm = 0 ; double anorm = 0 . 0 , c , f , g = 0 . 0 , h , s , scale = 0 . 0 , x , y , z = 0 . 0 ; double [ ] rv1 = new double [ n ] ; Matrix A = new Matrix ( this ) ; Matrix T = new Matrix ( n , n ) ; / / Householder reduction to bidiagonal form . for ( i = 0 ; i < n ; + + i ) { l = i + 1 ; s = 0 . 0 ; rv1 [ i ] = scale * g ; g = scale = 0 . 0 ; if ( i < m ) { for ( k = i ; k < m ; + + k ) scale + = Math . abs ( A . mem [ k ] [ i ] ) ; if ( scale ! = 0 . 0 ) { for ( k = i ; k < m ; + + k ) { A . mem [ k ] [ i ] / = scale ; s + = A . mem [ k ] [ i ] * A . mem [ k ] [ i ] ; } f = A . mem [ i ] [ i ] ; g = - sign ( Math . sqrt ( s ) , f ) ; h = f * g - s ; A . mem [ i ] [ i ] = f - g ; for ( j = l ; j < n ; + + j ) { s = 0 . 0 ; for ( k = i ; k < m ; + + k ) s + = A . mem [ k ] [ i ] * A . mem [ k ] [ j ] ; f = s / h ; for ( k = i ; k < m ; + + k ) A . mem [ k ] [ j ] + = f * A . mem [ k ] [ i ] ; } for ( k = i ; k < m ; + + k ) A . mem [ k ] [ i ] * = scale ; } } w [ i ] = scale * g ; g = s = scale = 0 . 0 ; if ( i < m & & i ! = n ) { for ( k = l ; k < n ; + + k ) scale + = Math . abs ( A . mem [ i ] [ k ] ) ; if ( scale ! = 0 . 0 ) { for ( k = l ; k < n ; + + k ) { A . mem [ i ] [ k ] / = scale ; s + = A . mem [ i ] [ k ] * A . mem [ i ] [ k ] ; } f = A . mem [ i ] [ l ] ; g = - sign ( Math . sqrt ( s ) , f ) ; h = f * g - s ; A . mem [ i ] [ l ] = f - g ; for ( k = l ; k < n ; + + k ) rv1 [ k ] = A . mem [ i ] [ k ] / h ; for ( j = l ; j < m ; + + j ) { s = 0 . 0 ; for ( k = l ; k < n ; + + k ) s + = A . mem [ j ] [ k ] * A . mem [ i ] [ k ] ; for ( k = l ; k < n ; + + k ) A . mem [ j ] [ k ] + = s * rv1 [ k ] ; } for ( k = l ; k < n ; + + k ) A . mem [ i ] [ k ] * = scale ; } } anorm = Math . max ( anorm , Math . abs ( w [ i ] ) + Math . abs ( rv1 [ i ] ) ) ; } / / Accumulation of right - hand transformations . for ( i = n - 1 ; i > = 0 ; - - i ) { if ( i < n - 1 ) { if ( g ! = 0 . 0 ) { for ( j = l ; j < n ; + + j ) T . mem [ j ] [ i ] = ( A . mem [ i ] [ j ] / A . mem [ i ] [ l ] ) / g ; for ( j = l ; j < n ; + + j ) { s = 0 . 0 ; for ( k = l ; k < n ; + + k ) s + = A . mem [ i ] [ k ] * T . mem [ k ] [ j ] ; for ( k = l ; k < n ; + + k ) T . mem [ k ] [ j ] + = s * T . mem [ k ] [ i ] ; } } for ( j = l ; j < n ; + + j ) T . mem [ i ] [ j ] = T . mem [ j ] [ i ] = 0 . 0 ; } T . mem [ i ] [ i ] = 1 . 0 ; g = rv1 [ i ] ; l = i ; } / / Accumulation of left - hand transformations . for ( i = Math . min ( m , n ) - 1 ; i > = 0 ; - - i ) { l = i + 1 ; g = w [ i ] ; for ( j = l ; j < n ; + + j ) A . mem [ i ] [ j ] = 0 . 0 ; if ( g ! = 0 . 0 ) { g = 1 . 0 / g ; for ( j = l ; j < n ; + + j ) { s = 0 . 0 ; for ( k = l ; k < m ; + + k ) s + = A . mem [ k ] [ i ] * A . mem [ k ] [ j ] ; f = ( s / A . mem [ i ] [ i ] ) * g ; for ( k = i ; k < m ; + + k ) A . mem [ k ] [ j ] + = f * A . mem [ k ] [ i ] ; } for ( j = i ; j < m ; + + j ) A . mem [ j ] [ i ] * = g ; } else for ( j = i ; j < m ; + + j ) A . mem [ j ] [ i ] = 0 . 0 ; + + A . mem [ i ] [ i ] ; } / / Diagonalization of the bidiagonal form : Loop over singular values , and over allowed iterations . for ( k = n - 1 ; k > = 0 ; - - k ) { for ( int its = 0 ; its < 30 ; + + its ) { flag = true ; / / Test for splitting . Note that rv1 [ 0 ] is always zero . for ( l = k ; l > = 0 ; - - l ) { nm = l - 1 ; if ( ( Math . abs ( rv1 [ l ] ) + anorm ) = = anorm ) { flag = false ; break ; } if ( ( Math . abs ( w [ nm ] ) + anorm ) = = anorm ) break ; } if ( flag ) { c = 0 . 0 ; / / Cancellation of rv1 [ l ] if l > 1 . s = 1 . 0 ; for ( i = l ; i < = k ; + + i ) { f = s * rv1 [ i ] ; rv1 [ i ] = c * rv1 [ i ] ; if ( ( Math . abs ( f ) + anorm ) = = anorm ) break ; g = w [ i ] ; h = pythag ( f , g ) ; w [ i ] = h ; h = 1 . 0 / h ; c = g * h ; s = - f * h ; for ( j = 0 ; j < m ; + + j ) { y = A . mem [ j ] [ nm ] ; z = A . mem [ j ] [ i ] ; A . mem [ j ] [ nm ] = y * c + z * s ; A . mem [ j ] [ i ] = z * c - y * s ; } } } z = w [ k ] ; if ( l = = k ) / / Convergence . { if ( z < 0 . 0 ) { w [ k ] = - z ; / / Singular value is made nonnegative . for ( j = 0 ; j < n ; + + j ) T . mem [ j ] [ k ] = - T . mem [ j ] [ k ] ; } break ; } if ( its = = 30 ) throw new ArithmeticException ( "no convergence in 30 svdcom iterations . " ) ; x = w [ l ] ; nm = k - 1 ; y = w [ nm ] ; g = rv1 [ nm ] ; h = rv1 [ k ] ; f = ( ( y - z ) * ( y + z ) + ( g - h ) * ( g + h ) ) / ( 2 . 0 * h * y ) ; g = pythag ( f , 1 . 0 ) ; f = ( ( x - z ) * ( x + z ) + h * ( ( y / ( f + sign ( g , f ) ) ) - h ) ) / x ; c = s = 1 . 0 ; / / Next QR transformation : for ( j = 0 ; j < nm ; + + j ) { i = j + 1 ; g = rv1 [ i ] ; y = w [ i ] ; h = s * g ; g = c * g ; z = pythag ( f , h ) ; rv1 [ j ] = z ; c = f / z ; s = h / z ; f = x * c + g * s ; g = g * c - x * s ; h = y * s ; y * = c ; for ( jj = 0 ; jj < n ; + + jj ) { x = T . mem [ jj ] [ j ] ; z = T . mem [ jj ] [ i ] ; T . mem [ jj ] [ j ] = x * c + z * s ; T . mem [ jj ] [ i ] = z * c - x * s ; } z = pythag ( f , h ) ; w [ j ] = z ; / / Rotation can be arbitrary if z = 0 . if ( z ! = 0 . 0 ) { z = 1 . 0 / z ; c = f * z ; s = h * z ; } f = c * g + s * y ; x = c * y - s * g ; for ( jj = 0 ; jj < m ; + + jj ) { y = A . mem [ jj ] [ j ] ; z = A . mem [ jj ] [ i ] ; A . mem [ jj ] [ j ] = y * c + z * s ; A . mem [ jj ] [ i ] = z * c - y * s ; } } rv1 [ l ] = 0 . 0 ; rv1 [ k ] = f ; w [ k ] = x ; } } V . assign ( T ) ; U . assign ( A ) ; }
void test19 ( ) throws Throwable { Matrix matrix0 = new Matrix ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) ; / * * * Turns this image into a Java Image ( java . awt . Image ) . * * @param none * @see java . awt . image . ImageProducer * / ImageProducer getJavaImage ( ) ; / * * Returns a deep copy of an image * / Image < T > copy ( ) ; / * * * Returns a deep copy of the specified region of interest of the image . * * @param r region of interest of the image . * / Image < T > copy ( ROI r ) ; }
