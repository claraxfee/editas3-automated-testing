void test0 ( ) throws Throwable { NodeType nodeType0 = NodeType . byCode ( ( short ) 6 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test1 ( ) throws Throwable { NodeType nodeType0 = NodeType . byCode ( ( short ) 6 ) ; short short0 = nodeType0 . getCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" short getCode ( ) { return this . code ; }
void test0 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; QName qName0 = defaultDocumentFactory0 . createQName ( "5 , @_o4^F ] 5O" , "5 , @_o4^F ] 5O" , "5 , @_o4^F ] 5O" ) ; String string0 = qName0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test1 ( ) throws Throwable { QName qName0 = QName . get ( "~i" , ( Namespace ) null , "~i" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test2 ( ) throws Throwable { Namespace namespace0 = Namespace . get ( "t" ) ; QName qName0 = QName . get ( "t" , namespace0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test3 ( ) throws Throwable { QName qName0 = new QName ( "" ) ; DefaultElement defaultElement0 = new DefaultElement ( qName0 ) ; QName qName1 = defaultElement0 . getQName ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUniquePath ( Element context ) { StringBuffer path = new StringBuffer ( 10 ) ; Element parent = getParent ( ) ; if ( ( parent ! = null ) & & ( parent ! = context ) ) { path . append ( parent . getUniquePath ( context ) ) ; path . append ( ' / ' ) ; } path . append ( getXPathNameStep ( ) ) ; return path . toString ( ) ; }
void test4 ( ) throws Throwable { QName qName0 = QName . get ( "'" , "'" , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test5 ( ) throws Throwable { QName qName0 = new QName ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedName ( ) ; / * * * < p > * Returns any additional namespaces declarations for this element other * than namespace returned via the { @link #getNamespace ( ) }
void test6 ( ) throws Throwable { QName qName0 = new QName ( "H { aoj1RUm ? ^eMP" , ( Namespace ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test7 ( ) throws Throwable { QName qName0 = new QName ( ( String ) null , ( Namespace ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test8 ( ) throws Throwable { QNameCache qNameCache0 = new QNameCache ( ) ; QName qName0 = new QName ( "'" , ( Namespace ) null , "'" ) ; QName qName1 = qNameCache0 . intern ( qName0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test9 ( ) throws Throwable { QName qName0 = QName . get ( ( String ) null , ( String ) null , "c`3f ] X & z - ~~x = W@o" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedName ( ) ; / * * * < p > * Returns any additional namespaces declarations for this element other * than namespace returned via the { @link #getNamespace ( ) }
void test10 ( ) throws Throwable { QName qName0 = QName . get ( "" , "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNamespaceURI ( ) ; / * * * < p > * Returns the fully qualified name of this element . This will be the same * as the value returned from { @link #getName }
void test11 ( ) throws Throwable { QName qName0 = QName . get ( ( String ) null , ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNamespacePrefix ( ) ; / * * * < p > * Returns the URI mapped to the namespace of this element if one exists * otherwise an empty < code > String < / code > is returned . * < / p > * * @return the URI for the < code > Namespace < / code > of this element or an * empty < code > String < / code > * / String getNamespaceURI ( ) ; / * * * < p > * Returns the fully qualified name of this element . This will be the same * as the value returned from { @link #getName }
void test12 ( ) throws Throwable { QName qName0 = QName . get ( "'" , "'" , "'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNamespacePrefix ( ) ; / * * * < p > * Returns the URI mapped to the namespace of this element if one exists * otherwise an empty < code > String < / code > is returned . * < / p > * * @return the URI for the < code > Namespace < / code > of this element or an * empty < code > String < / code > * / String getNamespaceURI ( ) ; / * * * < p > * Returns the fully qualified name of this element . This will be the same * as the value returned from { @link #getName }
void test13 ( ) throws Throwable { QName qName0 = QName . get ( "org . dom4j . QName@babe [ name : 5 , @_o4^F ] 5O namespace : \"org . dom4j . Namespace@babe [ Namespace : prefix 5 , @_o4^F ] 5O mapped to URI \"5 , @_o4^F ] 5O\" ] \" ] " , "5 , @_o4^F ] 5O" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNamespaceURI ( ) ; / * * * < p > * Returns the fully qualified name of this element . This will be the same * as the value returned from { @link #getName }
void test14 ( ) throws Throwable { QName qName0 = QName . get ( "F" , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test15 ( ) throws Throwable { QNameCache qNameCache0 = new QNameCache ( ) ; QName qName0 = new QName ( "F" ) ; QName qName1 = qNameCache0 . intern ( qName0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test16 ( ) throws Throwable { QName qName0 = new QName ( "F" ) ; String string0 = qName0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test17 ( ) throws Throwable { Namespace namespace0 = Namespace . get ( "H { aoj1RUm ? ^eMP" , "H { aoj1RUm ? ^eMP" ) ; BeanElement beanElement0 = new BeanElement ( "H { aoj1RUm ? ^eMP" , namespace0 , ( Object ) "namespace : : H { aoj1RUm ? ^eMP" ) ; QName qName0 = beanElement0 . getQName ( "namespace : : H { aoj1RUm ? ^eMP" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUniquePath ( Element context ) { StringBuffer path = new StringBuffer ( 10 ) ; Element parent = getParent ( ) ; if ( ( parent ! = null ) & & ( parent ! = context ) ) { path . append ( parent . getUniquePath ( context ) ) ; path . append ( ' / ' ) ; } path . append ( getXPathNameStep ( ) ) ; return path . toString ( ) ; }
void test18 ( ) throws Throwable { QName qName0 = new QName ( "" ) ; DefaultElement defaultElement0 = new DefaultElement ( qName0 ) ; QName qName1 = defaultElement0 . getQName ( "XPath expression uses unbound namespace prefix " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object object ) { if ( this = = object ) { return true ; } else if ( object instanceof Namespace ) { Namespace that = ( Namespace ) object ; / / we cache hash codes so this should be quick if ( hashCode ( ) = = that . hashCode ( ) ) { return uri . equals ( that . getURI ( ) ) & & prefix . equals ( that . getPrefix ( ) ) ; } } return false ; }
void test0 ( ) throws Throwable { DefaultProcessingInstruction defaultProcessingInstruction0 = ( DefaultProcessingInstruction ) DocumentHelper . createProcessingInstruction ( " [ P_ & @5%lH - o ? ? mHCG" , " [ P_ & @5%lH - o ? ? mHCG" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test1 ( ) throws Throwable { DefaultElement defaultElement0 = ( DefaultElement ) DocumentHelper . createElement ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test4 ( ) throws Throwable { DefaultText defaultText0 = ( DefaultText ) DocumentHelper . createText ( "sO ( 1 ] Ie ? 7 / + " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsParent ( ) ; / * * * < p > * < code > getParent < / code > returns the parent < code > Element < / code > if * this node supports the parent relationship or null if it is the root * element or does not support the parent relationship . * < / p > * < p / > * < p > * This method is an optional feature and may not be supported for all * < code > Node < / code > implementations . * < / p > * * @return the parent of this node or null if it is the root of the tree or * the parent relationship is not supported . * / Element getParent ( ) ; / * * * < p > * < code > setParent < / code > sets the parent relationship of this node if the * parent relationship is supported or does nothing if the parent * relationship is not supported . * < / p > * < p / > * < p > * This method should only be called from inside an < code > Element < / code > * implementation method and is not intended for general use . * < / p > * * @param parent is the new parent of this node . * / void setParent ( Element parent ) ; / * * * < p > * < code > getDocument < / code > returns the < code > Document < / code > that this * < code > Node < / code > is part of if this node supports the parent * relationship . * < / p > * < p / > * < p > * This method is an optional feature and may not be supported for all * < code > Node < / code > implementations . * < / p > * * @return the document of this node or null if this feature is not * supported or the node is not associated with a * < code > Document < / code > * / Document getDocument ( ) ; / * * * < p > * < code > setDocument < / code > sets the document of this node if the parent * relationship is supported or does nothing if the parent relationship is * not supported . * < / p > * < p / > * < p > * This method should only be called from inside a < code > Document < / code > * implementation method and is not intended for general use . * < / p > * * @param document is the new document of this node . * / void setDocument ( Document document ) ; / * * * < p > * < code > isReadOnly < / code > returns true if this node is read only and * cannot be modified . Any attempt to modify a read - only < code > Node < / code > * will result in an < code > UnsupportedOperationException < / code > being * thrown . * < / p > * * @return true if this < code > Node < / code > is read only and cannot be * modified otherwise false . * / boolean isReadOnly ( ) ; / * * * < p > * < code > hasContent < / code > returns true if this node is a Branch ( either * an Element or a Document ) and it contains at least one content node such * as a child Element or Text node . * < / p > * * @return true if this < code > Node < / code > is a Branch with a nodeCount ( ) * of one or more . * / boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test5 ( ) throws Throwable { DefaultDocument defaultDocument0 = ( DefaultDocument ) DocumentHelper . createDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test6 ( ) throws Throwable { DefaultDocument defaultDocument0 = ( DefaultDocument ) DocumentHelper . createDocument ( ( Element ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTextTrim ( ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . This method returns the string - value of all the * contained { @link Text }
void test7 ( ) throws Throwable { DefaultComment defaultComment0 = ( DefaultComment ) DocumentHelper . createComment ( "za5%E$ ; pLkN" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNodeTypeName ( ) ; / * * * < p > * Removes this node from its parent if there is one . If this node is the * root element of a document then it is removed from the document as well . * < / p > * < p / > * < p > * This method is useful if you want to remove a node from its source * document and add it to another document . For example * < / p > * < code > Node node = . . . ; Element someOtherElement = . . . ; * someOtherElement . add ( node . detach ( ) ) ; < / code > * * @return the node that has been removed from its parent node if any and * its document if any . * / Node detach ( ) ; / * * * < p > * < code > selectNodes < / code > evaluates an XPath expression and returns the * result as a < code > List < / code > of < code > Node < / code > instances or * < code > String < / code > instances depending on the XPath expression . * < / p > * * @param xpathExpression is the XPath expression to be evaluated * @return the list of < code > Node < / code > or < code > String < / code > * instances depending on the XPath expression * / List < ? extends Node > selectNodes ( String xpathExpression ) ; / * * * < p > * < code > selectObject < / code > evaluates an XPath expression and returns the * result as an { @link Object }
void test8 ( ) throws Throwable { Namespace namespace0 = DocumentHelper . createNamespace ( "n < TDJmTJn$ = 5Q" , "n < TDJmTJn$ = 5Q" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" short getNodeType ( ) ; / * * * Returns the name of the type of this node such as "Document" , "Element" , * "Attribute" or "Text" * * @return the name of the type of this node * / String getNodeTypeName ( ) ; / * * * < p > * Removes this node from its parent if there is one . If this node is the * root element of a document then it is removed from the document as well . * < / p > * < p / > * < p > * This method is useful if you want to remove a node from its source * document and add it to another document . For example * < / p > * < code > Node node = . . . ; Element someOtherElement = . . . ; * someOtherElement . add ( node . detach ( ) ) ; < / code > * * @return the node that has been removed from its parent node if any and * its document if any . * / Node detach ( ) ; / * * * < p > * < code > selectNodes < / code > evaluates an XPath expression and returns the * result as a < code > List < / code > of < code > Node < / code > instances or * < code > String < / code > instances depending on the XPath expression . * < / p > * * @param xpathExpression is the XPath expression to be evaluated * @return the list of < code > Node < / code > or < code > String < / code > * instances depending on the XPath expression * / List < ? extends Node > selectNodes ( String xpathExpression ) ; / * * * < p > * < code > selectObject < / code > evaluates an XPath expression and returns the * result as an { @link Object }
void test9 ( ) throws Throwable { QName qName0 = DocumentHelper . createQName ( "Error occurred in DOM4J application . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test11 ( ) throws Throwable { DefaultEntity defaultEntity0 = ( DefaultEntity ) DocumentHelper . createEntity ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUniquePath ( Element context ) { StringBuffer path = new StringBuffer ( 10 ) ; Element parent = getParent ( ) ; if ( ( parent ! = null ) & & ( parent ! = context ) ) { path . append ( parent . getUniquePath ( context ) ) ; path . append ( ' / ' ) ; } path . append ( getXPathNameStep ( ) ) ; return path . toString ( ) ; }
void test14 ( ) throws Throwable { QName qName0 = DocumentHelper . createQName ( "lexic" , ( Namespace ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedName ( ) ; / * * * < p > * Returns any additional namespaces declarations for this element other * than namespace returned via the { @link #getNamespace ( ) }
void test15 ( ) throws Throwable { DefaultCDATA defaultCDATA0 = ( DefaultCDATA ) DocumentHelper . createCDATA ( " ? A$ ! fPbe" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test0 ( ) throws Throwable { NonLazyElement nonLazyElement0 = new NonLazyElement ( "e" ) ; Attribute attribute0 = NodeHelper . nodeAsAttribute ( ( Node ) nonLazyElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Attribute nodeAsAttribute ( Node node ) { if ( node . getNodeTypeEnum ( ) = = NodeType . ATTRIBUTE_NODE ) { assert node instanceof Attribute ; return ( Attribute ) node ; } return null ; }
void test1 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; QName qName0 = defaultDocumentFactory0 . createQName ( "e" , "e" , "e" ) ; DefaultAttribute defaultAttribute0 = new DefaultAttribute ( qName0 ) ; DefaultAttribute defaultAttribute1 = ( DefaultAttribute ) NodeHelper . nodeAsAttribute ( ( Node ) defaultAttribute0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Attribute nodeAsAttribute ( Node node ) { if ( node . getNodeTypeEnum ( ) = = NodeType . ATTRIBUTE_NODE ) { assert node instanceof Attribute ; return ( Attribute ) node ; } return null ; }
void test2 ( ) throws Throwable { DefaultDocument defaultDocument0 = new DefaultDocument ( ) ; DefaultDocument defaultDocument1 = ( DefaultDocument ) NodeHelper . nodeAsBranch ( ( Node ) defaultDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Branch nodeAsBranch ( Node node ) { if ( BRANCH_TYPE . contains ( node . getNodeType ( ) ) ) { assert node instanceof Branch ; return ( Branch ) node ; } return null ; }
void test3 ( ) throws Throwable { UserDataElement userDataElement0 = new UserDataElement ( "org . dom4j . util . UserDataAttribute@175089e4 [ Attribute : name value \"null\" ] " ) ; Document document0 = NodeHelper . nodeAsDocument ( ( Node ) userDataElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Document nodeAsDocument ( Node node ) { if ( node . getNodeTypeEnum ( ) = = NodeType . DOCUMENT_NODE ) { assert node instanceof Document ; return ( Document ) node ; } return null ; }
void test4 ( ) throws Throwable { DefaultDocument defaultDocument0 = new DefaultDocument ( ) ; DefaultDocument defaultDocument1 = ( DefaultDocument ) NodeHelper . nodeAsDocument ( ( Node ) defaultDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" NodeType getNodeTypeEnum ( ) { return NodeType . NAMESPACE_NODE ; }
void test5 ( ) throws Throwable { DOMEntityReference dOMEntityReference0 = new DOMEntityReference ( " [ GNP < daPYK'" ) ; BackedList < Element > backedList0 = NodeHelper . appendElementNamedLocal ( ( Node ) dOMEntityReference0 , ( BackedList < Element > ) null , " [ GNP < daPYK'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" BackedList < Element > appendElementNamedLocal ( Node node , BackedList < Element > list , String name ) { Element element = nodeAsElement ( node ) ; if ( element ! = null & & name . equals ( element . getName ( ) ) ) { list . addLocal ( element ) ; } return list ; }
void test7 ( ) throws Throwable { QName qName0 = new QName ( "Cannot lookup namespace URIs in DOM 2" ) ; UserDataElement userDataElement0 = new UserDataElement ( qName0 ) ; Namespace namespace0 = NodeHelper . nodeAsNamespace ( ( Node ) userDataElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Namespace nodeAsNamespace ( Node node ) { if ( node . getNodeTypeEnum ( ) = = NodeType . NAMESPACE_NODE ) { assert node instanceof Namespace ; return ( Namespace ) node ; } return null ; }
void test8 ( ) throws Throwable { Namespace namespace0 = Namespace . get ( " [ ( DefaultAbsoluteLocationPath ) : " , " [ ( DefaultAbsoluteLocationPath ) : " ) ; Namespace namespace1 = NodeHelper . nodeAsNamespace ( ( Node ) namespace0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUniquePath ( Element context ) { StringBuffer path = new StringBuffer ( 10 ) ; Element parent = getParent ( ) ; if ( ( parent ! = null ) & & ( parent ! = context ) ) { path . append ( parent . getUniquePath ( context ) ) ; path . append ( ' / ' ) ; } path . append ( getXPathNameStep ( ) ) ; return path . toString ( ) ; }
void test9 ( ) throws Throwable { NonLazyElement nonLazyElement0 = new NonLazyElement ( "e" ) ; ProcessingInstruction processingInstruction0 = NodeHelper . nodeAsProcessingInstruction ( ( Node ) nonLazyElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ProcessingInstruction nodeAsProcessingInstruction ( Node node ) { if ( node . getNodeTypeEnum ( ) = = NodeType . PROCESSING_INSTRUCTION_NODE ) { assert node instanceof ProcessingInstruction ; return ( ProcessingInstruction ) node ; } return null ; }
void test10 ( ) throws Throwable { DOMProcessingInstruction dOMProcessingInstruction0 = new DOMProcessingInstruction ( " [ ( DefaultAbsoluteLocationPath ) : " , " [ ( DefaultAbsoluteLocationPath ) : " ) ; DOMProcessingInstruction dOMProcessingInstruction1 = ( DOMProcessingInstruction ) NodeHelper . nodeAsProcessingInstruction ( ( Node ) dOMProcessingInstruction0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsParent ( ) ; / * * * < p > * < code > getParent < / code > returns the parent < code > Element < / code > if * this node supports the parent relationship or null if it is the root * element or does not support the parent relationship . * < / p > * < p / > * < p > * This method is an optional feature and may not be supported for all * < code > Node < / code > implementations . * < / p > * * @return the parent of this node or null if it is the root of the tree or * the parent relationship is not supported . * / Element getParent ( ) ; / * * * < p > * < code > setParent < / code > sets the parent relationship of this node if the * parent relationship is supported or does nothing if the parent * relationship is not supported . * < / p > * < p / > * < p > * This method should only be called from inside an < code > Element < / code > * implementation method and is not intended for general use . * < / p > * * @param parent is the new parent of this node . * / void setParent ( Element parent ) ; / * * * < p > * < code > getDocument < / code > returns the < code > Document < / code > that this * < code > Node < / code > is part of if this node supports the parent * relationship . * < / p > * < p / > * < p > * This method is an optional feature and may not be supported for all * < code > Node < / code > implementations . * < / p > * * @return the document of this node or null if this feature is not * supported or the node is not associated with a * < code > Document < / code > * / Document getDocument ( ) ; / * * * < p > * < code > setDocument < / code > sets the document of this node if the parent * relationship is supported or does nothing if the parent relationship is * not supported . * < / p > * < p / > * < p > * This method should only be called from inside a < code > Document < / code > * implementation method and is not intended for general use . * < / p > * * @param document is the new document of this node . * / void setDocument ( Document document ) ; / * * * < p > * < code > isReadOnly < / code > returns true if this node is read only and * cannot be modified . Any attempt to modify a read - only < code > Node < / code > * will result in an < code > UnsupportedOperationException < / code > being * thrown . * < / p > * * @return true if this < code > Node < / code > is read only and cannot be * modified otherwise false . * / boolean isReadOnly ( ) ; / * * * < p > * < code > hasContent < / code > returns true if this node is a Branch ( either * an Element or a Document ) and it contains at least one content node such * as a child Element or Text node . * < / p > * * @return true if this < code > Node < / code > is a Branch with a nodeCount ( ) * of one or more . * / boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test11 ( ) throws Throwable { FlyweightAttribute flyweightAttribute0 = new FlyweightAttribute ( "~" , "~" , ( Namespace ) null ) ; BackedList < Element > backedList0 = NodeHelper . appendElementLocal ( ( Node ) flyweightAttribute0 , ( BackedList < Element > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" BackedList < Element > appendElementLocal ( Node node , BackedList < Element > list ) { Element element = nodeAsElement ( node ) ; if ( element ! = null ) { list . addLocal ( element ) ; } return list ; }
void test14 ( ) throws Throwable { UserDataElement userDataElement0 = new UserDataElement ( "org . dom4j . util . UserDataAttribute@175089e4 [ Attribute : name value \"null\" ] " ) ; BackedList < Element > backedList0 = NodeHelper . appendElementNamedLocal ( ( Node ) userDataElement0 , ( BackedList < Element > ) null , "org . dom4j . util . UserDataAttribute@104b7faa [ Attribute : name name value \"null\" ] value \"null\" ] " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" BackedList < Element > appendElementNamedLocal ( Node node , BackedList < Element > list , String name ) { Element element = nodeAsElement ( node ) ; if ( element ! = null & & name . equals ( element . getName ( ) ) ) { list . addLocal ( element ) ; } return list ; }
void test15 ( ) throws Throwable { FlyweightAttribute flyweightAttribute0 = new FlyweightAttribute ( "~" , "~" , ( Namespace ) null ) ; QName qName0 = new QName ( "~" ) ; BackedList < Element > backedList0 = NodeHelper . appendElementQNamedLocal ( ( Node ) flyweightAttribute0 , ( BackedList < Element > ) null , qName0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" BackedList < Element > appendElementQNamedLocal ( Node node , BackedList < Element > list , QName qname ) { Element element = nodeAsElement ( node ) ; if ( element ! = null & & qname . equals ( element . getQName ( ) ) ) { list . addLocal ( element ) ; } return list ; }
void test16 ( ) throws Throwable { UserDataElement userDataElement0 = new UserDataElement ( "org . dom4j . util . UserDataAttribute@175089e4 [ Attribute : name value \"null\" ] " ) ; QName qName0 = userDataElement0 . getQName ( "org . dom4j . util . UserDataAttribute@175089e4 [ Attribute : name value \"null\" ] " ) ; BackedList < Element > backedList0 = NodeHelper . appendElementQNamedLocal ( ( Node ) userDataElement0 , ( BackedList < Element > ) null , qName0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" BackedList < Element > appendElementQNamedLocal ( Node node , BackedList < Element > list , QName qname ) { Element element = nodeAsElement ( node ) ; if ( element ! = null & & qname . equals ( element . getQName ( ) ) ) { list . addLocal ( element ) ; } return list ; }
void test17 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; QName qName0 = defaultDocumentFactory0 . createQName ( "e" , "e" , "e" ) ; DefaultAttribute defaultAttribute0 = new DefaultAttribute ( qName0 ) ; String string0 = NodeHelper . getAttributeValue ( ( Attribute ) defaultAttribute0 , "e" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAttributeValue ( Attribute attribute , String defaultValue ) { return attribute = = null ? defaultValue : attribute . getValue ( ) ; }
void test18 ( ) throws Throwable { String string0 = NodeHelper . getAttributeValue ( ( Attribute ) null , "e" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAttributeValue ( Attribute attribute , String defaultValue ) { return attribute = = null ? defaultValue : attribute . getValue ( ) ; }
void test1 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; DOMElement dOMElement0 = new DOMElement ( ( QName ) null ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "Propert8 file otSfound ! " , "Propert8 file otSfound ! " , "Propert8 file otSfound ! " ) ; DOMDocument dOMDocument0 = new DOMDocument ( dOMElement0 , dOMDocumentType0 ) ; mode0 . applyTemplates ( ( Document ) dOMDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isReadOnly ( ) ; / * * * < p > * < code > hasContent < / code > returns true if this node is a Branch ( either * an Element or a Document ) and it contains at least one content node such * as a child Element or Text node . * < / p > * * @return true if this < code > Node < / code > is a Branch with a nodeCount ( ) * of one or more . * / boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test2 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; UserDataElement userDataElement0 = new UserDataElement ( "COMME0T_NODE" ) ; QName qName0 = userDataElement0 . getQName ( "COMME0T_NODE" ) ; UserDataAttribute userDataAttribute0 = new UserDataAttribute ( qName0 ) ; Namespace namespace0 = userDataAttribute0 . getNamespace ( ) ; XPathPattern xPathPattern0 = ( XPathPattern ) namespace0 . createPattern ( "COMME0T_NODE" ) ; NullAction nullAction0 = NullAction . SINGLETON ; Rule rule0 = new Rule ( ( Pattern ) xPathPattern0 , ( Action ) nullAction0 ) ; mode0 . addRule ( rule0 ) ; mode0 . fireRule ( ( Node ) userDataElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" NodeType getNodeTypeEnum ( ) { return NodeType . NAMESPACE_NODE ; }
void test3 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; IndexedElement indexedElement0 = new IndexedElement ( "4HEp { X$tEdY / zI" ) ; NonLazyElement nonLazyElement0 = new NonLazyElement ( "4HEp { X$tEdY / zI" ) ; QName qName0 = nonLazyElement0 . getQName ( "4HEp { X$tEdY / zI" ) ; indexedElement0 . addAttribute ( qName0 , "4HEp { X$tEdY / zI" ) ; mode0 . applyTemplates ( ( Element ) indexedElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsParent ( ) ; / * * * < p > * < code > getParent < / code > returns the parent < code > Element < / code > if * this node supports the parent relationship or null if it is the root * element or does not support the parent relationship . * < / p > * < p / > * < p > * This method is an optional feature and may not be supported for all * < code > Node < / code > implementations . * < / p > * * @return the parent of this node or null if it is the root of the tree or * the parent relationship is not supported . * / Element getParent ( ) ; / * * * < p > * < code > setParent < / code > sets the parent relationship of this node if the * parent relationship is supported or does nothing if the parent * relationship is not supported . * < / p > * < p / > * < p > * This method should only be called from inside an < code > Element < / code > * implementation method and is not intended for general use . * < / p > * * @param parent is the new parent of this node . * / void setParent ( Element parent ) ; / * * * < p > * < code > getDocument < / code > returns the < code > Document < / code > that this * < code > Node < / code > is part of if this node supports the parent * relationship . * < / p > * < p / > * < p > * This method is an optional feature and may not be supported for all * < code > Node < / code > implementations . * < / p > * * @return the document of this node or null if this feature is not * supported or the node is not associated with a * < code > Document < / code > * / Document getDocument ( ) ; / * * * < p > * < code > setDocument < / code > sets the document of this node if the parent * relationship is supported or does nothing if the parent relationship is * not supported . * < / p > * < p / > * < p > * This method should only be called from inside a < code > Document < / code > * implementation method and is not intended for general use . * < / p > * * @param document is the new document of this node . * / void setDocument ( Document document ) ; / * * * < p > * < code > isReadOnly < / code > returns true if this node is read only and * cannot be modified . Any attempt to modify a read - only < code > Node < / code > * will result in an < code > UnsupportedOperationException < / code > being * thrown . * < / p > * * @return true if this < code > Node < / code > is read only and cannot be * modified otherwise false . * / boolean isReadOnly ( ) ; / * * * < p > * < code > hasContent < / code > returns true if this node is a Branch ( either * an Element or a Document ) and it contains at least one content node such * as a child Element or Text node . * < / p > * * @return true if this < code > Node < / code > is a Branch with a nodeCount ( ) * of one or more . * / boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test4 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; QName qName0 = defaultDocumentFactory0 . createQName ( " ! ) qw4 ( wm ; wDi#c2U_" , " ! ) qw4 ( wm ; wDi#c2U_" , " ! ) qw4 ( wm ; wDi#c2U_" ) ; IndexedElement indexedElement0 = new IndexedElement ( qName0 , 55296 ) ; indexedElement0 . addProcessingInstruction ( " ! ) qw4 ( wm ; wDi#c2U_" , " ! ) qw4 ( wm ; wDi#c2U_" ) ; mode0 . applyTemplates ( ( Element ) indexedElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getXPathNameStep ( ) { if ( ( prefix ! = null ) & & ! "" . equals ( prefix ) ) { return "namespace : : " + prefix ; } return "namespace : : * [ name ( ) = '' ] " ; }
void test5 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; DefaultPattern defaultPattern0 = new DefaultPattern ( ( NodeFilter ) null ) ; NullAction nullAction0 = NullAction . SINGLETON ; Rule rule0 = new Rule ( ( Pattern ) defaultPattern0 , ( Action ) nullAction0 ) ; mode0 . removeRule ( rule0 ) ; mode0 . addRule ( rule0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAppearenceCount ( ) { return appearenceCount ; }
void test6 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; UserDataElement userDataElement0 = new UserDataElement ( "COMME0T_NODE" ) ; QName qName0 = userDataElement0 . getQName ( "COMME0T_NODE" ) ; UserDataAttribute userDataAttribute0 = new UserDataAttribute ( qName0 ) ; Namespace namespace0 = userDataAttribute0 . getNamespace ( ) ; XPathPattern xPathPattern0 = ( XPathPattern ) namespace0 . createPattern ( "COMME0T_NODE" ) ; NullAction nullAction0 = NullAction . SINGLETON ; Rule rule0 = new Rule ( ( Pattern ) xPathPattern0 , ( Action ) nullAction0 ) ; mode0 . removeRule ( rule0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMatchesNodeName ( ) { return pattern . getMatchesNodeName ( ) ; }
void test7 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; QName qName0 = defaultDocumentFactory0 . createQName ( " ! ) qw4 ( wm ; wDi#c2U_" , " ! ) qw4 ( wm ; wDi#c2U_" , " ! ) qw4 ( wm ; wDi#c2U_" ) ; IndexedElement indexedElement0 = new IndexedElement ( qName0 , 55296 ) ; NodeType nodeType0 = NodeType . PROCESSING_INSTRUCTION_NODE ; mode0 . getRuleSet ( nodeType0 ) ; indexedElement0 . addProcessingInstruction ( " ! ) qw4 ( wm ; wDi#c2U_" , " ! ) qw4 ( wm ; wDi#c2U_" ) ; mode0 . applyTemplates ( ( Element ) indexedElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTextOnly ( ) ; / * * * Appends the attributes of the given element to me . This method behaves * like the { @link java . util . Collection#addAll ( java . util . Collection ) }
void test8 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; HashMap < String , RuleSet > hashMap0 = new HashMap < String , RuleSet > ( ) ; Map < String , RuleSet > map0 = mode0 . addToNameMap ( ( Map < String , RuleSet > ) hashMap0 , "IGNO / : E" , ( Rule ) null ) ; Map < String , RuleSet > map1 = mode0 . addToNameMap ( map0 , "IGNO / : E" , ( Rule ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test9 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; UserDataElement userDataElement0 = new UserDataElement ( "COMME0T_NODE" ) ; QName qName0 = userDataElement0 . getQName ( "COMME0T_NODE" ) ; UserDataAttribute userDataAttribute0 = new UserDataAttribute ( qName0 ) ; Namespace namespace0 = userDataAttribute0 . getNamespace ( ) ; XPathPattern xPathPattern0 = ( XPathPattern ) namespace0 . createPattern ( "COMME0T_NODE" ) ; NullAction nullAction0 = NullAction . SINGLETON ; Rule rule0 = new Rule ( ( Pattern ) xPathPattern0 , ( Action ) nullAction0 ) ; Map < String , RuleSet > map0 = mode0 . addToNameMap ( ( Map < String , RuleSet > ) null , "COMME0T_NODE" , rule0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test10 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; DefaultPattern defaultPattern0 = new DefaultPattern ( ( NodeFilter ) null ) ; NullAction nullAction0 = NullAction . SINGLETON ; Rule rule0 = new Rule ( ( Pattern ) defaultPattern0 , ( Action ) nullAction0 ) ; mode0 . removeFromNameMap ( ( Map < String , RuleSet > ) null , "" , rule0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test11 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; HashMap < String , RuleSet > hashMap0 = new HashMap < String , RuleSet > ( ) ; Rule rule0 = new Rule ( ) ; mode0 . removeFromNameMap ( ( Map < String , RuleSet > ) hashMap0 , "rAdj . | vw { _H" , rule0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test12 ( ) throws Throwable { Mode mode0 = new Mode ( ) ; HashMap < String , RuleSet > hashMap0 = new HashMap < String , RuleSet > ( ) ; mode0 . addToNameMap ( ( Map < String , RuleSet > ) hashMap0 , "IGNO / : E" , ( Rule ) null ) ; mode0 . removeFromNameMap ( ( Map < String , RuleSet > ) hashMap0 , "IGNO / : E" , ( Rule ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test1 ( ) throws Throwable { RuleSet ruleSet0 = new RuleSet ( ) ; NodeTypePattern nodeTypePattern0 = NodeTypePattern . ANY_TEXT ; NullAction nullAction0 = NullAction . SINGLETON ; Rule rule0 = new Rule ( ( Pattern ) nodeTypePattern0 , ( Action ) nullAction0 ) ; ruleSet0 . addRule ( rule0 ) ; DOMCDATA dOMCDATA0 = new DOMCDATA ( " ; [ { `Rj" ) ; Rule rule1 = ruleSet0 . getMatchingRule ( ( Node ) dOMCDATA0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Rule getMatchingRule ( Node node ) { Rule [ ] matches = getRuleArray ( ) ; for ( int i = matches . length - 1 ; i > = 0 ; i - - ) { Rule rule = matches [ i ] ; if ( rule . matches ( node ) ) { return rule ; } } return null ; }
void test2 ( ) throws Throwable { RuleSet ruleSet0 = new RuleSet ( ) ; String string0 = ruleSet0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test4 ( ) throws Throwable { RuleSet ruleSet0 = new RuleSet ( ) ; FlyweightCDATA flyweightCDATA0 = new FlyweightCDATA ( " ; [ { `Rj" ) ; Rule rule0 = ruleSet0 . getMatchingRule ( ( Node ) flyweightCDATA0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Rule getMatchingRule ( Node node ) { Rule [ ] matches = getRuleArray ( ) ; for ( int i = matches . length - 1 ; i > = 0 ; i - - ) { Rule rule = matches [ i ] ; if ( rule . matches ( node ) ) { return rule ; } } return null ; }
void test5 ( ) throws Throwable { RuleSet ruleSet0 = new RuleSet ( ) ; NodeTypePattern nodeTypePattern0 = NodeTypePattern . ANY_TEXT ; NullAction nullAction0 = NullAction . SINGLETON ; Rule rule0 = new Rule ( ( Pattern ) nodeTypePattern0 , ( Action ) nullAction0 ) ; ruleSet0 . addRule ( rule0 ) ; IndexedElement indexedElement0 = new IndexedElement ( "org . dom4j . rule . RuleSet@37cd74e0 [ RuleSet : [ ] ] " ) ; Namespace namespace0 = indexedElement0 . getNamespace ( ) ; BeanElement beanElement0 = new BeanElement ( " ; [ { `Rj" , namespace0 , ( Object ) "text ( ) " ) ; DOMText dOMText0 = new DOMText ( ( Element ) beanElement0 , "text ( ) " ) ; Rule rule1 = ruleSet0 . getMatchingRule ( ( Node ) dOMText0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test6 ( ) throws Throwable { RuleSet ruleSet0 = new RuleSet ( ) ; Rule [ ] ruleArray0 = ruleSet0 . getRuleArray ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Rule [ ] getRuleArray ( ) { if ( ruleArray = = null ) { Collections . sort ( rules ) ; int size = rules . size ( ) ; ruleArray = new Rule [ size ] ; rules . toArray ( ruleArray ) ; } return ruleArray ; }
void test1 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; String string0 = rule0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test2 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; rule0 . getMode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test3 ( ) throws Throwable { NameTest nameTest0 = new NameTest ( "#REQUIRED" , ( short ) 4449 ) ; XPathPattern xPathPattern0 = new XPathPattern ( ( Pattern ) nameTest0 ) ; NullAction nullAction0 = new NullAction ( ) ; Rule rule0 = new Rule ( ( org . dom4j . rule . Pattern ) xPathPattern0 , ( Action ) nullAction0 ) ; rule0 . setAction ( ( Action ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Mode getMode ( String modeName ) { Mode mode = ( Mode ) modes . get ( modeName ) ; if ( mode = = null ) { mode = createMode ( ) ; modes . put ( modeName , mode ) ; } return mode ; }
void test4 ( ) throws Throwable { NodeTypePattern nodeTypePattern0 = NodeTypePattern . ANY_ELEMENT ; Rule rule0 = new Rule ( ) ; rule0 . setPattern ( ( org . dom4j . rule . Pattern ) nodeTypePattern0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test5 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; rule0 . setMode ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test6 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; rule0 . setAppearenceCount ( 1780 ) ; NodeTypePattern nodeTypePattern0 = NodeTypePattern . ANY_ELEMENT ; Rule rule1 = new Rule ( ( org . dom4j . rule . Pattern ) nodeTypePattern0 ) ; boolean boolean0 = rule0 . equals ( ( Object ) rule1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAppearenceCount ( ) { return appearenceCount ; }
void test7 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; int int0 = rule0 . getAppearenceCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test8 ( ) throws Throwable { NameTest nameTest0 = new NameTest ( "#REQUIRED" , ( short ) 4449 ) ; UnionPattern unionPattern0 = new UnionPattern ( ( Pattern ) nameTest0 , ( Pattern ) nameTest0 ) ; XPathPattern xPathPattern0 = new XPathPattern ( ( Pattern ) unionPattern0 ) ; NullAction nullAction0 = new NullAction ( ) ; Rule rule0 = new Rule ( ( org . dom4j . rule . Pattern ) xPathPattern0 , ( Action ) nullAction0 ) ; Rule [ ] ruleArray0 = rule0 . getUnionRules ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test9 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; double double0 = rule0 . getPriority ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test11 ( ) throws Throwable { NameTest nameTest0 = new NameTest ( "#REQUIRED" , ( short ) 4449 ) ; UnionPattern unionPattern0 = new UnionPattern ( ( Pattern ) nameTest0 , ( Pattern ) nameTest0 ) ; XPathPattern xPathPattern0 = new XPathPattern ( ( Pattern ) unionPattern0 ) ; NullAction nullAction0 = new NullAction ( ) ; Rule rule0 = new Rule ( ( org . dom4j . rule . Pattern ) xPathPattern0 , ( Action ) nullAction0 ) ; rule0 . getMatchesNodeName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test12 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; int int0 = rule0 . getImportPrecedence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test13 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; boolean boolean0 = rule0 . equals ( ( Object ) " / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test14 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; boolean boolean0 = rule0 . equals ( ( Object ) rule0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test15 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; int int0 = rule0 . compareTo ( ( Object ) " | vht0NVb%6b$ < : o'T ) _" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test16 ( ) throws Throwable { NodeTypeTest nodeTypeTest0 = NodeTypeTest . COMMENT_TEST ; XPathPattern xPathPattern0 = new XPathPattern ( ( Pattern ) nodeTypeTest0 ) ; Rule rule0 = new Rule ( ( org . dom4j . rule . Pattern ) xPathPattern0 ) ; int int0 = rule0 . compareTo ( ( Object ) rule0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test17 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; NodeType nodeType0 = NodeType . ELEMENT_NODE ; NodeTypePattern nodeTypePattern0 = new NodeTypePattern ( nodeType0 ) ; NullAction nullAction0 = new NullAction ( ) ; Rule rule1 = new Rule ( ( org . dom4j . rule . Pattern ) nodeTypePattern0 , ( Action ) nullAction0 ) ; rule0 . setImportPrecedence ( 17 ) ; int int0 = rule0 . compareTo ( rule1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getImportPrecedence ( ) { return importPrecedence ; }
void test18 ( ) throws Throwable { Rule rule0 = new Rule ( ) ; NodeType nodeType0 = NodeType . ATTRIBUTE_NODE ; NodeTypePattern nodeTypePattern0 = new NodeTypePattern ( nodeType0 ) ; NullAction nullAction0 = new NullAction ( ) ; Rule rule1 = new Rule ( ( org . dom4j . rule . Pattern ) nodeTypePattern0 , ( Action ) nullAction0 ) ; rule0 . setPriority ( ( - 18 . 496891053278386 ) ) ; int int0 = rule0 . compareTo ( rule1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test19 ( ) throws Throwable { NodeTypePattern nodeTypePattern0 = NodeTypePattern . ANY_ELEMENT ; Rule rule0 = new Rule ( ( org . dom4j . rule . Pattern ) nodeTypePattern0 ) ; rule0 . getUnionRules ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test1 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; List < Object > list0 = DefaultExpr . convertToList ( ( Object ) " * " ) ; stylesheet0 . run ( list0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test2 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; stylesheet0 . setValueOfAction ( ( Action ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getModeName ( ) { return modeName ; }
void test3 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; DefaultEntity defaultEntity0 = ( DefaultEntity ) defaultDocumentFactory0 . createEntity ( "" , "" ) ; stylesheet0 . run ( ( Node ) defaultEntity0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test4 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; QName qName0 = defaultDocumentFactory0 . createQName ( "@ [ h^ { ^so1" ) ; UserDataAttribute userDataAttribute0 = new UserDataAttribute ( qName0 ) ; List < Object > list0 = DefaultExpr . convertToList ( ( Object ) userDataAttribute0 ) ; stylesheet0 . applyTemplates ( ( Object ) list0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test5 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; stylesheet0 . clear ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getModeName ( ) { return modeName ; }
void test6 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; DOMCDATA dOMCDATA0 = new DOMCDATA ( "#e" ) ; DefaultXPath defaultXPath0 = ( DefaultXPath ) dOMCDATA0 . createXPath ( "Document" ) ; stylesheet0 . applyTemplates ( ( Object ) "Document" , ( XPath ) defaultXPath0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getModeName ( ) { return modeName ; }
void test7 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; DOMCDATA dOMCDATA0 = new DOMCDATA ( "#e" ) ; stylesheet0 . run ( ( Object ) dOMCDATA0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPrefix ( ) { return prefix ; }
void test8 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; stylesheet0 . setModeName ( "#e" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getModeName ( ) { return modeName ; }
void test9 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; Action action0 = stylesheet0 . getValueOfAction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action getValueOfAction ( ) { return ruleManager . getValueOfAction ( ) ; }
void test11 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; String string0 = stylesheet0 . getModeName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getModeName ( ) { return modeName ; }
void test12 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; DOMElement dOMElement0 = new DOMElement ( "" ) ; List < Namespace > list0 = dOMElement0 . additionalNamespaces ( "" ) ; stylesheet0 . run ( ( Object ) list0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test13 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; stylesheet0 . run ( ( Object ) "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getModeName ( ) { return modeName ; }
void test14 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; Namespace namespace0 = Namespace . XML_NAMESPACE ; QName qName0 = QName . get ( " ] uZfhu5 < S ; ko" , namespace0 ) ; DOMElement dOMElement0 = new DOMElement ( qName0 , 0 ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( " ] uZfhu5 < S ; ko" , " ] uZfhu5 < S ; ko" ) ; DOMDocument dOMDocument0 = new DOMDocument ( dOMElement0 , dOMDocumentType0 ) ; List < Node > list0 = dOMDocument0 . content ( ) ; stylesheet0 . run ( ( List ) list0 , " ] uZfhu5 < S ; ko" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getModeName ( ) { return modeName ; }
void test16 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; QName qName0 = QName . get ( "" , "" ) ; DOMElement dOMElement0 = new DOMElement ( qName0 , ( - 284 ) ) ; dOMElement0 . addComment ( "" ) ; stylesheet0 . applyTemplates ( ( Object ) dOMElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNodeName ( ) { return "#document" ; }
void test17 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; DOMElement dOMElement0 = new DOMElement ( "" ) ; DOMDocument dOMDocument0 = new DOMDocument ( dOMElement0 ) ; stylesheet0 . applyTemplates ( ( Object ) dOMDocument0 , "processing - instruction ( ) " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasChildNodes ( ) { return nodeCount ( ) > 0 ; }
void test18 ( ) throws Throwable { Stylesheet stylesheet0 = new Stylesheet ( ) ; stylesheet0 . applyTemplates ( ( Object ) "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getModeName ( ) { return modeName ; }
void test0 ( ) throws Throwable { RuleManager ruleManager0 = new RuleManager ( ) ; Mode mode0 = ruleManager0 . getMode ( "Y\"NxIHF$urj * yy / s | #" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAppearenceCount ( ) { return appearenceCount ; }
void test2 ( ) throws Throwable { RuleManager ruleManager0 = new RuleManager ( ) ; NullAction nullAction0 = new NullAction ( ) ; ruleManager0 . setValueOfAction ( ( Action ) nullAction0 ) ; NodeTypePattern nodeTypePattern0 = NodeTypePattern . ANY_DOCUMENT ; Rule rule0 = ruleManager0 . createDefaultRule ( ( Pattern ) nodeTypePattern0 , ( Action ) nullAction0 ) ; ruleManager0 . removeRule ( rule0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getImportPrecedence ( ) { return importPrecedence ; }
void test3 ( ) throws Throwable { RuleManager ruleManager0 = new RuleManager ( ) ; NodeTypeTest nodeTypeTest0 = new NodeTypeTest ( ( short ) 0 ) ; UnionPattern unionPattern0 = new UnionPattern ( ( org . jaxen . pattern . Pattern ) nodeTypeTest0 , ( org . jaxen . pattern . Pattern ) nodeTypeTest0 ) ; XPathPattern xPathPattern0 = new XPathPattern ( ( org . jaxen . pattern . Pattern ) unionPattern0 ) ; NullAction nullAction0 = new NullAction ( ) ; Rule rule0 = new Rule ( ( Pattern ) xPathPattern0 , ( Action ) nullAction0 ) ; ruleManager0 . removeRule ( rule0 ) ; ruleManager0 . addRule ( rule0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAppearenceCount ( ) { return appearenceCount ; }
void test4 ( ) throws Throwable { RuleManager ruleManager0 = new RuleManager ( ) ; NullAction nullAction0 = new NullAction ( ) ; NodeTypePattern nodeTypePattern0 = NodeTypePattern . ANY_DOCUMENT ; Rule rule0 = ruleManager0 . createDefaultRule ( ( Pattern ) nodeTypePattern0 , ( Action ) nullAction0 ) ; ruleManager0 . removeRule ( rule0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getImportPrecedence ( ) { return importPrecedence ; }
void test5 ( ) throws Throwable { RuleManager ruleManager0 = new RuleManager ( ) ; Rule rule0 = ruleManager0 . getMatchingRule ( "" , ( Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Rule getMatchingRule ( Node node ) { Rule [ ] matches = getRuleArray ( ) ; for ( int i = matches . length - 1 ; i > = 0 ; i - - ) { Rule rule = matches [ i ] ; if ( rule . matches ( node ) ) { return rule ; } } return null ; }
void test6 ( ) throws Throwable { RuleManager ruleManager0 = new RuleManager ( ) ; Mode mode0 = ruleManager0 . getMode ( "Y\"NxIHF$urj * yy / s | #" ) ; DOMElement dOMElement0 = new DOMElement ( "Y\"NxIHF$urj * yy / s | #" ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( ) ; DOMDocument dOMDocument0 = new DOMDocument ( "Y\"NxIHF$urj * yy / s | #" , dOMElement0 , dOMDocumentType0 ) ; mode0 . fireRule ( ( Node ) dOMDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasChildNodes ( ) { return nodeCount ( ) > 0 ; }
void test0 ( ) throws Throwable { DefaultPattern defaultPattern0 = new DefaultPattern ( ( NodeFilter ) null ) ; String string0 = defaultPattern0 . getMatchesNodeName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMatchesNodeName ( ) { return pattern . getMatchesNodeName ( ) ; }
void test1 ( ) throws Throwable { DefaultPattern defaultPattern0 = new DefaultPattern ( ( NodeFilter ) null ) ; Pattern [ ] patternArray0 = defaultPattern0 . getUnionPatterns ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Pattern [ ] getUnionPatterns ( ) ; / * * * DOCUMENT ME ! * * @return the type of node the pattern matches which by default should * return ANY_NODE if it can match any kind of node . * / NodeType getMatchType ( ) ; / * * * For patterns which only match an ATTRIBUTE_NODE or an ELEMENT_NODE then * this pattern may return the name of the element or attribute it matches . * This allows a more efficient rule matching algorithm to be performed , * rather than a brute force approach of evaluating every pattern for a * given Node . * * @return the name of the element or attribute this pattern matches or null * if this pattern matches any or more than one name . * / String getMatchesNodeName ( ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test2 ( ) throws Throwable { DefaultPattern defaultPattern0 = new DefaultPattern ( ( NodeFilter ) null ) ; double double0 = defaultPattern0 . getPriority ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test3 ( ) throws Throwable { DefaultPattern defaultPattern0 = new DefaultPattern ( ( NodeFilter ) null ) ; NodeType nodeType0 = defaultPattern0 . getMatchType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test0 ( ) throws Throwable { NodeType nodeType0 = NodeType . ENTITY_REFERENCE_NODE ; NodeTypePattern nodeTypePattern0 = new NodeTypePattern ( nodeType0 ) ; String string0 = nodeTypePattern0 . getMatchesNodeName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMatchesNodeName ( ) { return pattern . getMatchesNodeName ( ) ; }
void test1 ( ) throws Throwable { NodeType nodeType0 = NodeType . ENTITY_REFERENCE_NODE ; NodeTypePattern nodeTypePattern0 = new NodeTypePattern ( nodeType0 ) ; NodeType nodeType1 = nodeTypePattern0 . getMatchType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" NodeType getMatchType ( ) { return pattern . getMatchType ( ) ; }
void test2 ( ) throws Throwable { NodeType nodeType0 = NodeType . ENTITY_REFERENCE_NODE ; NodeTypePattern nodeTypePattern0 = new NodeTypePattern ( nodeType0 ) ; Pattern [ ] patternArray0 = nodeTypePattern0 . getUnionPatterns ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Pattern [ ] getUnionPatterns ( ) ; / * * * DOCUMENT ME ! * * @return the type of node the pattern matches which by default should * return ANY_NODE if it can match any kind of node . * / NodeType getMatchType ( ) ; / * * * For patterns which only match an ATTRIBUTE_NODE or an ELEMENT_NODE then * this pattern may return the name of the element or attribute it matches . * This allows a more efficient rule matching algorithm to be performed , * rather than a brute force approach of evaluating every pattern for a * given Node . * * @return the name of the element or attribute this pattern matches or null * if this pattern matches any or more than one name . * / String getMatchesNodeName ( ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test3 ( ) throws Throwable { NodeType nodeType0 = NodeType . NAMESPACE_NODE ; NodeTypePattern nodeTypePattern0 = new NodeTypePattern ( nodeType0 ) ; double double0 = nodeTypePattern0 . getPriority ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test4 ( ) throws Throwable { NodeType nodeType0 = NodeType . NAMESPACE_NODE ; NodeTypePattern nodeTypePattern0 = new NodeTypePattern ( nodeType0 ) ; DefaultDocument defaultDocument0 = new DefaultDocument ( " , * NhS ( " ) ; boolean boolean0 = nodeTypePattern0 . matches ( ( Node ) defaultDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matches ( Node node ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test5 ( ) throws Throwable { NodeType nodeType0 = NodeType . NAMESPACE_NODE ; NodeTypePattern nodeTypePattern0 = new NodeTypePattern ( nodeType0 ) ; Namespace namespace0 = Namespace . XML_NAMESPACE ; boolean boolean0 = nodeTypePattern0 . matches ( ( Node ) namespace0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matches ( Node node ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test0 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "bTQBDP * Tk5ZGcZ" ) ; defaultXPath0 . selectObject ( ( Object ) defaultXPath0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test2 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "bTQBDP * Tk5ZGcZ" ) ; defaultXPath0 . booleanValueOf ( ( Object ) "NaN" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test3 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "VH_bIc_\" / S . 5ym" ) ; defaultXPath0 . numberValueOf ( ( Object ) "VH_bIc_\" / S . 5ym" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test4 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( " . \"Z' . na9 = e'" ) ; List < Object > list0 = defaultXPath0 . selectNodes ( ( Object ) true , ( XPath ) defaultXPath0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test5 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "VH_bIc_\" / S . 5ym" ) ; XPathFunctionContext xPathFunctionContext0 = ( XPathFunctionContext ) defaultXPath0 . getFunctionContext ( ) ; defaultXPath0 . setFunctionContext ( ( FunctionContext ) xPathFunctionContext0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) ; / * * * DOCUMENT ME ! * * @return the trimmed text value where whitespace is trimmed and normalised * into single spaces . This method does not return null . * / String getTextTrim ( ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . This method returns the string - value of all the * contained { @link Text }
void test6 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "processing - instruction ( ) " ) ; SimpleVariableContext simpleVariableContext0 = new SimpleVariableContext ( ) ; defaultXPath0 . setVariableContext ( ( VariableContext ) simpleVariableContext0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test7 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( " . \"Z' . na9 = e'" ) ; String string0 = defaultXPath0 . getText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test8 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "VH_bIc_\" / S . 5ym" ) ; String string0 = defaultXPath0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test10 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "processing - instruction ( ) " ) ; SimpleVariableContext simpleVariableContext0 = ( SimpleVariableContext ) defaultXPath0 . getVariableContext ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test11 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "processing - instruction ( ) " ) ; defaultXPath0 . getNamespaceContext ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test12 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "VH_bIc_\" / S . 5ym" ) ; NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; QName qName0 = namespaceStack0 . getQName ( "VH_bIc_\" / S . 5ym" , "VH_bIc_\" / S . 5ym" , "VH_bIc_\" / S . 5ym" ) ; UserDataAttribute userDataAttribute0 = new UserDataAttribute ( qName0 ) ; Object object0 = defaultXPath0 . evaluate ( ( Object ) userDataAttribute0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test13 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "VH_bIc_\" / S . 5ym" ) ; NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; defaultXPath0 . selectSingleNode ( ( Object ) namespaceStack0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test14 ( ) throws Throwable { Namespace namespace0 = Namespace . NO_NAMESPACE ; BaseElement baseElement0 = new BaseElement ( " . \"Z' . na9 = e'" , namespace0 ) ; BaseElement baseElement1 = ( BaseElement ) baseElement0 . selectSingleNode ( " . \"Z' . na9 = e'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUniquePath ( Element context ) { StringBuffer path = new StringBuffer ( 10 ) ; Element parent = getParent ( ) ; if ( ( parent ! = null ) & & ( parent ! = context ) ) { path . append ( parent . getUniquePath ( context ) ) ; path . append ( ' / ' ) ; } path . append ( getXPathNameStep ( ) ) ; return path . toString ( ) ; }
void test16 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( " . \"Z' . na9 = e'" ) ; defaultXPath0 . sort ( ( List ) null , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test17 ( ) throws Throwable { DefaultComment defaultComment0 = new DefaultComment ( "VH_bIc_\" / . 5ym" ) ; List < ? > list0 = defaultComment0 . selectNodes ( "VH_bIc_\" / . 5ym" , "VH_bIc_\" / . 5ym" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test18 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( " . \"Z' . na9 = e'" ) ; List < Object > list0 = defaultXPath0 . selectNodes ( ( Object ) " . \"Z' . na9 = e'" , ( XPath ) defaultXPath0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test19 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "Nor_ = 11" ) ; DOMElement dOMElement0 = new DOMElement ( "Nor_ = 11" ) ; boolean boolean0 = defaultXPath0 . matches ( ( Node ) dOMElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test20 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "bTQBDP * Tk5ZGcZ" ) ; Namespace namespace0 = Namespace . get ( "bTQBDP * Tk5ZGcZ" ) ; boolean boolean0 = defaultXPath0 . matches ( ( Node ) namespace0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test21 ( ) throws Throwable { DefaultXPath defaultXPath0 = new DefaultXPath ( "processing - instruction ( ) " ) ; NonLazyElement nonLazyElement0 = new NonLazyElement ( "processing - instruction ( ) " ) ; Namespace namespace0 = Namespace . get ( "processing - instruction ( ) " ) ; DOMProcessingInstruction dOMProcessingInstruction0 = new DOMProcessingInstruction ( ( Element ) nonLazyElement0 , "processing - instruction ( ) " , "processing - instruction ( ) " ) ; Map < String , String > map0 = dOMProcessingInstruction0 . getValues ( ) ; defaultXPath0 . setNamespaceURIs ( map0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matches ( Node node ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test1 ( ) throws Throwable { LocationPathPattern locationPathPattern0 = new LocationPathPattern ( ) ; XPathPattern xPathPattern0 = new XPathPattern ( ( Pattern ) locationPathPattern0 ) ; String string0 = xPathPattern0 . getText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) ; / * * * DOCUMENT ME ! * * @return the trimmed text value where whitespace is trimmed and normalised * into single spaces . This method does not return null . * / String getTextTrim ( ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . This method returns the string - value of all the * contained { @link Text }
void test2 ( ) throws Throwable { AnyChildNodeTest anyChildNodeTest0 = AnyChildNodeTest . getInstance ( ) ; XPathPattern xPathPattern0 = new XPathPattern ( ( Pattern ) anyChildNodeTest0 ) ; double double0 = xPathPattern0 . getPriority ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPriority ( ) { return priority ; }
void test3 ( ) throws Throwable { XPathPattern xPathPattern0 = new XPathPattern ( "namespace ( ) " ) ; SimpleVariableContext simpleVariableContext0 = new SimpleVariableContext ( ) ; xPathPattern0 . setVariableContext ( ( VariableContext ) simpleVariableContext0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMatchesNodeName ( ) { return pattern . getMatchesNodeName ( ) ; }
void test4 ( ) throws Throwable { XPathPattern xPathPattern0 = new XPathPattern ( "IC" ) ; NodeType nodeType0 = xPathPattern0 . getMatchType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" NodeType getMatchType ( ) { return pattern . getMatchType ( ) ; }
void test5 ( ) throws Throwable { LocationPathPattern locationPathPattern0 = new LocationPathPattern ( ) ; XPathPattern xPathPattern0 = new XPathPattern ( ( Pattern ) locationPathPattern0 ) ; String string0 = xPathPattern0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test6 ( ) throws Throwable { AnyChildNodeTest anyChildNodeTest0 = AnyChildNodeTest . getInstance ( ) ; XPathPattern xPathPattern0 = new XPathPattern ( ( Pattern ) anyChildNodeTest0 ) ; String string0 = xPathPattern0 . getMatchesNodeName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMatchesNodeName ( ) { return pattern . getMatchesNodeName ( ) ; }
void test7 ( ) throws Throwable { LocationPathPattern locationPathPattern0 = new LocationPathPattern ( ) ; XPathPattern xPathPattern0 = new XPathPattern ( ( Pattern ) locationPathPattern0 ) ; org . dom4j . rule . Pattern [ ] patternArray0 = xPathPattern0 . getUnionPatterns ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Pattern [ ] getUnionPatterns ( ) ; / * * * DOCUMENT ME ! * * @return the type of node the pattern matches which by default should * return ANY_NODE if it can match any kind of node . * / NodeType getMatchType ( ) ; / * * * For patterns which only match an ATTRIBUTE_NODE or an ELEMENT_NODE then * this pattern may return the name of the element or attribute it matches . * This allows a more efficient rule matching algorithm to be performed , * rather than a brute force approach of evaluating every pattern for a * given Node . * * @return the name of the element or attribute this pattern matches or null * if this pattern matches any or more than one name . * / String getMatchesNodeName ( ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test4 ( ) throws Throwable { DOMReader dOMReader0 = new DOMReader ( ( DocumentFactory ) null ) ; DOMElement dOMElement0 = new DOMElement ( "g_ugsfd ? \" ? t ; o [ x" ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "g_ugsfd ? \" ? t ; o [ x" , "g_ugsfd ? \" ? t ; o [ x" ) ; DOMDocument dOMDocument0 = new DOMDocument ( dOMElement0 , dOMDocumentType0 ) ; DOMDocument dOMDocument1 = ( DOMDocument ) dOMReader0 . read ( ( Document ) dOMDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUniquePath ( Element context ) { StringBuffer path = new StringBuffer ( 10 ) ; Element parent = getParent ( ) ; if ( ( parent ! = null ) & & ( parent ! = context ) ) { path . append ( parent . getUniquePath ( context ) ) ; path . append ( ' / ' ) ; } path . append ( getXPathNameStep ( ) ) ; return path . toString ( ) ; }
void test5 ( ) throws Throwable { DOMReader dOMReader0 = new DOMReader ( ) ; DOMCDATA dOMCDATA0 = new DOMCDATA ( " . " ) ; DOMElement dOMElement0 = new DOMElement ( " . " ) ; dOMReader0 . readTree ( ( Node ) dOMCDATA0 , ( Branch ) dOMElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test7 ( ) throws Throwable { DOMReader dOMReader0 = new DOMReader ( ) ; QName qName0 = QName . get ( "qkz8#_" ) ; DOMAttribute dOMAttribute0 = new DOMAttribute ( qName0 , "qkz8#_" ) ; BeanElement beanElement0 = new BeanElement ( qName0 ) ; dOMReader0 . readTree ( ( Node ) dOMAttribute0 , ( Branch ) beanElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNamespaceURI ( ) ; / * * * < p > * Returns the fully qualified name of this element . This will be the same * as the value returned from { @link #getName }
void test8 ( ) throws Throwable { DOMReader dOMReader0 = new DOMReader ( ) ; QName qName0 = QName . get ( "qkz8#_" ) ; DOMText dOMText0 = new DOMText ( "qkz8#_" ) ; DOMElement dOMElement0 = new DOMElement ( qName0 , ( - 4 ) ) ; dOMReader0 . readTree ( ( Node ) dOMText0 , ( Branch ) dOMElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) ; / * * * DOCUMENT ME ! * * @return the trimmed text value where whitespace is trimmed and normalised * into single spaces . This method does not return null . * / String getTextTrim ( ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . This method returns the string - value of all the * contained { @link Text }
void test10 ( ) throws Throwable { DOMReader dOMReader0 = new DOMReader ( ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( ) ; DOMDocument dOMDocument0 = new DOMDocument ( dOMDocumentType0 ) ; DOMComment dOMComment0 = ( DOMComment ) dOMDocument0 . createComment ( "" ) ; dOMReader0 . readTree ( ( Node ) dOMComment0 , ( Branch ) dOMDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test11 ( ) throws Throwable { DOMReader dOMReader0 = new DOMReader ( ( DocumentFactory ) null ) ; DOMElement dOMElement0 = new DOMElement ( "g_ugsfd ? \" ? t ; o [ x" ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "g_ugsfd ? \" ? t ; o [ x" , "g_ugsfd ? \" ? t ; o [ x" ) ; DOMDocument dOMDocument0 = new DOMDocument ( dOMElement0 , dOMDocumentType0 ) ; dOMReader0 . readTree ( ( Node ) dOMDocument0 , ( Branch ) dOMDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test12 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; DOMReader dOMReader0 = new DOMReader ( ( DocumentFactory ) defaultDocumentFactory0 ) ; DOMNamespace dOMNamespace0 = new DOMNamespace ( "a * d / = NcU" , "a * d / = NcU" ) ; BeanElement beanElement0 = new BeanElement ( "a * d / = NcU" , ( Namespace ) dOMNamespace0 , ( Object ) "a * d / = NcU" ) ; dOMReader0 . readTree ( ( Node ) dOMNamespace0 , ( Branch ) beanElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test13 ( ) throws Throwable { DOMReader dOMReader0 = new DOMReader ( ) ; UserDataElement userDataElement0 = new UserDataElement ( "FS9x" ) ; DOMComment dOMComment0 = new DOMComment ( ( Element ) userDataElement0 , "FS9x" ) ; dOMReader0 . readTree ( ( Node ) dOMComment0 , ( Branch ) userDataElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int nodeCount ( ) ; / * * * Returns the element of the given ID attribute value . If this tree is * capable of understanding which attribute value should be used for the ID * then it should be used , otherwise this method should return null . * * @param elementID DOCUMENT ME ! * @return DOCUMENT ME ! * / Element elementByID ( String elementID ) ; / * * * < p > * Returns the content nodes of this branch as a backed { @link List }
void test14 ( ) throws Throwable { DOMReader dOMReader0 = new DOMReader ( ) ; DOMDocument dOMDocument0 = new DOMDocument ( ) ; DOMElement dOMElement0 = ( DOMElement ) dOMDocument0 . createElement ( "_IX { Gjp ] 3dM / " ) ; dOMReader0 . readElement ( ( Node ) dOMElement0 , ( Branch ) dOMDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test0 ( ) throws Throwable { SAXModifier sAXModifier0 = new SAXModifier ( ) ; sAXModifier0 . setDocumentFactory ( ( DocumentFactory ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test4 ( ) throws Throwable { SAXModifier sAXModifier0 = new SAXModifier ( true ) ; sAXModifier0 . resetModifiers ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test8 ( ) throws Throwable { SAXModifier sAXModifier0 = new SAXModifier ( ( XMLReader ) null , false ) ; DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) sAXModifier0 . getDocumentFactory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DocumentFactory getDocumentFactory ( ) { return DefaultDocumentFactory . getInstance ( ) ; }
void test12 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; SAXModifier sAXModifier0 = new SAXModifier ( ( XMLReader ) xMLWriter0 , false ) ; sAXModifier0 . setXMLWriter ( xMLWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test0 ( ) throws Throwable { SAXEventRecorder . SAXEvent sAXEventRecorder_SAXEvent0 = new SAXEventRecorder . SAXEvent ( ) ; Object object0 = sAXEventRecorder_SAXEvent0 . getParm ( 1822 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SAXEventRecorder ( ) { }
void test21 ( ) throws Throwable { SAXEventRecorder sAXEventRecorder0 = new SAXEventRecorder ( ) ; Attributes2Impl attributes2Impl0 = new Attributes2Impl ( ) ; sAXEventRecorder0 . startElement ( " . c , ass" , " . c , ass" , " . c , ass" , ( Attributes ) attributes2Impl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) { return DOMNodeHelper . getLength ( this ) ; }
void test24 ( ) throws Throwable { SAXEventRecorder sAXEventRecorder0 = new SAXEventRecorder ( ) ; ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; PrintStream printStream0 = new PrintStream ( ( OutputStream ) byteArrayOutputStream0 ) ; sAXEventRecorder0 . elementDecl ( "'#wN" , "'#wN" ) ; ObjectOutputStream objectOutputStream0 = new ObjectOutputStream ( ( OutputStream ) printStream0 ) ; sAXEventRecorder0 . writeExternal ( ( ObjectOutput ) objectOutputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test0 ( ) throws Throwable { ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( 1399 ) ; STAXEventWriter sTAXEventWriter0 = new STAXEventWriter ( ( OutputStream ) byteArrayOutputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void writeEntity ( Entity entity ) throws XMLStreamException { consumer . add ( createEntityReference ( entity ) ) ; }
void test8 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 397 ) ; STAXEventWriter sTAXEventWriter0 = new STAXEventWriter ( ( Writer ) charArrayWriter0 ) ; / / XMLEventFactoryImpl xMLEventFactoryImpl0 = ( XMLEventFactoryImpl ) sTAXEventWriter0 . getEventFactory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" STAXEventWriter ( ) { }
void test10 ( ) throws Throwable { STAXEventWriter sTAXEventWriter0 = new STAXEventWriter ( ) ; XMLEventConsumer xMLEventConsumer0 = sTAXEventWriter0 . getConsumer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XMLEventConsumer getConsumer ( ) { return consumer ; }
void test2 ( ) throws Throwable { String [ ] stringArray0 = new String [ 2 ] ; PruningElementStack pruningElementStack0 = new PruningElementStack ( stringArray0 , ( ElementHandler ) null , 49 ) ; Element element0 = pruningElementStack0 . popElement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Element popElement ( ) { if ( lastElementIndex < 0 ) { return null ; } return stack [ lastElementIndex - - ] ; }
void test3 ( ) throws Throwable { String [ ] stringArray0 = new String [ 7 ] ; PruningElementStack pruningElementStack0 = new PruningElementStack ( stringArray0 , ( ElementHandler ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean validElement ( Element element , int index ) { String requiredName = path [ index ] ; String name = element . getName ( ) ; if ( requiredName = = name ) { return true ; } if ( ( requiredName ! = null ) & & ( name ! = null ) ) { return requiredName . equals ( name ) ; } return false ; }
void test4 ( ) throws Throwable { String [ ] stringArray0 = new String [ 2 ] ; stringArray0 [ 1 ] = "j_ } + G_ ( ] < J" ; PruningElementStack pruningElementStack0 = new PruningElementStack ( stringArray0 , ( ElementHandler ) null , 49 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean validElement ( Element element , int index ) { String requiredName = path [ index ] ; String name = element . getName ( ) ; if ( requiredName = = name ) { return true ; } if ( ( requiredName ! = null ) & & ( name ! = null ) ) { return requiredName . equals ( name ) ; } return false ; }
void test2 ( ) throws Throwable { SAXValidator sAXValidator0 = new SAXValidator ( ) ; SAXParserImpl . JAXPSAXParser sAXParserImpl_JAXPSAXParser0 = ( SAXParserImpl . JAXPSAXParser ) sAXValidator0 . createXMLReader ( ) ; SAXValidator sAXValidator1 = new SAXValidator ( ( XMLReader ) sAXParserImpl_JAXPSAXParser0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object object ) { if ( this = = object ) { return true ; } else if ( object instanceof Namespace ) { Namespace that = ( Namespace ) object ; / / we cache hash codes so this should be quick if ( hashCode ( ) = = that . hashCode ( ) ) { return uri . equals ( that . getURI ( ) ) & & prefix . equals ( that . getPrefix ( ) ) ; } } return false ; }
void test3 ( ) throws Throwable { SAXValidator sAXValidator0 = new SAXValidator ( ) ; ErrorHandler errorHandler0 = sAXValidator0 . getErrorHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ErrorHandler getErrorHandler ( ) { return errorHandler ; }
void test6 ( ) throws Throwable { SAXValidator sAXValidator0 = new SAXValidator ( ) ; SAXParserImpl . JAXPSAXParser sAXParserImpl_JAXPSAXParser0 = ( SAXParserImpl . JAXPSAXParser ) sAXValidator0 . getXMLReader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XMLReader getXMLReader ( ) throws SAXException { if ( xmlReader = = null ) { xmlReader = createXMLReader ( ) ; } return xmlReader ; }
void test0 ( ) throws Throwable { HTMLWriter hTMLWriter0 = new HTMLWriter ( ( Writer ) null ) ; hTMLWriter0 . writeDeclaration ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test1 ( ) throws Throwable { PipedOutputStream pipedOutputStream0 = new PipedOutputStream ( ) ; PrintStream printStream0 = new PrintStream ( ( OutputStream ) pipedOutputStream0 ) ; HTMLWriter hTMLWriter0 = new HTMLWriter ( ( OutputStream ) printStream0 ) ; hTMLWriter0 . endCDATA ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test2 ( ) throws Throwable { HTMLWriter hTMLWriter0 = new HTMLWriter ( ) ; NonLazyElement nonLazyElement0 = new NonLazyElement ( "" ) ; hTMLWriter0 . writeElement ( ( Element ) nonLazyElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNamespaceURI ( ) ; / * * * < p > * Returns the fully qualified name of this element . This will be the same * as the value returned from { @link #getName }
void test4 ( ) throws Throwable { HTMLWriter hTMLWriter0 = new HTMLWriter ( ) ; hTMLWriter0 . getOmitElementCloseSet ( ) ; hTMLWriter0 . writeClose ( "P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test5 ( ) throws Throwable { HTMLWriter hTMLWriter0 = new HTMLWriter ( ) ; hTMLWriter0 . startCDATA ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test7 ( ) throws Throwable { HTMLWriter hTMLWriter0 = new HTMLWriter ( ) ; Set < String > set0 = hTMLWriter0 . getPreformattedTags ( ) ; hTMLWriter0 . setPreformattedTags ( set0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test9 ( ) throws Throwable { ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; HTMLWriter hTMLWriter0 = new HTMLWriter ( ( OutputStream ) byteArrayOutputStream0 , outputFormat0 ) ; FlyweightText flyweightText0 = new FlyweightText ( "" ) ; hTMLWriter0 . write ( ( Text ) flyweightText0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test10 ( ) throws Throwable { HTMLWriter hTMLWriter0 = new HTMLWriter ( ) ; hTMLWriter0 . writeCDATA ( "P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test11 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; outputFormat0 . setXHTML ( true ) ; HTMLWriter hTMLWriter0 = new HTMLWriter ( outputFormat0 ) ; hTMLWriter0 . writeCDATA ( "SpaceRequiredInPI" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test12 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "\n" ) ; HTMLWriter hTMLWriter0 = new HTMLWriter ( outputFormat0 ) ; hTMLWriter0 . writeString ( "\n" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test13 ( ) throws Throwable { HTMLWriter hTMLWriter0 = new HTMLWriter ( ) ; hTMLWriter0 . writeClose ( "P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test14 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "\n" ) ; HTMLWriter hTMLWriter0 = new HTMLWriter ( outputFormat0 ) ; hTMLWriter0 . endElement ( "\n" , "\n" , "\n" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test15 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; outputFormat0 . setXHTML ( true ) ; HTMLWriter hTMLWriter0 = new HTMLWriter ( outputFormat0 ) ; UserDataElement userDataElement0 = new UserDataElement ( "SpaceRequiredInPI" ) ; hTMLWriter0 . write ( ( Element ) userDataElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUniquePath ( Element context ) { StringBuffer path = new StringBuffer ( 10 ) ; Element parent = getParent ( ) ; if ( ( parent ! = null ) & & ( parent ! = context ) ) { path . append ( parent . getUniquePath ( context ) ) ; path . append ( ' / ' ) ; } path . append ( getXPathNameStep ( ) ) ; return path . toString ( ) ; }
void test16 ( ) throws Throwable { HTMLWriter hTMLWriter0 = new HTMLWriter ( ) ; hTMLWriter0 . writeEmptyElementClose ( "P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test17 ( ) throws Throwable { HTMLWriter hTMLWriter0 = new HTMLWriter ( ) ; hTMLWriter0 . setOmitElementCloseSet ( ( Set < String > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test18 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; HTMLWriter hTMLWriter0 = new HTMLWriter ( outputFormat0 ) ; Set < String > set0 = hTMLWriter0 . getPreformattedTags ( ) ; hTMLWriter0 . setOmitElementCloseSet ( set0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test19 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "w & A | j_I1slisnV = $" ) ; HTMLWriter hTMLWriter0 = new HTMLWriter ( ( Writer ) null , outputFormat0 ) ; hTMLWriter0 . setPreformattedTags ( ( Set < String > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test20 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; HTMLWriter hTMLWriter0 = new HTMLWriter ( outputFormat0 ) ; outputFormat0 . setNewLineAfterNTags ( 780 ) ; UserDataElement userDataElement0 = new UserDataElement ( "SpaceRequiredInPI" ) ; hTMLWriter0 . write ( ( Element ) userDataElement0 ) ; hTMLWriter0 . write ( ( Node ) userDataElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRootElement ( ) ; / * * * < p > * Returns true if this < code > Element < / code > has mixed content . Mixed * content means that an element contains both textual data and child * elements . * < / p > * * @return true if this element contains mixed content . * / boolean hasMixedContent ( ) ; / * * * < p > * Returns true if this < code > Element < / code > has text only content . * < / p > * * @return true if this element is empty or only contains text content . * / boolean isTextOnly ( ) ; / * * * Appends the attributes of the given element to me . This method behaves * like the { @link java . util . Collection#addAll ( java . util . Collection ) }
void test1 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Document read ( File file ) throws DocumentException { try { / * * We cannot convert the file to an URL because if the filename * contains '#' characters , there will be problems with the URL in * the InputSource ( because a URL like * http : / / myhost . com / index#anchor is treated the same as * http : / / myhost . com / index ) Thanks to Christian Oetterli * / InputSource source = new InputSource ( new FileInputStream ( file ) ) ; if ( this . encoding ! = null ) { source . setEncoding ( this . encoding ) ; } String path = file . getAbsolutePath ( ) ; if ( path ! = null ) { / / Code taken from Ant FileUtils StringBuffer sb = new StringBuffer ( "file : / / " ) ; / / add an extra slash for filesystems with drive - specifiers if ( ! path . startsWith ( File . separator ) ) { sb . append ( " / " ) ; } path = path . replace ( '\\' , ' / ' ) ; sb . append ( path ) ; source . setSystemId ( sb . toString ( ) ) ; } return read ( source ) ; } catch ( FileNotFoundException e ) { throw new DocumentException ( e . getMessage ( ) , e ) ; } }
void test2 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test3 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test5 ( ) throws Throwable { XMLFilterImpl xMLFilterImpl0 = new XMLFilterImpl ( ) ; SAXReader sAXReader0 = new SAXReader ( ( XMLReader ) xMLFilterImpl0 ) ; sAXReader0 . setDispatchHandler ( ( DispatchHandler ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test8 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( false ) ; sAXReader0 . setDefaultHandler ( ( ElementHandler ) null ) ; sAXReader0 . removeHandler ( "Provider for " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test9 ( ) throws Throwable { XMLFilterImpl xMLFilterImpl0 = new XMLFilterImpl ( ) ; SAXReader sAXReader0 = new SAXReader ( ( XMLReader ) xMLFilterImpl0 ) ; sAXReader0 . resetHandlers ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStringInternEnabled ( ) { return stringInternEnabled ; }
void test10 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( ( XMLReader ) null ) ; sAXReader0 . setIgnoreComments ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test11 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( ) ; DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) sAXReader0 . getDocumentFactory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStringInternEnabled ( ) { return stringInternEnabled ; }
void test12 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( ) ; sAXReader0 . getErrorHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test13 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( true ) ; sAXReader0 . getEncoding ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test14 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( true ) ; sAXReader0 . setStringInternEnabled ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isValidating ( ) { return validating ; }
void test15 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( ) ; sAXReader0 . addHandler ( "schema - not - supported" , ( ElementHandler ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStringInternEnabled ( ) { return stringInternEnabled ; }
void test16 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXReader sAXReader0 = new SAXReader ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXReader0 . removeHandler ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test17 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( false ) ; sAXReader0 . getEntityResolver ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test18 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( ) ; sAXReader0 . setStripWhitespaceText ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test19 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( true ) ; sAXReader0 . setDocumentFactory ( ( DocumentFactory ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStringInternEnabled ( ) { return stringInternEnabled ; }
void test20 ( ) throws Throwable { XMLFilterImpl xMLFilterImpl0 = new XMLFilterImpl ( ) ; SAXReader sAXReader0 = new SAXReader ( ( XMLReader ) xMLFilterImpl0 , false ) ; sAXReader0 . setXMLReader ( ( XMLReader ) xMLFilterImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test21 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXReader sAXReader0 = new SAXReader ( ( DocumentFactory ) defaultDocumentFactory0 ) ; SAXParserImpl . JAXPSAXParser sAXParserImpl_JAXPSAXParser0 = ( SAXParserImpl . JAXPSAXParser ) sAXReader0 . getXMLReader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Document read ( File file ) throws DocumentException { try { / * * We cannot convert the file to an URL because if the filename * contains '#' characters , there will be problems with the URL in * the InputSource ( because a URL like * http : / / myhost . com / index#anchor is treated the same as * http : / / myhost . com / index ) Thanks to Christian Oetterli * / InputSource source = new InputSource ( new FileInputStream ( file ) ) ; if ( this . encoding ! = null ) { source . setEncoding ( this . encoding ) ; } String path = file . getAbsolutePath ( ) ; if ( path ! = null ) { / / Code taken from Ant FileUtils StringBuffer sb = new StringBuffer ( "file : / / " ) ; / / add an extra slash for filesystems with drive - specifiers if ( ! path . startsWith ( File . separator ) ) { sb . append ( " / " ) ; } path = path . replace ( '\\' , ' / ' ) ; sb . append ( path ) ; source . setSystemId ( sb . toString ( ) ) ; } return read ( source ) ; } catch ( FileNotFoundException e ) { throw new DocumentException ( e . getMessage ( ) , e ) ; } }
void test25 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( ( String ) null , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test35 ( ) throws Throwable { SAXReader sAXReader0 = new SAXReader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Document read ( File file ) throws DocumentException { try { / * * We cannot convert the file to an URL because if the filename * contains '#' characters , there will be problems with the URL in * the InputSource ( because a URL like * http : / / myhost . com / index#anchor is treated the same as * http : / / myhost . com / index ) Thanks to Christian Oetterli * / InputSource source = new InputSource ( new FileInputStream ( file ) ) ; if ( this . encoding ! = null ) { source . setEncoding ( this . encoding ) ; } String path = file . getAbsolutePath ( ) ; if ( path ! = null ) { / / Code taken from Ant FileUtils StringBuffer sb = new StringBuffer ( "file : / / " ) ; / / add an extra slash for filesystems with drive - specifiers if ( ! path . startsWith ( File . separator ) ) { sb . append ( " / " ) ; } path = path . replace ( '\\' , ' / ' ) ; sb . append ( path ) ; source . setSystemId ( sb . toString ( ) ) ; } return read ( source ) ; } catch ( FileNotFoundException e ) { throw new DocumentException ( e . getMessage ( ) , e ) ; } }
void test37 ( ) throws Throwable { SAXReader . SAXEntityResolver sAXReader_SAXEntityResolver0 = new SAXReader . SAXEntityResolver ( ( String ) null ) ; InputSource inputSource0 = sAXReader_SAXEntityResolver0 . resolveEntity ( ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPublicId ( ) { return getPublicID ( ) ; }
void test38 ( ) throws Throwable { SAXReader . SAXEntityResolver sAXReader_SAXEntityResolver0 = new SAXReader . SAXEntityResolver ( "" ) ; InputSource inputSource0 = sAXReader_SAXEntityResolver0 . resolveEntity ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncoding ( String text ) { String result = null ; String xml = text . trim ( ) ; if ( xml . startsWith ( " < ? xml" ) ) { int end = xml . indexOf ( " ? > " ) ; String sub = xml . substring ( 0 , end ) ; StringTokenizer tokens = new StringTokenizer ( sub , " = \"\'" ) ; while ( tokens . hasMoreTokens ( ) ) { String token = tokens . nextToken ( ) ; if ( "encoding" . equals ( token ) ) { if ( tokens . hasMoreTokens ( ) ) { result = tokens . nextToken ( ) ; } break ; } } } return result ; }
void test39 ( ) throws Throwable { SAXReader . SAXEntityResolver sAXReader_SAXEntityResolver0 = new SAXReader . SAXEntityResolver ( ( String ) null ) ; InputSource inputSource0 = sAXReader_SAXEntityResolver0 . resolveEntity ( "set ( int , Object ) unsuppGrted" , "set ( int , Object ) unsuppGrted" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemId ( ) { return getSystemID ( ) ; }
void test40 ( ) throws Throwable { SAXReader . SAXEntityResolver sAXReader_SAXEntityResolver0 = new SAXReader . SAXEntityResolver ( "" ) ; InputSource inputSource0 = sAXReader_SAXEntityResolver0 . resolveEntity ( "" , "http : / / xml . org / sax / features / string - interning" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemId ( ) { return getSystemID ( ) ; }
void test41 ( ) throws Throwable { SAXReader . SAXEntityResolver sAXReader_SAXEntityResolver0 = new SAXReader . SAXEntityResolver ( "3BhN" ) ; InputSource inputSource0 = sAXReader_SAXEntityResolver0 . resolveEntity ( "3BhN" , "3BhN" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemId ( ) { return getSystemID ( ) ; }
void test0 ( ) throws Throwable { DefaultDocument defaultDocument0 = new DefaultDocument ( ) ; DocumentInputSource documentInputSource0 = new DocumentInputSource ( ( Document ) defaultDocument0 ) ; StringReader stringReader0 = ( StringReader ) documentInputSource0 . getCharacterStream ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setCharacterStream ( Reader characterStream ) throws UnsupportedOperationException { throw new UnsupportedOperationException ( ) ; }
void test1 ( ) throws Throwable { DocumentInputSource documentInputSource0 = new DocumentInputSource ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemId ( ) { return getSystemID ( ) ; }
void test2 ( ) throws Throwable { DefaultDocument defaultDocument0 = new DefaultDocument ( ) ; DocumentInputSource documentInputSource0 = new DocumentInputSource ( ( Document ) defaultDocument0 ) ; DefaultDocument defaultDocument1 = ( DefaultDocument ) documentInputSource0 . getDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTextTrim ( ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . This method returns the string - value of all the * contained { @link Text }
void test3 ( ) throws Throwable { DefaultDocument defaultDocument0 = new DefaultDocument ( ) ; DocumentInputSource documentInputSource0 = new DocumentInputSource ( ( Document ) defaultDocument0 ) ; documentInputSource0 . setDocument ( ( Document ) defaultDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNodeTypeName ( ) ; / * * * < p > * Removes this node from its parent if there is one . If this node is the * root element of a document then it is removed from the document as well . * < / p > * < p / > * < p > * This method is useful if you want to remove a node from its source * document and add it to another document . For example * < / p > * < code > Node node = . . . ; Element someOtherElement = . . . ; * someOtherElement . add ( node . detach ( ) ) ; < / code > * * @return the node that has been removed from its parent node if any and * its document if any . * / Node detach ( ) ; / * * * < p > * < code > selectNodes < / code > evaluates an XPath expression and returns the * result as a < code > List < / code > of < code > Node < / code > instances or * < code > String < / code > instances depending on the XPath expression . * < / p > * * @param xpathExpression is the XPath expression to be evaluated * @return the list of < code > Node < / code > or < code > String < / code > * instances depending on the XPath expression * / List < ? extends Node > selectNodes ( String xpathExpression ) ; / * * * < p > * < code > selectObject < / code > evaluates an XPath expression and returns the * result as an { @link Object }
void test3 ( ) throws Throwable { STAXEventReader sTAXEventReader0 = new STAXEventReader ( ) ; javax . xml . namespace . QName qName0 = new javax . xml . namespace . QName ( "vXz@" , "vXz@" ) ; QName qName1 = sTAXEventReader0 . createQName ( qName0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test0 ( ) throws Throwable { DispatchHandler dispatchHandler0 = new DispatchHandler ( ) ; dispatchHandler0 . removeHandler ( "dc & G0z | ! y" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test1 ( ) throws Throwable { DispatchHandler dispatchHandler0 = new DispatchHandler ( ) ; dispatchHandler0 . getHandler ( "dc & G0z | ! y" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test2 ( ) throws Throwable { DispatchHandler dispatchHandler0 = new DispatchHandler ( ) ; dispatchHandler0 . getActiveHandlerCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test3 ( ) throws Throwable { DispatchHandler dispatchHandler0 = new DispatchHandler ( ) ; dispatchHandler0 . containsHandler ( "dc & G0z | ! y" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test5 ( ) throws Throwable { DispatchHandler dispatchHandler0 = new DispatchHandler ( ) ; dispatchHandler0 . resetHandlers ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test6 ( ) throws Throwable { DispatchHandler dispatchHandler0 = new DispatchHandler ( ) ; String string0 = dispatchHandler0 . getPath ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test0 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "Adding text to an XML document must not be null" , true , "Adding text to an XML document must not be null" ) ; XMLResult xMLResult0 = new XMLResult ( ( Writer ) null , outputFormat0 ) ; XMLWriter xMLWriter0 = xMLResult0 . getXMLWriter ( ) ; xMLResult0 . setXMLWriter ( xMLWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test1 ( ) throws Throwable { XMLResult xMLResult0 = new XMLResult ( ) ; XMLWriter xMLWriter0 = ( XMLWriter ) xMLResult0 . getLexicalHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test2 ( ) throws Throwable { ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; FilterOutputStream filterOutputStream0 = new FilterOutputStream ( ( OutputStream ) byteArrayOutputStream0 ) ; XMLResult xMLResult0 = new XMLResult ( ( OutputStream ) filterOutputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemId ( ) { return getSystemID ( ) ; }
void test3 ( ) throws Throwable { ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; OutputFormat outputFormat0 = new OutputFormat ( "" , true ) ; XMLResult xMLResult0 = new XMLResult ( ( OutputStream ) byteArrayOutputStream0 , outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemId ( ) { return getSystemID ( ) ; }
void test4 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; XMLResult xMLResult0 = new XMLResult ( xMLWriter0 ) ; XMLWriter xMLWriter1 = ( XMLWriter ) xMLResult0 . getHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ElementHandler getHandler ( String handlerPath ) { return ( ElementHandler ) handlers . get ( handlerPath ) ; }
void test5 ( ) throws Throwable { XMLResult xMLResult0 = new XMLResult ( ( Writer ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemId ( ) { return getSystemID ( ) ; }
void test0 ( ) throws Throwable { DOMDocumentResult dOMDocumentResult0 = new DOMDocumentResult ( ) ; DOMDocument dOMDocument0 = ( DOMDocument ) dOMDocumentResult0 . getDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" NodeType getNodeTypeEnum ( ) { return NodeType . NAMESPACE_NODE ; }
void test1 ( ) throws Throwable { DOMDocumentResult dOMDocumentResult0 = new DOMDocumentResult ( ) ; DefaultHandler defaultHandler0 = new DefaultHandler ( ) ; dOMDocumentResult0 . setHandler ( ( ContentHandler ) defaultHandler0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemId ( ) { return getSystemID ( ) ; }
void test2 ( ) throws Throwable { DOMDocumentResult dOMDocumentResult0 = new DOMDocumentResult ( ) ; DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; dOMDocumentResult0 . setHandler ( ( ContentHandler ) dOMSAXContentHandler0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemId ( ) { return getSystemID ( ) ; }
void test3 ( ) throws Throwable { DOMDocumentResult dOMDocumentResult0 = new DOMDocumentResult ( ) ; dOMDocumentResult0 . setLexicalHandler ( ( LexicalHandler ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemId ( ) { return getSystemID ( ) ; }
void test4 ( ) throws Throwable { DOMDocumentResult dOMDocumentResult0 = new DOMDocumentResult ( ) ; DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; dOMDocumentResult0 . setLexicalHandler ( ( LexicalHandler ) dOMSAXContentHandler0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemId ( ) { return getSystemID ( ) ; }
void test0 ( ) throws Throwable { SAXModifyReader sAXModifyReader0 = new SAXModifyReader ( ( XMLReader ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test1 ( ) throws Throwable { SAXModifyReader sAXModifyReader0 = new SAXModifyReader ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test2 ( ) throws Throwable { SAXModifyReader sAXModifyReader0 = new SAXModifyReader ( ) ; sAXModifyReader0 . setPruneElements ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test3 ( ) throws Throwable { SAXModifyReader sAXModifyReader0 = new SAXModifyReader ( ( XMLReader ) null , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test5 ( ) throws Throwable { SAXModifyReader sAXModifyReader0 = new SAXModifyReader ( true ) ; sAXModifyReader0 . setXMLWriter ( ( XMLWriter ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test6 ( ) throws Throwable { SAXModifyReader sAXModifyReader0 = new SAXModifyReader ( true ) ; boolean boolean0 = sAXModifyReader0 . isPruneElements ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test7 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXModifyReader sAXModifyReader0 = new SAXModifyReader ( ( DocumentFactory ) defaultDocumentFactory0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test8 ( ) throws Throwable { SAXModifyReader sAXModifyReader0 = new SAXModifyReader ( false ) ; XMLWriter xMLWriter0 = sAXModifyReader0 . getXMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XMLWriter getXMLWriter ( ) { return this . xmlWriter ; }
void test0 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "rVu0 , / " ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test1 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test2 ( ) throws Throwable { PipedWriter pipedWriter0 = new PipedWriter ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) pipedWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void endCDATA ( ) throws SAXException { }
void test3 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 0 ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 ) ; DOMDocument dOMDocument0 = new DOMDocument ( ) ; DOMDocument dOMDocument1 = ( DOMDocument ) dOMDocument0 . addProcessingInstruction ( "M # ; $9GwpV / wDb" , "M # ; $9GwpV / wDb" ) ; xMLWriter0 . write ( ( Document ) dOMDocument1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test4 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 1 ) ; OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 , outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test5 ( ) throws Throwable { ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( OutputStream ) byteArrayOutputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test6 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test7 ( ) throws Throwable { ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( 4520 ) ; OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( OutputStream ) byteArrayOutputStream0 , outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void writeAttribute ( Attribute attr ) throws XMLStreamException { consumer . add ( createAttribute ( attr ) ) ; }
void test8 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test9 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test10 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "8$G" , true , "8$G" ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) null , outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void writeOpen ( Element element ) throws SAXException { startElement ( element , null ) ; }
void test11 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test12 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "rVu0 , / " ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test13 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "rVu0 , / " ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test14 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test15 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test16 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 0 ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XPath parse ( String text ) { try { return new Dom4jXPath ( text ) ; } catch ( JaxenException e ) { throw new InvalidXPathException ( text , e . getMessage ( ) ) ; } catch ( RuntimeException e ) { } throw new InvalidXPathException ( text ) ; }
void test17 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test18 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test19 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test20 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test21 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test22 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test23 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test24 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test25 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 1 ) ; OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 , outputFormat0 ) ; NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; QName qName0 = namespaceStack0 . getQName ( " | " , " | " , " | " ) ; IndexedElement indexedElement0 = new IndexedElement ( qName0 , ( int ) 'c' ) ; xMLWriter0 . write ( ( Element ) indexedElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test26 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 1 ) ; OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 , outputFormat0 ) ; FlyweightCDATA flyweightCDATA0 = new FlyweightCDATA ( " | " ) ; xMLWriter0 . write ( ( CDATA ) flyweightCDATA0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test27 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 1 ) ; OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 , outputFormat0 ) ; DefaultComment defaultComment0 = new DefaultComment ( " | " ) ; xMLWriter0 . write ( ( Comment ) defaultComment0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test28 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test29 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test30 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test31 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 1 ) ; OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 , outputFormat0 ) ; FlyweightEntity flyweightEntity0 = new FlyweightEntity ( " | " , " | " ) ; xMLWriter0 . write ( ( Entity ) flyweightEntity0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test32 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test34 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test35 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test36 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 ) ; xMLWriter0 . write ( "$0$R { " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test37 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 1 ) ; OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 , outputFormat0 ) ; FlyweightEntity flyweightEntity0 = new FlyweightEntity ( " | " , " | " ) ; xMLWriter0 . write ( ( Object ) flyweightEntity0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test38 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test39 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test40 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test41 ( ) throws Throwable { PipedInputStream pipedInputStream0 = new PipedInputStream ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void write ( Writer writer ) throws IOException ; / * * * Returns the type of this node as constant from { @link NodeType }
void test42 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setProperty ( String name , Object value ) throws SAXException { getXMLReader ( ) . setProperty ( name , value ) ; }
void test43 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 0 ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XPath parse ( String text ) { try { return new Dom4jXPath ( text ) ; } catch ( JaxenException e ) { throw new InvalidXPathException ( text , e . getMessage ( ) ) ; } catch ( RuntimeException e ) { } throw new InvalidXPathException ( text ) ; }
void test44 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getProperty ( String name ) throws SAXNotRecognizedException , SAXNotSupportedException { for ( int i = 0 ; i < LEXICAL_HANDLER_NAMES . length ; i + + ) { if ( LEXICAL_HANDLER_NAMES [ i ] . equals ( name ) ) { return getLexicalHandler ( ) ; } } return properties . get ( name ) ; }
void test45 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 1 ) ; OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 , outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setLexicalHandler ( LexicalHandler lexicalHandler ) { this . lexicalHandler = lexicalHandler ; }
void test46 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test47 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test48 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test49 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test50 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void characters ( char [ ] ch , int start , int length ) throws SAXException { if ( ( ch = = null ) | | ( ch . length = = 0 ) | | ( length < = 0 ) ) { return ; } try { / * * we can't use the writeString method here because it's possible we * don't receive all characters at once and calling writeString * would cause unwanted spaces to be added in between these chunks * of character arrays . * / String string = String . valueOf ( ch , start , length ) ; if ( escapeText ) { string = escapeElementEntities ( string ) ; } if ( format . isTrimText ( ) ) { if ( ( lastOutputNodeType = = NodeType . TEXT_NODE ) & & ! charsAdded ) { writer . write ( ' ' ) ; } else if ( charsAdded & & Character . isWhitespace ( lastChar ) ) { writer . write ( ' ' ) ; } else if ( lastOutputNodeType = = NodeType . ELEMENT_NODE & & format . isPadText ( ) & & lastElementClosed & & Character . isWhitespace ( ch [ 0 ] ) ) { writer . write ( PAD_TEXT ) ; } String delim = "" ; StringTokenizer tokens = new StringTokenizer ( string ) ; while ( tokens . hasMoreTokens ( ) ) { writer . write ( delim ) ; writer . write ( tokens . nextToken ( ) ) ; delim = " " ; } } else { writer . write ( string ) ; } charsAdded = true ; lastChar = ch [ ( start + length ) - 1 ] ; lastOutputNodeType = NodeType . TEXT_NODE ; super . characters ( ch , start , length ) ; } catch ( IOException e ) { handleException ( e ) ; } }
void test51 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test52 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test53 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test54 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test55 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test57 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test58 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "rVu0 , / " ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test59 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test60 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test61 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test62 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "MSG_NMTOKEN_REQUIRED_IN_ENUMERATION" ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test63 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test64 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test65 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test66 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test67 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test68 ( ) throws Throwable { CharArrayWriter charArrayWriter0 = new CharArrayWriter ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) charArrayWriter0 ) ; UserDataElement userDataElement0 = new UserDataElement ( "$0$R { " ) ; QName qName0 = userDataElement0 . getQName ( ) ; DOMElement dOMElement0 = new DOMElement ( qName0 ) ; DOMElement dOMElement1 = ( DOMElement ) dOMElement0 . addCDATA ( "Index value : " ) ; xMLWriter0 . writeElementContent ( ( Element ) dOMElement1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test69 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test70 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test71 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test72 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test73 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test74 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test75 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "xmlns : c , f Xj`ayl } NUa [ " ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test76 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "" ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test77 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; outputFormat0 . setExpandEmptyElements ( true ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test78 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void write ( Writer writer ) throws IOException ; / * * * Returns the type of this node as constant from { @link NodeType }
void test79 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test80 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test81 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test82 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test83 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "MSG_NMTOKEN_REQUIRED_IN_ENUMERATION" ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test84 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test85 ( ) throws Throwable { XMLWriter xMLWriter0 = new XMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test86 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEscapeText ( ) { return escapeText ; }
void test87 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaximumAllowedCharacter ( ) { if ( maximumAllowedCharacter = = 0 ) { maximumAllowedCharacter = defaultMaximumAllowedCharacter ( ) ; } return maximumAllowedCharacter ; }
void test88 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( outputFormat0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolveEntityRefs ( ) { return resolveEntityRefs ; }
void test0 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( ) ; outputFormat0 . getIndent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSuppressDeclaration ( ) { return suppressDeclaration ; }
void test1 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; boolean boolean0 = outputFormat0 . isNewlines ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNewLineAfterDeclaration ( ) { return newLineAfterDeclaration ; }
void test2 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; boolean boolean0 = outputFormat0 . isPadText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLineSeparator ( ) { return lineSeparator ; }
void test3 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( " - xhtml - xh2ml" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int parseOptions ( String [ ] args , int i ) { for ( int size = args . length ; i < size ; i + + ) { if ( args [ i ] . equals ( " - suppressDeclaration" ) ) { setSuppressDeclaration ( true ) ; } else if ( args [ i ] . equals ( " - omitEncoding" ) ) { setOmitEncoding ( true ) ; } else if ( args [ i ] . equals ( " - indent" ) ) { setIndent ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - indentSize" ) ) { setIndentSize ( Integer . parseInt ( args [ + + i ] ) ) ; } else if ( args [ i ] . startsWith ( " - expandEmpty" ) ) { setExpandEmptyElements ( true ) ; } else if ( args [ i ] . equals ( " - encoding" ) ) { setEncoding ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - newlines" ) ) { setNewlines ( true ) ; } else if ( args [ i ] . equals ( " - lineSeparator" ) ) { setLineSeparator ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - trimText" ) ) { setTrimText ( true ) ; } else if ( args [ i ] . equals ( " - padText" ) ) { setPadText ( true ) ; } else if ( args [ i ] . startsWith ( " - xhtml" ) ) { setXHTML ( true ) ; } else { return i ; } } return i ; }
void test4 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( " " , true ) ; boolean boolean0 = outputFormat0 . isXHTML ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNewLineAfterDeclaration ( ) { return newLineAfterDeclaration ; }
void test5 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLineSeparator ( ) { return lineSeparator ; }
void test6 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "5 { * 9 . = KP_% b" ) ; boolean boolean0 = outputFormat0 . isNewLineAfterDeclaration ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isExpandEmptyElements ( ) { return expandEmptyElements ; }
void test7 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( ) ; int int0 = outputFormat0 . getNewLineAfterNTags ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncoding ( String text ) { String result = null ; String xml = text . trim ( ) ; if ( xml . startsWith ( " < ? xml" ) ) { int end = xml . indexOf ( " ? > " ) ; String sub = xml . substring ( 0 , end ) ; StringTokenizer tokens = new StringTokenizer ( sub , " = \"\'" ) ; while ( tokens . hasMoreTokens ( ) ) { String token = tokens . nextToken ( ) ; if ( "encoding" . equals ( token ) ) { if ( tokens . hasMoreTokens ( ) ) { result = tokens . nextToken ( ) ; } break ; } } } return result ; }
void test8 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "IV4 / * " , false ) ; boolean boolean0 = outputFormat0 . isOmitEncoding ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isExpandEmptyElements ( ) { return expandEmptyElements ; }
void test9 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSuppressDeclaration ( ) { return suppressDeclaration ; }
void test10 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int parseOptions ( String [ ] args , int i ) { for ( int size = args . length ; i < size ; i + + ) { if ( args [ i ] . equals ( " - suppressDeclaration" ) ) { setSuppressDeclaration ( true ) ; } else if ( args [ i ] . equals ( " - omitEncoding" ) ) { setOmitEncoding ( true ) ; } else if ( args [ i ] . equals ( " - indent" ) ) { setIndent ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - indentSize" ) ) { setIndentSize ( Integer . parseInt ( args [ + + i ] ) ) ; } else if ( args [ i ] . startsWith ( " - expandEmpty" ) ) { setExpandEmptyElements ( true ) ; } else if ( args [ i ] . equals ( " - encoding" ) ) { setEncoding ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - newlines" ) ) { setNewlines ( true ) ; } else if ( args [ i ] . equals ( " - lineSeparator" ) ) { setLineSeparator ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - trimText" ) ) { setTrimText ( true ) ; } else if ( args [ i ] . equals ( " - padText" ) ) { setPadText ( true ) ; } else if ( args [ i ] . startsWith ( " - xhtml" ) ) { setXHTML ( true ) ; } else { return i ; } } return i ; }
void test11 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( ) ; boolean boolean0 = outputFormat0 . isTrimText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isOmitEncoding ( ) { return omitEncoding ; }
void test13 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( " - expandEmpty - & WE > 5ZwE9UCc`yq" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int parseOptions ( String [ ] args , int i ) { for ( int size = args . length ; i < size ; i + + ) { if ( args [ i ] . equals ( " - suppressDeclaration" ) ) { setSuppressDeclaration ( true ) ; } else if ( args [ i ] . equals ( " - omitEncoding" ) ) { setOmitEncoding ( true ) ; } else if ( args [ i ] . equals ( " - indent" ) ) { setIndent ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - indentSize" ) ) { setIndentSize ( Integer . parseInt ( args [ + + i ] ) ) ; } else if ( args [ i ] . startsWith ( " - expandEmpty" ) ) { setExpandEmptyElements ( true ) ; } else if ( args [ i ] . equals ( " - encoding" ) ) { setEncoding ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - newlines" ) ) { setNewlines ( true ) ; } else if ( args [ i ] . equals ( " - lineSeparator" ) ) { setLineSeparator ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - trimText" ) ) { setTrimText ( true ) ; } else if ( args [ i ] . equals ( " - padText" ) ) { setPadText ( true ) ; } else if ( args [ i ] . startsWith ( " - xhtml" ) ) { setXHTML ( true ) ; } else { return i ; } } return i ; }
void test14 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "5 { * 9 . = KP_% b" ) ; String string0 = outputFormat0 . getLineSeparator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isXHTML ( ) { return doXHTML ; }
void test15 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; char char0 = outputFormat0 . getAttributeQuoteCharacter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isExpandEmptyElements ( ) { return expandEmptyElements ; }
void test16 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getNewLineAfterNTags ( ) { return newLineAfterNTags ; }
void test17 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; boolean boolean0 = outputFormat0 . isSuppressDeclaration ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isOmitEncoding ( ) { return omitEncoding ; }
void test18 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( ) ; boolean boolean0 = outputFormat0 . isExpandEmptyElements ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncoding ( String text ) { String result = null ; String xml = text . trim ( ) ; if ( xml . startsWith ( " < ? xml" ) ) { int end = xml . indexOf ( " ? > " ) ; String sub = xml . substring ( 0 , end ) ; StringTokenizer tokens = new StringTokenizer ( sub , " = \"\'" ) ; while ( tokens . hasMoreTokens ( ) ) { String token = tokens . nextToken ( ) ; if ( "encoding" . equals ( token ) ) { if ( tokens . hasMoreTokens ( ) ) { result = tokens . nextToken ( ) ; } break ; } } } return result ; }
void test19 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( ) ; String string0 = outputFormat0 . getEncoding ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPadText ( ) { return padText ; }
void test21 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; outputFormat0 . setEncoding ( " - omitEncoding" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNewlines ( ) { return newlines ; }
void test23 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; outputFormat0 . setIndent ( " - omitEncoding" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isOmitEncoding ( ) { return omitEncoding ; }
void test24 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( " " , true ) ; outputFormat0 . setIndent ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getNewLineAfterNTags ( ) { return newLineAfterNTags ; }
void test25 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; outputFormat0 . setIndent ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNewLineAfterDeclaration ( ) { return newLineAfterDeclaration ; }
void test26 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( "IV4 / * " , false ) ; outputFormat0 . setAttributeQuoteCharacter ( '\'' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" char getAttributeQuoteCharacter ( ) { return attributeQuoteChar ; }
void test27 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; outputFormat0 . setAttributeQuoteCharacter ( '\"' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNewlines ( ) { return newlines ; }
void test29 ( ) throws Throwable { OutputFormat outputFormat0 = new OutputFormat ( " - trimText" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int parseOptions ( String [ ] args , int i ) { for ( int size = args . length ; i < size ; i + + ) { if ( args [ i ] . equals ( " - suppressDeclaration" ) ) { setSuppressDeclaration ( true ) ; } else if ( args [ i ] . equals ( " - omitEncoding" ) ) { setOmitEncoding ( true ) ; } else if ( args [ i ] . equals ( " - indent" ) ) { setIndent ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - indentSize" ) ) { setIndentSize ( Integer . parseInt ( args [ + + i ] ) ) ; } else if ( args [ i ] . startsWith ( " - expandEmpty" ) ) { setExpandEmptyElements ( true ) ; } else if ( args [ i ] . equals ( " - encoding" ) ) { setEncoding ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - newlines" ) ) { setNewlines ( true ) ; } else if ( args [ i ] . equals ( " - lineSeparator" ) ) { setLineSeparator ( args [ + + i ] ) ; } else if ( args [ i ] . equals ( " - trimText" ) ) { setTrimText ( true ) ; } else if ( args [ i ] . equals ( " - padText" ) ) { setPadText ( true ) ; } else if ( args [ i ] . startsWith ( " - xhtml" ) ) { setXHTML ( true ) ; } else { return i ; } } return i ; }
void test30 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createPrettyPrint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isXHTML ( ) { return doXHTML ; }
void test31 ( ) throws Throwable { OutputFormat outputFormat0 = OutputFormat . createCompactFormat ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNewlines ( ) { return newlines ; }
void test0 ( ) throws Throwable { PruningDispatchHandler pruningDispatchHandler0 = new PruningDispatchHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test8 ( ) throws Throwable { XPP3Reader xPP3Reader0 = new XPP3Reader ( ) ; XmlPullParserFactory xmlPullParserFactory0 = XmlPullParserFactory . newInstance ( ) ; xPP3Reader0 . setXPPFactory ( xmlPullParserFactory0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isValidating ( ) { return validating ; }
void test0 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; DefaultDocument defaultDocument0 = ( DefaultDocument ) defaultDocumentFactory0 . createDocument ( "" ) ; DocumentSource documentSource0 = new DocumentSource ( ( Node ) defaultDocument0 ) ; SAXWriter sAXWriter0 = ( SAXWriter ) documentSource0 . getXMLReader ( ) ; documentSource0 . setXMLReader ( ( XMLReader ) sAXWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeclareNamespaceAttributes ( ) { return declareNamespaceAttributes ; }
void test1 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; QName qName0 = defaultDocumentFactory0 . createQName ( " ) " , " ) " , " ) " ) ; DOMElement dOMElement0 = new DOMElement ( qName0 ) ; DOMDocument dOMDocument0 = new DOMDocument ( dOMElement0 ) ; DocumentSource documentSource0 = new DocumentSource ( ( Document ) dOMDocument0 ) ; SAXWriter sAXWriter0 = ( SAXWriter ) documentSource0 . getXMLReader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeclareNamespaceAttributes ( ) { return declareNamespaceAttributes ; }
void test2 ( ) throws Throwable { DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "^" , "^" , "^" ) ; DOMDocument dOMDocument0 = new DOMDocument ( ( DOMElement ) null , dOMDocumentType0 ) ; DocumentSource documentSource0 = new DocumentSource ( ( Document ) dOMDocument0 ) ; DOMDocument dOMDocument1 = ( DOMDocument ) documentSource0 . getDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNodeTypeName ( ) ; / * * * < p > * Removes this node from its parent if there is one . If this node is the * root element of a document then it is removed from the document as well . * < / p > * < p / > * < p > * This method is useful if you want to remove a node from its source * document and add it to another document . For example * < / p > * < code > Node node = . . . ; Element someOtherElement = . . . ; * someOtherElement . add ( node . detach ( ) ) ; < / code > * * @return the node that has been removed from its parent node if any and * its document if any . * / Node detach ( ) ; / * * * < p > * < code > selectNodes < / code > evaluates an XPath expression and returns the * result as a < code > List < / code > of < code > Node < / code > instances or * < code > String < / code > instances depending on the XPath expression . * < / p > * * @param xpathExpression is the XPath expression to be evaluated * @return the list of < code > Node < / code > or < code > String < / code > * instances depending on the XPath expression * / List < ? extends Node > selectNodes ( String xpathExpression ) ; / * * * < p > * < code > selectObject < / code > evaluates an XPath expression and returns the * result as an { @link Object }
void test4 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; QName qName0 = defaultDocumentFactory0 . createQName ( " ) " , " ) " , " ) " ) ; DOMElement dOMElement0 = new DOMElement ( qName0 ) ; DOMDocument dOMDocument0 = new DOMDocument ( dOMElement0 ) ; DocumentSource documentSource0 = new DocumentSource ( ( Document ) dOMDocument0 ) ; InputSource inputSource0 = SAXSource . sourceToInputSource ( ( Source ) documentSource0 ) ; documentSource0 . setInputSource ( inputSource0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPublicId ( ) { return getPublicID ( ) ; }
void test6 ( ) throws Throwable { Namespace namespace0 = Namespace . XML_NAMESPACE ; DOMElement dOMElement0 = new DOMElement ( "" , namespace0 ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( ) ; DOMDocument dOMDocument0 = new DOMDocument ( "" , dOMElement0 , dOMDocumentType0 ) ; DocumentSource documentSource0 = new DocumentSource ( ( Document ) dOMDocument0 ) ; XMLFilterImpl xMLFilterImpl0 = new XMLFilterImpl ( ) ; XMLFilterImpl xMLFilterImpl1 = new XMLFilterImpl ( ( XMLReader ) xMLFilterImpl0 ) ; documentSource0 . setXMLReader ( ( XMLReader ) xMLFilterImpl1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setXMLReader ( XMLReader reader ) { this . xmlReader = reader ; }
void test0 ( ) throws Throwable { SAXParserImpl . JAXPSAXParser sAXParserImpl_JAXPSAXParser0 = ( SAXParserImpl . JAXPSAXParser ) JAXPHelper . createXMLReader ( false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XMLReader createXMLReader ( ) throws SAXException { return SAXHelper . createXMLReader ( isValidating ( ) ) ; }
void test1 ( ) throws Throwable { JAXPHelper jAXPHelper0 = new JAXPHelper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JAXPHelper ( ) { }
void test2 ( ) throws Throwable { DocumentImpl documentImpl0 = ( DocumentImpl ) JAXPHelper . createDocument ( false , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Document createDocument ( ) ; Document createDocument ( String encoding ) ; Document createDocument ( Element rootElement ) ; DocumentType createDocType ( String name , String publicId , String systemId ) ; Element createElement ( QName qname ) ; Element createElement ( String name ) ; Element createElement ( String qualifiedName , String namespaceURI ) ; Attribute createAttribute ( Element owner , QName qname , String value ) ; Attribute createAttribute ( Element owner , String name , String value ) ; CDATA createCDATA ( String text ) ; Comment createComment ( String text ) ; Text createText ( String text ) ; Entity createEntity ( String name , String text ) ; Namespace createNamespace ( String prefix , String uri ) ; ProcessingInstruction createProcessingInstruction ( String target , String data ) ; ProcessingInstruction createProcessingInstruction ( String target , Map data ) ; QName createQName ( String localName , Namespace namespace ) ; QName createQName ( String localName ) ; QName createQName ( String name , String prefix , String uri ) ; QName createQName ( String qualifiedName , String uri ) ; XPath createXPath ( String xpathExpression ) throws InvalidXPathException ; XPath createXPath ( String xpathExpression , VariableContext variableContext ) ; NodeFilter createXPathFilter ( String xpathFilterExpression , VariableContext variableContext ) ; NodeFilter createXPathFilter ( String xpathFilterExpression ) ; Pattern createPattern ( String xpathPattern ) ; List < QName > getQNames ( ) ; Map < String , String > getXPathNamespaceURIs ( ) ; void setXPathNamespaceURIs ( Map < String , String > namespaceURIs ) ; }
void test0 ( ) throws Throwable { ElementStack elementStack0 = new ElementStack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test1 ( ) throws Throwable { ElementStack elementStack0 = new ElementStack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test2 ( ) throws Throwable { ElementStack elementStack0 = new ElementStack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test3 ( ) throws Throwable { ElementStack elementStack0 = new ElementStack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test4 ( ) throws Throwable { ElementStack elementStack0 = new ElementStack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test5 ( ) throws Throwable { ElementStack elementStack0 = new ElementStack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test6 ( ) throws Throwable { ElementStack elementStack0 = new ElementStack ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void pushElement ( Element element ) { int length = stack . length ; if ( + + lastElementIndex > = length ) { reallocate ( length * 2 ) ; } stack [ lastElementIndex ] = element ; }
void test7 ( ) throws Throwable { ElementStack elementStack0 = new ElementStack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test8 ( ) throws Throwable { ElementStack elementStack0 = new ElementStack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test9 ( ) throws Throwable { ElementStack elementStack0 = new ElementStack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test10 ( ) throws Throwable { ElementStack elementStack0 = new ElementStack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test0 ( ) throws Throwable { SAXParserImpl . JAXPSAXParser sAXParserImpl_JAXPSAXParser0 = ( SAXParserImpl . JAXPSAXParser ) SAXHelper . createXMLReader ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean setParserProperty ( XMLReader reader , String propertyName , Object value ) { try { reader . setProperty ( propertyName , value ) ; return true ; } catch ( SAXNotSupportedException e ) { / / ignore } catch ( SAXNotRecognizedException e ) { / / ignore } return false ; }
void test1 ( ) throws Throwable { SAXParserImpl . JAXPSAXParser sAXParserImpl_JAXPSAXParser0 = ( SAXParserImpl . JAXPSAXParser ) SAXHelper . createXMLReader ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean setParserFeature ( XMLReader reader , String featureName , boolean value ) { try { reader . setFeature ( featureName , value ) ; return true ; } catch ( SAXNotSupportedException e ) { / / ignore } catch ( SAXNotRecognizedException e ) { / / ignore } return false ; }
void test2 ( ) throws Throwable { SAXHelper sAXHelper0 = new SAXHelper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isVerboseErrorReporting ( ) { try { String flag = System . getProperty ( "org . dom4j . verbose" ) ; if ( ( flag ! = null ) & & flag . equalsIgnoreCase ( "true" ) ) { return true ; } } catch ( Exception e ) { / / in case a security exception / / happens in an applet or similar JVM } return true ; }
void test3 ( ) throws Throwable { boolean boolean0 = SAXHelper . isVerboseErrorReporting ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isVerboseErrorReporting ( ) { try { String flag = System . getProperty ( "org . dom4j . verbose" ) ; if ( ( flag ! = null ) & & flag . equalsIgnoreCase ( "true" ) ) { return true ; } } catch ( Exception e ) { / / in case a security exception / / happens in an applet or similar JVM } return true ; }
void test0 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 , ( ElementHandler ) null , ( ElementStack ) null ) ; XMLWriter xMLWriter0 = sAXModifyContentHandler0 . getXMLWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XMLWriter getXMLWriter ( ) { return this . xmlWriter ; }
void test1 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; sAXModifyContentHandler0 . startDTD ( "O : OE18T ! Iti ( 56$N" , "O : OE18T ! Iti ( 56$N" , "O : OE18T ! Iti ( 56$N" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test2 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) namespaceStack0 . getDocumentFactory ( ) ; SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 , ( ElementHandler ) null ) ; sAXModifyContentHandler0 . startDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test3 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; StringWriter stringWriter0 = new StringWriter ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) stringWriter0 ) ; sAXModifyContentHandler0 . setXMLWriter ( xMLWriter0 ) ; sAXModifyContentHandler0 . startDTD ( "@" , "@" , "@" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test4 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; sAXModifyContentHandler0 . endDTD ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test5 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; StringWriter stringWriter0 = new StringWriter ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) stringWriter0 ) ; sAXModifyContentHandler0 . setXMLWriter ( xMLWriter0 ) ; sAXModifyContentHandler0 . endDTD ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test6 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; sAXModifyContentHandler0 . startEntity ( " [ Comment : \"" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test7 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; StringWriter stringWriter0 = new StringWriter ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) stringWriter0 ) ; sAXModifyContentHandler0 . setXMLWriter ( xMLWriter0 ) ; sAXModifyContentHandler0 . startEntity ( "@" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test8 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; sAXModifyContentHandler0 . endEntity ( " [ Comment : \"" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test9 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( OutputStream ) byteArrayOutputStream0 ) ; sAXModifyContentHandler0 . setXMLWriter ( xMLWriter0 ) ; sAXModifyContentHandler0 . endEntity ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test10 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 , ( ElementHandler ) null , ( ElementStack ) null ) ; sAXModifyContentHandler0 . notationDecl ( " / " , " / " , " / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test11 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( OutputStream ) byteArrayOutputStream0 ) ; sAXModifyContentHandler0 . setXMLWriter ( xMLWriter0 ) ; sAXModifyContentHandler0 . notationDecl ( "" , "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test12 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( OutputStream ) byteArrayOutputStream0 ) ; sAXModifyContentHandler0 . setXMLWriter ( xMLWriter0 ) ; sAXModifyContentHandler0 . startDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test13 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; sAXModifyContentHandler0 . setDocumentLocator ( ( Locator ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test14 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( OutputStream ) byteArrayOutputStream0 ) ; sAXModifyContentHandler0 . setXMLWriter ( xMLWriter0 ) ; Locator2Impl locator2Impl0 = new Locator2Impl ( ) ; sAXModifyContentHandler0 . setDocumentLocator ( ( Locator ) locator2Impl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncoding ( String text ) { String result = null ; String xml = text . trim ( ) ; if ( xml . startsWith ( " < ? xml" ) ) { int end = xml . indexOf ( " ? > " ) ; String sub = xml . substring ( 0 , end ) ; StringTokenizer tokens = new StringTokenizer ( sub , " = \"\'" ) ; while ( tokens . hasMoreTokens ( ) ) { String token = tokens . nextToken ( ) ; if ( "encoding" . equals ( token ) ) { if ( tokens . hasMoreTokens ( ) ) { result = tokens . nextToken ( ) ; } break ; } } } return result ; }
void test15 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; sAXModifyContentHandler0 . endDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test16 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( OutputStream ) byteArrayOutputStream0 ) ; sAXModifyContentHandler0 . setXMLWriter ( xMLWriter0 ) ; sAXModifyContentHandler0 . endDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test17 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; sAXModifyContentHandler0 . startPrefixMapping ( " [ Comment : \"" , " [ Comment : \"" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test18 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( OutputStream ) byteArrayOutputStream0 ) ; sAXModifyContentHandler0 . setXMLWriter ( xMLWriter0 ) ; sAXModifyContentHandler0 . startPrefixMapping ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test19 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; sAXModifyContentHandler0 . endPrefixMapping ( "O : OE18T ! Iti ( 56$N" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test20 ( ) throws Throwable { SAXModifyContentHandler sAXModifyContentHandler0 = new SAXModifyContentHandler ( ) ; StringWriter stringWriter0 = new StringWriter ( ) ; OutputFormat outputFormat0 = new OutputFormat ( "9" , false , "9" ) ; XMLWriter xMLWriter0 = new XMLWriter ( ( Writer ) stringWriter0 , outputFormat0 ) ; sAXModifyContentHandler0 . setXMLWriter ( xMLWriter0 ) ; sAXModifyContentHandler0 . endPrefixMapping ( "9" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test0 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . notationDecl ( " ( j" , " ( j" , " ( j" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test1 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; InputSource inputSource0 = new InputSource ( ( InputStream ) null ) ; sAXContentHandler0 . setInputSource ( inputSource0 ) ; sAXContentHandler0 . endDTD ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test2 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . setElementStack ( ( ElementStack ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test4 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . unparsedEntityDecl ( "" , "" , "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test6 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; LocatorImpl locatorImpl0 = new LocatorImpl ( ) ; Locator2Impl locator2Impl0 = new Locator2Impl ( ( Locator ) locatorImpl0 ) ; sAXContentHandler0 . setDocumentLocator ( ( Locator ) locator2Impl0 ) ; DefaultDocument defaultDocument0 = ( DefaultDocument ) sAXContentHandler0 . getDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test7 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test8 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; boolean boolean0 = sAXContentHandler0 . isIncludeInternalDTDDeclarations ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test9 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; boolean boolean0 = sAXContentHandler0 . isMergeAdjacentText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test10 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . getEntityResolver ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test11 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; boolean boolean0 = sAXContentHandler0 . isIncludeExternalDTDDeclarations ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test12 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . warning ( ( SAXParseException ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test13 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . getInputSource ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test14 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; boolean boolean0 = sAXContentHandler0 . isIgnoreComments ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test15 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test16 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) null ) ; sAXContentHandler0 . endDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test17 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . setEntityResolver ( ( EntityResolver ) sAXContentHandler0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test18 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; boolean boolean0 = sAXContentHandler0 . isStripWhitespaceText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test20 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . endPrefixMapping ( "2Z" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test21 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . startPrefixMapping ( "" , "" ) ; BaseElement baseElement0 = new BaseElement ( "" ) ; sAXContentHandler0 . addDeclaredNamespaces ( ( Element ) baseElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test22 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . processingInstruction ( " attribuutes : " , "E { " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test23 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; Attributes2Impl attributes2Impl0 = new Attributes2Impl ( ) ; sAXContentHandler0 . startElement ( " attribuutes : " , " attribuutes : " , " attribuutes : " , ( Attributes ) attributes2Impl0 ) ; sAXContentHandler0 . processingInstruction ( " attribuutes : " , " attribuutes : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test24 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . startDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test25 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test26 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; AttributesImpl attributesImpl0 = new AttributesImpl ( ) ; Attributes2Impl attributes2Impl0 = new Attributes2Impl ( ( Attributes ) attributesImpl0 ) ; sAXContentHandler0 . startElement ( "Class [ " , "Class [ " , "Class [ " , ( Attributes ) attributes2Impl0 ) ; sAXContentHandler0 . startElement ( "Class [ " , "Class [ " , "Class [ " , ( Attributes ) attributesImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test27 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . endElement ( "" , "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test28 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test29 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; char [ ] charArray0 = new char [ 10 ] ; sAXContentHandler0 . characters ( charArray0 , ( int ) 'X' , ( int ) 'X' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test30 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; char [ ] charArray0 = new char [ 7 ] ; sAXContentHandler0 . characters ( charArray0 , ( int ) ' = ' , ( int ) '\u0000' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test33 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void characters ( char [ ] ch , int start , int length ) throws SAXException { if ( ( ch = = null ) | | ( ch . length = = 0 ) | | ( length < = 0 ) ) { return ; } try { / * * we can't use the writeString method here because it's possible we * don't receive all characters at once and calling writeString * would cause unwanted spaces to be added in between these chunks * of character arrays . * / String string = String . valueOf ( ch , start , length ) ; if ( escapeText ) { string = escapeElementEntities ( string ) ; } if ( format . isTrimText ( ) ) { if ( ( lastOutputNodeType = = NodeType . TEXT_NODE ) & & ! charsAdded ) { writer . write ( ' ' ) ; } else if ( charsAdded & & Character . isWhitespace ( lastChar ) ) { writer . write ( ' ' ) ; } else if ( lastOutputNodeType = = NodeType . ELEMENT_NODE & & format . isPadText ( ) & & lastElementClosed & & Character . isWhitespace ( ch [ 0 ] ) ) { writer . write ( PAD_TEXT ) ; } String delim = "" ; StringTokenizer tokens = new StringTokenizer ( string ) ; while ( tokens . hasMoreTokens ( ) ) { writer . write ( delim ) ; writer . write ( tokens . nextToken ( ) ) ; delim = " " ; } } else { writer . write ( string ) ; } charsAdded = true ; lastChar = ch [ ( start + length ) - 1 ] ; lastOutputNodeType = NodeType . TEXT_NODE ; super . characters ( ch , start , length ) ; } catch ( IOException e ) { handleException ( e ) ; } }
void test35 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; char [ ] charArray0 = new char [ 22 ] ; Attributes2Impl attributes2Impl0 = new Attributes2Impl ( ) ; sAXContentHandler0 . startElement ( "2 . 0" , "2 . 0" , "2 . 0" , ( Attributes ) attributes2Impl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void characters ( char [ ] ch , int start , int length ) throws SAXException { if ( ( ch = = null ) | | ( ch . length = = 0 ) | | ( length < = 0 ) ) { return ; } try { / * * we can't use the writeString method here because it's possible we * don't receive all characters at once and calling writeString * would cause unwanted spaces to be added in between these chunks * of character arrays . * / String string = String . valueOf ( ch , start , length ) ; if ( escapeText ) { string = escapeElementEntities ( string ) ; } if ( format . isTrimText ( ) ) { if ( ( lastOutputNodeType = = NodeType . TEXT_NODE ) & & ! charsAdded ) { writer . write ( ' ' ) ; } else if ( charsAdded & & Character . isWhitespace ( lastChar ) ) { writer . write ( ' ' ) ; } else if ( lastOutputNodeType = = NodeType . ELEMENT_NODE & & format . isPadText ( ) & & lastElementClosed & & Character . isWhitespace ( ch [ 0 ] ) ) { writer . write ( PAD_TEXT ) ; } String delim = "" ; StringTokenizer tokens = new StringTokenizer ( string ) ; while ( tokens . hasMoreTokens ( ) ) { writer . write ( delim ) ; writer . write ( tokens . nextToken ( ) ) ; delim = " " ; } } else { writer . write ( string ) ; } charsAdded = true ; lastChar = ch [ ( start + length ) - 1 ] ; lastOutputNodeType = NodeType . TEXT_NODE ; super . characters ( ch , start , length ) ; } catch ( IOException e ) { handleException ( e ) ; } }
void test36 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; char [ ] charArray0 = new char [ 7 ] ; Attributes2Impl attributes2Impl0 = new Attributes2Impl ( ) ; sAXContentHandler0 . startElement ( "b attributes : " , "b attributes : " , "b attributes : " , ( Attributes ) attributes2Impl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void characters ( char [ ] ch , int start , int length ) throws SAXException { if ( ( ch = = null ) | | ( ch . length = = 0 ) | | ( length < = 0 ) ) { return ; } try { / * * we can't use the writeString method here because it's possible we * don't receive all characters at once and calling writeString * would cause unwanted spaces to be added in between these chunks * of character arrays . * / String string = String . valueOf ( ch , start , length ) ; if ( escapeText ) { string = escapeElementEntities ( string ) ; } if ( format . isTrimText ( ) ) { if ( ( lastOutputNodeType = = NodeType . TEXT_NODE ) & & ! charsAdded ) { writer . write ( ' ' ) ; } else if ( charsAdded & & Character . isWhitespace ( lastChar ) ) { writer . write ( ' ' ) ; } else if ( lastOutputNodeType = = NodeType . ELEMENT_NODE & & format . isPadText ( ) & & lastElementClosed & & Character . isWhitespace ( ch [ 0 ] ) ) { writer . write ( PAD_TEXT ) ; } String delim = "" ; StringTokenizer tokens = new StringTokenizer ( string ) ; while ( tokens . hasMoreTokens ( ) ) { writer . write ( delim ) ; writer . write ( tokens . nextToken ( ) ) ; delim = " " ; } } else { writer . write ( string ) ; } charsAdded = true ; lastChar = ch [ ( start + length ) - 1 ] ; lastOutputNodeType = NodeType . TEXT_NODE ; super . characters ( ch , start , length ) ; } catch ( IOException e ) { handleException ( e ) ; } }
void test37 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . endDTD ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test38 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . startDTD ( "" , ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test39 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; QName qName0 = namespaceStack0 . getAttributeQName ( "b attributes : " , "b attributes : " , "b attributes : " ) ; IndexedElement indexedElement0 = new IndexedElement ( qName0 , 2489 ) ; sAXContentHandler0 . addExternalDTDDeclaration ( ( Object ) indexedElement0 ) ; sAXContentHandler0 . startDTD ( "b attributes : " , "b attributes : " , "b attributes : " ) ; sAXContentHandler0 . endDTD ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test40 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . startDTD ( "" , "" , "" ) ; sAXContentHandler0 . startEntity ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test41 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . startEntity ( "amp" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test42 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . endEntity ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test43 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . startEntity ( "" ) ; sAXContentHandler0 . endEntity ( "" ) ; sAXContentHandler0 . elementDecl ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test44 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test45 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; char [ ] charArray0 = new char [ 22 ] ; sAXContentHandler0 . comment ( charArray0 , 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test46 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 , ( ElementHandler ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void comment ( char [ ] ch , int start , int length ) throws SAXException { if ( showCommentsInDTDs | | ! inDTD ) { try { charsAdded = false ; writeComment ( new String ( ch , start , length ) ) ; } catch ( IOException e ) { handleException ( e ) ; } } if ( lexicalHandler ! = null ) { lexicalHandler . comment ( ch , start , length ) ; } }
void test47 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; char [ ] charArray0 = new char [ 10 ] ; sAXContentHandler0 . comment ( charArray0 , 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test48 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; char [ ] charArray0 = new char [ 22 ] ; Attributes2Impl attributes2Impl0 = new Attributes2Impl ( ) ; sAXContentHandler0 . startElement ( "2 . 0" , "2 . 0" , "2 . 0" , ( Attributes ) attributes2Impl0 ) ; sAXContentHandler0 . comment ( charArray0 , 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test49 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . elementDecl ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test50 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . startEntity ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test51 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test52 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . attributeDecl ( "" , "" , "" , "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test53 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . startEntity ( "" ) ; sAXContentHandler0 . endEntity ( "" ) ; sAXContentHandler0 . attributeDecl ( "" , "" , "" , "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test54 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . startEntity ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test55 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . internalEntityDecl ( "2 . 0" , "2 . 0" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test56 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . startDTD ( " attribuutes : " , " attribuutes : " , " attribuutes : " ) ; sAXContentHandler0 . internalEntityDecl ( " attribuutes : " , " attribuutes : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeInternalDTDDeclarations ( ) { return includeInternalDTDDeclarations ; }
void test57 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . startEntity ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test58 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; sAXContentHandler0 . externalEntityDecl ( " > o\ncat" , " > o\ncat" , " > o\ncat" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test59 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; sAXContentHandler0 . startDTD ( "b attributes : " , "b attributes : " , "b attributes : " ) ; sAXContentHandler0 . externalEntityDecl ( "b attributes : " , "b attributes : " , "b attributes : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test60 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test62 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void completeCurrentTextNode ( ) { if ( stripWhitespaceText ) { boolean whitespace = true ; for ( int i = 0 , size = textBuffer . length ( ) ; i < size ; i + + ) { if ( ! Character . isWhitespace ( textBuffer . charAt ( i ) ) ) { whitespace = false ; break ; } } if ( ! whitespace ) { currentElement . addText ( textBuffer . toString ( ) ) ; } } else { currentElement . addText ( textBuffer . toString ( ) ) ; } textBuffer . setLength ( 0 ) ; textInTextBuffer = false ; }
void test63 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; boolean boolean0 = sAXContentHandler0 . isIgnorableEntity ( "apos" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test64 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; boolean boolean0 = sAXContentHandler0 . isIgnorableEntity ( "gt" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test65 ( ) throws Throwable { SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ) ; boolean boolean0 = sAXContentHandler0 . isIgnorableEntity ( "lt" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test66 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) DefaultDocumentFactory . getInstance ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) defaultDocumentFactory0 ) ; boolean boolean0 = sAXContentHandler0 . isIgnorableEntity ( "quot" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test67 ( ) throws Throwable { AttributesImpl attributesImpl0 = new AttributesImpl ( ) ; SAXContentHandler sAXContentHandler0 = new SAXContentHandler ( ( DocumentFactory ) null ) ; sAXContentHandler0 . addAttributes ( ( Element ) null , ( Attributes ) attributesImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeExternalDTDDeclarations ( ) { return includeExternalDTDDeclarations ; }
void test0 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; dOMSAXContentHandler0 . startDTD ( "This Entity is read - only . It cannot be modified" , "This Entity is read - only . It cannot be modified" , "This Entity is read - only . It cannot be modified" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test1 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; dOMSAXContentHandler0 . endDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test2 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; dOMSAXContentHandler0 . endDTD ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test3 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; dOMSAXContentHandler0 . getEntityResolver ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test4 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test5 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; dOMSAXContentHandler0 . setElementStack ( ( ElementStack ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test6 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void completeCurrentTextNode ( ) { if ( stripWhitespaceText ) { boolean whitespace = true ; for ( int i = 0 , size = textBuffer . length ( ) ; i < size ; i + + ) { if ( ! Character . isWhitespace ( textBuffer . charAt ( i ) ) ) { whitespace = false ; break ; } } if ( ! whitespace ) { currentElement . addText ( textBuffer . toString ( ) ) ; } } else { currentElement . addText ( textBuffer . toString ( ) ) ; } textBuffer . setLength ( 0 ) ; textInTextBuffer = false ; }
void test8 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; dOMSAXContentHandler0 . startEntity ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test9 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; Locator2Impl locator2Impl0 = new Locator2Impl ( ) ; dOMSAXContentHandler0 . setDocumentLocator ( ( Locator ) locator2Impl0 ) ; AttributesImpl attributesImpl0 = new AttributesImpl ( ) ; Attributes2Impl attributes2Impl0 = new Attributes2Impl ( ( Attributes ) attributesImpl0 ) ; dOMSAXContentHandler0 . startElement ( "This Entity is read - only . It cannot be modified" , "This Entity is read - only . It cannot be modified" , "This Entity is read - only . It cannot be modified" , ( Attributes ) attributes2Impl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test10 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; dOMSAXContentHandler0 . setEntityResolver ( ( EntityResolver ) dOMSAXContentHandler0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test12 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; boolean boolean0 = dOMSAXContentHandler0 . isMergeAdjacentText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test13 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; boolean boolean0 = dOMSAXContentHandler0 . isStripWhitespaceText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test14 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; dOMSAXContentHandler0 . endPrefixMapping ( "sC" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test15 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; boolean boolean0 = dOMSAXContentHandler0 . isIgnoreComments ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test17 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; dOMSAXContentHandler0 . startPrefixMapping ( ( String ) null , ( String ) null ) ; Attributes2Impl attributes2Impl0 = new Attributes2Impl ( ) ; dOMSAXContentHandler0 . startElement ( ( String ) null , ( String ) null , "" , ( Attributes ) attributes2Impl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test19 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; dOMSAXContentHandler0 . warning ( ( SAXParseException ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test20 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test21 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; dOMSAXContentHandler0 . endEntity ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test22 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; dOMSAXContentHandler0 . getInputSource ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test23 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; dOMSAXContentHandler0 . processingInstruction ( "9m7" , "9m7" ) ; AttributesImpl attributesImpl0 = new AttributesImpl ( ) ; dOMSAXContentHandler0 . startElement ( "9m7" , "9m7" , "9m7" , ( Attributes ) attributesImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test24 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; Attributes2Impl attributes2Impl0 = new Attributes2Impl ( ) ; dOMSAXContentHandler0 . startElement ( "" , ( String ) null , "" , ( Attributes ) attributes2Impl0 ) ; dOMSAXContentHandler0 . processingInstruction ( ( String ) null , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test25 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; dOMSAXContentHandler0 . startDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test26 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test27 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void characters ( char [ ] ch , int start , int length ) throws SAXException { if ( ( ch = = null ) | | ( ch . length = = 0 ) | | ( length < = 0 ) ) { return ; } try { / * * we can't use the writeString method here because it's possible we * don't receive all characters at once and calling writeString * would cause unwanted spaces to be added in between these chunks * of character arrays . * / String string = String . valueOf ( ch , start , length ) ; if ( escapeText ) { string = escapeElementEntities ( string ) ; } if ( format . isTrimText ( ) ) { if ( ( lastOutputNodeType = = NodeType . TEXT_NODE ) & & ! charsAdded ) { writer . write ( ' ' ) ; } else if ( charsAdded & & Character . isWhitespace ( lastChar ) ) { writer . write ( ' ' ) ; } else if ( lastOutputNodeType = = NodeType . ELEMENT_NODE & & format . isPadText ( ) & & lastElementClosed & & Character . isWhitespace ( ch [ 0 ] ) ) { writer . write ( PAD_TEXT ) ; } String delim = "" ; StringTokenizer tokens = new StringTokenizer ( string ) ; while ( tokens . hasMoreTokens ( ) ) { writer . write ( delim ) ; writer . write ( tokens . nextToken ( ) ) ; delim = " " ; } } else { writer . write ( string ) ; } charsAdded = true ; lastChar = ch [ ( start + length ) - 1 ] ; lastOutputNodeType = NodeType . TEXT_NODE ; super . characters ( ch , start , length ) ; } catch ( IOException e ) { handleException ( e ) ; } }
void test28 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; AttributesImpl attributesImpl0 = new AttributesImpl ( ) ; dOMSAXContentHandler0 . startElement ( "9m7" , "9m7" , "9m7" , ( Attributes ) attributesImpl0 ) ; dOMSAXContentHandler0 . startElement ( "9m7" , "9m7" , "9m7" , ( Attributes ) attributesImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test29 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; dOMSAXContentHandler0 . endElement ( "GS$ ) \"1" , "GS$ ) \"1" , "GS$ ) \"1" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test30 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test31 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; char [ ] charArray0 = new char [ 10 ] ; dOMSAXContentHandler0 . characters ( charArray0 , ( int ) '\u0000' , ( int ) '9' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test32 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; char [ ] charArray0 = new char [ 4 ] ; dOMSAXContentHandler0 . characters ( charArray0 , ( int ) 'X' , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test34 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; dOMSAXContentHandler0 . startCDATA ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void characters ( char [ ] ch , int start , int length ) throws SAXException { if ( ( ch = = null ) | | ( ch . length = = 0 ) | | ( length < = 0 ) ) { return ; } try { / * * we can't use the writeString method here because it's possible we * don't receive all characters at once and calling writeString * would cause unwanted spaces to be added in between these chunks * of character arrays . * / String string = String . valueOf ( ch , start , length ) ; if ( escapeText ) { string = escapeElementEntities ( string ) ; } if ( format . isTrimText ( ) ) { if ( ( lastOutputNodeType = = NodeType . TEXT_NODE ) & & ! charsAdded ) { writer . write ( ' ' ) ; } else if ( charsAdded & & Character . isWhitespace ( lastChar ) ) { writer . write ( ' ' ) ; } else if ( lastOutputNodeType = = NodeType . ELEMENT_NODE & & format . isPadText ( ) & & lastElementClosed & & Character . isWhitespace ( ch [ 0 ] ) ) { writer . write ( PAD_TEXT ) ; } String delim = "" ; StringTokenizer tokens = new StringTokenizer ( string ) ; while ( tokens . hasMoreTokens ( ) ) { writer . write ( delim ) ; writer . write ( tokens . nextToken ( ) ) ; delim = " " ; } } else { writer . write ( string ) ; } charsAdded = true ; lastChar = ch [ ( start + length ) - 1 ] ; lastOutputNodeType = NodeType . TEXT_NODE ; super . characters ( ch , start , length ) ; } catch ( IOException e ) { handleException ( e ) ; } }
void test35 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test36 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; char [ ] charArray0 = new char [ 9 ] ; dOMSAXContentHandler0 . comment ( charArray0 , ( int ) '\u0000' , ( int ) '\u0000' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMergeAdjacentText ( ) { return mergeAdjacentText ; }
void test37 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( dOMDocumentFactory0 ) ; Attributes2Impl attributes2Impl0 = new Attributes2Impl ( ) ; dOMSAXContentHandler0 . startElement ( "" , ( String ) null , "" , ( Attributes ) attributes2Impl0 ) ; char [ ] charArray0 = new char [ 7 ] ; dOMSAXContentHandler0 . comment ( charArray0 , 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test39 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; Attributes2Impl attributes2Impl0 = new Attributes2Impl ( ) ; InputSource inputSource0 = new InputSource ( "E_5Ul f + $l" ) ; dOMSAXContentHandler0 . setInputSource ( inputSource0 ) ; dOMSAXContentHandler0 . startElement ( "xmlns : E_5Ul f + $l" , "xmlns : E_5Ul f + $l" , "E_5Ul f + $l" , ( Attributes ) attributes2Impl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test40 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; AttributesImpl attributesImpl0 = new AttributesImpl ( ) ; attributesImpl0 . addAttribute ( "9m7" , "9m7" , "9m7" , "9m7" , "9m7" ) ; dOMSAXContentHandler0 . startElement ( "9m7" , "9m7" , "9m7" , ( Attributes ) attributesImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStripWhitespaceText ( ) { return stripWhitespaceText ; }
void test41 ( ) throws Throwable { DOMSAXContentHandler dOMSAXContentHandler0 = new DOMSAXContentHandler ( ) ; DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMNamespace dOMNamespace0 = ( DOMNamespace ) dOMDocumentFactory0 . createNamespace ( "E_5Ul f + $l" , "E_5Ul f + $l" ) ; String string0 = dOMSAXContentHandler0 . attributeNameForNamespace ( ( Namespace ) dOMNamespace0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIgnoreComments ( ) { return ignoreComments ; }
void test1 ( ) throws Throwable { SAXModifyElementHandler sAXModifyElementHandler0 = new SAXModifyElementHandler ( ( ElementModifier ) null ) ; Element element0 = sAXModifyElementHandler0 . getModifiedElement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Element getModifiedElement ( ) { return modifiedElement ; }
void test2 ( ) throws Throwable { JAXBModifier jAXBModifier0 = new JAXBModifier ( " & QXjlW ; " ) ; jAXBModifier0 . setPruneElements ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test10 ( ) throws Throwable { JAXBModifier jAXBModifier0 = new JAXBModifier ( " ) ' / P" ) ; jAXBModifier0 . removeObjectModifier ( " ) ' / P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test12 ( ) throws Throwable { JAXBModifier jAXBModifier0 = new JAXBModifier ( " ) ' / P" ) ; CharArrayWriter charArrayWriter0 = new CharArrayWriter ( 1424 ) ; jAXBModifier0 . setOutput ( ( Writer ) charArrayWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test14 ( ) throws Throwable { JAXBModifier jAXBModifier0 = new JAXBModifier ( " ) ' / P" ) ; jAXBModifier0 . resetObjectModifiers ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test1 ( ) throws Throwable { JAXBReader jAXBReader0 = new JAXBReader ( "Q" ) ; jAXBReader0 . addHandler ( "Q" , ( ElementHandler ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test3 ( ) throws Throwable { JAXBReader jAXBReader0 = new JAXBReader ( "MSG_SPACE_REQUIbED_BEFORE_ENTITY_NAME_IN_ENTITYDE L" ) ; jAXBReader0 . removeHandler ( "MSG_SPACE_REQUIbED_BEFORE_ENTITY_NAME_IN_ENTITYDE L" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test11 ( ) throws Throwable { JAXBReader jAXBReader0 = new JAXBReader ( "8y . KDfZ" , ( ClassLoader ) null ) ; jAXBReader0 . addObjectHandler ( "8y . KDfZ" , ( JAXBObjectHandler ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test12 ( ) throws Throwable { JAXBReader jAXBReader0 = new JAXBReader ( "MSG_SPACE_REQUIbED_BEFORE_ENTITY_NAME_IN_ENTITYDE L" ) ; jAXBReader0 . removeObjectHandler ( "MSG_SPACE_REQUIbED_BEFORE_ENTITY_NAME_IN_ENTITYDE L" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test13 ( ) throws Throwable { JAXBReader jAXBReader0 = new JAXBReader ( "" ) ; boolean boolean0 = jAXBReader0 . isPruneElements ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test14 ( ) throws Throwable { JAXBReader jAXBReader0 = new JAXBReader ( "E" ) ; jAXBReader0 . setPruneElements ( true ) ; jAXBReader0 . resetHandlers ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test15 ( ) throws Throwable { JAXBReader jAXBReader0 = new JAXBReader ( "8y . KDfZ" , ( ClassLoader ) null ) ; jAXBReader0 . setPruneElements ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneElements ( ) { return pruneElements ; }
void test0 ( ) throws Throwable { ArrayList < Node > arrayList0 = new ArrayList < Node > ( ) ; ContentListFacade < Node > contentListFacade0 = new ContentListFacade < Node > ( ( AbstractBranch ) null , ( List < Node > ) arrayList0 ) ; int int0 = contentListFacade0 . indexOf ( ( Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int indexOf ( Node node ) ; / * * * Returns the number of < code > Node < / code > instances that this branch * contains . * * @return the number of nodes this branch contains * / int nodeCount ( ) ; / * * * Returns the element of the given ID attribute value . If this tree is * capable of understanding which attribute value should be used for the ID * then it should be used , otherwise this method should return null . * * @param elementID DOCUMENT ME ! * @return DOCUMENT ME ! * / Element elementByID ( String elementID ) ; / * * * < p > * Returns the content nodes of this branch as a backed { @link List }
void test3 ( ) throws Throwable { Vector < Node > vector0 = new Vector < Node > ( ) ; ContentListFacade < Node > contentListFacade0 = new ContentListFacade < Node > ( ( AbstractBranch ) null , ( List < Node > ) vector0 ) ; boolean boolean0 = contentListFacade0 . containsAll ( ( Collection < ? > ) vector0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean containsAll ( Collection < ? > c ) { return branchContent . containsAll ( c ) ; }
void test4 ( ) throws Throwable { ArrayList < Node > arrayList0 = new ArrayList < Node > ( ) ; ContentListFacade < Node > contentListFacade0 = new ContentListFacade < Node > ( ( AbstractBranch ) null , ( List < Node > ) arrayList0 ) ; boolean boolean0 = contentListFacade0 . addAll ( ( Collection < ? extends Node > ) contentListFacade0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addAll ( RuleSet that ) { rules . addAll ( that . rules ) ; ruleArray = null ; }
void test5 ( ) throws Throwable { ArrayList < Node > arrayList0 = new ArrayList < Node > ( ) ; ContentListFacade < Node > contentListFacade0 = new ContentListFacade < Node > ( ( AbstractBranch ) null , ( List < Node > ) arrayList0 ) ; boolean boolean0 = contentListFacade0 . contains ( ( Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean contains ( T node ) { return branchContent . contains ( node ) ; }
void test6 ( ) throws Throwable { ArrayList < Node > arrayList0 = new ArrayList < Node > ( ) ; ContentListFacade < Node > contentListFacade0 = new ContentListFacade < Node > ( ( AbstractBranch ) null , ( List < Node > ) arrayList0 ) ; boolean boolean0 = contentListFacade0 . isEmpty ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test9 ( ) throws Throwable { ArrayList < Node > arrayList0 = new ArrayList < Node > ( ) ; ContentListFacade < Node > contentListFacade0 = new ContentListFacade < Node > ( ( AbstractBranch ) null , ( List < Node > ) arrayList0 ) ; int int0 = contentListFacade0 . lastIndexOf ( ( Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int lastIndexOf ( T node ) { return branchContent . lastIndexOf ( node ) ; }
void test11 ( ) throws Throwable { ArrayList < Node > arrayList0 = new ArrayList < Node > ( ) ; ContentListFacade < Node > contentListFacade0 = new ContentListFacade < Node > ( ( AbstractBranch ) null , ( List < Node > ) arrayList0 ) ; Node [ ] nodeArray0 = new Node [ 5 ] ; Node [ ] nodeArray1 = contentListFacade0 . toArray ( nodeArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Node [ ] toArray ( ) { return ( Node [ ] ) branchContent . toArray ( ) ; }
void test12 ( ) throws Throwable { ArrayList < Node > arrayList0 = new ArrayList < Node > ( ) ; arrayList0 . add ( ( Node ) null ) ; ContentListFacade < Node > contentListFacade0 = new ContentListFacade < Node > ( ( AbstractBranch ) null , ( List < Node > ) arrayList0 ) ; List < Node > list0 = contentListFacade0 . subList ( 0 , 0 ) ; boolean boolean0 = contentListFacade0 . retainAll ( ( Collection < ? > ) list0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test13 ( ) throws Throwable { ArrayList < Node > arrayList0 = new ArrayList < Node > ( ) ; ContentListFacade < Node > contentListFacade0 = new ContentListFacade < Node > ( ( AbstractBranch ) null , ( List < Node > ) arrayList0 ) ; boolean boolean0 = contentListFacade0 . addAll ( 8118 , ( Collection < ? extends Node > ) arrayList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addAll ( RuleSet that ) { rules . addAll ( that . rules ) ; ruleArray = null ; }
void test14 ( ) throws Throwable { ArrayList < Node > arrayList0 = new ArrayList < Node > ( ) ; ContentListFacade < Node > contentListFacade0 = new ContentListFacade < Node > ( ( AbstractBranch ) null , ( List < Node > ) arrayList0 ) ; contentListFacade0 . clear ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test16 ( ) throws Throwable { ArrayList < Node > arrayList0 = new ArrayList < Node > ( ) ; ContentListFacade < Node > contentListFacade0 = new ContentListFacade < Node > ( ( AbstractBranch ) null , ( List < Node > ) arrayList0 ) ; arrayList0 . add ( ( Node ) null ) ; boolean boolean0 = contentListFacade0 . removeAll ( ( Collection < ? > ) arrayList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test6 ( ) throws Throwable { LazyList < Node > lazyList0 = new LazyList < Node > ( ) ; BackedList < Node > backedList0 = new BackedList < Node > ( ( AbstractBranch ) null , ( List < Node > ) lazyList0 , ( List < Node > ) lazyList0 ) ; backedList0 . clear ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test0 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float loadFactor ( ) { return loadFactor ; }
void test1 ( ) throws Throwable { HashMap < Object , Map . Entry < Integer , ConcurrentReaderHashMap > > hashMap0 = new HashMap < Object , Map . Entry < Integer , ConcurrentReaderHashMap > > ( ) ; ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ( Map ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test2 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float loadFactor ( ) { return loadFactor ; }
void test3 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( 1915 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test4 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" float loadFactor ( ) { return loadFactor ; }
void test5 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test6 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( 134 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test7 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean containsKey ( Object key ) { return get ( key ) ! = null ; }
void test8 ( ) throws Throwable { HashMap < Object , Map . Entry < Integer , ConcurrentReaderHashMap > > hashMap0 = new HashMap < Object , Map . Entry < Integer , ConcurrentReaderHashMap > > ( ) ; ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ( Map ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test9 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test10 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ConcurrentReaderHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor < = 0 ) throw new IllegalArgumentException ( "Illegal Load factor : " + loadFactor ) ; this . loadFactor = loadFactor ; int cap = p2capacity ( initialCapacity ) ; table = new Entry [ cap ] ; threshold = ( int ) ( cap * loadFactor ) ; }
void test11 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test12 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test13 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test14 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test15 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( 1915 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test16 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test17 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( 134 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test18 ( ) throws Throwable { HashMap < String , Object > hashMap0 = new HashMap < String , Object > ( ) ; ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ( Map ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test19 ( ) throws Throwable { HashMap < String , Object > hashMap0 = new HashMap < String , Object > ( ) ; ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ( Map ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test20 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object put ( Object key , Object value ) { if ( value = = null ) throw new NullPointerException ( ) ; int hash = hash ( key ) ; Entry [ ] tab = table ; int index = hash & ( tab . length - 1 ) ; Entry first = tab [ index ] ; Entry e ; for ( e = first ; e ! = null ; e = e . next ) if ( e . hash = = hash & & eq ( key , e . key ) ) break ; ( this ) { if ( tab = = table ) { if ( e = = null ) { / / make sure we are adding to correct list if ( first = = tab [ index ] ) { / / Add to front of list Entry newEntry = new Entry ( hash , key , value , first ) ; tab [ index ] = newEntry ; if ( + + count > = threshold ) rehash ( ) ; else recordModification ( newEntry ) ; return null ; } } else { Object oldValue = e . value ; if ( first = = tab [ index ] & & oldValue ! = null ) { e . value = value ; return oldValue ; } } } / / retry if wrong list or lost race against concurrent remove return sput ( key , value , hash ) ; } }
void test21 ( ) throws Throwable { HashMap < String , Object > hashMap0 = new HashMap < String , Object > ( ) ; hashMap0 . put ( "" , ( Object ) "" ) ; ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ( Map ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean findAndRemoveEntry ( Map . Entry entry ) { Object key = entry . getKey ( ) ; Object v = get ( key ) ; if ( v ! = null & & v . equals ( entry . getValue ( ) ) ) { remove ( key ) ; return true ; } else return false ; }
void test22 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test23 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test25 ( ) throws Throwable { HashMap < String , Object > hashMap0 = new HashMap < String , Object > ( ) ; Object object0 = hashMap0 . put ( "" , ( Object ) "" ) ; ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ( Map ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test26 ( ) throws Throwable { HashMap < String , Object > hashMap0 = new HashMap < String , Object > ( ) ; ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ( Map ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean containsValue ( Object value ) { if ( value = = null ) throw new NullPointerException ( ) ; Entry tab [ ] = getTableForReading ( ) ; for ( int i = 0 ; i < tab . length ; + + i ) { for ( Entry e = tab [ i ] ; e ! = null ; e = e . next ) if ( value . equals ( e . value ) ) return true ; } return false ; }
void test27 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( 134 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean containsValue ( Object value ) { if ( value = = null ) throw new NullPointerException ( ) ; Entry tab [ ] = getTableForReading ( ) ; for ( int i = 0 ; i < tab . length ; + + i ) { for ( Entry e = tab [ i ] ; e ! = null ; e = e . next ) if ( value . equals ( e . value ) ) return true ; } return false ; }
void test28 ( ) throws Throwable { HashMap < String , Object > hashMap0 = new HashMap < String , Object > ( ) ; ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ( Map ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean containsValue ( Object value ) { if ( value = = null ) throw new NullPointerException ( ) ; Entry tab [ ] = getTableForReading ( ) ; for ( int i = 0 ; i < tab . length ; + + i ) { for ( Entry e = tab [ i ] ; e ! = null ; e = e . next ) if ( value . equals ( e . value ) ) return true ; } return false ; }
void test29 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test30 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test31 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test32 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean findAndRemoveEntry ( Map . Entry entry ) { Object key = entry . getKey ( ) ; Object v = get ( key ) ; if ( v ! = null & & v . equals ( entry . getValue ( ) ) ) { remove ( key ) ; return true ; } else return false ; }
void test33 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( 134 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test34 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setValue ( String name , String value ) ; void setValues ( Map < String , String > data ) ; boolean removeValue ( String name ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test35 ( ) throws Throwable { ConcurrentReaderHashMap . Entry concurrentReaderHashMap_Entry0 = new ConcurrentReaderHashMap . Entry ( 1915 , ( Object ) " { } " , ( Object ) null , ( ConcurrentReaderHashMap . Entry ) null ) ; AbstractMap . SimpleEntry < Map . Entry < ConcurrentReaderHashMap , String > , String > abstractMap_SimpleEntry0 = new AbstractMap . SimpleEntry < Map . Entry < ConcurrentReaderHashMap , String > , String > ( ( Map . Entry < ConcurrentReaderHashMap , String > ) null , " { } " ) ; boolean boolean0 = concurrentReaderHashMap_Entry0 . equals ( ( Object ) abstractMap_SimpleEntry0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test36 ( ) throws Throwable { ConcurrentReaderHashMap . Entry concurrentReaderHashMap_Entry0 = new ConcurrentReaderHashMap . Entry ( 1915 , ( Object ) " { } " , ( Object ) null , ( ConcurrentReaderHashMap . Entry ) null ) ; boolean boolean0 = concurrentReaderHashMap_Entry0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test37 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int capacity ( ) { return table . length ; }
void test38 ( ) throws Throwable { ConcurrentReaderHashMap concurrentReaderHashMap0 = new ConcurrentReaderHashMap ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean remove ( Attribute attribute ) ; / * * * Removes the given < code > CDATA < / code > if the node is an immediate child * of this element . If the given node is not an immediate child of this * element then the { @link Node#detach ( ) }
void test0 ( ) throws Throwable { NamespaceCache namespaceCache0 = new NamespaceCache ( ) ; Namespace namespace0 = namespaceCache0 . createNamespace ( " aJO + K$e ? t@l" , " aJO + K$e ? t@l" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getURI ( ) { return uri ; }
void test1 ( ) throws Throwable { NamespaceCache namespaceCache0 = new NamespaceCache ( ) ; Namespace namespace0 = namespaceCache0 . get ( " aJO + K$e ? t@l" , " aJO + K$e ? t@l" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" NodeType getNodeTypeEnum ( ) { return NodeType . NAMESPACE_NODE ; }
void test2 ( ) throws Throwable { NamespaceCache namespaceCache0 = new NamespaceCache ( ) ; Namespace namespace0 = namespaceCache0 . get ( " aJO + K$e ? t@l" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getXPathNameStep ( ) { if ( ( prefix ! = null ) & & ! "" . equals ( prefix ) ) { return "namespace : : " + prefix ; } return "namespace : : * [ name ( ) = '' ] " ; }
void test0 ( ) throws Throwable { SingleIterator < Object > singleIterator0 = new SingleIterator < Object > ( ( Object ) "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasNext ( ) { return first ; }
void test2 ( ) throws Throwable { SingleIterator < Object > singleIterator0 = new SingleIterator < Object > ( ( Object ) "" ) ; boolean boolean0 = singleIterator0 . hasNext ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasNext ( ) { return first ; }
void test1 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; namespaceStack0 . clear ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test2 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; DefaultDocumentFactory defaultDocumentFactory0 = ( DefaultDocumentFactory ) namespaceStack0 . getDocumentFactory ( ) ; namespaceStack0 . setDocumentFactory ( ( DocumentFactory ) defaultDocumentFactory0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test3 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; String string0 = namespaceStack0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test5 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; int int0 = namespaceStack0 . size ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test6 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; Namespace namespace0 = namespaceStack0 . getNamespaceForPrefix ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Namespace getNamespaceForPrefix ( String prefix ) ; / * * * < p > * Returns the < code > Namespace < / code > which is mapped to the given URI or * null if it could not be found . If there is more than one * < code > Namespace < / code > mapped to the URI , which of them will be * returned is undetermined . * < / p > * * @param uri DOCUMENT ME ! * @return the < code > Namespace < / code > associated with the given URI * / Namespace getNamespaceForURI ( String uri ) ; / * * * < p > * Returns the all namespaces which are mapped to the given URI or an empty * list if no such namespaces could be found . * < / p > * * @param uri DOCUMENT ME ! * @return the namespaces associated with the given URI * @since 1 . 5 * / List < Namespace > getNamespacesForURI ( String uri ) ; / * * * < p > * Returns the namespace prefix of this element if one exists otherwise an * empty < code > String < / code > is returned . * < / p > * * @return the prefix of the < code > Namespace < / code > of this element or an * empty < code > String < / code > * / String getNamespacePrefix ( ) ; / * * * < p > * Returns the URI mapped to the namespace of this element if one exists * otherwise an empty < code > String < / code > is returned . * < / p > * * @return the URI for the < code > Namespace < / code > of this element or an * empty < code > String < / code > * / String getNamespaceURI ( ) ; / * * * < p > * Returns the fully qualified name of this element . This will be the same * as the value returned from { @link #getName }
void test7 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; NamespaceStack namespaceStack0 = new NamespaceStack ( ( DocumentFactory ) defaultDocumentFactory0 ) ; QName qName0 = namespaceStack0 . getQName ( "Qts ; jq : pu" , "" , "Qts ; jq : pu" ) ; IndexedElement indexedElement0 = new IndexedElement ( qName0 ) ; Namespace namespace0 = indexedElement0 . getNamespace ( ) ; namespaceStack0 . push ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean contains ( T node ) { return branchContent . contains ( node ) ; }
void test8 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; String string0 = namespaceStack0 . getURI ( " < Ih + fqv < a" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getURI ( ) { return uri ; }
void test9 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; namespaceStack0 . push ( "" , "" ) ; namespaceStack0 . getURI ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test10 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; NamespaceStack namespaceStack0 = new NamespaceStack ( ( DocumentFactory ) defaultDocumentFactory0 ) ; Namespace namespace0 = Namespace . get ( "" ) ; boolean boolean0 = namespaceStack0 . contains ( namespace0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean contains ( T node ) { return branchContent . contains ( node ) ; }
void test11 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; Namespace namespace0 = namespaceStack0 . addNamespace ( "Z3 pVi - A%Ahr - Q" , "Z3 pVi - A%Ahr - Q" ) ; namespaceStack0 . addNamespace ( "Z3 pVi - A%Ahr - Q" , " ? I' ) 1 ! ( 2W" ) ; boolean boolean0 = namespaceStack0 . contains ( namespace0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test12 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; QName qName0 = namespaceStack0 . getQName ( "" , ( String ) null , " < Ih + fqv < a" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedName ( ) ; / * * * < p > * Returns any additional namespaces declarations for this element other * than namespace returned via the { @link #getNamespace ( ) }
void test13 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; QName qName0 = namespaceStack0 . getQName ( " < Ih + fqv < a" , "" , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNamespaceURI ( ) ; / * * * < p > * Returns the fully qualified name of this element . This will be the same * as the value returned from { @link #getName }
void test14 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; QName qName0 = namespaceStack0 . getQName ( ( String ) null , " Nested exception : " , " Nested exception : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedName ( ) ; / * * * < p > * Returns any additional namespaces declarations for this element other * than namespace returned via the { @link #getNamespace ( ) }
void test15 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; namespaceStack0 . getAttributeQName ( "" , "" , ( String ) null ) ; QName qName0 = namespaceStack0 . getAttributeQName ( "" , "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNamespaceURI ( ) ; / * * * < p > * Returns the fully qualified name of this element . This will be the same * as the value returned from { @link #getName }
void test16 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; QName qName0 = namespaceStack0 . getAttributeQName ( ( String ) null , ( String ) null , " Nested exception : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedName ( ) ; / * * * < p > * Returns any additional namespaces declarations for this element other * than namespace returned via the { @link #getNamespace ( ) }
void test17 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; QName qName0 = namespaceStack0 . getAttributeQName ( "FomFe > U#" , "FomFe > U#" , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedName ( ) ; / * * * < p > * Returns any additional namespaces declarations for this element other * than namespace returned via the { @link #getNamespace ( ) }
void test18 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; namespaceStack0 . push ( "FomFe > U#" , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test19 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; namespaceStack0 . push ( "FAY@aLq = " , "G ( ht@" ) ; namespaceStack0 . pop ( "G ( ht@" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test20 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; NamespaceStack namespaceStack0 = new NamespaceStack ( ( DocumentFactory ) defaultDocumentFactory0 ) ; Namespace namespace0 = Namespace . get ( "" ) ; namespaceStack0 . push ( "" , "" ) ; boolean boolean0 = namespaceStack0 . contains ( namespace0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test21 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; IndexedElement indexedElement0 = new IndexedElement ( ( String ) null ) ; Namespace namespace0 = indexedElement0 . getNamespaceForPrefix ( "" ) ; QName qName0 = namespaceStack0 . pushQName ( " < Ih + fqv < a" , " < Ih + fqv < a" , namespace0 , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test22 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; Namespace namespace0 = Namespace . NO_NAMESPACE ; namespaceStack0 . push ( namespace0 ) ; namespaceStack0 . findDefaultNamespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test23 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; namespaceStack0 . push ( "FAY@aLq = " , "G ( ht@" ) ; namespaceStack0 . findDefaultNamespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test24 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; NamespaceStack namespaceStack0 = new NamespaceStack ( ( DocumentFactory ) defaultDocumentFactory0 ) ; namespaceStack0 . push ( "" , "" ) ; namespaceStack0 . getAttributeQName ( "Qts ; jq : pu" , "" , "Qts ; jq : pu" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test25 ( ) throws Throwable { NamespaceStack namespaceStack0 = new NamespaceStack ( ) ; Namespace namespace0 = Namespace . NO_NAMESPACE ; namespaceStack0 . push ( namespace0 ) ; namespaceStack0 . getAttributeQName ( "" , "" , ( String ) null ) ; namespaceStack0 . addNamespace ( "" , "" ) ; namespaceStack0 . pop ( ( String ) null ) ; Map < Object , Object > map0 = namespaceStack0 . getNamespaceCache ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test2 ( ) throws Throwable { CloneHelper cloneHelper0 = new CloneHelper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { LazyList < AbstractSequentialList < Object > > lazyList0 = new LazyList < AbstractSequentialList < Object > > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test1 ( ) throws Throwable { LazyList < Serializable > lazyList0 = new LazyList < Serializable > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" T set ( int index , T node ) { branch . childAdded ( node ) ; return branchContent . set ( index , node ) ; }
void test2 ( ) throws Throwable { LazyList < Object > lazyList0 = new LazyList < Object > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test3 ( ) throws Throwable { LazyList < Object > lazyList0 = new LazyList < Object > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test4 ( ) throws Throwable { LazyList < Object > lazyList0 = new LazyList < Object > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test5 ( ) throws Throwable { LazyList < Serializable > lazyList0 = new LazyList < Serializable > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test6 ( ) throws Throwable { LazyList < String > lazyList0 = new LazyList < String > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Namespace get ( String prefix , String uri ) { return CACHE . get ( prefix , uri ) ; }
void test7 ( ) throws Throwable { LazyList < Serializable > lazyList0 = new LazyList < Serializable > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean remove ( Attribute attribute ) ; / * * * Removes the given < code > CDATA < / code > if the node is an immediate child * of this element . If the given node is not an immediate child of this * element then the { @link Node#detach ( ) }
void test8 ( ) throws Throwable { LazyList < Object > lazyList0 = new LazyList < Object > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void removeRange ( int fromIndex , int toIndex ) { / / TODO write unit test Range < E > range = this . getRange ( fromIndex , toIndex ) ; range . lower . previous . next = range . upper ; range . upper . previous = range . lower . previous ; }
void test9 ( ) throws Throwable { LazyList < Serializable > lazyList0 = new LazyList < Serializable > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test10 ( ) throws Throwable { LazyList < LazyList < String > > lazyList0 = new LazyList < LazyList < String > > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test11 ( ) throws Throwable { LazyList < String > lazyList0 = new LazyList < String > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test12 ( ) throws Throwable { LazyList < Object > lazyList0 = new LazyList < Object > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addAll ( RuleSet that ) { rules . addAll ( that . rules ) ; ruleArray = null ; }
void test13 ( ) throws Throwable { LazyList < Object > lazyList0 = new LazyList < Object > ( ) ; lazyList0 . add ( ( Object ) lazyList0 ) ; lazyList0 . add ( ( Object ) lazyList0 ) ; lazyList0 . createIndexedList ( ) ; LazyList < AbstractSequentialList < Object > > lazyList1 = new LazyList < AbstractSequentialList < Object > > ( ) ; LazyList < Object > lazyList2 = ( LazyList < Object > ) lazyList0 . set ( 1 , ( Object ) lazyList1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test14 ( ) throws Throwable { LazyList < Serializable > lazyList0 = new LazyList < Serializable > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test15 ( ) throws Throwable { LazyList < Object > lazyList0 = new LazyList < Object > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test16 ( ) throws Throwable { LazyList < String > lazyList0 = new LazyList < String > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" T set ( int index , T node ) { branch . childAdded ( node ) ; return branchContent . set ( index , node ) ; }
void test17 ( ) throws Throwable { LazyList < Object > lazyList0 = new LazyList < Object > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test18 ( ) throws Throwable { LazyList < Serializable > lazyList0 = new LazyList < Serializable > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Entry < E > getEntryHeader ( int index ) { if ( index < 0 | | index > this . size ) { throw new IndexOutOfBoundsException ( MessageFormat . format ( "Index : { 0 } , Size : { 1 } " , index , this . size ) ) ; } if ( index = = 0 ) { return this . header . next ; } Entry < E > e = this . header ; if ( index < ( this . size > > 1 ) ) { for ( int i = 0 ; i < index ; i + + ) { e = e . next ; } } else { for ( int i = this . size ; i > index ; i - - ) { e = e . previous ; } } return e ; }
void test19 ( ) throws Throwable { LazyList < Serializable > lazyList0 = new LazyList < Serializable > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" LazyList ( ) { this . header = new Entry < E > ( null , null , null ) ; this . header . next = this . header ; this . header . previous = this . header ; }
void test20 ( ) throws Throwable { LazyList < Object > lazyList0 = new LazyList < Object > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object object ) { if ( this = = object ) { return true ; } else if ( object instanceof Namespace ) { Namespace that = ( Namespace ) object ; / / we cache hash codes so this should be quick if ( hashCode ( ) = = that . hashCode ( ) ) { return uri . equals ( that . getURI ( ) ) & & prefix . equals ( that . getPrefix ( ) ) ; } } return false ; }
void test21 ( ) throws Throwable { LazyList < LazyList < String > > lazyList0 = new LazyList < LazyList < String > > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test22 ( ) throws Throwable { LazyList < LazyList < AbstractSequentialList < String > > > lazyList0 = new LazyList < LazyList < AbstractSequentialList < String > > > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < E > subList ( int fromIndex , int toIndex ) { / / TODO write unit test Range < E > range = this . getRange ( fromIndex , toIndex ) ; Entry < E > newHeader = new Entry < E > ( null , range . lower , range . upper ) ; Entry < E > lastEntry = newHeader ; while ( range . lower ! = range . upper ) { lastEntry . next = new Entry < E > ( range . lower . element , null , lastEntry ) ; lastEntry = lastEntry . next ; range . lower = range . lower . next ; } newHeader . previous = lastEntry ; return new LazyList < E > ( newHeader ) ; }
void test23 ( ) throws Throwable { LazyList < AbstractSequentialList < Serializable > > lazyList0 = new LazyList < AbstractSequentialList < Serializable > > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void removeRange ( int fromIndex , int toIndex ) { / / TODO write unit test Range < E > range = this . getRange ( fromIndex , toIndex ) ; range . lower . previous . next = range . upper ; range . upper . previous = range . lower . previous ; }
void test24 ( ) throws Throwable { LazyList < Serializable > lazyList0 = new LazyList < Serializable > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test25 ( ) throws Throwable { LazyList < Serializable > lazyList0 = new LazyList < Serializable > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" E removeEntry ( Entry < E > entry ) { if ( entry = = header ) { throw new NoSuchElementException ( ) ; } this . indexedList = null ; entry . previous . next = entry . next ; entry . next . previous = entry . previous ; size - - ; modCount + + ; return entry . element ; }
void test26 ( ) throws Throwable { LazyList < AbstractSequentialList < Object > > lazyList0 = new LazyList < AbstractSequentialList < Object > > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" T next ( ) { T answer = object ; object = null ; first = false ; return answer ; }
void test27 ( ) throws Throwable { LazyList < Object > lazyList0 = new LazyList < Object > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test28 ( ) throws Throwable { LazyList < AbstractSequentialList < Object > > lazyList0 = new LazyList < AbstractSequentialList < Object > > ( ) ; LazyList . LazyListIterator lazyList_LazyListIterator0 = lazyList0 . new LazyListIterator ( 0 ) ; LazyList < Integer > lazyList1 = new LazyList < Integer > ( ) ; lazyList_LazyListIterator0 . add ( lazyList1 ) ; lazyList_LazyListIterator0 . previous ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return branchContent . isEmpty ( ) ; }
void test29 ( ) throws Throwable { LazyList < Serializable > lazyList0 = new LazyList < Serializable > ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" LazyList ( ) { this . header = new Entry < E > ( null , null , null ) ; this . header . next = this . header ; this . header . previous = this . header ; }
void test0 ( ) throws Throwable { ExternalEntityDecl externalEntityDecl0 = new ExternalEntityDecl ( ( String ) null , ( String ) null , ( String ) null ) ; String string0 = externalEntityDecl0 . getPublicID ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPublicID ( ) ; void setPublicID ( String publicID ) ; String getSystemID ( ) ; void setSystemID ( String systemID ) ; / * * * Returns a list of internal DTD declaration objects , defined in the * { @link org . dom4j . dtd }
void test1 ( ) throws Throwable { ExternalEntityDecl externalEntityDecl0 = new ExternalEntityDecl ( "YsQ5nzH2" , "YsQ5nzH2" , "YsQ5nzH2" ) ; String string0 = externalEntityDecl0 . getSystemID ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemID ( ) ; void setSystemID ( String systemID ) ; / * * * Returns a list of internal DTD declaration objects , defined in the * { @link org . dom4j . dtd }
void test2 ( ) throws Throwable { ExternalEntityDecl externalEntityDecl0 = new ExternalEntityDecl ( ) ; String string0 = externalEntityDecl0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test3 ( ) throws Throwable { ExternalEntityDecl externalEntityDecl0 = new ExternalEntityDecl ( ) ; externalEntityDecl0 . setPublicID ( "" ) ; externalEntityDecl0 . setName ( "" ) ; String string0 = externalEntityDecl0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test4 ( ) throws Throwable { ExternalEntityDecl externalEntityDecl0 = new ExternalEntityDecl ( ) ; externalEntityDecl0 . setName ( "%U3 ; j = " ) ; String string0 = externalEntityDecl0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test5 ( ) throws Throwable { ExternalEntityDecl externalEntityDecl0 = new ExternalEntityDecl ( "N1xq0 > } m" , "N1xq0 > } m" , "N1xq0 > } m" ) ; String string0 = externalEntityDecl0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test6 ( ) throws Throwable { ExternalEntityDecl externalEntityDecl0 = new ExternalEntityDecl ( ) ; externalEntityDecl0 . setName ( " < ! ENTITY " ) ; externalEntityDecl0 . setSystemID ( "%U3 ; j = " ) ; String string0 = externalEntityDecl0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test0 ( ) throws Throwable { InternalEntityDecl internalEntityDecl0 = new InternalEntityDecl ( "U ] M45B\"'F > A1 : - " , "U ] M45B\"'F > A1 : - " ) ; String string0 = internalEntityDecl0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test1 ( ) throws Throwable { InternalEntityDecl internalEntityDecl0 = new InternalEntityDecl ( "U ] M45B\"'F > A1 : - " , "U ] M45B\"'F > A1 : - " ) ; internalEntityDecl0 . setValue ( " < ! ENTITY U ] M45B\"'F > A1 : - \"U ] M45B & #34 ;  & #39 ; F & #62 ; A1 : - \" > " ) ; String string0 = internalEntityDecl0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test3 ( ) throws Throwable { InternalEntityDecl internalEntityDecl0 = new InternalEntityDecl ( ) ; String string0 = internalEntityDecl0 . getValue ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getValue ( String name ) ; / * * * DOCUMENT ME ! * * @return the values for this processing instruction as a Map * / Map < String , String > getValues ( ) ; void setValue ( String name , String value ) ; void setValues ( Map < String , String > data ) ; boolean removeValue ( String name ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test4 ( ) throws Throwable { InternalEntityDecl internalEntityDecl0 = new InternalEntityDecl ( "U ] M45B\"'F > A1 : - " , "U ] M45B\"'F > A1 : - " ) ; String string0 = internalEntityDecl0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test0 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( "#FIXED" , "#FIXED" , " > " , "#FIXED" , "#FIXED" ) ; attributeDecl0 . setElementName ( "1R < Ot > `t" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test1 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( ) ; String string0 = attributeDecl0 . getElementName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getElementName ( ) ; / * * * This method is the equivalent to the { @link #setName }
void test2 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( "" , "ko ; lJpr + MN0" , "ko ; lJpr + MN0" , "" , "ko ; lJpr + MN0" ) ; attributeDecl0 . setAttributeName ( " < ! ATTLIST > " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test3 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( "#FIXED" , "#FIXED" , " > " , "#FIXED" , "#FIXED" ) ; String string0 = attributeDecl0 . getValueDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test4 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( "#FIXED" , "#FIXED" , " > " , "#FIXED" , "#FIXED" ) ; String string0 = attributeDecl0 . getAttributeName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test5 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( " } K# / S" , " } K# / S" , " } K# / S" , " } K# / S" , " } K# / S" ) ; attributeDecl0 . setType ( " } K# / S" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getElementName ( ) ; / * * * This method is the equivalent to the { @link #setName }
void test6 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( "" , "ko ; lJpr + MN0" , "ko ; lJpr + MN0" , "" , "ko ; lJpr + MN0" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test7 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( "" , "ko ; lJpr + MN0" , "ko ; lJpr + MN0" , "" , "ko ; lJpr + MN0" ) ; String string0 = attributeDecl0 . getType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getValue ( String name ) ; / * * * DOCUMENT ME ! * * @return the values for this processing instruction as a Map * / Map < String , String > getValues ( ) ; void setValue ( String name , String value ) ; void setValues ( Map < String , String > data ) ; boolean removeValue ( String name ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test8 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( "" , "ko ; lJpr + MN0" , "ko ; lJpr + MN0" , "" , "ko ; lJpr + MN0" ) ; String string0 = attributeDecl0 . getValue ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test9 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( "#FIXED" , "#FIXED" , " > " , "#FIXED" , "#FIXED" ) ; attributeDecl0 . setValueDefault ( " < ! ATTLIST null 1R < Ot > `t 1R < Ot > `t 1R < Ot > `t > " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getType ( ) { return type ; }
void test10 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( ) ; String string0 = attributeDecl0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test11 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( "" , "ko ; lJpr + MN0" , "ko ; lJpr + MN0" , "" , "ko ; lJpr + MN0" ) ; String string0 = attributeDecl0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getValue ( String name ) ; / * * * DOCUMENT ME ! * * @return the values for this processing instruction as a Map * / Map < String , String > getValues ( ) ; void setValue ( String name , String value ) ; void setValues ( Map < String , String > data ) ; boolean removeValue ( String name ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test12 ( ) throws Throwable { AttributeDecl attributeDecl0 = new AttributeDecl ( "#FIXED" , "#FIXED" , "#FIXED" , "#FIXED" , "#FIXED" ) ; String string0 = attributeDecl0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test0 ( ) throws Throwable { ElementDecl elementDecl0 = new ElementDecl ( " & rj5o > " , " & rj5o > " ) ; elementDecl0 . setModel ( "J t + ; cs ( ZN9V + N7Dt" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test1 ( ) throws Throwable { ElementDecl elementDecl0 = new ElementDecl ( "'3 ) A ! [ ) w9# | ] " , "'3 ) A ! [ ) w9# | ] " ) ; String string0 = elementDecl0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test2 ( ) throws Throwable { ElementDecl elementDecl0 = new ElementDecl ( "'3 ) A ! [ ) w9# | ] " , "'3 ) A ! [ ) w9# | ] " ) ; String string0 = elementDecl0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test3 ( ) throws Throwable { ElementDecl elementDecl0 = new ElementDecl ( " & rj5o > " , " & rj5o > " ) ; elementDecl0 . setName ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test4 ( ) throws Throwable { ElementDecl elementDecl0 = new ElementDecl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getModel ( ) { return model ; }
void test5 ( ) throws Throwable { ElementDecl elementDecl0 = new ElementDecl ( "'3 ) A ! [ ) w9# | ] " , "'3 ) A ! [ ) w9# | ] " ) ; String string0 = elementDecl0 . getModel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getModel ( ) { return model ; }
void test0 ( ) throws Throwable { SimpleSingleton simpleSingleton0 = new SimpleSingleton ( ) ; Object object0 = simpleSingleton0 . instance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object instance ( ) ; / * * * reset the instance to a new instance for the implemented strategy * / void reset ( ) ; / * * * set a singleton class name that will be used to create the singleton * based on the strategy implementation of this interface . The default * constructor of the class will be used and must be . * / void setSingletonClassName ( String singletonClassName ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test0 ( ) throws Throwable { IndexedDocumentFactory indexedDocumentFactory0 = new IndexedDocumentFactory ( ) ; IndexedElement indexedElement0 = ( IndexedElement ) indexedDocumentFactory0 . createElement ( ( QName ) null , ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) ; / * * * DOCUMENT ME ! * * @return the trimmed text value where whitespace is trimmed and normalised * into single spaces . This method does not return null . * / String getTextTrim ( ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . This method returns the string - value of all the * contained { @link Text }
void test1 ( ) throws Throwable { IndexedDocumentFactory indexedDocumentFactory0 = ( IndexedDocumentFactory ) IndexedDocumentFactory . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DocumentFactory getInstance ( ) { if ( singleton = = null ) { singleton = createSingleton ( ) ; } return ( DocumentFactory ) singleton . instance ( ) ; }
void test2 ( ) throws Throwable { IndexedDocumentFactory indexedDocumentFactory0 = new IndexedDocumentFactory ( ) ; IndexedElement indexedElement0 = ( IndexedElement ) indexedDocumentFactory0 . createElement ( "ProcessingInstruction" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTextTrim ( ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . This method returns the string - value of all the * contained { @link Text }
void test0 ( ) throws Throwable { NonLazyDocumentFactory nonLazyDocumentFactory0 = new NonLazyDocumentFactory ( ) ; QName qName0 = QName . get ( "" , "" , "" ) ; NonLazyElement nonLazyElement0 = ( NonLazyElement ) nonLazyDocumentFactory0 . createElement ( qName0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedName ( ) ; / * * * < p > * Returns any additional namespaces declarations for this element other * than namespace returned via the { @link #getNamespace ( ) }
void test1 ( ) throws Throwable { NonLazyDocumentFactory nonLazyDocumentFactory0 = ( NonLazyDocumentFactory ) NonLazyDocumentFactory . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DocumentFactory getInstance ( ) { if ( singleton = = null ) { singleton = createSingleton ( ) ; } return ( DocumentFactory ) singleton . instance ( ) ; }
void test0 ( ) throws Throwable { UserDataDocumentFactory userDataDocumentFactory0 = ( UserDataDocumentFactory ) UserDataDocumentFactory . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DocumentFactory getInstance ( ) { if ( singleton = = null ) { singleton = createSingleton ( ) ; } return ( DocumentFactory ) singleton . instance ( ) ; }
void test1 ( ) throws Throwable { UserDataDocumentFactory userDataDocumentFactory0 = new UserDataDocumentFactory ( ) ; UserDataAttribute userDataAttribute0 = ( UserDataAttribute ) userDataDocumentFactory0 . createAttribute ( ( Element ) null , " > Z = qc5 ) & ZO ! " , " > Z = qc5 ) & ZO ! " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedName ( ) ; / * * * < p > * Returns any additional namespaces declarations for this element other * than namespace returned via the { @link #getNamespace ( ) }
void test2 ( ) throws Throwable { UserDataDocumentFactory userDataDocumentFactory0 = new UserDataDocumentFactory ( ) ; UserDataElement userDataElement0 = ( UserDataElement ) userDataDocumentFactory0 . createElement ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasMixedContent ( ) ; / * * * < p > * Returns true if this < code > Element < / code > has text only content . * < / p > * * @return true if this element is empty or only contains text content . * / boolean isTextOnly ( ) ; / * * * Appends the attributes of the given element to me . This method behaves * like the { @link java . util . Collection#addAll ( java . util . Collection ) }
void test2 ( ) throws Throwable { PerThreadSingleton perThreadSingleton0 = new PerThreadSingleton ( ) ; perThreadSingleton0 . instance ( ) ; Object object0 = perThreadSingleton0 . instance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object instance ( ) ; / * * * reset the instance to a new instance for the implemented strategy * / void reset ( ) ; / * * * set a singleton class name that will be used to create the singleton * based on the strategy implementation of this interface . The default * constructor of the class will be used and must be . * / void setSingletonClassName ( String singletonClassName ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test0 ( ) throws Throwable { DoubleNameMap < Object > doubleNameMap0 = new DoubleNameMap < Object > ( ) ; Object object0 = doubleNameMap0 . get ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Namespace get ( String prefix , String uri ) { return CACHE . get ( prefix , uri ) ; }
void test1 ( ) throws Throwable { DoubleNameMap < Object > doubleNameMap0 = new DoubleNameMap < Object > ( ) ; DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; Namespace namespace0 = defaultDocumentFactory0 . createNamespace ( "" , "" ) ; QName qName0 = QName . get ( "" , namespace0 , "" ) ; Object object0 = doubleNameMap0 . get ( qName0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Namespace get ( String prefix , String uri ) { return CACHE . get ( prefix , uri ) ; }
void test2 ( ) throws Throwable { DoubleNameMap < Object > doubleNameMap0 = new DoubleNameMap < Object > ( ) ; QName qName0 = new QName ( "$sGo { lQR2y ] #hA9\"Yp" ) ; doubleNameMap0 . remove ( qName0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedName ( ) ; / * * * < p > * Returns any additional namespaces declarations for this element other * than namespace returned via the { @link #getNamespace ( ) }
void test0 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DefaultDocument defaultDocument0 = new DefaultDocument ( ) ; defaultDocument0 . addComment ( ( String ) null ) ; int int0 = nodeComparator0 . compare ( ( Document ) defaultDocument0 , ( Document ) defaultDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test1 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DefaultDocument defaultDocument0 = new DefaultDocument ( "'_SGGC 2K q@# } V" ) ; DefaultDocument defaultDocument1 = ( DefaultDocument ) defaultDocument0 . addProcessingInstruction ( "'_SGGC 2K q@# } V" , "'_SGGC 2K q@# } V" ) ; DOMElement dOMElement0 = new DOMElement ( "'_SGGC 2K q@# } V" , ( Namespace ) null ) ; DefaultDocument defaultDocument2 = new DefaultDocument ( ( Element ) dOMElement0 ) ; int int0 = nodeComparator0 . compareContent ( ( Branch ) defaultDocument1 , ( Branch ) defaultDocument2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compareContent ( Branch b1 , Branch b2 ) { int c1 = b1 . nodeCount ( ) ; int c2 = b2 . nodeCount ( ) ; int answer = c1 - c2 ; if ( answer = = 0 ) { for ( int i = 0 ; i < c1 ; i + + ) { Node n1 = b1 . node ( i ) ; Node n2 = b2 . node ( i ) ; answer = compare ( n1 , n2 ) ; if ( answer ! = 0 ) { break ; } } } return answer ; }
void test2 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DefaultAttribute defaultAttribute0 = new DefaultAttribute ( "" , "" ) ; int int0 = nodeComparator0 . compare ( ( Node ) defaultAttribute0 , ( Node ) defaultAttribute0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test3 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DOMText dOMText0 = new DOMText ( "e & E ] zh , & - " ) ; int int0 = nodeComparator0 . compare ( ( Node ) dOMText0 , ( Node ) dOMText0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test4 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; Namespace namespace0 = Namespace . get ( "ssL ) y & " , "ssL ) y & " ) ; FlyweightAttribute flyweightAttribute0 = new FlyweightAttribute ( "ssL ) y & " , "ssL ) y & " , namespace0 ) ; QName qName0 = flyweightAttribute0 . getQName ( ) ; IndexedElement indexedElement0 = new IndexedElement ( qName0 , ( - 136 ) ) ; IndexedElement indexedElement1 = ( IndexedElement ) indexedElement0 . addCDATA ( "ssL ) y & " ) ; int int0 = nodeComparator0 . compare ( ( Element ) indexedElement1 , ( Element ) indexedElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test5 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DOMElement dOMElement0 = new DOMElement ( "Zz & vC ] 7W3oIuVy`uIg" ) ; DOMElement dOMElement1 = ( DOMElement ) dOMElement0 . addEntity ( "Zz & vC ] 7W3oIuVy`uIg" , "Zz & vC ] 7W3oIuVy`uIg" ) ; int int0 = nodeComparator0 . compare ( ( Element ) dOMElement1 , ( Element ) dOMElement1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test6 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DefaultDocument defaultDocument0 = new DefaultDocument ( ) ; defaultDocument0 . addProcessingInstruction ( "org . dom4j . dom . DOMProcessingInstruction@ed8c8dd [ ProcessingInstruction : & WtMw ; > IRdJY ; ] " , "org . dom4j . dom . DOMProcessingInstruction@ed8c8dd [ ProcessingInstruction : & WtMw ; > IRdJY ; ] " ) ; int int0 = nodeComparator0 . compare ( ( Node ) defaultDocument0 , ( Node ) defaultDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test7 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "'_SGGC 2K q@# } V" , "'_SGGC 2K q@# } V" , "'_SGGC 2K q@# } V" ) ; int int0 = nodeComparator0 . compare ( ( Node ) dOMDocumentType0 , ( Node ) dOMDocumentType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test8 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; Namespace namespace0 = Namespace . XML_NAMESPACE ; int int0 = nodeComparator0 . compare ( ( Node ) namespace0 , ( Node ) namespace0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test9 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DOMDocument dOMDocument0 = new DOMDocument ( ) ; DOMDocument dOMDocument1 = ( DOMDocument ) dOMDocument0 . clone ( ) ; DOMDocument dOMDocument2 = ( DOMDocument ) dOMDocument1 . addDocType ( "F'N ] 'YC + oWJs'~" , "F'N ] 'YC + oWJs'~" , "F'N ] 'YC + oWJs'~" ) ; int int0 = nodeComparator0 . compare ( ( Document ) dOMDocument2 , ( Document ) dOMDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test10 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; Namespace namespace0 = Namespace . XML_NAMESPACE ; QName qName0 = QName . get ( "" , namespace0 , "" ) ; UserDataElement userDataElement0 = new UserDataElement ( qName0 ) ; QName qName1 = new QName ( "" , namespace0 , "" ) ; DefaultElement defaultElement0 = ( DefaultElement ) userDataElement0 . addElement ( qName1 ) ; int int0 = nodeComparator0 . compare ( ( Element ) defaultElement0 , ( Element ) userDataElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test11 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DOMElement dOMElement0 = new DOMElement ( "" ) ; Namespace namespace0 = dOMElement0 . getNamespaceForPrefix ( "" ) ; NonLazyElement nonLazyElement0 = new NonLazyElement ( "" , namespace0 ) ; QName qName0 = nonLazyElement0 . getQName ( ) ; DOMElement dOMElement1 = ( DOMElement ) dOMElement0 . addAttribute ( qName0 , "" ) ; int int0 = nodeComparator0 . compare ( ( Element ) dOMElement1 , ( Element ) nonLazyElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test12 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; UserDataElement userDataElement0 = new UserDataElement ( "IH" ) ; QName qName0 = new QName ( "IH" , ( Namespace ) null ) ; UserDataElement userDataElement1 = ( UserDataElement ) userDataElement0 . addAttribute ( qName0 , "IH" ) ; DefaultDocument defaultDocument0 = new DefaultDocument ( ( Element ) userDataElement1 ) ; int int0 = nodeComparator0 . compare ( ( Document ) defaultDocument0 , ( Document ) defaultDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test13 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; QName qName0 = defaultDocumentFactory0 . createQName ( "F'N ] 'YC + oWJs'~" , "F'N ] 'YC + oWJs'~" , "F'N ] 'YC + oWJs'~" ) ; DefaultAttribute defaultAttribute0 = new DefaultAttribute ( qName0 ) ; NonLazyElement nonLazyElement0 = new NonLazyElement ( qName0 ) ; DefaultAttribute defaultAttribute1 = ( DefaultAttribute ) defaultDocumentFactory0 . createAttribute ( ( Element ) nonLazyElement0 , "F'N ] 'YC + oWJs'~" , "F'N ] 'YC + oWJs'~" ) ; int int0 = nodeComparator0 . compare ( ( Attribute ) defaultAttribute0 , ( Attribute ) defaultAttribute1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test14 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; Namespace namespace0 = Namespace . XML_NAMESPACE ; QName qName0 = QName . get ( ( String ) null , namespace0 , ( String ) null ) ; BeanElement beanElement0 = new BeanElement ( qName0 ) ; Namespace namespace1 = beanElement0 . getNamespaceForURI ( ( String ) null ) ; int int0 = nodeComparator0 . compare ( namespace1 , namespace0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test15 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "'_SGGC 2K q@# } V" , "'_SGGC 2K q@# } V" , "'_SGGC 2K q@# } V" ) ; int int0 = nodeComparator0 . compare ( ( DocumentType ) null , ( DocumentType ) dOMDocumentType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test16 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "" , "" , "" ) ; DefaultDocumentType defaultDocumentType0 = new DefaultDocumentType ( "" , "org . dom4j . dom . DOMCDATA@251a775e [ CDATA : \"\" ] " ) ; int int0 = nodeComparator0 . compare ( ( DocumentType ) dOMDocumentType0 , ( DocumentType ) defaultDocumentType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test17 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "e & E ] zh , & - " , "e & E ] zh , & - " , "e & E ] zh , & - " ) ; DOMDocumentType dOMDocumentType1 = new DOMDocumentType ( "e & E ] zh , & - " , "e & E ] zh , & - " , "e & E ] zh , & - " ) ; int int0 = nodeComparator0 . compare ( ( DocumentType ) dOMDocumentType1 , ( DocumentType ) dOMDocumentType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test18 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( ( String ) null , ( String ) null ) ; DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; DefaultDocumentType defaultDocumentType0 = ( DefaultDocumentType ) defaultDocumentFactory0 . createDocType ( ( String ) null , ( String ) null , "" ) ; int int0 = nodeComparator0 . compare ( ( DocumentType ) dOMDocumentType0 , ( DocumentType ) defaultDocumentType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test19 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; Namespace namespace0 = Namespace . XML_NAMESPACE ; QName qName0 = QName . get ( "" , namespace0 , "" ) ; UserDataElement userDataElement0 = new UserDataElement ( qName0 ) ; DefaultEntity defaultEntity0 = new DefaultEntity ( ( String ) null , "" ) ; DOMEntityReference dOMEntityReference0 = new DOMEntityReference ( ( Element ) userDataElement0 , "" , ( String ) null ) ; int int0 = nodeComparator0 . compare ( ( Entity ) defaultEntity0 , ( Entity ) dOMEntityReference0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test20 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; FlyweightProcessingInstruction flyweightProcessingInstruction0 = new FlyweightProcessingInstruction ( ) ; DefaultProcessingInstruction defaultProcessingInstruction0 = new DefaultProcessingInstruction ( ( Element ) null , "e & E ] zh , & - " , "e & E ] zh , & - " ) ; int int0 = nodeComparator0 . compare ( ( ProcessingInstruction ) flyweightProcessingInstruction0 , ( ProcessingInstruction ) defaultProcessingInstruction0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compare ( Node n1 , Node n2 ) { NodeType nodeType1 = n1 . getNodeTypeEnum ( ) ; NodeType nodeType2 = n2 . getNodeTypeEnum ( ) ; if ( nodeType1 ! = nodeType2 ) { return nodeType1 . getCode ( ) - nodeType2 . getCode ( ) ; } switch ( nodeType1 ) { case ELEMENT_NODE : return compare ( ( Element ) n1 , ( Element ) n2 ) ; case DOCUMENT_NODE : return compare ( ( Document ) n1 , ( Document ) n2 ) ; case ATTRIBUTE_NODE : return compare ( ( Attribute ) n1 , ( Attribute ) n2 ) ; case TEXT_NODE : return compare ( ( Text ) n1 , ( Text ) n2 ) ; case CDATA_SECTION_NODE : return compare ( ( CDATA ) n1 , ( CDATA ) n2 ) ; case ENTITY_REFERENCE_NODE : return compare ( ( Entity ) n1 , ( Entity ) n2 ) ; case PROCESSING_INSTRUCTION_NODE : return compare ( ( ProcessingInstruction ) n1 , ( ProcessingInstruction ) n2 ) ; case COMMENT_NODE : return compare ( ( Comment ) n1 , ( Comment ) n2 ) ; case DOCUMENT_TYPE_NODE : return compare ( ( DocumentType ) n1 , ( DocumentType ) n2 ) ; case NAMESPACE_NODE : return compare ( ( Namespace ) n1 , ( Namespace ) n2 ) ; default : throw new RuntimeException ( "Invalid node types . node1 : " + n1 + " and node2 : " + n2 ) ; } }
void test21 ( ) throws Throwable { NodeComparator nodeComparator0 = new NodeComparator ( ) ; NonLazyElement nonLazyElement0 = new NonLazyElement ( "" ) ; DefaultElement defaultElement0 = ( DefaultElement ) nonLazyElement0 . addElement ( "" ) ; int int0 = nodeComparator0 . compareContent ( ( Branch ) defaultElement0 , ( Branch ) nonLazyElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compareContent ( Branch b1 , Branch b2 ) { int c1 = b1 . nodeCount ( ) ; int c2 = b2 . nodeCount ( ) ; int answer = c1 - c2 ; if ( answer = = 0 ) { for ( int i = 0 ; i < c1 ; i + + ) { Node n1 = b1 . node ( i ) ; Node n2 = b2 . node ( i ) ; answer = compare ( n1 , n2 ) ; if ( answer ! = 0 ) { break ; } } } return answer ; }
void test0 ( ) throws Throwable { BranchTreeNode branchTreeNode0 = new BranchTreeNode ( ) ; Enumeration < Object > enumeration0 = branchTreeNode0 . children ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Enumeration children ( ) { return new Enumeration ( ) { int index = - 1 ; boolean hasMoreElements ( ) { return ( index + 1 ) < getChildCount ( ) ; } Object nextElement ( ) { return getChildAt ( + + index ) ; } } ; }
void test1 ( ) throws Throwable { IndexedElement indexedElement0 = new IndexedElement ( "" ) ; BranchTreeNode branchTreeNode0 = new BranchTreeNode ( ( Branch ) indexedElement0 ) ; String string0 = branchTreeNode0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test2 ( ) throws Throwable { IndexedElement indexedElement0 = new IndexedElement ( "" ) ; BranchTreeNode branchTreeNode0 = new BranchTreeNode ( ( Branch ) indexedElement0 ) ; branchTreeNode0 . getChildCount ( ) ; int int0 = branchTreeNode0 . getIndex ( ( TreeNode ) branchTreeNode0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getIndex ( TreeNode node ) { return getChildList ( ) . indexOf ( node ) ; }
void test3 ( ) throws Throwable { Namespace namespace0 = Namespace . NO_NAMESPACE ; NonLazyElement nonLazyElement0 = new NonLazyElement ( "" , namespace0 ) ; BranchTreeNode branchTreeNode0 = new BranchTreeNode ( ( Branch ) nonLazyElement0 ) ; boolean boolean0 = branchTreeNode0 . getAllowsChildren ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getAllowsChildren ( ) { return true ; }
void test4 ( ) throws Throwable { Namespace namespace0 = Namespace . NO_NAMESPACE ; NonLazyElement nonLazyElement0 = new NonLazyElement ( "" , namespace0 ) ; DefaultDocument defaultDocument0 = new DefaultDocument ( ( Element ) nonLazyElement0 ) ; BranchTreeNode branchTreeNode0 = new BranchTreeNode ( ( Branch ) defaultDocument0 ) ; int int0 = branchTreeNode0 . getChildCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getChildCount ( ) { return getChildList ( ) . size ( ) ; }
void test5 ( ) throws Throwable { UserDataElement userDataElement0 = new UserDataElement ( "X4~`" ) ; UserDataElement userDataElement1 = ( UserDataElement ) userDataElement0 . addCDATA ( "X4~`" ) ; BranchTreeNode branchTreeNode0 = new BranchTreeNode ( ( Branch ) userDataElement1 ) ; boolean boolean0 = branchTreeNode0 . isLeaf ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLeaf ( ) { return getXmlBranch ( ) . nodeCount ( ) < = 0 ; }
void test6 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "" , ( Namespace ) null ) ; BranchTreeNode branchTreeNode0 = new BranchTreeNode ( ( Branch ) dOMElement0 ) ; boolean boolean0 = branchTreeNode0 . isLeaf ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLeaf ( ) { return getXmlBranch ( ) . nodeCount ( ) < = 0 ; }
void test8 ( ) throws Throwable { IndexedElement indexedElement0 = new IndexedElement ( "" ) ; IndexedElement indexedElement1 = ( IndexedElement ) indexedElement0 . addComment ( "" ) ; BranchTreeNode branchTreeNode0 = new BranchTreeNode ( ( Branch ) indexedElement1 ) ; int int0 = branchTreeNode0 . getChildCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getChildCount ( ) { return getChildList ( ) . size ( ) ; }
void test9 ( ) throws Throwable { UserDataElement userDataElement0 = new UserDataElement ( "X4~`" ) ; UserDataElement userDataElement1 = ( UserDataElement ) userDataElement0 . addCDATA ( "X4~`" ) ; BranchTreeNode branchTreeNode0 = new BranchTreeNode ( ( Branch ) userDataElement1 ) ; List < Object > list0 = branchTreeNode0 . getChildList ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test0 ( ) throws Throwable { LeafTreeNode leafTreeNode0 = new LeafTreeNode ( ) ; Node node0 = leafTreeNode0 . getXmlNode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Node getXmlNode ( ) { return xmlNode ; }
void test1 ( ) throws Throwable { LeafTreeNode leafTreeNode0 = new LeafTreeNode ( ) ; boolean boolean0 = leafTreeNode0 . getAllowsChildren ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getAllowsChildren ( ) { return true ; }
void test2 ( ) throws Throwable { LeafTreeNode leafTreeNode0 = new LeafTreeNode ( ) ; Enumeration < Object > enumeration0 = leafTreeNode0 . children ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Enumeration children ( ) { return new Enumeration ( ) { int index = - 1 ; boolean hasMoreElements ( ) { return ( index + 1 ) < getChildCount ( ) ; } Object nextElement ( ) { return getChildAt ( + + index ) ; } } ; }
void test3 ( ) throws Throwable { FlyweightProcessingInstruction flyweightProcessingInstruction0 = new FlyweightProcessingInstruction ( ) ; LeafTreeNode leafTreeNode0 = new LeafTreeNode ( ( Node ) flyweightProcessingInstruction0 ) ; DefaultMutableTreeNode defaultMutableTreeNode0 = new DefaultMutableTreeNode ( ) ; int int0 = leafTreeNode0 . getIndex ( ( TreeNode ) defaultMutableTreeNode0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getIndex ( TreeNode node ) { return getChildList ( ) . indexOf ( node ) ; }
void test4 ( ) throws Throwable { LeafTreeNode leafTreeNode0 = new LeafTreeNode ( ) ; TreeNode treeNode0 = leafTreeNode0 . getParent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Element getParent ( ) ; / * * * < p > * < code > setParent < / code > sets the parent relationship of this node if the * parent relationship is supported or does nothing if the parent * relationship is not supported . * < / p > * < p / > * < p > * This method should only be called from inside an < code > Element < / code > * implementation method and is not intended for general use . * < / p > * * @param parent is the new parent of this node . * / void setParent ( Element parent ) ; / * * * < p > * < code > getDocument < / code > returns the < code > Document < / code > that this * < code > Node < / code > is part of if this node supports the parent * relationship . * < / p > * < p / > * < p > * This method is an optional feature and may not be supported for all * < code > Node < / code > implementations . * < / p > * * @return the document of this node or null if this feature is not * supported or the node is not associated with a * < code > Document < / code > * / Document getDocument ( ) ; / * * * < p > * < code > setDocument < / code > sets the document of this node if the parent * relationship is supported or does nothing if the parent relationship is * not supported . * < / p > * < p / > * < p > * This method should only be called from inside a < code > Document < / code > * implementation method and is not intended for general use . * < / p > * * @param document is the new document of this node . * / void setDocument ( Document document ) ; / * * * < p > * < code > isReadOnly < / code > returns true if this node is read only and * cannot be modified . Any attempt to modify a read - only < code > Node < / code > * will result in an < code > UnsupportedOperationException < / code > being * thrown . * < / p > * * @return true if this < code > Node < / code > is read only and cannot be * modified otherwise false . * / boolean isReadOnly ( ) ; / * * * < p > * < code > hasContent < / code > returns true if this node is a Branch ( either * an Element or a Document ) and it contains at least one content node such * as a child Element or Text node . * < / p > * * @return true if this < code > Node < / code > is a Branch with a nodeCount ( ) * of one or more . * / boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test5 ( ) throws Throwable { LeafTreeNode leafTreeNode0 = new LeafTreeNode ( ) ; int int0 = leafTreeNode0 . getChildCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getChildCount ( ) { return getChildList ( ) . size ( ) ; }
void test6 ( ) throws Throwable { LeafTreeNode leafTreeNode0 = new LeafTreeNode ( ) ; TreeNode treeNode0 = leafTreeNode0 . getChildAt ( 12559 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TreeNode getChildAt ( int childIndex ) { return ( TreeNode ) getChildList ( ) . get ( childIndex ) ; }
void test7 ( ) throws Throwable { LeafTreeNode leafTreeNode0 = new LeafTreeNode ( ) ; leafTreeNode0 . setParent ( leafTreeNode0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getAllowsChildren ( ) { return true ; }
void test8 ( ) throws Throwable { LeafTreeNode leafTreeNode0 = new LeafTreeNode ( ) ; boolean boolean0 = leafTreeNode0 . isLeaf ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLeaf ( ) { return getXmlBranch ( ) . nodeCount ( ) < = 0 ; }
void test9 ( ) throws Throwable { FlyweightProcessingInstruction flyweightProcessingInstruction0 = new FlyweightProcessingInstruction ( ) ; LeafTreeNode leafTreeNode0 = new LeafTreeNode ( ( Node ) flyweightProcessingInstruction0 ) ; UserDataElement userDataElement0 = new UserDataElement ( "" ) ; LeafTreeNode leafTreeNode1 = new LeafTreeNode ( ( TreeNode ) leafTreeNode0 , ( Node ) userDataElement0 ) ; String string0 = leafTreeNode1 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test10 ( ) throws Throwable { FlyweightProcessingInstruction flyweightProcessingInstruction0 = new FlyweightProcessingInstruction ( ) ; LeafTreeNode leafTreeNode0 = new LeafTreeNode ( ( Node ) flyweightProcessingInstruction0 ) ; String string0 = leafTreeNode0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return super . toString ( ) + " [ Namespace : prefix " + getPrefix ( ) + " mapped to URI \"" + getURI ( ) + "\" ] " ; }
void test3 ( ) throws Throwable { XMLTableDefinition xMLTableDefinition0 = new XMLTableDefinition ( ) ; XMLTableModel xMLTableModel0 = new XMLTableModel ( xMLTableDefinition0 , ( Object ) null ) ; Object object0 = xMLTableModel0 . getSource ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getSource ( ) { return source ; }
void test4 ( ) throws Throwable { XMLTableModel xMLTableModel0 = new XMLTableModel ( ( XMLTableDefinition ) null , ( Object ) null ) ; XMLTableDefinition xMLTableDefinition0 = xMLTableModel0 . getDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XMLTableDefinition getDefinition ( ) { return definition ; }
void test5 ( ) throws Throwable { XMLTableDefinition xMLTableDefinition0 = new XMLTableDefinition ( ) ; DefaultEditorKit . InsertBreakAction defaultEditorKit_InsertBreakAction0 = new DefaultEditorKit . InsertBreakAction ( ) ; JRadioButtonMenuItem jRadioButtonMenuItem0 = new JRadioButtonMenuItem ( ( Action ) defaultEditorKit_InsertBreakAction0 ) ; XMLTableModel xMLTableModel0 = new XMLTableModel ( xMLTableDefinition0 , ( Object ) "reference - uri - schemes - supported" ) ; xMLTableModel0 . setSource ( ( Object ) jRadioButtonMenuItem0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setSource ( Object source ) { this . source = source ; this . rows = null ; }
void test8 ( ) throws Throwable { XMLTableDefinition xMLTableDefinition0 = new XMLTableDefinition ( ) ; xMLTableDefinition0 . addColumnWithXPathName ( "LOWER_TRAILING_CORNER" , "LOWER_TRAILING_CORNER" , 3251 ) ; XMLTableModel xMLTableModel0 = new XMLTableModel ( xMLTableDefinition0 , ( Object ) "LOWER_TRAILING_CORNER" ) ; JTable jTable0 = new JTable ( ( TableModel ) xMLTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) { return definition . getColumnCount ( ) ; }
void test0 ( ) throws Throwable { XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( ) ; xMLTableColumnDefinition0 . handleException ( ( Exception ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test1 ( ) throws Throwable { XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( ) ; int int0 = xMLTableColumnDefinition0 . getType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getType ( ) { return type ; }
void test3 ( ) throws Throwable { DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "TEXT_NODE" , "TEXT_NODE" ) ; DefaultXPath defaultXPath0 = ( DefaultXPath ) dOMDocumentType0 . createXPath ( "TEXT_NODE" ) ; XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( "TEXT_NODE" , ( XPath ) defaultXPath0 , 0 ) ; xMLTableColumnDefinition0 . setColumnNameXPath ( ( XPath ) defaultXPath0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getType ( ) { return type ; }
void test4 ( ) throws Throwable { XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( ) ; XPath xPath0 = xMLTableColumnDefinition0 . getXPath ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getXPath ( ) { return xpath ; }
void test5 ( ) throws Throwable { XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( ( XPath ) null , ( XPath ) null , 2 ) ; Class < Object > class0 = xMLTableColumnDefinition0 . getColumnClass ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Class getColumnClass ( int columnIndex ) { return definition . getColumnClass ( columnIndex ) ; }
void test6 ( ) throws Throwable { XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( ) ; XPath xPath0 = xMLTableColumnDefinition0 . getColumnNameXPath ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XPath getColumnNameXPath ( int columnIndex ) { return getColumn ( columnIndex ) . getColumnNameXPath ( ) ; }
void test7 ( ) throws Throwable { DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "TEXT_NODE" , "TEXT_NODE" ) ; DefaultXPath defaultXPath0 = ( DefaultXPath ) dOMDocumentType0 . createXPath ( "TEXT_NODE" ) ; XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( "TEXT_NODE" , ( XPath ) defaultXPath0 , 0 ) ; xMLTableColumnDefinition0 . setXPath ( ( XPath ) defaultXPath0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getType ( ) { return type ; }
void test8 ( ) throws Throwable { XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( ) ; String string0 = xMLTableColumnDefinition0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test9 ( ) throws Throwable { XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( ) ; xMLTableColumnDefinition0 . setName ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getType ( ) { return type ; }
void test10 ( ) throws Throwable { int int0 = XMLTableColumnDefinition . parseType ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int parseType ( String typeName ) { if ( ( typeName ! = null ) & & ( typeName . length ( ) > 0 ) ) { if ( typeName . equals ( "string" ) ) { return STRING_TYPE ; } else if ( typeName . equals ( "number" ) ) { return NUMBER_TYPE ; } else if ( typeName . equals ( "node" ) ) { return NODE_TYPE ; } } return OBJECT_TYPE ; }
void test11 ( ) throws Throwable { int int0 = XMLTableColumnDefinition . parseType ( "number" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int parseType ( String typeName ) { if ( ( typeName ! = null ) & & ( typeName . length ( ) > 0 ) ) { if ( typeName . equals ( "string" ) ) { return STRING_TYPE ; } else if ( typeName . equals ( "number" ) ) { return NUMBER_TYPE ; } else if ( typeName . equals ( "node" ) ) { return NODE_TYPE ; } } return OBJECT_TYPE ; }
void test12 ( ) throws Throwable { int int0 = XMLTableColumnDefinition . parseType ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int parseType ( String typeName ) { if ( ( typeName ! = null ) & & ( typeName . length ( ) > 0 ) ) { if ( typeName . equals ( "string" ) ) { return STRING_TYPE ; } else if ( typeName . equals ( "number" ) ) { return NUMBER_TYPE ; } else if ( typeName . equals ( "node" ) ) { return NODE_TYPE ; } } return OBJECT_TYPE ; }
void test13 ( ) throws Throwable { int int0 = XMLTableColumnDefinition . parseType ( "string" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int parseType ( String typeName ) { if ( ( typeName ! = null ) & & ( typeName . length ( ) > 0 ) ) { if ( typeName . equals ( "string" ) ) { return STRING_TYPE ; } else if ( typeName . equals ( "number" ) ) { return NUMBER_TYPE ; } else if ( typeName . equals ( "node" ) ) { return NODE_TYPE ; } } return OBJECT_TYPE ; }
void test14 ( ) throws Throwable { int int0 = XMLTableColumnDefinition . parseType ( "nodb" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int parseType ( String typeName ) { if ( ( typeName ! = null ) & & ( typeName . length ( ) > 0 ) ) { if ( typeName . equals ( "string" ) ) { return STRING_TYPE ; } else if ( typeName . equals ( "number" ) ) { return NUMBER_TYPE ; } else if ( typeName . equals ( "node" ) ) { return NODE_TYPE ; } } return OBJECT_TYPE ; }
void test15 ( ) throws Throwable { int int0 = XMLTableColumnDefinition . parseType ( "node" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int parseType ( String typeName ) { if ( ( typeName ! = null ) & & ( typeName . length ( ) > 0 ) ) { if ( typeName . equals ( "string" ) ) { return STRING_TYPE ; } else if ( typeName . equals ( "number" ) ) { return NUMBER_TYPE ; } else if ( typeName . equals ( "node" ) ) { return NODE_TYPE ; } } return OBJECT_TYPE ; }
void test16 ( ) throws Throwable { XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( "string" , "nodb" , 1 ) ; Class < Object > class0 = xMLTableColumnDefinition0 . getColumnClass ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return this . name ; }
void test17 ( ) throws Throwable { DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "TEXT_NODE" , "TEXT_NODE" ) ; DefaultXPath defaultXPath0 = ( DefaultXPath ) dOMDocumentType0 . createXPath ( "TEXT_NODE" ) ; XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( "TEXT_NODE" , ( XPath ) defaultXPath0 , 0 ) ; Class < Object > class0 = xMLTableColumnDefinition0 . getColumnClass ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getType ( ) { return type ; }
void test18 ( ) throws Throwable { XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( "node" , ( XPath ) null , 3 ) ; Class < Object > class0 = xMLTableColumnDefinition0 . getColumnClass ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Class getColumnClass ( int columnIndex ) { return definition . getColumnClass ( columnIndex ) ; }
void test19 ( ) throws Throwable { DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( "TEXT_NODE" , "TEXT_NODE" ) ; DefaultXPath defaultXPath0 = ( DefaultXPath ) dOMDocumentType0 . createXPath ( "TEXT_NODE" ) ; XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( "TEXT_NODE" , ( XPath ) defaultXPath0 , 0 ) ; String string0 = ( String ) xMLTableColumnDefinition0 . getValue ( ( Object ) "TEXT_NODE" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getType ( ) { return type ; }
void test21 ( ) throws Throwable { XMLTableColumnDefinition xMLTableColumnDefinition0 = new XMLTableColumnDefinition ( "node" , "node" , 3 ) ; String string0 = ( String ) xMLTableColumnDefinition0 . getValue ( ( Object ) "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getType ( ) { return type ; }
void test0 ( ) throws Throwable { BeanDocumentFactory beanDocumentFactory0 = new BeanDocumentFactory ( ) ; Namespace namespace0 = Namespace . XML_NAMESPACE ; QName qName0 = beanDocumentFactory0 . createQName ( "osX | T" , namespace0 ) ; BeanElement beanElement0 = ( BeanElement ) beanDocumentFactory0 . createElement ( qName0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test1 ( ) throws Throwable { BeanDocumentFactory beanDocumentFactory0 = ( BeanDocumentFactory ) BeanDocumentFactory . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DocumentFactory getInstance ( ) { if ( singleton = = null ) { singleton = createSingleton ( ) ; } return ( DocumentFactory ) singleton . instance ( ) ; }
void test3 ( ) throws Throwable { BeanDocumentFactory beanDocumentFactory0 = new BeanDocumentFactory ( ) ; Namespace namespace0 = Namespace . XML_NAMESPACE ; QName qName0 = beanDocumentFactory0 . createQName ( "osX | T" , namespace0 ) ; AttributesImpl attributesImpl0 = new AttributesImpl ( ) ; BeanElement beanElement0 = ( BeanElement ) beanDocumentFactory0 . createElement ( qName0 , ( Attributes ) attributesImpl0 ) ; DefaultAttribute defaultAttribute0 = ( DefaultAttribute ) beanDocumentFactory0 . createAttribute ( ( Element ) beanElement0 , "osX | T" , "osX | T" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) ; / * * * DOCUMENT ME ! * * @return the trimmed text value where whitespace is trimmed and normalised * into single spaces . This method does not return null . * / String getTextTrim ( ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . This method returns the string - value of all the * contained { @link Text }
void test0 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "" ) ; DOMAttributeNodeMap dOMAttributeNodeMap0 = new DOMAttributeNodeMap ( dOMElement0 ) ; Node node0 = dOMAttributeNodeMap0 . getNamedItemNS ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Node getNamedItemNS ( String namespaceURI , String localName ) { return element . getAttributeNodeNS ( namespaceURI , localName ) ; }
void test1 ( ) throws Throwable { Namespace namespace0 = new Namespace ( "eD2%IR7z / 9W ] . . 3cadq" , "eD2%IR7z / 9W ] . . 3cadq" ) ; DOMElement dOMElement0 = new DOMElement ( "eD2%IR7z / 9W ] . . 3cadq" , namespace0 ) ; DOMAttributeNodeMap dOMAttributeNodeMap0 = new DOMAttributeNodeMap ( dOMElement0 ) ; int int0 = dOMAttributeNodeMap0 . getLength ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) { return DOMNodeHelper . getLength ( this ) ; }
void test2 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "" ) ; DOMAttributeNodeMap dOMAttributeNodeMap0 = new DOMAttributeNodeMap ( dOMElement0 ) ; Node node0 = dOMAttributeNodeMap0 . item ( 608 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Node item ( int index ) { return DOMNodeHelper . asDOMAttr ( element . attribute ( index ) ) ; }
void test3 ( ) throws Throwable { Namespace namespace0 = new Namespace ( "eD2%IR7z / 9W ] . . 3cadq" , "eD2%IR7z / 9W ] . . 3cadq" ) ; DOMElement dOMElement0 = new DOMElement ( "eD2%IR7z / 9W ] . . 3cadq" , namespace0 ) ; DOMAttributeNodeMap dOMAttributeNodeMap0 = new DOMAttributeNodeMap ( dOMElement0 ) ; Node node0 = dOMAttributeNodeMap0 . getNamedItem ( "eD2%IR7z / 9W ] . . 3cadq" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Node getNamedItem ( String name ) { return element . getAttributeNode ( name ) ; }
void test5 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "" ) ; DOMAttributeNodeMap dOMAttributeNodeMap0 = new DOMAttributeNodeMap ( dOMElement0 ) ; QName qName0 = dOMElement0 . getQName ( ) ; DOMAttribute dOMAttribute0 = new DOMAttribute ( qName0 , "" ) ; dOMAttributeNodeMap0 . setNamedItem ( ( Node ) dOMAttribute0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int attributeCount ( ) ; / * * * DOCUMENT ME ! * * @return an iterator over the attributes of this element * / Iterator < Attribute > attributeIterator ( ) ; / * * * Returns the attribute at the specified indexGets the * * @param index DOCUMENT ME ! * @return the attribute at the specified index where index & gt ; = 0 and * index & lt ; number of attributes or throws an * IndexOutOfBoundsException if the index is not within the * allowable range * / Attribute attribute ( int index ) ; / * * * Returns the attribute with the given name * * @param name DOCUMENT ME ! * @return the attribute for the given local name in any namespace . If there * are more than one attributes with the given local name in * different namespaces then the first one is returned . * / Attribute attribute ( String name ) ; / * * * DOCUMENT ME ! * * @param qName is the fully qualified name * @return the attribute for the given fully qualified name or null if it * could not be found . * / Attribute attribute ( QName qName ) ; / * * * < p > * This returns the attribute value for the attribute with the given name * and any namespace or null if there is no such attribute or the empty * string if the attribute value is empty . * < / p > * * @param name is the name of the attribute value to be returnd * @return the value of the attribute , null if the attribute does not exist * or the empty string * / String attributeValue ( String name ) ; / * * * < p > * This returns the attribute value for the attribute with the given name * and any namespace or the default value if there is no such attribute * value . * < / p > * * @param name is the name of the attribute value to be returnd * @param defaultValue is the default value to be returned if the attribute has no * value defined . * @return the value of the attribute or the defaultValue if the attribute * has no value defined . * / String attributeValue ( String name , String defaultValue ) ; / * * * < p > * This returns the attribute value for the attribute with the given fully * qualified name or null if there is no such attribute or the empty string * if the attribute value is empty . * < / p > * * @param qName is the fully qualified name * @return the value of the attribute , null if the attribute does not exist * or the empty string * / String attributeValue ( QName qName ) ; / * * * < p > * This returns the attribute value for the attribute with the given fully * qualified name or the default value if there is no such attribute value . * < / p > * * @param qName is the fully qualified name * @param defaultValue is the default value to be returned if the attribute has no * value defined . * @return the value of the attribute or the defaultValue if the attribute * has no value defined . * / String attributeValue ( QName qName , String defaultValue ) ; / / Content methods / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - / * * * Returns the first element for the given local name and any namespace . * * @param name DOCUMENT ME ! * @return the first element with the given local name * / Element element ( String name ) ; / * * * Returns the first element for the given fully qualified name . * * @param qName is the fully qualified name to search for * @return the first element with the given fully qualified name * / Element element ( QName qName ) ; / * * * < p > * Returns the elements contained in this element . If this element does not * contain any elements then this method returns an empty list . The list is * backed by the element such that changes to the list will be reflected in * the element though the reverse is not the case . * < / p > * * @return a list of all the elements in this element . * / List < Element > elements ( ) ; / * * * < p > * Returns the elements contained in this element with the given local name * and any namespace . If no elements are found then this method returns an * empty list . The list is backed by the element such that changes to the * list will be reflected in the element though the reverse is not the case . * < / p > * * @param name DOCUMENT ME ! * @return a list of all the elements in this element for the given local * name * / List < Element > elements ( String name ) ; / * * * < p > * Returns the elements contained in this element with the given fully * qualified name . If no elements are found then this method returns an * empty list . The list is backed by the element such that changes to the * list will be reflected in the element though the reverse is not the case . * < / p > * * @param qName is the fully qualified name to search for * @return a list of all the elements in this element for the given fully * qualified name . * / List < Element > elements ( QName qName ) ; / * * * Returns an iterator over all this elements child elements . * * @return an iterator over the contained elements * / Iterator < Element > elementIterator ( ) ; / * * * Returns an iterator over the elements contained in this element which * match the given local name and any namespace . * * @param name DOCUMENT ME ! * @return an iterator over the contained elements matching the given local * name * / Iterator < Element > elementIterator ( String name ) ; / * * * Returns an iterator over the elements contained in this element which * match the given fully qualified name . * * @param qName is the fully qualified name to search for * @return an iterator over the contained elements matching the given fully * qualified name * / Iterator < Element > elementIterator ( QName qName ) ; / / Helper methods / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - / * * * DOCUMENT ME ! * * @return true if this element is the root element of a document and this * element supports the parent relationship else false . * / boolean isRootElement ( ) ; / * * * < p > * Returns true if this < code > Element < / code > has mixed content . Mixed * content means that an element contains both textual data and child * elements . * < / p > * * @return true if this element contains mixed content . * / boolean hasMixedContent ( ) ; / * * * < p > * Returns true if this < code > Element < / code > has text only content . * < / p > * * @return true if this element is empty or only contains text content . * / boolean isTextOnly ( ) ; / * * * Appends the attributes of the given element to me . This method behaves * like the { @link java . util . Collection#addAll ( java . util . Collection ) }
void test8 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "" ) ; DOMAttributeNodeMap dOMAttributeNodeMap0 = new DOMAttributeNodeMap ( dOMElement0 ) ; QName qName0 = dOMElement0 . getQName ( ) ; DOMAttribute dOMAttribute0 = new DOMAttribute ( qName0 , "" ) ; DOMAttribute dOMAttribute1 = ( DOMAttribute ) dOMAttributeNodeMap0 . setNamedItemNS ( ( Node ) dOMAttribute0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) { return DOMNodeHelper . getLength ( this ) ; }
void test9 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "" ) ; DOMAttributeNodeMap dOMAttributeNodeMap0 = new DOMAttributeNodeMap ( dOMElement0 ) ; Node node0 = dOMAttributeNodeMap0 . removeNamedItemNS ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Node removeNamedItemNS ( String namespaceURI , String localName ) throws DOMException { org . w3c . dom . Attr attr = element . getAttributeNodeNS ( namespaceURI , localName ) ; if ( attr ! = null ) { return element . removeAttributeNode ( attr ) ; } return attr ; }
void test1 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMDocumentType dOMDocumentType0 = ( DOMDocumentType ) dOMDocumentFactory0 . createDocumentType ( "0" , "0" , "0" ) ; DOMDocument dOMDocument0 = ( DOMDocument ) dOMDocumentFactory0 . createDocument ( "0" , "0" , ( DocumentType ) dOMDocumentType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test2 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMAttribute dOMAttribute0 = ( DOMAttribute ) dOMDocumentFactory0 . createAttribute ( ( Element ) null , "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" NodeType getNodeTypeEnum ( ) { return NodeType . NAMESPACE_NODE ; }
void test3 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMComment dOMComment0 = ( DOMComment ) dOMDocumentFactory0 . createComment ( "p . ^^g } oxu1l~ / i" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPrefix ( ) { return prefix ; }
void test4 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMElement dOMElement0 = ( DOMElement ) dOMDocumentFactory0 . createElement ( "p . ^^g } oxu1l~ / i" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNodeValue ( ) throws DOMException { return null ; }
void test5 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; QName qName0 = QName . get ( "N & " , "N & " , "N & " ) ; DOMElement dOMElement0 = ( DOMElement ) dOMDocumentFactory0 . createElement ( qName0 , ( - 1727 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test7 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMText dOMText0 = ( DOMText ) dOMDocumentFactory0 . createText ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNodeName ( ) { return "#document" ; }
void test8 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMCDATA dOMCDATA0 = ( DOMCDATA ) dOMDocumentFactory0 . createCDATA ( "wO_JFBFg" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test9 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = ( DOMDocumentFactory ) DOMDocumentFactory . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DocumentFactory getInstance ( ) { if ( singleton = = null ) { singleton = createSingleton ( ) ; } return ( DocumentFactory ) singleton . instance ( ) ; }
void test10 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMDocument dOMDocument0 = ( DOMDocument ) dOMDocumentFactory0 . createDocument ( "n . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" short getNodeType ( ) ; / * * * Returns the name of the type of this node such as "Document" , "Element" , * "Attribute" or "Text" * * @return the name of the type of this node * / String getNodeTypeName ( ) ; / * * * < p > * Removes this node from its parent if there is one . If this node is the * root element of a document then it is removed from the document as well . * < / p > * < p / > * < p > * This method is useful if you want to remove a node from its source * document and add it to another document . For example * < / p > * < code > Node node = . . . ; Element someOtherElement = . . . ; * someOtherElement . add ( node . detach ( ) ) ; < / code > * * @return the node that has been removed from its parent node if any and * its document if any . * / Node detach ( ) ; / * * * < p > * < code > selectNodes < / code > evaluates an XPath expression and returns the * result as a < code > List < / code > of < code > Node < / code > instances or * < code > String < / code > instances depending on the XPath expression . * < / p > * * @param xpathExpression is the XPath expression to be evaluated * @return the list of < code > Node < / code > or < code > String < / code > * instances depending on the XPath expression * / List < ? extends Node > selectNodes ( String xpathExpression ) ; / * * * < p > * < code > selectObject < / code > evaluates an XPath expression and returns the * result as an { @link Object }
void test11 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMNamespace dOMNamespace0 = ( DOMNamespace ) dOMDocumentFactory0 . createNamespace ( " ( i , , %C / _H [ " , " ( i , , %C / _H [ " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getXPathNameStep ( ) { if ( ( prefix ! = null ) & & ! "" . equals ( prefix ) ) { return "namespace : : " + prefix ; } return "namespace : : * [ name ( ) = '' ] " ; }
void test12 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMEntityReference dOMEntityReference0 = ( DOMEntityReference ) dOMDocumentFactory0 . createEntity ( "n . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringValue ( ) ; / * * * Accesses the data of this element which may implement data typing * bindings such as XML Schema or Java Bean bindings or will return the same * value as { @link #getText }
void test13 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMProcessingInstruction dOMProcessingInstruction0 = ( DOMProcessingInstruction ) dOMDocumentFactory0 . createProcessingInstruction ( "n . " , "n . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" NodeType getNodeTypeEnum ( ) { return NodeType . NAMESPACE_NODE ; }
void test14 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMDocumentType dOMDocumentType0 = ( DOMDocumentType ) dOMDocumentFactory0 . createDocType ( "xml" , "xml" , "xml" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSystemID ( ) ; void setSystemID ( String systemID ) ; / * * * Returns a list of internal DTD declaration objects , defined in the * { @link org . dom4j . dtd }
void test15 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMEntityReference dOMEntityReference0 = ( DOMEntityReference ) dOMDocumentFactory0 . createEntity ( "core" , "core" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringValue ( ) ; / * * * Accesses the data of this element which may implement data typing * bindings such as XML Schema or Java Bean bindings or will return the same * value as { @link #getText }
void test16 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; boolean boolean0 = dOMDocumentFactory0 . hasFeature ( "xml" , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasFeature ( String feature , String version ) { if ( "XML" . equalsIgnoreCase ( feature ) | | "Core" . equalsIgnoreCase ( feature ) ) { return ( ( version = = null ) | | ( version . length ( ) = = 0 ) | | "1 . 0" . equals ( version ) | | "2 . 0" . equals ( version ) ) ; } return false ; }
void test17 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; boolean boolean0 = dOMDocumentFactory0 . hasFeature ( "" , "core" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasFeature ( String feature , String version ) { if ( "XML" . equalsIgnoreCase ( feature ) | | "Core" . equalsIgnoreCase ( feature ) ) { return ( ( version = = null ) | | ( version . length ( ) = = 0 ) | | "1 . 0" . equals ( version ) | | "2 . 0" . equals ( version ) ) ; } return false ; }
void test18 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; boolean boolean0 = dOMDocumentFactory0 . hasFeature ( "core" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasFeature ( String feature , String version ) { if ( "XML" . equalsIgnoreCase ( feature ) | | "Core" . equalsIgnoreCase ( feature ) ) { return ( ( version = = null ) | | ( version . length ( ) = = 0 ) | | "1 . 0" . equals ( version ) | | "2 . 0" . equals ( version ) ) ; } return false ; }
void test19 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; boolean boolean0 = dOMDocumentFactory0 . hasFeature ( "core" , "core" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasFeature ( String feature , String version ) { if ( "XML" . equalsIgnoreCase ( feature ) | | "Core" . equalsIgnoreCase ( feature ) ) { return ( ( version = = null ) | | ( version . length ( ) = = 0 ) | | "1 . 0" . equals ( version ) | | "2 . 0" . equals ( version ) ) ; } return false ; }
void test20 ( ) throws Throwable { DOMDocumentFactory dOMDocumentFactory0 = new DOMDocumentFactory ( ) ; DOMDocument dOMDocument0 = ( DOMDocument ) dOMDocumentFactory0 . createDocument ( " ( i , , %C / _H [ " , " ( i , , %C / _H [ " , ( DocumentType ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String asXML ( ) { StringBuffer asxml = new StringBuffer ( 10 ) ; String pref = getPrefix ( ) ; if ( ( pref ! = null ) & & ( pref . length ( ) > 0 ) ) { asxml . append ( "xmlns : " ) ; asxml . append ( pref ) ; asxml . append ( " = \"" ) ; } else { asxml . append ( "xmlns = \"" ) ; } asxml . append ( getURI ( ) ) ; asxml . append ( "\"" ) ; return asxml . toString ( ) ; }
void test0 ( ) throws Throwable { FlyweightComment flyweightComment0 = new FlyweightComment ( "EZF8F`x ] q" ) ; boolean boolean0 = DOMNodeHelper . supports ( ( Node ) flyweightComment0 , "EZF8F`x ] q" , "EZF8F`x ] q" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supports ( String feature , String version ) { return DOMNodeHelper . supports ( this , feature , version ) ; }
void test1 ( ) throws Throwable { org . w3c . dom . Node node0 = DOMNodeHelper . getLastChild ( ( Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Node getLastChild ( ) { return DOMNodeHelper . asDOMNode ( node ( nodeCount ( ) - 1 ) ) ; }
void test2 ( ) throws Throwable { DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( ) ; org . w3c . dom . Node node0 = DOMNodeHelper . getFirstChild ( ( Node ) dOMDocumentType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Node getFirstChild ( ) { return DOMNodeHelper . asDOMNode ( node ( 0 ) ) ; }
void test4 ( ) throws Throwable { DefaultComment defaultComment0 = new DefaultComment ( ( Element ) null , "" ) ; String string0 = DOMNodeHelper . getData ( ( CharacterData ) defaultComment0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getData ( ) ; / * * * Sets the data value of this element if this element supports data binding * or calls { @link #setText }
void test5 ( ) throws Throwable { boolean boolean0 = DOMNodeHelper . isSupported ( ( Node ) null , " ] FDB } t + e ! SXe8i6X" , " ] FDB } t + e ! SXe8i6X" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSupported ( String feature , String version ) { return DOMNodeHelper . isSupported ( this , feature , version ) ; }
void test7 ( ) throws Throwable { BeanElement beanElement0 = new BeanElement ( ( QName ) null ) ; DOMNodeHelper . setNodeValue ( ( Node ) beanElement0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int nodeCount ( ) ; / * * * Returns the element of the given ID attribute value . If this tree is * capable of understanding which attribute value should be used for the ID * then it should be used , otherwise this method should return null . * * @param elementID DOCUMENT ME ! * @return DOCUMENT ME ! * / Element elementByID ( String elementID ) ; / * * * < p > * Returns the content nodes of this branch as a backed { @link List }
void test8 ( ) throws Throwable { DOMDocument dOMDocument0 = new DOMDocument ( "CjzH51x`9u_l" ) ; boolean boolean0 = DOMNodeHelper . isNodeEquals ( ( org . w3c . dom . Node ) dOMDocument0 , ( org . w3c . dom . Node ) dOMDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNodeEquals ( org . w3c . dom . Node node1 , org . w3c . dom . Node node2 ) { if ( node1 = = null & & node2 = = null ) { return true ; } if ( node1 = = null | | node2 = = null ) { return false ; } if ( node1 . getNodeType ( ) ! = node2 . getNodeType ( ) ) { return false ; } if ( ! isStringEquals ( node1 . getNodeName ( ) , node2 . getNodeName ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getLocalName ( ) , node2 . getLocalName ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getNamespaceURI ( ) , node2 . getNamespaceURI ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getPrefix ( ) , node2 . getPrefix ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getNodeValue ( ) , node2 . getNodeValue ( ) ) ) { return false ; } return true ; }
void test10 ( ) throws Throwable { NodeList nodeList0 = DOMNodeHelper . createNodeList ( ( List ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" NodeList createNodeList ( List list ) { return new NodeList ( ) { org . w3c . dom . Node item ( int index ) { if ( index > = getLength ( ) ) { / * * From the NodeList specification : If index is greater than * or equal to the number of nodes in the list , this returns * null . * / return null ; } else { return DOMNodeHelper . asDOMNode ( ( Node ) list . get ( index ) ) ; } } int getLength ( ) { return list . size ( ) ; } } ; }
void test11 ( ) throws Throwable { UserDataElement userDataElement0 = new UserDataElement ( "found system property , value = " ) ; String string0 = DOMNodeHelper . getNodeValue ( ( Node ) userDataElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNodeValue ( ) throws DOMException { return null ; }
void test12 ( ) throws Throwable { DOMCDATA dOMCDATA0 = new DOMCDATA ( "" ) ; DOMNodeHelper . setData ( ( CharacterData ) dOMCDATA0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getData ( ) ; / * * * Sets the data value of this element if this element supports data binding * or calls { @link #setText }
void test13 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "znQlJ : cAw ( " ) ; boolean boolean0 = DOMNodeHelper . hasChildNodes ( ( Node ) dOMElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasChildNodes ( ) { return nodeCount ( ) > 0 ; }
void test14 ( ) throws Throwable { FlyweightCDATA flyweightCDATA0 = new FlyweightCDATA ( "" ) ; NamedNodeMap namedNodeMap0 = DOMNodeHelper . getAttributes ( ( Node ) flyweightCDATA0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" NamedNodeMap getAttributes ( ) { return null ; }
void test15 ( ) throws Throwable { DOMNodeHelper dOMNodeHelper0 = new DOMNodeHelper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DOMNodeHelper ( ) { }
void test16 ( ) throws Throwable { DOMNodeHelper . EmptyNodeList dOMNodeHelper_EmptyNodeList0 = ( DOMNodeHelper . EmptyNodeList ) DOMNodeHelper . getChildNodes ( ( Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) { return DOMNodeHelper . getLength ( this ) ; }
void test17 ( ) throws Throwable { DOMNodeHelper . EmptyNodeList dOMNodeHelper_EmptyNodeList0 = new DOMNodeHelper . EmptyNodeList ( ) ; int int0 = dOMNodeHelper_EmptyNodeList0 . getLength ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) { return DOMNodeHelper . getLength ( this ) ; }
void test18 ( ) throws Throwable { DOMNodeHelper . EmptyNodeList dOMNodeHelper_EmptyNodeList0 = new DOMNodeHelper . EmptyNodeList ( ) ; org . w3c . dom . Node node0 = dOMNodeHelper_EmptyNodeList0 . item ( 3635 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Node item ( int index ) { return DOMNodeHelper . asDOMAttr ( element . attribute ( index ) ) ; }
void test19 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "znQlJ : cAw ( " ) ; org . w3c . dom . Node node0 = DOMNodeHelper . getPreviousSibling ( ( Node ) dOMElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Node getPreviousSibling ( ) { return DOMNodeHelper . getPreviousSibling ( this ) ; }
void test20 ( ) throws Throwable { IndexedElement indexedElement0 = new IndexedElement ( "qX & & E0' ) h = 7XTN ( '%" ) ; DefaultElement defaultElement0 = ( DefaultElement ) indexedElement0 . addElement ( "qX & & E0' ) h = 7XTN ( '%" ) ; org . w3c . dom . Node node0 = DOMNodeHelper . getPreviousSibling ( ( Node ) defaultElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Node getPreviousSibling ( ) { return DOMNodeHelper . getPreviousSibling ( this ) ; }
void test22 ( ) throws Throwable { IndexedElement indexedElement0 = new IndexedElement ( "qX & & E0' ) h = 7XTN ( '%" ) ; org . w3c . dom . Node node0 = DOMNodeHelper . getNextSibling ( ( Node ) indexedElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Node getNextSibling ( ) { return DOMNodeHelper . getNextSibling ( this ) ; }
void test23 ( ) throws Throwable { UserDataElement userDataElement0 = new UserDataElement ( "found system property , value = " ) ; DOMComment dOMComment0 = new DOMComment ( ( Element ) userDataElement0 , "found system property , value = " ) ; DOMComment dOMComment1 = ( DOMComment ) dOMComment0 . asXPathResult ( ( Element ) userDataElement0 ) ; org . w3c . dom . Node node0 = DOMNodeHelper . getNextSibling ( ( Node ) dOMComment1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Node getNextSibling ( ) { return DOMNodeHelper . getNextSibling ( this ) ; }
void test24 ( ) throws Throwable { NonLazyElement nonLazyElement0 = new NonLazyElement ( "" ) ; DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; QName qName0 = defaultDocumentFactory0 . createQName ( "" ) ; DefaultElement defaultElement0 = ( DefaultElement ) nonLazyElement0 . addElement ( qName0 ) ; org . w3c . dom . Node node0 = DOMNodeHelper . getNextSibling ( ( Node ) defaultElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Node getNextSibling ( ) { return DOMNodeHelper . getNextSibling ( this ) ; }
void test26 ( ) throws Throwable { NonLazyElement nonLazyElement0 = new NonLazyElement ( "" ) ; QName qName0 = nonLazyElement0 . getQName ( "" ) ; DOMElement dOMElement0 = new DOMElement ( qName0 , ( - 1 ) ) ; DOMNodeHelper . insertBefore ( ( Node ) dOMElement0 , ( org . w3c . dom . Node ) dOMElement0 , ( org . w3c . dom . Node ) dOMElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTextOnly ( ) ; / * * * Appends the attributes of the given element to me . This method behaves * like the { @link java . util . Collection#addAll ( java . util . Collection ) }
void test29 ( ) throws Throwable { Namespace namespace0 = Namespace . XML_NAMESPACE ; DOMElement dOMElement0 = new DOMElement ( "found system property , value = " , namespace0 ) ; DOMDocument dOMDocument0 = new DOMDocument ( dOMElement0 ) ; DOMElement dOMElement1 = ( DOMElement ) DOMNodeHelper . replaceChild ( ( Node ) dOMDocument0 , ( org . w3c . dom . Node ) dOMDocument0 , ( org . w3c . dom . Node ) dOMElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLocalName ( ) { return element . getName ( ) ; }
void test31 ( ) throws Throwable { UserDataElement userDataElement0 = new UserDataElement ( "found system property , value = " ) ; DOMComment dOMComment0 = new DOMComment ( ( Element ) userDataElement0 , "found system property , value = " ) ; DOMComment dOMComment1 = ( DOMComment ) DOMNodeHelper . removeChild ( ( Node ) userDataElement0 , ( org . w3c . dom . Node ) dOMComment0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" NodeType getNodeTypeEnum ( ) { return NodeType . NAMESPACE_NODE ; }
void test34 ( ) throws Throwable { boolean boolean0 = DOMNodeHelper . hasAttributes ( ( Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasAttributes ( ) { return DOMNodeHelper . hasAttributes ( this ) ; }
void test35 ( ) throws Throwable { DOMNamespace dOMNamespace0 = new DOMNamespace ( ( Element ) null , ( String ) null , ( String ) null ) ; boolean boolean0 = DOMNodeHelper . hasAttributes ( ( Node ) dOMNamespace0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasAttributes ( ) { return DOMNodeHelper . hasAttributes ( this ) ; }
void test36 ( ) throws Throwable { IndexedElement indexedElement0 = new IndexedElement ( "4^pkz" ) ; boolean boolean0 = DOMNodeHelper . hasAttributes ( ( Node ) indexedElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasAttributes ( ) { return DOMNodeHelper . hasAttributes ( this ) ; }
void test37 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "2joRT : = EA ( = = / h8tO" , ( Namespace ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasAttributes ( ) { return DOMNodeHelper . hasAttributes ( this ) ; }
void test38 ( ) throws Throwable { FlyweightComment flyweightComment0 = new FlyweightComment ( ( String ) null ) ; int int0 = DOMNodeHelper . getLength ( ( CharacterData ) flyweightComment0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) { return DOMNodeHelper . getLength ( this ) ; }
void test39 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; DefaultCDATA defaultCDATA0 = ( DefaultCDATA ) defaultDocumentFactory0 . createCDATA ( "" ) ; int int0 = DOMNodeHelper . getLength ( ( CharacterData ) defaultCDATA0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) { return DOMNodeHelper . getLength ( this ) ; }
void test43 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; DefaultCDATA defaultCDATA0 = ( DefaultCDATA ) defaultDocumentFactory0 . createCDATA ( " > z" ) ; DOMNodeHelper . insertData ( ( CharacterData ) defaultCDATA0 , 0 , " > z" ) ; String string0 = DOMNodeHelper . substringData ( ( CharacterData ) defaultCDATA0 , 3 , 3 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) ; / * * * DOCUMENT ME ! * * @return the trimmed text value where whitespace is trimmed and normalised * into single spaces . This method does not return null . * / String getTextTrim ( ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . This method returns the string - value of all the * contained { @link Text }
void test44 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; DefaultCDATA defaultCDATA0 = ( DefaultCDATA ) defaultDocumentFactory0 . createCDATA ( "q > z . " ) ; String string0 = DOMNodeHelper . substringData ( ( CharacterData ) defaultCDATA0 , 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String substringData ( int offset , int count ) throws DOMException { return DOMNodeHelper . substringData ( this , offset , count ) ; }
void test45 ( ) throws Throwable { DefaultText defaultText0 = new DefaultText ( ( Element ) null , ( String ) null ) ; DOMNodeHelper . appendData ( ( CharacterData ) defaultText0 , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test47 ( ) throws Throwable { DOMText dOMText0 = new DOMText ( "ReseFrvedPITarget" ) ; DOMNodeHelper . appendData ( ( CharacterData ) dOMText0 , "ReseFrvedPITarget" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringValue ( ) ; / * * * Accesses the data of this element which may implement data typing * bindings such as XML Schema or Java Bean bindings or will return the same * value as { @link #getText }
void test49 ( ) throws Throwable { DOMText dOMText0 = new DOMText ( ( String ) null ) ; DOMNodeHelper . insertData ( ( CharacterData ) dOMText0 , ( - 1946 ) , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNodeTypeName ( ) ; / * * * < p > * Removes this node from its parent if there is one . If this node is the * root element of a document then it is removed from the document as well . * < / p > * < p / > * < p > * This method is useful if you want to remove a node from its source * document and add it to another document . For example * < / p > * < code > Node node = . . . ; Element someOtherElement = . . . ; * someOtherElement . add ( node . detach ( ) ) ; < / code > * * @return the node that has been removed from its parent node if any and * its document if any . * / Node detach ( ) ; / * * * < p > * < code > selectNodes < / code > evaluates an XPath expression and returns the * result as a < code > List < / code > of < code > Node < / code > instances or * < code > String < / code > instances depending on the XPath expression . * < / p > * * @param xpathExpression is the XPath expression to be evaluated * @return the list of < code > Node < / code > or < code > String < / code > * instances depending on the XPath expression * / List < ? extends Node > selectNodes ( String xpathExpression ) ; / * * * < p > * < code > selectObject < / code > evaluates an XPath expression and returns the * result as an { @link Object }
void test55 ( ) throws Throwable { DefaultComment defaultComment0 = new DefaultComment ( ( Element ) null , ( String ) null ) ; DOMNodeHelper . deleteData ( ( CharacterData ) defaultComment0 , 0 , 3635 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUniquePath ( Element context ) { StringBuffer path = new StringBuffer ( 10 ) ; Element parent = getParent ( ) ; if ( ( parent ! = null ) & & ( parent ! = context ) ) { path . append ( parent . getUniquePath ( context ) ) ; path . append ( ' / ' ) ; } path . append ( getXPathNameStep ( ) ) ; return path . toString ( ) ; }
void test57 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "2joRT : = EA ( = = / h8tO" , ( Namespace ) null ) ; DefaultCDATA defaultCDATA0 = new DefaultCDATA ( ( Element ) dOMElement0 , "2joRT : = EA ( = = / h8tO" ) ; DOMNodeHelper . deleteData ( ( CharacterData ) defaultCDATA0 , 0 , 292 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringValue ( ) ; / * * * Accesses the data of this element which may implement data typing * bindings such as XML Schema or Java Bean bindings or will return the same * value as { @link #getText }
void test61 ( ) throws Throwable { DefaultText defaultText0 = new DefaultText ( ( String ) null ) ; DOMNodeHelper . replaceData ( ( CharacterData ) defaultText0 , 8013 , 8013 , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsParent ( ) ; / * * * < p > * < code > getParent < / code > returns the parent < code > Element < / code > if * this node supports the parent relationship or null if it is the root * element or does not support the parent relationship . * < / p > * < p / > * < p > * This method is an optional feature and may not be supported for all * < code > Node < / code > implementations . * < / p > * * @return the parent of this node or null if it is the root of the tree or * the parent relationship is not supported . * / Element getParent ( ) ; / * * * < p > * < code > setParent < / code > sets the parent relationship of this node if the * parent relationship is supported or does nothing if the parent * relationship is not supported . * < / p > * < p / > * < p > * This method should only be called from inside an < code > Element < / code > * implementation method and is not intended for general use . * < / p > * * @param parent is the new parent of this node . * / void setParent ( Element parent ) ; / * * * < p > * < code > getDocument < / code > returns the < code > Document < / code > that this * < code > Node < / code > is part of if this node supports the parent * relationship . * < / p > * < p / > * < p > * This method is an optional feature and may not be supported for all * < code > Node < / code > implementations . * < / p > * * @return the document of this node or null if this feature is not * supported or the node is not associated with a * < code > Document < / code > * / Document getDocument ( ) ; / * * * < p > * < code > setDocument < / code > sets the document of this node if the parent * relationship is supported or does nothing if the parent relationship is * not supported . * < / p > * < p / > * < p > * This method should only be called from inside a < code > Document < / code > * implementation method and is not intended for general use . * < / p > * * @param document is the new document of this node . * / void setDocument ( Document document ) ; / * * * < p > * < code > isReadOnly < / code > returns true if this node is read only and * cannot be modified . Any attempt to modify a read - only < code > Node < / code > * will result in an < code > UnsupportedOperationException < / code > being * thrown . * < / p > * * @return true if this < code > Node < / code > is read only and cannot be * modified otherwise false . * / boolean isReadOnly ( ) ; / * * * < p > * < code > hasContent < / code > returns true if this node is a Branch ( either * an Element or a Document ) and it contains at least one content node such * as a child Element or Text node . * < / p > * * @return true if this < code > Node < / code > is a Branch with a nodeCount ( ) * of one or more . * / boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test63 ( ) throws Throwable { DefaultDocumentFactory defaultDocumentFactory0 = new DefaultDocumentFactory ( ) ; DefaultText defaultText0 = ( DefaultText ) defaultDocumentFactory0 . createText ( "0" ) ; DOMNodeHelper . replaceData ( ( CharacterData ) defaultText0 , 0 , 0 , "0" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringValue ( ) ; / * * * Accesses the data of this element which may implement data typing * bindings such as XML Schema or Java Bean bindings or will return the same * value as { @link #getText }
void test64 ( ) throws Throwable { DefaultAttribute defaultAttribute0 = new DefaultAttribute ( "J ] aWHR - ( Q" , "J ] aWHR - ( Q" ) ; QName qName0 = defaultAttribute0 . getQName ( ) ; IndexedElement indexedElement0 = new IndexedElement ( qName0 ) ; List < Attribute > list0 = indexedElement0 . attributes ( ) ; DOMElement dOMElement0 = new DOMElement ( qName0 ) ; DOMDocument dOMDocument0 = new DOMDocument ( dOMElement0 ) ; DOMNodeHelper . appendElementsByTagName ( ( List ) list0 , ( Branch ) dOMDocument0 , "J ] aWHR - ( Q" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) ; / * * * DOCUMENT ME ! * * @param depth DOCUMENT ME ! * @return the element at the specified depth index , 0 = root element * / Element getElement ( int depth ) ; / * * * DOCUMENT ME ! * * @return the path as a string * / String getPath ( ) ; / * * * DOCUMENT ME ! * * @return the current element * / Element getCurrent ( ) ; / * * * Adds the < code > ElementHandler < / code > to be called when the specified * path is encounted . The path can be either an absolute path ( i . e . prefixed * with " / " ) or a relative path ( i . e . assummed to be a child of the current * path as retrieved by < b > getPath < / b > . * * @param path is the path to be handled * @param handler is the < code > ElementHandler < / code > to be called by the event * based processor . * / void addHandler ( String path , ElementHandler handler ) ; / * * * Removes the < code > ElementHandler < / code > from the event based processor , * for the specified path . The path can be either an absolute path ( i . e . * prefixed with " / " ) or a relative path ( i . e . assummed to be a child of the * current path as retrieved by < b > getPath < / b > . * * @param path is the path to remove the < code > ElementHandler < / code > for . * / void removeHandler ( String path ) ; } / * * Redistribution and use of this software and associated documentation * ( "Software" ) , with or without modification , are permitted provided that the * following conditions are met : * * 1 . Redistributions of source code must retain copyright statements and * notices . Redistributions must also contain a copy of this document . * * 2 . Redistributions in binary form must reproduce the above copyright notice , * this list of conditions and the following disclaimer in the documentation * and / or other materials provided with the distribution . * * 3 . The name "DOM4J" must not be used to endorse or promote products derived * from this Software without prior written permission of MetaStuff , Ltd . For * written permission , please contact dom4j - info@metastuff . com . * * 4 . Products derived from this Software may not be called "DOM4J" nor may * "DOM4J" appear in their names without prior written permission of MetaStuff , * Ltd . DOM4J is a registered trademark of MetaStuff , Ltd . * * 5 . Due credit should be given to the DOM4J Project - http : / / dom4j . sourceforge . net * * THIS SOFTWARE IS PROVIDED BY METASTUFF , LTD . AND CONTRIBUTORS ``AS IS'' AND * ANY EXPRESSED OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED . IN NO EVENT SHALL METASTUFF , LTD . OR ITS CONTRIBUTORS BE * LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR * CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS * INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN * CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE . * * Copyright 2001 - 2005 ( C ) MetaStuff , Ltd . All Rights Reserved . * /
void test65 ( ) throws Throwable { UserDataElement userDataElement0 = new UserDataElement ( " { " ) ; NonLazyElement nonLazyElement0 = new NonLazyElement ( " { " , ( Namespace ) null ) ; List < Element > list0 = nonLazyElement0 . elements ( " { " ) ; UserDataElement userDataElement1 = ( UserDataElement ) userDataElement0 . addProcessingInstruction ( " { " , " { " ) ; DOMNodeHelper . appendElementsByTagName ( ( List ) list0 , ( Branch ) userDataElement1 , " { " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test66 ( ) throws Throwable { IndexedElement indexedElement0 = new IndexedElement ( "qX & & E0' ) h = 7XTN ( '%" ) ; indexedElement0 . addElement ( "qX & & E0' ) h = 7XTN ( '%" ) ; List < ProcessingInstruction > list0 = indexedElement0 . processingInstructions ( "" ) ; DOMNodeHelper . appendElementsByTagName ( ( List ) list0 , ( Branch ) indexedElement0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringValue ( ) ; / * * * Accesses the data of this element which may implement data typing * bindings such as XML Schema or Java Bean bindings or will return the same * value as { @link #getText }
void test67 ( ) throws Throwable { IndexedElement indexedElement0 = new IndexedElement ( "qX & & E0' ) h = 7XTN ( '%" ) ; indexedElement0 . addElement ( "qX & & E0' ) h = 7XTN ( '%" ) ; List < ProcessingInstruction > list0 = indexedElement0 . processingInstructions ( "" ) ; DOMNodeHelper . appendElementsByTagNameNS ( ( List ) list0 , ( Branch ) indexedElement0 , "" , "Uyn - KZX ! S$aZ" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringValue ( ) ; / * * * Accesses the data of this element which may implement data typing * bindings such as XML Schema or Java Bean bindings or will return the same * value as { @link #getText }
void test68 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "R" ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( ) ; DOMDocument dOMDocument0 = new DOMDocument ( dOMElement0 , dOMDocumentType0 ) ; DOMDocument dOMDocument1 = ( DOMDocument ) dOMDocument0 . addProcessingInstruction ( "R" , "R" ) ; DOMNodeHelper . appendElementsByTagNameNS ( ( List ) null , ( Branch ) dOMDocument1 , "R" , "R" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTextTrim ( ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . This method returns the string - value of all the * contained { @link Text }
void test70 ( ) throws Throwable { DOMDocument dOMDocument0 = new DOMDocument ( "CjzH51x`9u_l" ) ; DOMDocument dOMDocument1 = ( DOMDocument ) DOMNodeHelper . asDOMNode ( ( Node ) dOMDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Node asDOMNode ( Node node ) { if ( node = = null ) { return null ; } if ( node instanceof org . w3c . dom . Node ) { return ( org . w3c . dom . Node ) node ; } else { / / Use DOMWriter ? System . out . println ( "Cannot convert : " + node + " into a W3C DOM Node" ) ; notSupported ( ) ; return null ; } }
void test71 ( ) throws Throwable { DOMDocument dOMDocument0 = new DOMDocument ( "CjzH51x`9u_l" ) ; DOMDocument dOMDocument1 = ( DOMDocument ) DOMNodeHelper . asDOMDocument ( ( Document ) dOMDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Document asDOMDocument ( Document document ) { if ( document = = null ) { return null ; } if ( document instanceof org . w3c . dom . Document ) { return ( org . w3c . dom . Document ) document ; } else { / / Use DOMWriter ? notSupported ( ) ; return null ; } }
void test72 ( ) throws Throwable { org . w3c . dom . Document document0 = DOMNodeHelper . asDOMDocument ( ( Document ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Document asDOMDocument ( Document document ) { if ( document = = null ) { return null ; } if ( document instanceof org . w3c . dom . Document ) { return ( org . w3c . dom . Document ) document ; } else { / / Use DOMWriter ? notSupported ( ) ; return null ; } }
void test74 ( ) throws Throwable { DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( " < 5 ) G ? U" , " < 5 ) G ? U" ) ; DOMDocumentType dOMDocumentType1 = ( DOMDocumentType ) DOMNodeHelper . asDOMDocumentType ( ( DocumentType ) dOMDocumentType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasContent ( ) ; / * * * < p > * < code > getName < / code > returns the name of this node . This is the XML * local name of the element , attribute , entity or processing instruction . * For CDATA and Text nodes this method will return null . * < / p > * * @return the XML name of this node * / String getName ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param name is the new name of this node * / void setName ( String name ) ; / * * * < p > * Returns the text of this node . * < / p > * * @return the text for this node . * / String getText ( ) ; / * * * < p > * Sets the text data of this node or this method will throw an * < code > UnsupportedOperationException < / code > if it is read - only . * < / p > * * @param text is the new textual value of this node * / void setText ( String text ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . * * @return the text from all the child Text and Element nodes appended * together . * / String getStringValue ( ) ; / * * * < p > * Returns the XPath expression which will return a node set containing the * given node such as / a / b / & #64 ; c . No indexing will be used to restrict the * path if multiple elements with the same name occur on the path . * < / p > * * @return the XPath expression which will return a nodeset containing at * least this node . * / String getPath ( ) ; / * * * Returns the relative XPath expression which will return a node set * containing the given node such as a / b / & #64 ; c . No indexing will be used to * restrict the path if multiple elements with the same name occur on the * path . * * @param context is the parent context from which the relative path should * start . If the context is null or the context is not an * ancestor of this node then the path will be absolute and start * from the document and so begin with the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing at least this node . * / String getPath ( Element context ) ; / * * * < p > * Returns the XPath expression which will return a nodeset of one node * which is the current node . This method will use the XPath index operator * to restrict the path if multiple elements with the same name occur on the * path . * < / p > * * @return the XPath expression which will return a nodeset containing just * this node . * / String getUniquePath ( ) ; / * * * < p > * Returns the relative unique XPath expression from the given context which * will return a nodeset of one node which is the current node . This method * will use the XPath index operator to restrict the path if multiple * elements with the same name occur on the path . * < / p > * * @param context is the parent context from which the path should start . If the * context is null or the context is not an ancestor of this node * then the path will start from the document and so begin with * the ' / ' character . * @return the XPath expression relative to the given context which will * return a nodeset containing just this node . * / String getUniquePath ( Element context ) ; / * * * < p > * < code > asXML < / code > returns the textual XML representation of this node . * < / p > * * @return the XML representation of this node * / String asXML ( ) ; / * * * < p > * < code > write < / code > writes this node as the default XML notation for * this node . If you wish to control the XML output ( such as for pretty * printing , changing the indentation policy etc . ) then please use { @link * org . dom4j . io . XMLWriter }
void test75 ( ) throws Throwable { org . w3c . dom . DocumentType documentType0 = DOMNodeHelper . asDOMDocumentType ( ( DocumentType ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . DocumentType asDOMDocumentType ( DocumentType dt ) { if ( dt = = null ) { return null ; } if ( dt instanceof org . w3c . dom . DocumentType ) { return ( org . w3c . dom . DocumentType ) dt ; } else { / / Use DOMWriter ? notSupported ( ) ; return null ; } }
void test77 ( ) throws Throwable { DOMCDATA dOMCDATA0 = new DOMCDATA ( "" ) ; DOMCDATA dOMCDATA1 = ( DOMCDATA ) DOMNodeHelper . asDOMText ( ( CharacterData ) dOMCDATA0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Text asDOMText ( CharacterData text ) { if ( text = = null ) { return null ; } if ( text instanceof org . w3c . dom . Text ) { return ( org . w3c . dom . Text ) text ; } else { / / Use DOMWriter ? notSupported ( ) ; return null ; } }
void test78 ( ) throws Throwable { Text text0 = DOMNodeHelper . asDOMText ( ( CharacterData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Text asDOMText ( CharacterData text ) { if ( text = = null ) { return null ; } if ( text instanceof org . w3c . dom . Text ) { return ( org . w3c . dom . Text ) text ; } else { / / Use DOMWriter ? notSupported ( ) ; return null ; } }
void test80 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "unparsed - entity - uri" ) ; DOMElement dOMElement1 = ( DOMElement ) DOMNodeHelper . asDOMElement ( ( Node ) dOMElement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTagName ( ) { return getName ( ) ; }
void test81 ( ) throws Throwable { org . w3c . dom . Element element0 = DOMNodeHelper . asDOMElement ( ( Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Element asDOMElement ( Node element ) { if ( element = = null ) { return null ; } if ( element instanceof org . w3c . dom . Element ) { return ( org . w3c . dom . Element ) element ; } else { / / Use DOMWriter ? notSupported ( ) ; return null ; } }
void test84 ( ) throws Throwable { Attr attr0 = DOMNodeHelper . asDOMAttr ( ( Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" org . w3c . dom . Attr asDOMAttr ( Node attribute ) { if ( attribute = = null ) { return null ; } if ( attribute instanceof org . w3c . dom . Attr ) { return ( org . w3c . dom . Attr ) attribute ; } else { / / Use DOMWriter ? notSupported ( ) ; return null ; } }
void test85 ( ) throws Throwable { Class < ? > class0 = DOMNodeHelper . class ; BeanMetaData beanMetaData0 = BeanMetaData . get ( class0 ) ; QName qName0 = beanMetaData0 . getQName ( 0 ) ; DOMAttribute dOMAttribute0 = new DOMAttribute ( qName0 , "Unable to resolve prefix with null prefix resolver . " ) ; DOMAttribute dOMAttribute1 = ( DOMAttribute ) DOMNodeHelper . asDOMAttr ( ( Node ) dOMAttribute0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) ; / * * * DOCUMENT ME ! * * @return the trimmed text value where whitespace is trimmed and normalised * into single spaces . This method does not return null . * / String getTextTrim ( ) ; / * * * Returns the XPath string - value of this node . The behaviour of this method * is defined in the < a href = "http : / / www . w3 . org / TR / xpath" > XPath * specification < / a > . This method returns the string - value of all the * contained { @link Text }
void test86 ( ) throws Throwable { ProcessorExsltFunction processorExsltFunction0 = new ProcessorExsltFunction ( ) ; boolean boolean0 = DOMNodeHelper . isNodeEquals ( ( org . w3c . dom . Node ) null , ( org . w3c . dom . Node ) processorExsltFunction0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNodeEquals ( org . w3c . dom . Node node1 , org . w3c . dom . Node node2 ) { if ( node1 = = null & & node2 = = null ) { return true ; } if ( node1 = = null | | node2 = = null ) { return false ; } if ( node1 . getNodeType ( ) ! = node2 . getNodeType ( ) ) { return false ; } if ( ! isStringEquals ( node1 . getNodeName ( ) , node2 . getNodeName ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getLocalName ( ) , node2 . getLocalName ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getNamespaceURI ( ) , node2 . getNamespaceURI ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getPrefix ( ) , node2 . getPrefix ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getNodeValue ( ) , node2 . getNodeValue ( ) ) ) { return false ; } return true ; }
void test87 ( ) throws Throwable { boolean boolean0 = DOMNodeHelper . isNodeEquals ( ( org . w3c . dom . Node ) null , ( org . w3c . dom . Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNodeEquals ( org . w3c . dom . Node node1 , org . w3c . dom . Node node2 ) { if ( node1 = = null & & node2 = = null ) { return true ; } if ( node1 = = null | | node2 = = null ) { return false ; } if ( node1 . getNodeType ( ) ! = node2 . getNodeType ( ) ) { return false ; } if ( ! isStringEquals ( node1 . getNodeName ( ) , node2 . getNodeName ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getLocalName ( ) , node2 . getLocalName ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getNamespaceURI ( ) , node2 . getNamespaceURI ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getPrefix ( ) , node2 . getPrefix ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getNodeValue ( ) , node2 . getNodeValue ( ) ) ) { return false ; } return true ; }
void test88 ( ) throws Throwable { DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( ) ; boolean boolean0 = DOMNodeHelper . isNodeEquals ( ( org . w3c . dom . Node ) dOMDocumentType0 , ( org . w3c . dom . Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNodeEquals ( org . w3c . dom . Node node1 , org . w3c . dom . Node node2 ) { if ( node1 = = null & & node2 = = null ) { return true ; } if ( node1 = = null | | node2 = = null ) { return false ; } if ( node1 . getNodeType ( ) ! = node2 . getNodeType ( ) ) { return false ; } if ( ! isStringEquals ( node1 . getNodeName ( ) , node2 . getNodeName ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getLocalName ( ) , node2 . getLocalName ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getNamespaceURI ( ) , node2 . getNamespaceURI ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getPrefix ( ) , node2 . getPrefix ( ) ) ) { return false ; } if ( ! isStringEquals ( node1 . getNodeValue ( ) , node2 . getNodeValue ( ) ) ) { return false ; } return true ; }
void test89 ( ) throws Throwable { DOMElement dOMElement0 = new DOMElement ( "" ) ; DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( ) ; DOMDocument dOMDocument0 = new DOMDocument ( "" , dOMElement0 , dOMDocumentType0 ) ; boolean boolean0 = dOMElement0 . isEqualNode ( ( org . w3c . dom . Node ) dOMDocument0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualNode ( Node other ) { return DOMNodeHelper . isNodeEquals ( this , other ) ; }
void test90 ( ) throws Throwable { DOMCDATA dOMCDATA0 = new DOMCDATA ( "y" ) ; boolean boolean0 = DOMNodeHelper . isNodeSame ( ( org . w3c . dom . Node ) dOMCDATA0 , ( org . w3c . dom . Node ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNodeSame ( org . w3c . dom . Node node1 , org . w3c . dom . Node node2 ) { return node1 = = node2 ; }
void test91 ( ) throws Throwable { DOMDocumentType dOMDocumentType0 = new DOMDocumentType ( ) ; boolean boolean0 = DOMNodeHelper . isNodeSame ( ( org . w3c . dom . Node ) dOMDocumentType0 , ( org . w3c . dom . Node ) dOMDocumentType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNodeSame ( org . w3c . dom . Node node1 , org . w3c . dom . Node node2 ) { return node1 = = node2 ; }
