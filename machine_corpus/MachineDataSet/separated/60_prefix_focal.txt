void test0 ( ) throws Throwable { FSPathFactory fSPathFactory0 = new FSPathFactory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FSPathFactory ( ) { }
void test0 ( ) throws Throwable { FSPathResultListImpl fSPathResultListImpl0 = new FSPathResultListImpl ( ) ; FSPathResultListImpl fSPathResultListImpl1 = ( FSPathResultListImpl ) fSPathResultListImpl0 . each ( ( Callback ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FSPathResultList each ( Callback callback ) throws IOException ; FSPathResultModificationList delete ( ) throws IOException , OperationNotPermittedException ; FSPathResultModificationList copy ( String destinationPath ) throws IOException , OperationNotPermittedException ; FSPathResultModificationList move ( String destinationPath ) throws IOException , OperationNotPermittedException ; FSPathResultModificationList rename ( String matchExpression , String replaceExpresion ) throws IOException , OperationNotPermittedException ; }
void test2 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { try { FSPathResultListImpl fSPathResultListImpl0 = new FSPathResultListImpl ( ) ; File file0 = new File ( " . " ) ; FSPathResult fSPathResult0 = new FSPathResult ( file0 ) ; fSPathResultListImpl0 . add ( fSPathResult0 ) ; FSPathResultModificationListImpl fSPathResultModificationListImpl0 = ( FSPathResultModificationListImpl ) fSPathResultListImpl0 . delete ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String get ( Object key ) { String xpr = convertToXPath ( ( String ) key ) ; try { String result = ( String ) getXPath ( ) . evaluate ( xpr + " / text ( ) " , this . doc , XPathConstants . STRING ) ; return result . equals ( "" ) ? null : result ; } catch ( XPathExpressionException e ) { return null ; } }
void test8 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { try { FSPathResultListImpl fSPathResultListImpl0 = new FSPathResultListImpl ( ) ; File file0 = new File ( " is not writable" ) ; FSPathResult fSPathResult0 = new FSPathResult ( file0 ) ; fSPathResultListImpl0 . add ( fSPathResult0 ) ; FSPathResultModificationListImpl fSPathResultModificationListImpl0 = ( FSPathResultModificationListImpl ) fSPathResultListImpl0 . rename ( " is not writable" , " is not writable" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String get ( Object key ) { String xpr = convertToXPath ( ( String ) key ) ; try { String result = ( String ) getXPath ( ) . evaluate ( xpr + " / text ( ) " , this . doc , XPathConstants . STRING ) ; return result . equals ( "" ) ? null : result ; } catch ( XPathExpressionException e ) { return null ; } }
void test0 ( ) throws Throwable { FSPathResultModificationListImpl fSPathResultModificationListImpl0 = new FSPathResultModificationListImpl ( ) ; FSPathResultModificationListImpl fSPathResultModificationListImpl1 = ( FSPathResultModificationListImpl ) fSPathResultModificationListImpl0 . onFailure ( ( Callback ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FSPathResultModificationList onFailure ( Callback callback ) { for ( FSPathResult result : this . getFailures ( ) ) { callback . call ( result ) ; } return this ; }
void test2 ( ) throws Throwable { FSPathResultModificationListImpl fSPathResultModificationListImpl0 = new FSPathResultModificationListImpl ( ) ; boolean boolean0 = fSPathResultModificationListImpl0 . hasFailures ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasFailures ( ) { return ( this . firstFailure ! = null ) ; }
void test3 ( ) throws Throwable { FSPathResultModificationListImpl fSPathResultModificationListImpl0 = new FSPathResultModificationListImpl ( ) ; Boolean boolean0 = Boolean . TRUE ; FSPathResult fSPathResult0 = new FSPathResult ( boolean0 ) ; fSPathResultModificationListImpl0 . addFailure ( fSPathResult0 ) ; boolean boolean1 = fSPathResultModificationListImpl0 . hasFailures ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { try { return ( ( Double ) getXPath ( ) . evaluate ( "count ( " + allTextNodesExpr + " ) " , this . doc , XPathConstants . NUMBER ) ) . intValue ( ) ; } catch ( XPathExpressionException xpee ) { return - 1 ; } }
void test4 ( ) throws Throwable { FSPathResultModificationListImpl fSPathResultModificationListImpl0 = new FSPathResultModificationListImpl ( ) ; FSPathResultListImpl fSPathResultListImpl0 = ( FSPathResultListImpl ) fSPathResultModificationListImpl0 . getSuccesses ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test5 ( ) throws Throwable { FSPathResultModificationListImpl fSPathResultModificationListImpl0 = new FSPathResultModificationListImpl ( ) ; Boolean boolean0 = Boolean . TRUE ; FSPathResult fSPathResult0 = new FSPathResult ( boolean0 ) ; fSPathResultModificationListImpl0 . addSuccess ( fSPathResult0 ) ; FSPathResultListImpl fSPathResultListImpl0 = ( FSPathResultListImpl ) fSPathResultModificationListImpl0 . getSuccesses ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { try { return ( ( Double ) getXPath ( ) . evaluate ( "count ( " + allTextNodesExpr + " ) " , this . doc , XPathConstants . NUMBER ) ) . intValue ( ) ; } catch ( XPathExpressionException xpee ) { return - 1 ; } }
void test6 ( ) throws Throwable { FSPathResultModificationListImpl fSPathResultModificationListImpl0 = new FSPathResultModificationListImpl ( ) ; FSPathResult fSPathResult0 = new FSPathResult ( ( Boolean ) false ) ; fSPathResultModificationListImpl0 . addSuccess ( fSPathResult0 ) ; fSPathResultModificationListImpl0 . addSuccess ( fSPathResult0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return this . size ( ) < 1 ; }
void test7 ( ) throws Throwable { FSPathResultModificationListImpl fSPathResultModificationListImpl0 = new FSPathResultModificationListImpl ( ) ; Boolean boolean0 = Boolean . TRUE ; FSPathResult fSPathResult0 = new FSPathResult ( boolean0 ) ; fSPathResultModificationListImpl0 . addFailure ( fSPathResult0 ) ; fSPathResultModificationListImpl0 . addFailure ( fSPathResult0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return this . size ( ) < 1 ; }
void test0 ( ) throws Throwable { Date date0 = new Date ( ) ; FSPathResult fSPathResult0 = new FSPathResult ( date0 ) ; File file0 = fSPathResult0 . getFile ( ) ; FSPathResult fSPathResult1 = new FSPathResult ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FSPathResult ( File file ) { this . resultFile = file ; }
void test1 ( ) throws Throwable { URI uRI0 = new URI ( " ! 8" ) ; FSPathResult fSPathResult0 = new FSPathResult ( uRI0 ) ; String string0 = fSPathResult0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test2 ( ) throws Throwable { Date date0 = new Date ( ) ; FSPathResult fSPathResult0 = new FSPathResult ( date0 ) ; fSPathResult0 . getURI ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" URI getURI ( ) { return this . resultURI ; }
void test3 ( ) throws Throwable { Boolean boolean0 = Boolean . FALSE ; FSPathResult fSPathResult0 = new FSPathResult ( boolean0 ) ; String string0 = fSPathResult0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test4 ( ) throws Throwable { Date date0 = new Date ( ) ; FSPathResult fSPathResult0 = new FSPathResult ( date0 ) ; fSPathResult0 . getBoolean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Boolean getBoolean ( ) { return this . resultBoolean ; }
void test6 ( ) throws Throwable { Double double0 = new Double ( 0 . 0 ) ; FSPathResult fSPathResult0 = new FSPathResult ( double0 ) ; String string0 = fSPathResult0 . getString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getString ( ) { return this . resultString ; }
void test7 ( ) throws Throwable { Double double0 = new Double ( 0 . 0 ) ; FSPathResult fSPathResult0 = new FSPathResult ( double0 ) ; Date date0 = fSPathResult0 . getDate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Date getDate ( ) { return this . resultDate ; }
void test8 ( ) throws Throwable { File file0 = new File ( ( File ) null , "" ) ; FSPathResult fSPathResult0 = new FSPathResult ( file0 ) ; String string0 = fSPathResult0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test9 ( ) throws Throwable { FSPathResult fSPathResult0 = new FSPathResult ( "Xn4b9X7\"7U bz , FE" ) ; String string0 = fSPathResult0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test10 ( ) throws Throwable { Double double0 = new Double ( 1518 . 710032287509 ) ; FSPathResult fSPathResult0 = new FSPathResult ( double0 ) ; String string0 = fSPathResult0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test11 ( ) throws Throwable { Date date0 = new Date ( ( - 272L ) ) ; FSPathResult fSPathResult0 = new FSPathResult ( date0 ) ; String string0 = fSPathResult0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test12 ( ) throws Throwable { FSPathResult fSPathResult0 = new FSPathResult ( ( Date ) null ) ; String string0 = fSPathResult0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test2 ( ) throws Throwable { DefaultFSPath defaultFSPath0 = new DefaultFSPath ( ) ; File file0 = defaultFSPath0 . getRootDirectory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" File getRootDirectory ( ) { return this . rootDirectory ; }
void test4 ( ) throws Throwable { DefaultFSPath defaultFSPath0 = new DefaultFSPath ( ) ; QName qName0 = new QName ( "" ) ; FSPathResultListImpl fSPathResultListImpl0 = ( FSPathResultListImpl ) defaultFSPath0 . query ( "" , qName0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test0 ( ) throws Throwable { Commands commands0 = Commands . CD ; String string0 = commands0 . getDescription ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDescription ( ) { return this . description ; }
void test1 ( ) throws Throwable { boolean boolean0 = Commands . isCommand ( "t = UD & D" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCommand ( String value ) { for ( Commands c : Commands . values ( ) ) { if ( c . getCommandText ( ) . equals ( value ) ) { return true ; } } return false ; }
void test2 ( ) throws Throwable { boolean boolean0 = Commands . isCommand ( "help" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCommand ( String value ) { for ( Commands c : Commands . values ( ) ) { if ( c . getCommandText ( ) . equals ( value ) ) { return true ; } } return false ; }
void test0 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 3 ] ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; PrintStream printStream0 = new PrintStream ( ( OutputStream ) byteArrayOutputStream0 ) ; Prompt prompt0 = new Prompt ( ( InputStream ) byteArrayInputStream0 , printStream0 , printStream0 ) ; prompt0 . setPromptText ( "\u0000\uFFFD\uFFFD" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPromptText ( ) { return promptText ; }
void test1 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 3 ] ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; PrintStream printStream0 = new PrintStream ( ( OutputStream ) byteArrayOutputStream0 ) ; Prompt prompt0 = new Prompt ( ( InputStream ) byteArrayInputStream0 , printStream0 , printStream0 ) ; String string0 = prompt0 . getPromptText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPromptText ( ) { return promptText ; }
void test2 ( ) throws Throwable { FileDescriptor fileDescriptor0 = FileDescriptor . out ; FileInputStream fileInputStream0 = new FileInputStream ( fileDescriptor0 ) ; Prompt prompt0 = new Prompt ( ( InputStream ) fileInputStream0 , ( PrintStream ) null , ( PrintStream ) null ) ; prompt0 . close ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPromptText ( ) { return promptText ; }
void test3 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 3 ] ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; PrintStream printStream0 = new PrintStream ( ( OutputStream ) byteArrayOutputStream0 ) ; Prompt prompt0 = new Prompt ( ( InputStream ) byteArrayInputStream0 , printStream0 , printStream0 ) ; prompt0 . readLine ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { try { return ( ( Double ) getXPath ( ) . evaluate ( "count ( " + allTextNodesExpr + " ) " , this . doc , XPathConstants . NUMBER ) ) . intValue ( ) ; } catch ( XPathExpressionException xpee ) { return - 1 ; } }
void test4 ( ) throws Throwable { RegexFunction regexFunction0 = new RegexFunction ( ) ; LinkedList < String > linkedList0 = new LinkedList < String > ( ) ; linkedList0 . add ( " < \"^ . 2 - dId" ) ; linkedList0 . add ( " < \"^ . 2 - dId" ) ; Pattern pattern0 = regexFunction0 . getPattern ( ( List ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object evaluate ( List args ) throws XPathFunctionException { String nodeValue = this . getNodeValue ( args ) ; Pattern pattern = this . getPattern ( args ) ; Boolean isMatch = new Boolean ( pattern . matcher ( nodeValue ) . matches ( ) ) ; return isMatch ; }
void test0 ( ) throws Throwable { RegexFunctionResolver regexFunctionResolver0 = new RegexFunctionResolver ( ) ; QName qName0 = new QName ( "matches" , "matches" ) ; RegexFunction regexFunction0 = ( RegexFunction ) regexFunctionResolver0 . resolveFunction ( qName0 , ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XPathFunction resolveFunction ( QName functionName , int arity ) { if ( arity = = 2 / / & & this . regexQName . getPrefix ( ) . equals ( functionName . getPrefix ( ) ) & & this . regexQName . getLocalPart ( ) . equals ( functionName . getLocalPart ( ) ) ) { return new RegexFunction ( ) ; } return null ; }
void test1 ( ) throws Throwable { RegexFunctionResolver regexFunctionResolver0 = new RegexFunctionResolver ( ) ; QName qName0 = new QName ( "matches" , "matches" ) ; RegexFunction regexFunction0 = ( RegexFunction ) regexFunctionResolver0 . resolveFunction ( qName0 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XPathFunction resolveFunction ( QName functionName , int arity ) { if ( arity = = 2 / / & & this . regexQName . getPrefix ( ) . equals ( functionName . getPrefix ( ) ) & & this . regexQName . getLocalPart ( ) . equals ( functionName . getLocalPart ( ) ) ) { return new RegexFunction ( ) ; } return null ; }
void test2 ( ) throws Throwable { RegexFunctionResolver regexFunctionResolver0 = new RegexFunctionResolver ( ) ; QName qName0 = new QName ( "matcMf" ) ; RegexFunction regexFunction0 = ( RegexFunction ) regexFunctionResolver0 . resolveFunction ( qName0 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" XPathFunction resolveFunction ( QName functionName , int arity ) { if ( arity = = 2 / / & & this . regexQName . getPrefix ( ) . equals ( functionName . getPrefix ( ) ) & & this . regexQName . getLocalPart ( ) . equals ( functionName . getLocalPart ( ) ) ) { return new RegexFunction ( ) ; } return null ; }
void test2 ( ) throws Throwable { FSNamespaceContext fSNamespaceContext0 = new FSNamespaceContext ( ) ; String string0 = fSNamespaceContext0 . getNamespaceURI ( "L | o06 + JXd Q / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNamespaceURI ( String prefix ) { if ( prefix = = null ) throw new NullPointerException ( "Null prefix" ) ; else if ( "fs" . equals ( prefix ) ) return "http : / / sugar . sourceforge . net / safari / fspath" ; else if ( "xml" . equals ( prefix ) ) return XMLConstants . XML_NS_URI ; return XMLConstants . NULL_NS_URI ; }
void test4 ( ) throws Throwable { FSNamespaceContext fSNamespaceContext0 = new FSNamespaceContext ( ) ; String string0 = fSNamespaceContext0 . getNamespaceURI ( "fs" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNamespaceURI ( String prefix ) { if ( prefix = = null ) throw new NullPointerException ( "Null prefix" ) ; else if ( "fs" . equals ( prefix ) ) return "http : / / sugar . sourceforge . net / safari / fspath" ; else if ( "xml" . equals ( prefix ) ) return XMLConstants . XML_NS_URI ; return XMLConstants . NULL_NS_URI ; }
void test5 ( ) throws Throwable { FSNamespaceContext fSNamespaceContext0 = new FSNamespaceContext ( ) ; String string0 = fSNamespaceContext0 . getNamespaceURI ( "xml" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNamespaceURI ( String prefix ) { if ( prefix = = null ) throw new NullPointerException ( "Null prefix" ) ; else if ( "fs" . equals ( prefix ) ) return "http : / / sugar . sourceforge . net / safari / fspath" ; else if ( "xml" . equals ( prefix ) ) return XMLConstants . XML_NS_URI ; return XMLConstants . NULL_NS_URI ; }
void test1 ( ) throws Throwable { LinkedList < LocalReference > linkedList0 = new LinkedList < LocalReference > ( ) ; LocalAttributeReference localAttributeReference0 = new LocalAttributeReference ( ) ; linkedList0 . offer ( ( LocalReference ) localAttributeReference0 ) ; localAttributeReference0 . setResolved ( ) ; DefaultLocalReferenceProcessor defaultLocalReferenceProcessor0 = new DefaultLocalReferenceProcessor ( ) ; defaultLocalReferenceProcessor0 . processLocalReferences ( ( List < LocalReference > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return this . size ( ) < 1 ; }
void test0 ( ) throws Throwable { IncludeHolder includeHolder0 = new IncludeHolder ( ) ; String string0 = includeHolder0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test1 ( ) throws Throwable { IncludeHolder includeHolder0 = new IncludeHolder ( ) ; Document document0 = includeHolder0 . getDocument ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Document getDocument ( ) { return document ; }
void test2 ( ) throws Throwable { IncludeHolder includeHolder0 = new IncludeHolder ( ) ; includeHolder0 . setDocument ( ( Document ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test0 ( ) throws Throwable { LocalAttributeReference localAttributeReference0 = new LocalAttributeReference ( ) ; String string0 = localAttributeReference0 . getAttributeName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAttributeName ( ) { return attributeName ; }
void test1 ( ) throws Throwable { LocalAttributeReference localAttributeReference0 = new LocalAttributeReference ( ) ; localAttributeReference0 . setAttributeName ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAttributeName ( ) { return attributeName ; }
void test1 ( ) throws Throwable { char [ ] charArray0 = new char [ 9 ] ; charArray0 [ 0 ] = ' . ' ; ANTLRStringStream aNTLRStringStream0 = new ANTLRStringStream ( charArray0 , 1 ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRStringStream0 ) ; CommonToken commonToken0 = ( CommonToken ) sCLLexer0 . nextToken ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test6 ( ) throws Throwable { char [ ] charArray0 = new char [ 8 ] ; charArray0 [ 1 ] = ' : ' ; ANTLRStringStream aNTLRStringStream0 = new ANTLRStringStream ( charArray0 , ( int ) 'k' ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRStringStream0 ) ; sCLLexer0 . mTokens ( ) ; sCLLexer0 . mTokens ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void mTokens ( ) throws RecognitionException { / / net / sf / sugar / scl / SCL . g : 1 : 8 : ( T__19 | OPEN_NESTING | CLOSE_NESTING | ASSIGNMENT_OP | VALID_NAME_CHARS | WS | STRING_LITERAL | START_INCLUDE | END_INCLUDE | START_UNPARSED_INCLUDE | REF_CHAR | QUOTE | AS_KEYWORD | STRING_SEQUENCE_CHAR | COMMENT | LINE_COMMENT ) int alt8 = 16 ; alt8 = dfa8 . predict ( input ) ; switch ( alt8 ) { case 1 : / / net / sf / sugar / scl / SCL . g : 1 : 10 : T__19 { mT__19 ( ) ; } break ; case 2 : / / net / sf / sugar / scl / SCL . g : 1 : 16 : OPEN_NESTING { mOPEN_NESTING ( ) ; } break ; case 3 : / / net / sf / sugar / scl / SCL . g : 1 : 29 : CLOSE_NESTING { mCLOSE_NESTING ( ) ; } break ; case 4 : / / net / sf / sugar / scl / SCL . g : 1 : 43 : ASSIGNMENT_OP { mASSIGNMENT_OP ( ) ; } break ; case 5 : / / net / sf / sugar / scl / SCL . g : 1 : 57 : VALID_NAME_CHARS { mVALID_NAME_CHARS ( ) ; } break ; case 6 : / / net / sf / sugar / scl / SCL . g : 1 : 74 : WS { mWS ( ) ; } break ; case 7 : / / net / sf / sugar / scl / SCL . g : 1 : 77 : STRING_LITERAL { mSTRING_LITERAL ( ) ; } break ; case 8 : / / net / sf / sugar / scl / SCL . g : 1 : 92 : START_INCLUDE { mSTART_INCLUDE ( ) ; } break ; case 9 : / / net / sf / sugar / scl / SCL . g : 1 : 106 : END_INCLUDE { mEND_INCLUDE ( ) ; } break ; case 10 : / / net / sf / sugar / scl / SCL . g : 1 : 118 : START_UNPARSED_INCLUDE { mSTART_UNPARSED_INCLUDE ( ) ; } break ; case 11 : / / net / sf / sugar / scl / SCL . g : 1 : 141 : REF_CHAR { mREF_CHAR ( ) ; } break ; case 12 : / / net / sf / sugar / scl / SCL . g : 1 : 150 : QUOTE { mQUOTE ( ) ; } break ; case 13 : / / net / sf / sugar / scl / SCL . g : 1 : 156 : AS_KEYWORD { mAS_KEYWORD ( ) ; } break ; case 14 : / / net / sf / sugar / scl / SCL . g : 1 : 167 : STRING_SEQUENCE_CHAR { mSTRING_SEQUENCE_CHAR ( ) ; } break ; case 15 : / / net / sf / sugar / scl / SCL . g : 1 : 188 : COMMENT { mCOMMENT ( ) ; } break ; case 16 : / / net / sf / sugar / scl / SCL . g : 1 : 196 : LINE_COMMENT { mLINE_COMMENT ( ) ; } break ; } }
void test8 ( ) throws Throwable { ANTLRReaderStream aNTLRReaderStream0 = new ANTLRReaderStream ( ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRReaderStream0 ) ; String string0 = sCLLexer0 . getGrammarFileName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getGrammarFileName ( ) { return "net / sf / sugar / scl / SCL . g" ; }
void test10 ( ) throws Throwable { char [ ] charArray0 = new char [ 5 ] ; charArray0 [ 0 ] = '~' ; ANTLRStringStream aNTLRStringStream0 = new ANTLRStringStream ( charArray0 , ( int ) '~' ) ; RecognizerSharedState recognizerSharedState0 = new RecognizerSharedState ( ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRStringStream0 , recognizerSharedState0 ) ; sCLLexer0 . mTokens ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void mTokens ( ) throws RecognitionException { / / net / sf / sugar / scl / SCL . g : 1 : 8 : ( T__19 | OPEN_NESTING | CLOSE_NESTING | ASSIGNMENT_OP | VALID_NAME_CHARS | WS | STRING_LITERAL | START_INCLUDE | END_INCLUDE | START_UNPARSED_INCLUDE | REF_CHAR | QUOTE | AS_KEYWORD | STRING_SEQUENCE_CHAR | COMMENT | LINE_COMMENT ) int alt8 = 16 ; alt8 = dfa8 . predict ( input ) ; switch ( alt8 ) { case 1 : / / net / sf / sugar / scl / SCL . g : 1 : 10 : T__19 { mT__19 ( ) ; } break ; case 2 : / / net / sf / sugar / scl / SCL . g : 1 : 16 : OPEN_NESTING { mOPEN_NESTING ( ) ; } break ; case 3 : / / net / sf / sugar / scl / SCL . g : 1 : 29 : CLOSE_NESTING { mCLOSE_NESTING ( ) ; } break ; case 4 : / / net / sf / sugar / scl / SCL . g : 1 : 43 : ASSIGNMENT_OP { mASSIGNMENT_OP ( ) ; } break ; case 5 : / / net / sf / sugar / scl / SCL . g : 1 : 57 : VALID_NAME_CHARS { mVALID_NAME_CHARS ( ) ; } break ; case 6 : / / net / sf / sugar / scl / SCL . g : 1 : 74 : WS { mWS ( ) ; } break ; case 7 : / / net / sf / sugar / scl / SCL . g : 1 : 77 : STRING_LITERAL { mSTRING_LITERAL ( ) ; } break ; case 8 : / / net / sf / sugar / scl / SCL . g : 1 : 92 : START_INCLUDE { mSTART_INCLUDE ( ) ; } break ; case 9 : / / net / sf / sugar / scl / SCL . g : 1 : 106 : END_INCLUDE { mEND_INCLUDE ( ) ; } break ; case 10 : / / net / sf / sugar / scl / SCL . g : 1 : 118 : START_UNPARSED_INCLUDE { mSTART_UNPARSED_INCLUDE ( ) ; } break ; case 11 : / / net / sf / sugar / scl / SCL . g : 1 : 141 : REF_CHAR { mREF_CHAR ( ) ; } break ; case 12 : / / net / sf / sugar / scl / SCL . g : 1 : 150 : QUOTE { mQUOTE ( ) ; } break ; case 13 : / / net / sf / sugar / scl / SCL . g : 1 : 156 : AS_KEYWORD { mAS_KEYWORD ( ) ; } break ; case 14 : / / net / sf / sugar / scl / SCL . g : 1 : 167 : STRING_SEQUENCE_CHAR { mSTRING_SEQUENCE_CHAR ( ) ; } break ; case 15 : / / net / sf / sugar / scl / SCL . g : 1 : 188 : COMMENT { mCOMMENT ( ) ; } break ; case 16 : / / net / sf / sugar / scl / SCL . g : 1 : 196 : LINE_COMMENT { mLINE_COMMENT ( ) ; } break ; } }
void test12 ( ) throws Throwable { ANTLRStringStream aNTLRStringStream0 = new ANTLRStringStream ( "2Z : 3\" . " ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRStringStream0 ) ; sCLLexer0 . mTokens ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void mTokens ( ) throws RecognitionException { / / net / sf / sugar / scl / SCL . g : 1 : 8 : ( T__19 | OPEN_NESTING | CLOSE_NESTING | ASSIGNMENT_OP | VALID_NAME_CHARS | WS | STRING_LITERAL | START_INCLUDE | END_INCLUDE | START_UNPARSED_INCLUDE | REF_CHAR | QUOTE | AS_KEYWORD | STRING_SEQUENCE_CHAR | COMMENT | LINE_COMMENT ) int alt8 = 16 ; alt8 = dfa8 . predict ( input ) ; switch ( alt8 ) { case 1 : / / net / sf / sugar / scl / SCL . g : 1 : 10 : T__19 { mT__19 ( ) ; } break ; case 2 : / / net / sf / sugar / scl / SCL . g : 1 : 16 : OPEN_NESTING { mOPEN_NESTING ( ) ; } break ; case 3 : / / net / sf / sugar / scl / SCL . g : 1 : 29 : CLOSE_NESTING { mCLOSE_NESTING ( ) ; } break ; case 4 : / / net / sf / sugar / scl / SCL . g : 1 : 43 : ASSIGNMENT_OP { mASSIGNMENT_OP ( ) ; } break ; case 5 : / / net / sf / sugar / scl / SCL . g : 1 : 57 : VALID_NAME_CHARS { mVALID_NAME_CHARS ( ) ; } break ; case 6 : / / net / sf / sugar / scl / SCL . g : 1 : 74 : WS { mWS ( ) ; } break ; case 7 : / / net / sf / sugar / scl / SCL . g : 1 : 77 : STRING_LITERAL { mSTRING_LITERAL ( ) ; } break ; case 8 : / / net / sf / sugar / scl / SCL . g : 1 : 92 : START_INCLUDE { mSTART_INCLUDE ( ) ; } break ; case 9 : / / net / sf / sugar / scl / SCL . g : 1 : 106 : END_INCLUDE { mEND_INCLUDE ( ) ; } break ; case 10 : / / net / sf / sugar / scl / SCL . g : 1 : 118 : START_UNPARSED_INCLUDE { mSTART_UNPARSED_INCLUDE ( ) ; } break ; case 11 : / / net / sf / sugar / scl / SCL . g : 1 : 141 : REF_CHAR { mREF_CHAR ( ) ; } break ; case 12 : / / net / sf / sugar / scl / SCL . g : 1 : 150 : QUOTE { mQUOTE ( ) ; } break ; case 13 : / / net / sf / sugar / scl / SCL . g : 1 : 156 : AS_KEYWORD { mAS_KEYWORD ( ) ; } break ; case 14 : / / net / sf / sugar / scl / SCL . g : 1 : 167 : STRING_SEQUENCE_CHAR { mSTRING_SEQUENCE_CHAR ( ) ; } break ; case 15 : / / net / sf / sugar / scl / SCL . g : 1 : 188 : COMMENT { mCOMMENT ( ) ; } break ; case 16 : / / net / sf / sugar / scl / SCL . g : 1 : 196 : LINE_COMMENT { mLINE_COMMENT ( ) ; } break ; } }
void test13 ( ) throws Throwable { char [ ] charArray0 = new char [ 5 ] ; charArray0 [ 0 ] = 'k' ; ANTLRStringStream aNTLRStringStream0 = new ANTLRStringStream ( charArray0 , ( int ) 'k' ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRStringStream0 ) ; sCLLexer0 . nextToken ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SCLLexer ( ) { ; }
void test19 ( ) throws Throwable { char [ ] charArray0 = new char [ 5 ] ; charArray0 [ 0 ] = '#' ; ANTLRStringStream aNTLRStringStream0 = new ANTLRStringStream ( charArray0 , ( int ) ' - ' ) ; RecognizerSharedState recognizerSharedState0 = new RecognizerSharedState ( ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRStringStream0 , recognizerSharedState0 ) ; sCLLexer0 . mTokens ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void mTokens ( ) throws RecognitionException { / / net / sf / sugar / scl / SCL . g : 1 : 8 : ( T__19 | OPEN_NESTING | CLOSE_NESTING | ASSIGNMENT_OP | VALID_NAME_CHARS | WS | STRING_LITERAL | START_INCLUDE | END_INCLUDE | START_UNPARSED_INCLUDE | REF_CHAR | QUOTE | AS_KEYWORD | STRING_SEQUENCE_CHAR | COMMENT | LINE_COMMENT ) int alt8 = 16 ; alt8 = dfa8 . predict ( input ) ; switch ( alt8 ) { case 1 : / / net / sf / sugar / scl / SCL . g : 1 : 10 : T__19 { mT__19 ( ) ; } break ; case 2 : / / net / sf / sugar / scl / SCL . g : 1 : 16 : OPEN_NESTING { mOPEN_NESTING ( ) ; } break ; case 3 : / / net / sf / sugar / scl / SCL . g : 1 : 29 : CLOSE_NESTING { mCLOSE_NESTING ( ) ; } break ; case 4 : / / net / sf / sugar / scl / SCL . g : 1 : 43 : ASSIGNMENT_OP { mASSIGNMENT_OP ( ) ; } break ; case 5 : / / net / sf / sugar / scl / SCL . g : 1 : 57 : VALID_NAME_CHARS { mVALID_NAME_CHARS ( ) ; } break ; case 6 : / / net / sf / sugar / scl / SCL . g : 1 : 74 : WS { mWS ( ) ; } break ; case 7 : / / net / sf / sugar / scl / SCL . g : 1 : 77 : STRING_LITERAL { mSTRING_LITERAL ( ) ; } break ; case 8 : / / net / sf / sugar / scl / SCL . g : 1 : 92 : START_INCLUDE { mSTART_INCLUDE ( ) ; } break ; case 9 : / / net / sf / sugar / scl / SCL . g : 1 : 106 : END_INCLUDE { mEND_INCLUDE ( ) ; } break ; case 10 : / / net / sf / sugar / scl / SCL . g : 1 : 118 : START_UNPARSED_INCLUDE { mSTART_UNPARSED_INCLUDE ( ) ; } break ; case 11 : / / net / sf / sugar / scl / SCL . g : 1 : 141 : REF_CHAR { mREF_CHAR ( ) ; } break ; case 12 : / / net / sf / sugar / scl / SCL . g : 1 : 150 : QUOTE { mQUOTE ( ) ; } break ; case 13 : / / net / sf / sugar / scl / SCL . g : 1 : 156 : AS_KEYWORD { mAS_KEYWORD ( ) ; } break ; case 14 : / / net / sf / sugar / scl / SCL . g : 1 : 167 : STRING_SEQUENCE_CHAR { mSTRING_SEQUENCE_CHAR ( ) ; } break ; case 15 : / / net / sf / sugar / scl / SCL . g : 1 : 188 : COMMENT { mCOMMENT ( ) ; } break ; case 16 : / / net / sf / sugar / scl / SCL . g : 1 : 196 : LINE_COMMENT { mLINE_COMMENT ( ) ; } break ; } }
void test20 ( ) throws Throwable { char [ ] charArray0 = new char [ 9 ] ; charArray0 [ 0 ] = '`' ; ANTLRStringStream aNTLRStringStream0 = new ANTLRStringStream ( charArray0 , 1 ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRStringStream0 ) ; CommonToken commonToken0 = ( CommonToken ) sCLLexer0 . nextToken ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test21 ( ) throws Throwable { char [ ] charArray0 = new char [ 9 ] ; ANTLRStringStream aNTLRStringStream0 = new ANTLRStringStream ( charArray0 , 1 ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRStringStream0 ) ; sCLLexer0 . setBacktrackingLevel ( ( int ) ( byte ) 13 ) ; sCLLexer0 . mLINE_COMMENT ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void mLINE_COMMENT ( ) throws RecognitionException { try { int _type = LINE_COMMENT ; int _channel = DEFAULT_TOKEN_CHANNEL ; / / net / sf / sugar / scl / SCL . g : 287 : 16 : ( ' / / ' ( ~ ( '\\n' | '\\r' ) ) * ( '\\r' ) ? '\\n' ) / / net / sf / sugar / scl / SCL . g : 287 : 19 : ' / / ' ( ~ ( '\\n' | '\\r' ) ) * ( '\\r' ) ? '\\n' { match ( " / / " ) ; / / net / sf / sugar / scl / SCL . g : 287 : 24 : ( ~ ( '\\n' | '\\r' ) ) * loop6 : do { int alt6 = 2 ; int LA6_0 = input . LA ( 1 ) ; if ( ( ( LA6_0 > = '\u0000' & & LA6_0 < = '\t' ) | | ( LA6_0 > = '\u000B' & & LA6_0 < = '\f' ) | | ( LA6_0 > = '\u000E' & & LA6_0 < = '\uFFFF' ) ) ) { alt6 = 1 ; } switch ( alt6 ) { case 1 : / / net / sf / sugar / scl / SCL . g : 287 : 24 : ~ ( '\\n' | '\\r' ) { if ( ( input . LA ( 1 ) > = '\u0000' & & input . LA ( 1 ) < = '\t' ) | | ( input . LA ( 1 ) > = '\u000B' & & input . LA ( 1 ) < = '\f' ) | | ( input . LA ( 1 ) > = '\u000E' & & input . LA ( 1 ) < = '\uFFFF' ) ) { input . consume ( ) ; } else { MismatchedSetException mse = new MismatchedSetException ( null , input ) ; recover ( mse ) ; throw mse ; } } break ; default : break loop6 ; } } while ( true ) ; / / net / sf / sugar / scl / SCL . g : 287 : 38 : ( '\\r' ) ? int alt7 = 2 ; switch ( input . LA ( 1 ) ) { case '\r' : { alt7 = 1 ; } break ; } switch ( alt7 ) { case 1 : / / net / sf / sugar / scl / SCL . g : 287 : 38 : '\\r' { match ( '\r' ) ; } break ; } match ( '\n' ) ; _channel = HIDDEN ; } state . type = _type ; state . channel = _channel ; } finally { } }
void test0 ( ) throws Throwable { IncludeValue includeValue0 = new IncludeValue ( ) ; String string0 = includeValue0 . getPropertyName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPropertyName ( ) { return propertyName ; }
void test1 ( ) throws Throwable { IncludeValue includeValue0 = new IncludeValue ( ) ; includeValue0 . setXPathQuery ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getXPathQuery ( ) { return xPathQuery ; }
void test2 ( ) throws Throwable { IncludeValue includeValue0 = new IncludeValue ( ) ; String string0 = includeValue0 . getXPathQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getXPathQuery ( ) { return xPathQuery ; }
void test3 ( ) throws Throwable { IncludeValue includeValue0 = new IncludeValue ( ) ; includeValue0 . setPropertyName ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFullyResolved ( ) { return fullyResolved ; }
void test0 ( ) throws Throwable { PathConversionUtils pathConversionUtils0 = new PathConversionUtils ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { String string0 = PathConversionUtils . convertToXPath ( "0IA6 . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String convertToXPath ( String key ) { StringBuffer xpath = new StringBuffer ( " / " + SCLParser . SCL_ROOT_ELEMENT + " / " ) . append ( key . replace ( " . " , " / " ) ) ; return xpath . toString ( ) ; }
void test2 ( ) throws Throwable { IIOMetadataNode iIOMetadataNode0 = new IIOMetadataNode ( "\\UbY ! ] LOe < 64" ) ; IIOMetadataNode iIOMetadataNode1 = ( IIOMetadataNode ) PathConversionUtils . processDotDelimitedPath ( ( Element ) iIOMetadataNode0 , "\\UbY ! ] LOe < 64" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Element processDotDelimitedPath ( Element parentElement , String propertyName ) { String [ ] pathSteps = propertyName . split ( "\\ . " ) ; Document doc = parentElement . getOwnerDocument ( ) ; Element currentElement = parentElement ; for ( String step : pathSteps ) { NodeList childNodes = currentElement . getElementsByTagName ( step ) ; if ( childNodes . getLength ( ) < 1 ) { Element newElement = doc . createElement ( step ) ; currentElement . appendChild ( newElement ) ; currentElement = newElement ; } else { currentElement = ( Element ) childNodes . item ( 0 ) ; } } return currentElement ; }
void test0 ( ) throws Throwable { URI uRI0 = new URI ( "AIy" , "AIy" , "AIy" ) ; IIOMetadataNode iIOMetadataNode0 = new IIOMetadataNode ( "AIy" ) ; DefaultIncludeProcessor defaultIncludeProcessor0 = new DefaultIncludeProcessor ( uRI0 , ( Document ) null ) ; defaultIncludeProcessor0 . prepareIncludeValue ( ( Element ) iIOMetadataNode0 , "AIy" , "AIy" , uRI0 , "file" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void prepareIncludeValue ( Element parentElement , String propertyName , String includeLocation , URI parentLocation , String xpathQuery ) throws IncludeException ; void resolveIncludes ( Document currentDocument ) throws IncludeException ; void loadUnparsedInclude ( Element parentElement , String propertyName , String includeLocation , URI parentLocation ) throws IncludeException ; }
void test1 ( ) throws Throwable { URI uRI0 = new URI ( "AIy" , "AIy" , "AIy" ) ; IIOMetadataNode iIOMetadataNode0 = new IIOMetadataNode ( "AIy" ) ; DefaultIncludeProcessor defaultIncludeProcessor0 = new DefaultIncludeProcessor ( uRI0 , ( Document ) null ) ; defaultIncludeProcessor0 . prepareInclude ( ( Element ) iIOMetadataNode0 , "file" , uRI0 , "AIy" ) ; defaultIncludeProcessor0 . prepareIncludeValue ( ( Element ) iIOMetadataNode0 , "file" , "file" , uRI0 , "file" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void prepareIncludeValue ( Element parentElement , String propertyName , String includeLocation , URI parentLocation , String xpathQuery ) throws IncludeException ; void resolveIncludes ( Document currentDocument ) throws IncludeException ; void loadUnparsedInclude ( Element parentElement , String propertyName , String includeLocation , URI parentLocation ) throws IncludeException ; }
void test6 ( ) throws Throwable { URI uRI0 = new URI ( "classpath" , "classpath" , "classpath" ) ; IIOMetadataNode iIOMetadataNode0 = new IIOMetadataNode ( "classpath" ) ; DefaultIncludeProcessor defaultIncludeProcessor0 = new DefaultIncludeProcessor ( uRI0 , ( Document ) null ) ; defaultIncludeProcessor0 . prepareInclude ( ( Element ) iIOMetadataNode0 , "file" , uRI0 , "classpath" ) ; defaultIncludeProcessor0 . prepareInclude ( ( Element ) iIOMetadataNode0 , "file" , uRI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void prepareInclude ( Element parentElement , String includeLocation , URI parentLocation ) throws IncludeException ; void prepareInclude ( Element parentElement , String includeLocation , URI parentLocation , String xpathQuery ) throws IncludeException ; void prepareIncludeValue ( Element parentElement , String propertyName , String includeLocation , URI parentLocation , String xpathQuery ) throws IncludeException ; void resolveIncludes ( Document currentDocument ) throws IncludeException ; void loadUnparsedInclude ( Element parentElement , String propertyName , String includeLocation , URI parentLocation ) throws IncludeException ; }
void test7 ( ) throws Throwable { URI uRI0 = new URI ( "" ) ; IIOMetadataNode iIOMetadataNode0 = new IIOMetadataNode ( "" ) ; DefaultIncludeProcessor defaultIncludeProcessor0 = new DefaultIncludeProcessor ( uRI0 , ( Document ) null ) ; defaultIncludeProcessor0 . prepareInclude ( ( Element ) iIOMetadataNode0 , "" , uRI0 ) ; defaultIncludeProcessor0 . prepareInclude ( ( Element ) iIOMetadataNode0 , "" , uRI0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void prepareInclude ( Element parentElement , String includeLocation , URI parentLocation ) throws IncludeException ; void prepareInclude ( Element parentElement , String includeLocation , URI parentLocation , String xpathQuery ) throws IncludeException ; void prepareIncludeValue ( Element parentElement , String propertyName , String includeLocation , URI parentLocation , String xpathQuery ) throws IncludeException ; void resolveIncludes ( Document currentDocument ) throws IncludeException ; void loadUnparsedInclude ( Element parentElement , String propertyName , String includeLocation , URI parentLocation ) throws IncludeException ; }
void test0 ( ) throws Throwable { IncludePartial includePartial0 = new IncludePartial ( ) ; String string0 = includePartial0 . getXPathQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getXPathQuery ( ) { return xPathQuery ; }
void test1 ( ) throws Throwable { IncludePartial includePartial0 = new IncludePartial ( ) ; includePartial0 . setXPathQuery ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test0 ( ) throws Throwable { Include include0 = new Include ( ) ; IncludeHolder includeHolder0 = include0 . getIncludeHolder ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IncludeHolder getIncludeHolder ( ) { return includeHolder ; }
void test1 ( ) throws Throwable { Include include0 = new Include ( ) ; IIOMetadataNode iIOMetadataNode0 = new IIOMetadataNode ( "" ) ; include0 . setParentElement ( ( Element ) iIOMetadataNode0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setParentElement ( Element parentElement ) { this . parentElement = parentElement ; }
void test2 ( ) throws Throwable { Include include0 = new Include ( ) ; URI uRI0 = include0 . getIncludeURI ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" URI getIncludeURI ( ) { return includeURI ; }
void test3 ( ) throws Throwable { Include include0 = new Include ( ) ; URI uRI0 = include0 . getParentURI ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" URI getParentURI ( ) { return parentURI ; }
void test4 ( ) throws Throwable { Include include0 = new Include ( ) ; boolean boolean0 = include0 . isFullyResolved ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFullyResolved ( ) { return fullyResolved ; }
void test5 ( ) throws Throwable { Include include0 = new Include ( ) ; String string0 = include0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test6 ( ) throws Throwable { Include include0 = new Include ( ) ; include0 . setIncludeHolder ( ( IncludeHolder ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test7 ( ) throws Throwable { Include include0 = new Include ( ) ; include0 . setParentURI ( ( URI ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFullyResolved ( ) { return fullyResolved ; }
void test8 ( ) throws Throwable { Include include0 = new Include ( ) ; Element element0 = include0 . getParentElement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Element getParentElement ( ) { return parentElement ; }
void test9 ( ) throws Throwable { Include include0 = new Include ( ) ; include0 . setFullyResolved ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { if ( this . resultFile ! = null ) { return this . resultFile . getAbsolutePath ( ) ; } if ( this . resultString ! = null ) { return this . resultString ; } if ( this . resultDouble ! = null ) { return this . resultDouble . toString ( ) ; } if ( this . resultBoolean ! = null ) { return this . resultBoolean . toString ( ) ; } if ( this . resultDate ! = null ) { return this . resultDate . toString ( ) ; } if ( this . resultURI ! = null ) { return this . resultURI . toString ( ) ; } return "FSPathResult : empty" ; }
void test10 ( ) throws Throwable { Include include0 = new Include ( ) ; include0 . setIncludeURI ( ( URI ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFullyResolved ( ) { return fullyResolved ; }
void test0 ( ) throws Throwable { LocalReference localReference0 = new LocalReference ( ) ; localReference0 . setResolved ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isResolved ( ) { return resolved ; }
void test1 ( ) throws Throwable { LocalReference localReference0 = new LocalReference ( ) ; localReference0 . setParentElement ( ( Element ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isResolved ( ) { return resolved ; }
void test2 ( ) throws Throwable { LocalReference localReference0 = new LocalReference ( ) ; localReference0 . setXPathQuery ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getXPathQuery ( ) { return xPathQuery ; }
void test3 ( ) throws Throwable { LocalReference localReference0 = new LocalReference ( ) ; String string0 = localReference0 . getXPathQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getXPathQuery ( ) { return xPathQuery ; }
void test4 ( ) throws Throwable { LocalReference localReference0 = new LocalReference ( ) ; Element element0 = localReference0 . getParentElement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Element getParentElement ( ) { return parentElement ; }
void test5 ( ) throws Throwable { LocalReference localReference0 = new LocalReference ( ) ; boolean boolean0 = localReference0 . isResolved ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isResolved ( ) { return resolved ; }
void test0 ( ) throws Throwable { ANTLRStringStream aNTLRStringStream0 = new ANTLRStringStream ( ) ; RecognizerSharedState recognizerSharedState0 = new RecognizerSharedState ( ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRStringStream0 ) ; BufferedTokenStream bufferedTokenStream0 = new BufferedTokenStream ( ( TokenSource ) sCLLexer0 ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) bufferedTokenStream0 , recognizerSharedState0 ) ; sCLParser0 . varName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SCLParser . varName_return varName ( ) throws RecognitionException { SCLParser . varName_return retval = new SCLParser . varName_return ( ) ; retval . start = input . LT ( 1 ) ; try { / / net / sf / sugar / scl / SCL . g : 218 : 12 : ( ( VALID_NAME_CHARS ) + ) / / net / sf / sugar / scl / SCL . g : 218 : 14 : ( VALID_NAME_CHARS ) + { / / net / sf / sugar / scl / SCL . g : 218 : 14 : ( VALID_NAME_CHARS ) + int cnt9 = 0 ; loop9 : do { int alt9 = 2 ; switch ( input . LA ( 1 ) ) { case VALID_NAME_CHARS : { alt9 = 1 ; } break ; } switch ( alt9 ) { case 1 : / / net / sf / sugar / scl / SCL . g : 218 : 14 : VALID_NAME_CHARS { match ( input , VALID_NAME_CHARS , FOLLOW_VALID_NAME_CHARS_in_varName298 ) ; } break ; default : if ( cnt9 > = 1 ) break loop9 ; EarlyExitException eee = new EarlyExitException ( 9 , input ) ; throw eee ; } cnt9 + + ; } while ( true ) ; } retval . stop = input . LT ( - 1 ) ; } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; } finally { } return retval ; }
void test1 ( ) throws Throwable { UnbufferedTokenStream unbufferedTokenStream0 = new UnbufferedTokenStream ( ( TokenSource ) null ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) unbufferedTokenStream0 ) ; sCLParser0 . prepareLocalRefTree ( ( Element ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void prepareLocalRefTree ( Element parentElement , String xPathExpression ) { LocalReference localRef = new LocalReference ( ) { { setParentElement ( parentElement ) ; setXPathQuery ( xPathExpression ) ; } } ; this . localRefs . add ( localRef ) ; }
void test2 ( ) throws Throwable { ANTLRReaderStream aNTLRReaderStream0 = new ANTLRReaderStream ( ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRReaderStream0 ) ; UnbufferedTokenStream unbufferedTokenStream0 = new UnbufferedTokenStream ( ( TokenSource ) sCLLexer0 ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) unbufferedTokenStream0 ) ; IIOMetadataNode iIOMetadataNode0 = new IIOMetadataNode ( ( String ) null ) ; sCLParser0 . prepareLocalRef ( ( Element ) iIOMetadataNode0 , ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void prepareLocalRef ( Element parentElement , String attributeName , String xPathExpression ) { LocalAttributeReference localRef = new LocalAttributeReference ( ) { { setParentElement ( parentElement ) ; setXPathQuery ( xPathExpression ) ; setAttributeName ( attributeName ) ; } } ; this . localRefs . add ( localRef ) ; }
void test3 ( ) throws Throwable { ANTLRInputStream aNTLRInputStream0 = new ANTLRInputStream ( ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRInputStream0 , ( RecognizerSharedState ) null ) ; CommonTokenStream commonTokenStream0 = new CommonTokenStream ( ( TokenSource ) sCLLexer0 ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) commonTokenStream0 ) ; sCLParser0 . namespaceName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SCLParser . namespaceName_return namespaceName ( ) throws RecognitionException { SCLParser . namespaceName_return retval = new SCLParser . namespaceName_return ( ) ; retval . start = input . LT ( 1 ) ; SCLParser . compositeNamespaceName_return compositeNamespaceName1 = null ; try { / / net / sf / sugar / scl / SCL . g : 179 : 16 : ( varName | compositeNamespaceName ) int alt3 = 2 ; alt3 = dfa3 . predict ( input ) ; switch ( alt3 ) { case 1 : / / net / sf / sugar / scl / SCL . g : 179 : 18 : varName { pushFollow ( FOLLOW_varName_in_namespaceName132 ) ; varName ( ) ; state . _fsp - - ; this . elements . push ( addChildElement ( this . elements . peek ( ) , input . toString ( retval . start , input . LT ( - 1 ) ) ) ) ; } break ; case 2 : / / net / sf / sugar / scl / SCL . g : 180 : 9 : compositeNamespaceName { pushFollow ( FOLLOW_compositeNamespaceName_in_namespaceName145 ) ; compositeNamespaceName1 = compositeNamespaceName ( ) ; state . _fsp - - ; this . elements . push ( addChildElements ( this . elements . peek ( ) , ( compositeNamespaceName1 ! = null ? input . toString ( compositeNamespaceName1 . start , compositeNamespaceName1 . stop ) : null ) ) ) ; } break ; } retval . stop = input . LT ( - 1 ) ; } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; } finally { } return retval ; }
void test4 ( ) throws Throwable { TokenRewriteStream tokenRewriteStream0 = new TokenRewriteStream ( ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) tokenRewriteStream0 , ( RecognizerSharedState ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDescription ( ) { return this . description ; }
void test5 ( ) throws Throwable { ANTLRReaderStream aNTLRReaderStream0 = new ANTLRReaderStream ( ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRReaderStream0 ) ; UnbufferedTokenStream unbufferedTokenStream0 = new UnbufferedTokenStream ( ( TokenSource ) sCLLexer0 ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) unbufferedTokenStream0 ) ; / / Undeclared exception ! try { sCLParser0 . varValue ( ) ; fail ( "Expecting exception : NullPointerException" ) ; } catch ( NullPointerException e ) { } "<AssertPlaceHolder>" ; } "<FocalMethod>" SCLParser . varValue_return varValue ( ) throws RecognitionException { SCLParser . varValue_return retval = new SCLParser . varValue_return ( ) ; retval . start = input . LT ( 1 ) ; try { / / net / sf / sugar / scl / SCL . g : 220 : 13 : ( STRING_LITERAL ) / / net / sf / sugar / scl / SCL . g : 220 : 15 : STRING_LITERAL { match ( input , STRING_LITERAL , FOLLOW_STRING_LITERAL_in_varValue312 ) ; } retval . stop = input . LT ( - 1 ) ; } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; } finally { } return retval ; }
void test6 ( ) throws Throwable { ANTLRStringStream aNTLRStringStream0 = new ANTLRStringStream ( ) ; RecognizerSharedState recognizerSharedState0 = new RecognizerSharedState ( ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRStringStream0 ) ; BufferedTokenStream bufferedTokenStream0 = new BufferedTokenStream ( ( TokenSource ) sCLLexer0 ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) bufferedTokenStream0 , recognizerSharedState0 ) ; sCLParser0 . includeValue ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SCLParser . includeValue_return includeValue ( ) throws RecognitionException { SCLParser . includeValue_return retval = new SCLParser . includeValue_return ( ) ; retval . start = input . LT ( 1 ) ; Token s1 = null ; Token s2 = null ; try { / / net / sf / sugar / scl / SCL . g : 224 : 6 : ( START_INCLUDE s1 = STRING_LITERAL AS_KEYWORD s2 = STRING_LITERAL END_INCLUDE ) / / net / sf / sugar / scl / SCL . g : 224 : 8 : START_INCLUDE s1 = STRING_LITERAL AS_KEYWORD s2 = STRING_LITERAL END_INCLUDE { match ( input , START_INCLUDE , FOLLOW_START_INCLUDE_in_includeValue334 ) ; s1 = ( Token ) match ( input , STRING_LITERAL , FOLLOW_STRING_LITERAL_in_includeValue338 ) ; match ( input , AS_KEYWORD , FOLLOW_AS_KEYWORD_in_includeValue340 ) ; s2 = ( Token ) match ( input , STRING_LITERAL , FOLLOW_STRING_LITERAL_in_includeValue344 ) ; match ( input , END_INCLUDE , FOLLOW_END_INCLUDE_in_includeValue346 ) ; retval . includeLocation = ( s1 ! = null ? s1 . getText ( ) : null ) ; retval . xPathQuery = ( s2 ! = null ? s2 . getText ( ) : null ) ; } retval . stop = input . LT ( - 1 ) ; } catch ( RecognitionException re ) { reportError ( re ) ; recover ( input , re ) ; } finally { } return retval ; }
void test7 ( ) throws Throwable { ANTLRInputStream aNTLRInputStream0 = new ANTLRInputStream ( ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRInputStream0 , ( RecognizerSharedState ) null ) ; CommonTokenStream commonTokenStream0 = new CommonTokenStream ( ( TokenSource ) sCLLexer0 ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) commonTokenStream0 ) ; sCLParser0 . compositeNamespaceName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { try { return ( ( Double ) getXPath ( ) . evaluate ( "count ( " + allTextNodesExpr + " ) " , this . doc , XPathConstants . NUMBER ) ) . intValue ( ) ; } catch ( XPathExpressionException xpee ) { return - 1 ; } }
void test10 ( ) throws Throwable { LegacyCommonTokenStream legacyCommonTokenStream0 = new LegacyCommonTokenStream ( ) ; RecognizerSharedState recognizerSharedState0 = new RecognizerSharedState ( ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) legacyCommonTokenStream0 , recognizerSharedState0 ) ; sCLParser0 . setIncludeProcessor ( ( IncludeProcessor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getGrammarFileName ( ) { return "net / sf / sugar / scl / SCL . g" ; }
void test11 ( ) throws Throwable { UnbufferedTokenStream unbufferedTokenStream0 = new UnbufferedTokenStream ( ( TokenSource ) null ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) unbufferedTokenStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String sanitiseText ( String rawText ) { String unquotedText = stripQuotes ( rawText ) ; return normaliseEscapeChars ( unquotedText ) ; }
void test12 ( ) throws Throwable { LegacyCommonTokenStream legacyCommonTokenStream0 = new LegacyCommonTokenStream ( ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) legacyCommonTokenStream0 ) ; DefaultLocalReferenceProcessor defaultLocalReferenceProcessor0 = ( DefaultLocalReferenceProcessor ) sCLParser0 . getLocalReferenceProcessor ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" LocalReferenceProcessor getLocalReferenceProcessor ( ) { return localReferenceProcessor ; }
void test14 ( ) throws Throwable { CommonTokenStream commonTokenStream0 = new CommonTokenStream ( ) ; RecognizerSharedState recognizerSharedState0 = new RecognizerSharedState ( ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) commonTokenStream0 , recognizerSharedState0 ) ; DefaultLocalReferenceProcessor defaultLocalReferenceProcessor0 = new DefaultLocalReferenceProcessor ( ) ; sCLParser0 . setLocalReferenceProcessor ( ( LocalReferenceProcessor ) defaultLocalReferenceProcessor0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setLocalReferenceProcessor ( LocalReferenceProcessor processor ) { localReferenceProcessor = processor ; }
void test15 ( ) throws Throwable { CommonTokenStream commonTokenStream0 = new CommonTokenStream ( ) ; RecognizerSharedState recognizerSharedState0 = new RecognizerSharedState ( ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) commonTokenStream0 , recognizerSharedState0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Document getRootDocument ( ) { return this . doc ; }
void test16 ( ) throws Throwable { ANTLRInputStream aNTLRInputStream0 = new ANTLRInputStream ( ) ; SCLLexer sCLLexer0 = new SCLLexer ( ( CharStream ) aNTLRInputStream0 , ( RecognizerSharedState ) null ) ; CommonTokenStream commonTokenStream0 = new CommonTokenStream ( ( TokenSource ) sCLLexer0 ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) commonTokenStream0 ) ; IIOMetadataNode iIOMetadataNode0 = new IIOMetadataNode ( "" ) ; IIOMetadataNode iIOMetadataNode1 = ( IIOMetadataNode ) sCLParser0 . addChildElements ( ( Element ) iIOMetadataNode0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Element addChildElements ( Element currentElement , String compositePath ) { return processDotDelimitedPath ( currentElement , compositePath ) ; }
void test19 ( ) throws Throwable { LegacyCommonTokenStream legacyCommonTokenStream0 = new LegacyCommonTokenStream ( ) ; RecognizerSharedState recognizerSharedState0 = new RecognizerSharedState ( ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) legacyCommonTokenStream0 , recognizerSharedState0 ) ; List < LocalReference > list0 = sCLParser0 . getLocalRefs ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return this . size ( ) < 1 ; }
void test20 ( ) throws Throwable { UnbufferedTokenStream unbufferedTokenStream0 = new UnbufferedTokenStream ( ( TokenSource ) null ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) unbufferedTokenStream0 ) ; URI uRI0 = sCLParser0 . getRootSCLFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" URI getRootSCLFile ( ) { return this . rootSCLFile ; }
void test23 ( ) throws Throwable { TokenRewriteStream tokenRewriteStream0 = new TokenRewriteStream ( ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) tokenRewriteStream0 , ( RecognizerSharedState ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getGrammarFileName ( ) { return "net / sf / sugar / scl / SCL . g" ; }
void test24 ( ) throws Throwable { LegacyCommonTokenStream legacyCommonTokenStream0 = new LegacyCommonTokenStream ( ) ; RecognizerSharedState recognizerSharedState0 = new RecognizerSharedState ( ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) legacyCommonTokenStream0 , recognizerSharedState0 ) ; sCLParser0 . setRootSCLFile ( ( URI ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setRootSCLFile ( URI rootSCLFile ) { this . rootSCLFile = rootSCLFile ; }
void test28 ( ) throws Throwable { LegacyCommonTokenStream legacyCommonTokenStream0 = new LegacyCommonTokenStream ( ) ; RecognizerSharedState recognizerSharedState0 = new RecognizerSharedState ( ) ; SCLParser sCLParser0 = new SCLParser ( ( TokenStream ) legacyCommonTokenStream0 , recognizerSharedState0 ) ; IncludeProcessor includeProcessor0 = sCLParser0 . getIncludeProcessor ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IncludeProcessor getIncludeProcessor ( ) { return this . includeProcessor ; }
