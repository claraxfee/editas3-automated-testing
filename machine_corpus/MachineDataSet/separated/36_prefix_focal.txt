void test0 ( ) throws Throwable { TableOrderer tableOrderer0 = new TableOrderer ( ) ; LinkedList < Table > linkedList0 = new LinkedList < Table > ( ) ; LinkedList < ForeignKeyConstraint > linkedList1 = new LinkedList < ForeignKeyConstraint > ( ) ; List < Table > list0 = tableOrderer0 . getTablesOrderedByRI ( ( Collection < Table > ) linkedList0 , ( Collection < ForeignKeyConstraint > ) linkedList1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < Table > getTablesOrderedByRI ( Collection < Table > tables , Collection < ForeignKeyConstraint > recursiveConstraints ) { List < Table > heads = new ArrayList < Table > ( ) ; List < Table > tails = new ArrayList < Table > ( ) ; List < Table > remainingTables = new ArrayList < Table > ( tables ) ; List < Table > unattached = new ArrayList < Table > ( ) ; / / first pass to gather the 'low hanging fruit' for ( Iterator < Table > iter = remainingTables . iterator ( ) ; iter . hasNext ( ) ; ) { Table table = iter . next ( ) ; if ( table . isRemote ( ) ) { / / ignore remote tables since there's no way to deal with them table . unlinkParents ( ) ; table . unlinkChildren ( ) ; iter . remove ( ) ; } else if ( table . isLeaf ( ) & & table . isRoot ( ) ) { / / floater , so add it to 'unattached' unattached . add ( table ) ; iter . remove ( ) ; } } unattached = sortTrimmedLevel ( unattached ) ; boolean prunedNonReals = false ; while ( ! remainingTables . isEmpty ( ) ) { int tablesLeft = remainingTables . size ( ) ; tails . addAll ( 0 , trimLeaves ( remainingTables ) ) ; heads . addAll ( trimRoots ( remainingTables ) ) ; / / if we could't trim anything then there's recursion . . . . / / resolve it by removing a constraint , one by one , 'till the tables are all trimmed if ( tablesLeft = = remainingTables . size ( ) ) { if ( ! prunedNonReals ) { / / get ride of everything that isn't explicitly specified by the database for ( Table table : remainingTables ) { table . removeNonRealForeignKeys ( ) ; } prunedNonReals = true ; continue ; } boolean foundSimpleRecursion = false ; for ( Table potentialRecursiveTable : remainingTables ) { ForeignKeyConstraint recursiveConstraint = potentialRecursiveTable . removeSelfReferencingConstraint ( ) ; if ( recursiveConstraint ! = null ) { recursiveConstraints . add ( recursiveConstraint ) ; foundSimpleRecursion = true ; } } if ( ! foundSimpleRecursion ) { / / expensive comparison , but we're down to the end of the tables so it shouldn't really matter Set < Table > byParentChildDelta = new TreeSet < Table > ( new Comparator < Table > ( ) { / / sort on the delta between number of parents and kids so we can / / target the tables with the biggest delta and therefore the most impact / / on reducing the smaller of the two int compare ( Table table1 , Table table2 ) { int rc = Math . abs ( table2 . getNumChildren ( ) - table2 . getNumParents ( ) ) - Math . abs ( table1 . getNumChildren ( ) - table1 . getNumParents ( ) ) ; if ( rc = = 0 ) rc = table1 . compareTo ( table2 ) ; return rc ; } } ) ; byParentChildDelta . addAll ( remainingTables ) ; Table recursiveTable = byParentChildDelta . iterator ( ) . next ( ) ; / / this one has the largest delta ForeignKeyConstraint removedConstraint = recursiveTable . removeAForeignKeyConstraint ( ) ; recursiveConstraints . add ( removedConstraint ) ; } } } / / we've gathered all the heads and tails , so combine them here moving 'unattached' tables to the end List < Table > ordered = new ArrayList < Table > ( heads . size ( ) + tails . size ( ) ) ; ordered . addAll ( heads ) ; heads = null ; / / allow gc ASAP ordered . addAll ( tails ) ; tails = null ; / / allow gc ASAP ordered . addAll ( unattached ) ; return ordered ; }
void test0 ( ) throws Throwable { TreeSet < Table > treeSet0 = new TreeSet < Table > ( ) ; List < ImpliedForeignKeyConstraint > list0 = DbAnalyzer . getImpliedConstraints ( ( Collection < Table > ) treeSet0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < ImpliedForeignKeyConstraint > getImpliedConstraints ( Collection < Table > tables ) { List < TableColumn > columnsWithoutParents = new ArrayList < TableColumn > ( ) ; Map < TableColumn , Table > allPrimaries = new TreeMap < TableColumn , Table > ( new Comparator < TableColumn > ( ) { int compare ( TableColumn column1 , TableColumn column2 ) { int rc = column1 . getName ( ) . compareToIgnoreCase ( column2 . getName ( ) ) ; if ( rc = = 0 ) rc = column1 . getType ( ) . compareToIgnoreCase ( column2 . getType ( ) ) ; if ( rc = = 0 ) rc = column1 . getLength ( ) - column2 . getLength ( ) ; return rc ; } } ) ; int duplicatePrimaries = 0 ; / / gather all the primary key columns and columns without parents for ( Table table : tables ) { List < TableColumn > tablePrimaries = table . getPrimaryColumns ( ) ; if ( tablePrimaries . size ( ) = = 1 ) { / / can't match up multiples . . . yet . . . for ( TableColumn primary : tablePrimaries ) { if ( primary . allowsImpliedChildren ( ) & & allPrimaries . put ( primary , table ) ! = null ) + + duplicatePrimaries ; } } for ( TableColumn column : table . getColumns ( ) ) { if ( ! column . isForeignKey ( ) & & column . allowsImpliedParents ( ) ) columnsWithoutParents . add ( column ) ; } } / / if more than half of the tables have the same primary key then / / it's most likely a database where primary key names aren't unique / / ( e . g . they all have a primary key named 'ID' ) if ( duplicatePrimaries > allPrimaries . size ( ) ) / / bizarre logic , but it does approximately what we need return new ArrayList < ImpliedForeignKeyConstraint > ( ) ; sortColumnsByTable ( columnsWithoutParents ) ; List < ImpliedForeignKeyConstraint > impliedConstraints = new ArrayList < ImpliedForeignKeyConstraint > ( ) ; for ( TableColumn childColumn : columnsWithoutParents ) { Table primaryTable = allPrimaries . get ( childColumn ) ; if ( primaryTable ! = null & & primaryTable ! = childColumn . getTable ( ) ) { TableColumn parentColumn = primaryTable . getColumn ( childColumn . getName ( ) ) ; / / make sure the potential child - > parent relationships isn't already a / / parent - > child relationship if ( parentColumn . getParentConstraint ( childColumn ) = = null ) { / / ok , we've found a potential relationship with a column matches a primary / / key column in another table and isn't already related to that column impliedConstraints . add ( new ImpliedForeignKeyConstraint ( parentColumn , childColumn ) ) ; } } } return impliedConstraints ; }
void test1 ( ) throws Throwable { HashSet < Table > hashSet0 = new HashSet < Table > ( ) ; List < Table > list0 = DbAnalyzer . getTablesWithoutIndexes ( ( Collection < Table > ) hashSet0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < Table > getTablesWithoutIndexes ( Collection < Table > tables ) { List < Table > withoutIndexes = new ArrayList < Table > ( ) ; for ( Table table : tables ) { if ( table . getIndexes ( ) . size ( ) = = 0 & & ! table . isView ( ) & & ! table . isLogical ( ) ) withoutIndexes . add ( table ) ; } return sortTablesByName ( withoutIndexes ) ; }
void test2 ( ) throws Throwable { DbAnalyzer dbAnalyzer0 = new DbAnalyzer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test5 ( ) throws Throwable { HashMap < String , Table > hashMap0 = new HashMap < String , Table > ( ) ; List < RailsForeignKeyConstraint > list0 = DbAnalyzer . getRailsConstraints ( ( Map < String , Table > ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < RailsForeignKeyConstraint > getRailsConstraints ( Map < String , Table > tables ) { List < RailsForeignKeyConstraint > railsConstraints = new ArrayList < RailsForeignKeyConstraint > ( tables . size ( ) ) ; / / iterate thru each column in each table looking for columns that / / match Rails naming conventions for ( Table table : tables . values ( ) ) { for ( TableColumn column : table . getColumns ( ) ) { String columnName = column . getName ( ) . toLowerCase ( ) ; if ( ! column . isForeignKey ( ) & & column . allowsImpliedParents ( ) & & columnName . endsWith ( "_id" ) ) { String singular = columnName . substring ( 0 , columnName . length ( ) - 3 ) ; String primaryTableName = Inflection . pluralize ( singular ) ; Table primaryTable = tables . get ( primaryTableName ) ; if ( primaryTable ! = null ) { TableColumn primaryColumn = primaryTable . getColumn ( "ID" ) ; if ( primaryColumn ! = null ) { railsConstraints . add ( new RailsForeignKeyConstraint ( primaryColumn , column ) ) ; } } } } } return railsConstraints ; }
void test7 ( ) throws Throwable { TreeSet < Table > treeSet0 = new TreeSet < Table > ( ) ; List < ForeignKeyConstraint > list0 = DbAnalyzer . getForeignKeyConstraints ( ( Collection < Table > ) treeSet0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < ForeignKeyConstraint > getForeignKeyConstraints ( Collection < Table > tables ) { List < ForeignKeyConstraint > constraints = new ArrayList < ForeignKeyConstraint > ( ) ; for ( Table table : tables ) { constraints . addAll ( table . getForeignKeys ( ) ) ; } return constraints ; }
void test9 ( ) throws Throwable { TreeSet < Table > treeSet0 = new TreeSet < Table > ( ) ; List < Table > list0 = DbAnalyzer . getOrphans ( ( Collection < Table > ) treeSet0 ) ; List < Table > list1 = DbAnalyzer . getTablesWithIncrementingColumnNames ( ( Collection < Table > ) list0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object other ) { if ( other = = null | | ! ( other instanceof Version ) ) return false ; return compareTo ( ( Version ) other ) = = 0 ; }
void test11 ( ) throws Throwable { LinkedHashSet < Table > linkedHashSet0 = new LinkedHashSet < Table > ( ) ; List < TableColumn > list0 = DbAnalyzer . getMustBeUniqueNullableColumns ( ( Collection < Table > ) linkedHashSet0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < TableColumn > getMustBeUniqueNullableColumns ( Collection < Table > tables ) { List < TableColumn > uniqueNullables = new ArrayList < TableColumn > ( ) ; for ( Table table : tables ) { for ( TableIndex index : table . getIndexes ( ) ) { if ( index . isUniqueNullable ( ) ) { uniqueNullables . addAll ( index . getColumns ( ) ) ; } } } return sortColumnsByTable ( uniqueNullables ) ; }
void test15 ( ) throws Throwable { TreeSet < Table > treeSet0 = new TreeSet < Table > ( ) ; List < Table > list0 = DbAnalyzer . getOrphans ( ( Collection < Table > ) treeSet0 ) ; List < Table > list1 = DbAnalyzer . getTablesWithOneColumn ( ( Collection < Table > ) list0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < Table > getTablesWithOneColumn ( Collection < Table > tables ) { List < Table > singleColumnTables = new ArrayList < Table > ( ) ; for ( Table table : tables ) { if ( table . getColumns ( ) . size ( ) = = 1 ) singleColumnTables . add ( table ) ; } return sortTablesByName ( singleColumnTables ) ; }
void test17 ( ) throws Throwable { TreeSet < Table > treeSet0 = new TreeSet < Table > ( ) ; List < TableColumn > list0 = DbAnalyzer . getDefaultNullStringColumns ( ( Collection < Table > ) treeSet0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < TableColumn > getDefaultNullStringColumns ( Collection < Table > tables ) { List < TableColumn > defaultNullStringColumns = new ArrayList < TableColumn > ( ) ; for ( Table table : tables ) { for ( TableColumn column : table . getColumns ( ) ) { Object defaultValue = column . getDefaultValue ( ) ; if ( defaultValue ! = null & & defaultValue instanceof String ) { String defaultString = defaultValue . toString ( ) ; if ( defaultString . trim ( ) . equalsIgnoreCase ( "'null'" ) ) { defaultNullStringColumns . add ( column ) ; } } } } return sortColumnsByTable ( defaultNullStringColumns ) ; }
void test0 ( ) throws Throwable { Revision revision0 = new Revision ( ) ; String string0 = revision0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return rev ; }
void test0 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "dITHT ; Ep0 - GT { & " , 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteRule ( ) { return deleteRule ; }
void test1 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "p" , 1678 , 1678 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test2 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "" , 2 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDeleteRuleName ( ) { switch ( getDeleteRule ( ) ) { case importedKeyCascade : return "Cascade on delete" ; case importedKeyRestrict : case importedKeyNoAction : return "Restrict delete" ; case importedKeySetNull : return "Null on delete" ; default : return "" ; } }
void test3 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "WuoY^l | : H ) 7Vk3%" , 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compareTo ( Routine other ) { int rc = getName ( ) . compareTo ( other . getName ( ) ) ; if ( rc = = 0 ) rc = getType ( ) . compareTo ( other . getType ( ) ) ; if ( rc = = 0 ) rc = String . valueOf ( getReturnType ( ) ) . compareTo ( String . valueOf ( other . getReturnType ( ) ) ) ; if ( rc = = 0 ) rc = getDefinition ( ) . compareTo ( other . getDefinition ( ) ) ; return rc ; }
void test4 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "WuoY^l | : H ) 7Vk3%" , 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRestrictDelete ( ) { return getDeleteRule ( ) = = importedKeyNoAction | | getDeleteRule ( ) = = importedKeyRestrict ; }
void test5 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "dITHT ; Ep0 - GT { & " , 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDeleteRuleName ( ) { switch ( getDeleteRule ( ) ) { case importedKeyCascade : return "Cascade on delete" ; case importedKeyRestrict : case importedKeyNoAction : return "Restrict delete" ; case importedKeySetNull : return "Null on delete" ; default : return "" ; } }
void test6 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "WuoY^l | : H ) 7Vk3%" , 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRestrictDelete ( ) { return getDeleteRule ( ) = = importedKeyNoAction | | getDeleteRule ( ) = = importedKeyRestrict ; }
void test7 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "p" , 1678 , 1678 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test8 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "dITHT ; Ep0 - GT { & " , 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDeleteRuleName ( ) { switch ( getDeleteRule ( ) ) { case importedKeyCascade : return "Cascade on delete" ; case importedKeyRestrict : case importedKeyNoAction : return "Restrict delete" ; case importedKeySetNull : return "Null on delete" ; default : return "" ; } }
void test9 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "" , 2 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test10 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "HfUR" , 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test11 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "@0pGN$SqPl87 ( 3" , 690 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test12 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "yITHT ; Ep0 - GT | & " , ( - 304 ) , ( - 304 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteRule ( ) { return deleteRule ; }
void test13 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "" , 2 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test14 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "dITHT ; Ep0 - GT { & " , 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test15 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "" , 2 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test16 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "WuoY^l | : H ) 7Vk3%" , 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test17 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "yITHT ; Ep0 - GT | & " , ( - 304 ) , ( - 304 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteRule ( ) { return deleteRule ; }
void test18 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "dITHT ; Ep0 - GT { & " , 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test19 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "" , 2 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test20 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "@0pGN$SqPl87 ( 3" , 690 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test21 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "yITHT ; Ep0 - GT | & " , ( - 304 ) , ( - 304 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteRule ( ) { return deleteRule ; }
void test22 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "HfUR" , 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test23 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "" , 2 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test24 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "@0pGN$SqPl87 ( 3" , 690 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test25 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "WuoY^l | : H ) 7Vk3%" , ( - 226 ) , ( - 226 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteRule ( ) { return deleteRule ; }
void test26 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "" , 2 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNullOnDelete ( ) { return getDeleteRule ( ) = = importedKeySetNull ; }
void test27 ( ) throws Throwable { ForeignKeyConstraint foreignKeyConstraint0 = new ForeignKeyConstraint ( ( Table ) null , "yITHT ; Ep0 - GT | & " , ( - 304 ) , ( - 304 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateRule ( ) { return updateRule ; }
void test0 ( ) throws Throwable { Routine routine0 = new Routine ( "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , false , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" ) ; List < RoutineParameter > list0 = routine0 . getParameters ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeterministic ( ) { return deterministic ; }
void test1 ( ) throws Throwable { Routine routine0 = new Routine ( "" , "" , ( String ) null , ( String ) null , "" , true , ( String ) null , "" , ( String ) null ) ; String string0 = routine0 . getComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeterministic ( ) { return deterministic ; }
void test2 ( ) throws Throwable { Routine routine0 = new Routine ( "" , "" , "" , "" , "" , false , "" , "" , "" ) ; String string0 = routine0 . getSecurityType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeterministic ( ) { return deterministic ; }
void test3 ( ) throws Throwable { Routine routine0 = new Routine ( "" , "" , ( String ) null , ( String ) null , "" , true , ( String ) null , "" , ( String ) null ) ; String string0 = routine0 . getDataAccess ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeterministic ( ) { return deterministic ; }
void test4 ( ) throws Throwable { Routine routine0 = new Routine ( "" , "" , "" , "" , "" , false , "" , "" , "" ) ; int int0 = routine0 . compareTo ( routine0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeterministic ( ) { return deterministic ; }
void test5 ( ) throws Throwable { Routine routine0 = new Routine ( "" , "" , "" , "" , "" , false , "" , "" , "" ) ; RoutineParameter routineParameter0 = new RoutineParameter ( "" , "" , "" ) ; routine0 . addParameter ( routineParameter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeterministic ( ) { return deterministic ; }
void test6 ( ) throws Throwable { Routine routine0 = new Routine ( "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , false , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" ) ; String string0 = routine0 . getDefinitionLanguage ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeterministic ( ) { return deterministic ; }
void test7 ( ) throws Throwable { Routine routine0 = new Routine ( "3w@8Jt . Bp & nE" , "" , "" , "3w@8Jt . Bp & nE" , "3w@8Jt . Bp & nE" , true , "3w@8Jt . Bp & nE" , "3w@8Jt . Bp & nE" , "" ) ; boolean boolean0 = routine0 . isDeterministic ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeterministic ( ) { return deterministic ; }
void test8 ( ) throws Throwable { Routine routine0 = new Routine ( "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , false , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" , "K# > . ~26w ) - 13~" ) ; Routine routine1 = new Routine ( " - % | D . Y" , " - % | D . Y" , "K# > . ~26w ) - 13~" , " - % | D . Y" , " - % | D . Y" , false , " - % | D . Y" , "" , " - % | D . Y" ) ; int int0 = routine0 . compareTo ( routine1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDataAccess ( ) { return dataAccess ; }
void test0 ( ) throws Throwable { RoutineParameter routineParameter0 = new RoutineParameter ( "" , "" , "" ) ; String string0 = routineParameter0 . getType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getType ( ) { return type ; }
void test1 ( ) throws Throwable { RoutineParameter routineParameter0 = new RoutineParameter ( "" , "" , "" ) ; String string0 = routineParameter0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return name ; }
void test2 ( ) throws Throwable { RoutineParameter routineParameter0 = new RoutineParameter ( "" , "" , "" ) ; String string0 = routineParameter0 . getMode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMode ( ) { return mode ; }
void test0 ( ) throws Throwable { Table . ByColumnIdComparator table_ByColumnIdComparator0 = new Table . ByColumnIdComparator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Table ( Database db , String catalog , String schema , String name , String comments ) throws SQLException { this . db = db ; this . catalog = catalog ; this . schema = schema ; this . container = schema ! = null ? schema : catalog ! = null ? catalog : db . getName ( ) ; this . name = name ; this . fullName = getFullName ( db . getName ( ) , catalog , schema , name ) ; if ( fineEnabled ) logger . fine ( "Creating " + getClass ( ) . getSimpleName ( ) + " " + fullName ) ; setComments ( comments ) ; initColumns ( ) ; initIndexes ( ) ; initPrimaryKeys ( ) ; }
void test4 ( ) throws Throwable { String string0 = Table . getFullName ( "ExclA0ing colu , ny" , "ExclA0ing colu , ny" , "ExclA0ing colu , ny" , "ExclA0ing colu , ny" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFullName ( ) { return fullName ; }
void test5 ( ) throws Throwable { String string0 = Table . getFullName ( ( String ) null , ( String ) null , ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFullName ( ) { return fullName ; }
void test6 ( ) throws Throwable { String string0 = Table . getFullName ( ( String ) null , ( String ) null , "null . null" , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFullName ( ) { return fullName ; }
