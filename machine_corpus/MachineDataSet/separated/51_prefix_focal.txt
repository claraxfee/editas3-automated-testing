void test0 ( ) throws Throwable { GenericClassLoaderFilter genericClassLoaderFilter0 = new GenericClassLoaderFilter ( ) ; boolean boolean0 = genericClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test1 ( ) throws Throwable { GenericClassLoaderFilter genericClassLoaderFilter0 = new GenericClassLoaderFilter ( ) ; boolean boolean0 = genericClassLoaderFilter0 . accept ( ( ClassLoader ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test2 ( ) throws Throwable { GenericClassLoaderFilter genericClassLoaderFilter0 = new GenericClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = genericClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test0 ( ) throws Throwable { JBossServletClassLoaderFilter jBossServletClassLoaderFilter0 = new JBossServletClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = jBossServletClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test1 ( ) throws Throwable { JBossServletClassLoaderFilter jBossServletClassLoaderFilter0 = new JBossServletClassLoaderFilter ( ) ; boolean boolean0 = jBossServletClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test0 ( ) throws Throwable { Info info0 = new Info ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = info0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test1 ( ) throws Throwable { Info info0 = new Info ( ) ; boolean boolean0 = info0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test0 ( ) throws Throwable { JBossEJBClassLoaderFilter jBossEJBClassLoaderFilter0 = new JBossEJBClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = jBossEJBClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test1 ( ) throws Throwable { JBossEJBClassLoaderFilter jBossEJBClassLoaderFilter0 = new JBossEJBClassLoaderFilter ( ) ; boolean boolean0 = jBossEJBClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test0 ( ) throws Throwable { JBossUniversalClassLoaderFilter jBossUniversalClassLoaderFilter0 = new JBossUniversalClassLoaderFilter ( ) ; boolean boolean0 = jBossUniversalClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test1 ( ) throws Throwable { JBossUniversalClassLoaderFilter jBossUniversalClassLoaderFilter0 = new JBossUniversalClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = jBossUniversalClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test0 ( ) throws Throwable { EclipseOSGIClassLoaderFilter eclipseOSGIClassLoaderFilter0 = new EclipseOSGIClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = eclipseOSGIClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test1 ( ) throws Throwable { EclipseOSGIClassLoaderFilter eclipseOSGIClassLoaderFilter0 = new EclipseOSGIClassLoaderFilter ( ) ; boolean boolean0 = eclipseOSGIClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test0 ( ) throws Throwable { TextOutput textOutput0 = new TextOutput ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { Action action0 = Action . STOP ; ActionRecord actionRecord0 = new ActionRecord ( ( String ) null , ( String ) null , action0 , 1030L ) ; actionRecord0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getThreadId ( ) { return _threadId ; }
void test1 ( ) throws Throwable { Action action0 = Action . STOP ; ActionRecord actionRecord0 = new ActionRecord ( ( String ) null , ( String ) null , action0 , 1030L ) ; actionRecord0 . getMethodName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getThreadId ( ) { return _threadId ; }
void test2 ( ) throws Throwable { Action action0 = Action . STOP ; ActionRecord actionRecord0 = new ActionRecord ( ( String ) null , ( String ) null , action0 , 1030L ) ; actionRecord0 . getAction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getThreadId ( ) { return _threadId ; }
void test3 ( ) throws Throwable { Action action0 = Action . STOP ; ActionRecord actionRecord0 = new ActionRecord ( ( String ) null , ( String ) null , action0 , 1030L ) ; long long0 = actionRecord0 . getThreadId ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getThreadId ( ) { return _threadId ; }
void test0 ( ) throws Throwable { TimeRecord timeRecord0 = new TimeRecord ( 43L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TimeRecord ( long time ) { _pointInTime = time ; }
void test0 ( ) throws Throwable { YASLResourceManagerImpl yASLResourceManagerImpl0 = new YASLResourceManagerImpl ( "" ) ; SnapshotListCellRenderer snapshotListCellRenderer0 = new SnapshotListCellRenderer ( ( YASLResourceManager ) yASLResourceManagerImpl0 ) ; JList jList0 = new JList ( ) ; SnapshotListCellRenderer snapshotListCellRenderer1 = ( SnapshotListCellRenderer ) snapshotListCellRenderer0 . getListCellRendererComponent ( jList0 , ( Object ) null , 0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { setComponentOrientation ( list . getComponentOrientation ( ) ) ; if ( isSelected ) { setBackground ( list . getSelectionBackground ( ) ) ; setForeground ( list . getSelectionForeground ( ) ) ; } else { setBackground ( list . getBackground ( ) ) ; setForeground ( list . getForeground ( ) ) ; } Snapshot snapshot = ( Snapshot ) value ; setEnabled ( list . isEnabled ( ) ) ; setFont ( list . getFont ( ) ) ; setBorder ( ( cellHasFocus ) ? UIManager . getBorder ( "List . focusCellHighlightBorder" ) : noFocusBorder ) ; / / display snapshot info String displayText = "" ; if ( snapshot ! = null ) { String template = resMan . getString ( resMan . getDefaultBundle ( ) , "label . snapshot . item" ) ; displayText = MessageFormat . format ( template , new Object [ ] { snapshot . getName ( ) , snapshot . getHost ( ) , snapshot . getPort ( ) } ) ; } setText ( displayText ) ; setVerticalTextPosition ( JLabel . CENTER ) ; setHorizontalTextPosition ( JLabel . TRAILING ) ; return this ; }
void test1 ( ) throws Throwable { YASLResourceManagerImpl yASLResourceManagerImpl0 = new YASLResourceManagerImpl ( "" ) ; SnapshotListCellRenderer snapshotListCellRenderer0 = new SnapshotListCellRenderer ( ( YASLResourceManager ) yASLResourceManagerImpl0 ) ; JList jList0 = new JList ( ) ; SnapshotListCellRenderer snapshotListCellRenderer1 = ( SnapshotListCellRenderer ) snapshotListCellRenderer0 . getListCellRendererComponent ( jList0 , ( Object ) null , 422 , true , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { setComponentOrientation ( list . getComponentOrientation ( ) ) ; if ( isSelected ) { setBackground ( list . getSelectionBackground ( ) ) ; setForeground ( list . getSelectionForeground ( ) ) ; } else { setBackground ( list . getBackground ( ) ) ; setForeground ( list . getForeground ( ) ) ; } Snapshot snapshot = ( Snapshot ) value ; setEnabled ( list . isEnabled ( ) ) ; setFont ( list . getFont ( ) ) ; setBorder ( ( cellHasFocus ) ? UIManager . getBorder ( "List . focusCellHighlightBorder" ) : noFocusBorder ) ; / / display snapshot info String displayText = "" ; if ( snapshot ! = null ) { String template = resMan . getString ( resMan . getDefaultBundle ( ) , "label . snapshot . item" ) ; displayText = MessageFormat . format ( template , new Object [ ] { snapshot . getName ( ) , snapshot . getHost ( ) , snapshot . getPort ( ) } ) ; } setText ( displayText ) ; setVerticalTextPosition ( JLabel . CENTER ) ; setHorizontalTextPosition ( JLabel . TRAILING ) ; return this ; }
void test0 ( ) throws Throwable { NumbersOnlyDocument numbersOnlyDocument0 = new NumbersOnlyDocument ( ) ; JTextPane jTextPane0 = new JTextPane ( ) ; MutableAttributeSet mutableAttributeSet0 = jTextPane0 . getInputAttributes ( ) ; numbersOnlyDocument0 . insertString ( 0 , ( String ) null , ( AttributeSet ) mutableAttributeSet0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void insertString ( int offset , String str , AttributeSet a ) throws BadLocationException { if ( str ! = null & & str . length ( ) > 0 ) { int length = str . length ( ) ; boolean accept = true ; for ( int idx = 0 ; idx < length & & accept ; idx + + ) { accept = Character . isDigit ( str . charAt ( idx ) ) ; } if ( accept ) { super . insertString ( offset , str , a ) ; } } }
void test1 ( ) throws Throwable { NumbersOnlyDocument numbersOnlyDocument0 = new NumbersOnlyDocument ( ) ; numbersOnlyDocument0 . insertString ( 1698 , "Xh0%Fn`" , ( AttributeSet ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void insertString ( int offset , String str , AttributeSet a ) throws BadLocationException { if ( str ! = null & & str . length ( ) > 0 ) { int length = str . length ( ) ; boolean accept = true ; for ( int idx = 0 ; idx < length & & accept ; idx + + ) { accept = Character . isDigit ( str . charAt ( idx ) ) ; } if ( accept ) { super . insertString ( offset , str , a ) ; } } }
void test2 ( ) throws Throwable { NumbersOnlyDocument numbersOnlyDocument0 = new NumbersOnlyDocument ( ) ; numbersOnlyDocument0 . insertString ( 1 , "" , ( AttributeSet ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void insertString ( int offset , String str , AttributeSet a ) throws BadLocationException { if ( str ! = null & & str . length ( ) > 0 ) { int length = str . length ( ) ; boolean accept = true ; for ( int idx = 0 ; idx < length & & accept ; idx + + ) { accept = Character . isDigit ( str . charAt ( idx ) ) ; } if ( accept ) { super . insertString ( offset , str , a ) ; } } }
void test1 ( ) throws Throwable { Snapshot snapshot0 = new Snapshot ( "" , "" , "" , "" , "" ) ; String string0 = snapshot0 . getHost ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHost ( ) { return host ; }
void test2 ( ) throws Throwable { Snapshot snapshot0 = new Snapshot ( "" , "" , "" , "" , "" ) ; String string0 = snapshot0 . getOriginalName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getOriginalName ( ) { return originalName ; }
void test3 ( ) throws Throwable { Snapshot snapshot0 = new Snapshot ( "" , "" , "" , "" , "" ) ; String string0 = snapshot0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test4 ( ) throws Throwable { Snapshot snapshot0 = new Snapshot ( "mZ" , "mZ" , "mZ" , "mZ" , "mZ" ) ; String string0 = snapshot0 . getPath ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return path ; }
void test5 ( ) throws Throwable { Snapshot snapshot0 = new Snapshot ( "" , "" , "" , "" , "" ) ; String string0 = snapshot0 . getPort ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPort ( ) { return port ; }
void test6 ( ) throws Throwable { Snapshot snapshot0 = new Snapshot ( "" , "" , "" , "" , "" ) ; String string0 = snapshot0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return name ; }
void test7 ( ) throws Throwable { Snapshot snapshot0 = new Snapshot ( "" , "" , "" , "" , "" ) ; String string0 = snapshot0 . getPathAndName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPathAndName ( ) { File pathAndName = new File ( path , name ) ; return pathAndName . getPath ( ) ; }
void test0 ( ) throws Throwable { SnapshotListModel snapshotListModel0 = new SnapshotListModel ( ) ; int int0 = snapshotListModel0 . getSize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test3 ( ) throws Throwable { SnapshotListModel snapshotListModel0 = new SnapshotListModel ( ) ; snapshotListModel0 . addSnapshot ( ( Snapshot ) null ) ; Snapshot snapshot0 = new Snapshot ( ( String ) null , ( String ) null , ( String ) null , ( String ) null , ( String ) null ) ; snapshotListModel0 . addSnapshot ( snapshot0 ) ; snapshotListModel0 . addSnapshot ( snapshot0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test0 ( ) throws Throwable { SnapshotEventManager snapshotEventManager0 = new SnapshotEventManager ( ) ; YASLSwingApplicationImpl yASLSwingApplicationImpl0 = new YASLSwingApplicationImpl ( ) ; StartSnapshotAction startSnapshotAction0 = new StartSnapshotAction ( "uC ) " , ( SnapshotInfoModel ) null , snapshotEventManager0 , ( YASLSwingApplication ) yASLSwingApplicationImpl0 ) ; Snapshot snapshot0 = new Snapshot ( "uC ) " , "uC ) " , "uC ) " , "uC ) " , "wantsInput" ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( 2 , snapshot0 ) ; startSnapshotAction0 . handleSnapshotEvent ( snapshotEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleSnapshotEvent ( SnapshotEvent event ) { switch ( event . getId ( ) ) { case SnapshotEvent . ID_SNAPSHOT_STARTED : name . setEditable ( false ) ; port . setEditable ( false ) ; host . setEditable ( false ) ; break ; case SnapshotEvent . ID_SNAPSHOT_CAPTURED : snapshotListModel . addSnapshot ( event . getSnapshot ( ) ) ; case SnapshotEvent . ID_SNAPSHOT_CAPTURE_FAILED : name . setEditable ( true ) ; port . setEditable ( true ) ; host . setEditable ( true ) ; break ; } }
void test1 ( ) throws Throwable { YASLSwingApplicationImpl yASLSwingApplicationImpl0 = new YASLSwingApplicationImpl ( ) ; StartSnapshotAction startSnapshotAction0 = new StartSnapshotAction ( " + Uw" , ( SnapshotInfoModel ) null , ( SnapshotEventManager ) null , ( YASLSwingApplication ) yASLSwingApplicationImpl0 ) ; Snapshot snapshot0 = new Snapshot ( " + Uw" , " + Uw" , " + Uw" , " + Uw" , " + Uw" ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( 1262 , snapshot0 ) ; startSnapshotAction0 . handleSnapshotEvent ( snapshotEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getId ( ) { return eventId ; }
void test0 ( ) throws Throwable { SnapshotEventManager snapshotEventManager0 = new SnapshotEventManager ( ) ; YASLSwingApplicationImpl yASLSwingApplicationImpl0 = new YASLSwingApplicationImpl ( ) ; FinishSnapshotAction finishSnapshotAction0 = new FinishSnapshotAction ( "YASLSwingApplicationImpl : the YASLSwingAppFrame attribute is null . \n" , snapshotEventManager0 , ( YASLSwingApplication ) yASLSwingApplicationImpl0 ) ; Snapshot snapshot0 = new Snapshot ( "YASLSwingApplicationImpl : the YASLSwingAppFrame attribute is null . \n" , "YASLSwingApplicationImpl : the YASLSwingAppFrame attribute is null . \n" , "YASLSwingApplicationImpl : the YASLSwingAppFrame attribute is null . \n" , "YASLSwingApplicationImpl : the YASLSwingAppFrame attribute is null . \n" , "YASLSwingApplicationImpl : the YASLSwingAppFrame attribute is null . \n" ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( 1 , snapshot0 ) ; finishSnapshotAction0 . handleSnapshotEvent ( snapshotEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleSnapshotEvent ( SnapshotEvent event ) { switch ( event . getId ( ) ) { case SnapshotEvent . ID_SNAPSHOT_STARTED : name . setEditable ( false ) ; port . setEditable ( false ) ; host . setEditable ( false ) ; break ; case SnapshotEvent . ID_SNAPSHOT_CAPTURED : snapshotListModel . addSnapshot ( event . getSnapshot ( ) ) ; case SnapshotEvent . ID_SNAPSHOT_CAPTURE_FAILED : name . setEditable ( true ) ; port . setEditable ( true ) ; host . setEditable ( true ) ; break ; } }
void test1 ( ) throws Throwable { SnapshotEventManager snapshotEventManager0 = new SnapshotEventManager ( ) ; YASLSwingApplicationImpl yASLSwingApplicationImpl0 = new YASLSwingApplicationImpl ( ) ; FinishSnapshotAction finishSnapshotAction0 = new FinishSnapshotAction ( " [ w | B35zcXyR ; - ; " , snapshotEventManager0 , ( YASLSwingApplication ) yASLSwingApplicationImpl0 ) ; Snapshot snapshot0 = new Snapshot ( " [ w | B35zcXyR ; - ; " , " [ w | B35zcXyR ; - ; " , " [ w | B35zcXyR ; - ; " , " [ w | B35zcXyR ; - ; " , " [ w | B35zcXyR ; - ; " ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( 0 , snapshot0 ) ; finishSnapshotAction0 . handleSnapshotEvent ( snapshotEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleSnapshotEvent ( SnapshotEvent event ) { switch ( event . getId ( ) ) { case SnapshotEvent . ID_SNAPSHOT_STARTED : name . setEditable ( false ) ; port . setEditable ( false ) ; host . setEditable ( false ) ; break ; case SnapshotEvent . ID_SNAPSHOT_CAPTURED : snapshotListModel . addSnapshot ( event . getSnapshot ( ) ) ; case SnapshotEvent . ID_SNAPSHOT_CAPTURE_FAILED : name . setEditable ( true ) ; port . setEditable ( true ) ; host . setEditable ( true ) ; break ; } }
void test0 ( ) throws Throwable { YASLSwingApplicationImpl yASLSwingApplicationImpl0 = new YASLSwingApplicationImpl ( ) ; ErrorDisplayAction errorDisplayAction0 = new ErrorDisplayAction ( ( YASLSwingApplication ) yASLSwingApplicationImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return name ; }
void test0 ( ) throws Throwable { ViewSnapshotAction viewSnapshotAction0 = new ViewSnapshotAction ( " | < " , ( SnapshotsTakenModel ) null , ( YASLSwingApplication ) null ) ; Snapshot snapshot0 = new Snapshot ( " | < " , " | < " , " | < " , " | < " , " | < " ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( 963 , snapshot0 ) ; viewSnapshotAction0 . handleSnapshotEvent ( snapshotEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleSnapshotEvent ( SnapshotEvent event ) { switch ( event . getId ( ) ) { case SnapshotEvent . ID_SNAPSHOT_STARTED : name . setEditable ( false ) ; port . setEditable ( false ) ; host . setEditable ( false ) ; break ; case SnapshotEvent . ID_SNAPSHOT_CAPTURED : snapshotListModel . addSnapshot ( event . getSnapshot ( ) ) ; case SnapshotEvent . ID_SNAPSHOT_CAPTURE_FAILED : name . setEditable ( true ) ; port . setEditable ( true ) ; host . setEditable ( true ) ; break ; } }
void test1 ( ) throws Throwable { YASLSwingApplicationImpl yASLSwingApplicationImpl0 = new YASLSwingApplicationImpl ( ) ; ViewSnapshotAction viewSnapshotAction0 = new ViewSnapshotAction ( "r~4" , ( SnapshotsTakenModel ) null , ( YASLSwingApplication ) yASLSwingApplicationImpl0 ) ; Snapshot snapshot0 = new Snapshot ( "r~4" , "r~4" , "r~4" , "r~4" , "r~4" ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( 2 , snapshot0 ) ; viewSnapshotAction0 . handleSnapshotEvent ( snapshotEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleSnapshotEvent ( SnapshotEvent event ) { switch ( event . getId ( ) ) { case SnapshotEvent . ID_SNAPSHOT_STARTED : name . setEditable ( false ) ; port . setEditable ( false ) ; host . setEditable ( false ) ; break ; case SnapshotEvent . ID_SNAPSHOT_CAPTURED : snapshotListModel . addSnapshot ( event . getSnapshot ( ) ) ; case SnapshotEvent . ID_SNAPSHOT_CAPTURE_FAILED : name . setEditable ( true ) ; port . setEditable ( true ) ; host . setEditable ( true ) ; break ; } }
void test0 ( ) throws Throwable { SnapshotEventManager snapshotEventManager0 = new SnapshotEventManager ( ) ; YASLSwingApplicationImpl yASLSwingApplicationImpl0 = new YASLSwingApplicationImpl ( ) ; StartSnapshotAction startSnapshotAction0 = new StartSnapshotAction ( "T ? label . name" , ( SnapshotInfoModel ) null , snapshotEventManager0 , ( YASLSwingApplication ) yASLSwingApplicationImpl0 ) ; YASLActionEvent yASLActionEvent0 = startSnapshotAction0 . getErrorEvent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" YASLActionEvent getErrorEvent ( ) { YASLActionEvent event = new YASLActionEvent ( this , YASLActionEvent . ACTION_PERFORMED , "" ) ; event . addProperty ( JIPSnapManConstants . KEY_ERR_DLGTITLE , "dlg . title . missing" ) ; return event ; }
void test1 ( ) throws Throwable { YASLSwingApplicationImpl yASLSwingApplicationImpl0 = new YASLSwingApplicationImpl ( ) ; BrowsePathAction browsePathAction0 = new BrowsePathAction ( "%@ ] pv & " , ( SnapshotPathModel ) null , ( YASLSwingApplication ) yASLSwingApplicationImpl0 ) ; Snapshot snapshot0 = new Snapshot ( "%@ ] pv & " , "%@ ] pv & " , "%@ ] pv & " , "%@ ] pv & " , "%@ ] pv & " ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( 1 , snapshot0 ) ; browsePathAction0 . handleSnapshotEvent ( snapshotEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleSnapshotEvent ( SnapshotEvent event ) { switch ( event . getId ( ) ) { case SnapshotEvent . ID_SNAPSHOT_STARTED : name . setEditable ( false ) ; port . setEditable ( false ) ; host . setEditable ( false ) ; break ; case SnapshotEvent . ID_SNAPSHOT_CAPTURED : snapshotListModel . addSnapshot ( event . getSnapshot ( ) ) ; case SnapshotEvent . ID_SNAPSHOT_CAPTURE_FAILED : name . setEditable ( true ) ; port . setEditable ( true ) ; host . setEditable ( true ) ; break ; } }
void test2 ( ) throws Throwable { YASLSwingApplicationImpl yASLSwingApplicationImpl0 = new YASLSwingApplicationImpl ( ) ; BrowsePathAction browsePathAction0 = new BrowsePathAction ( "%@ ] pv & " , ( SnapshotPathModel ) null , ( YASLSwingApplication ) yASLSwingApplicationImpl0 ) ; Snapshot snapshot0 = new Snapshot ( "%@ ] pv & " , "%@ ] pv & " , "%@ ] pv & " , "%@ ] pv & " , "%@ ] pv & " ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( 0 , snapshot0 ) ; browsePathAction0 . handleSnapshotEvent ( snapshotEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleSnapshotEvent ( SnapshotEvent event ) { switch ( event . getId ( ) ) { case SnapshotEvent . ID_SNAPSHOT_STARTED : name . setEditable ( false ) ; port . setEditable ( false ) ; host . setEditable ( false ) ; break ; case SnapshotEvent . ID_SNAPSHOT_CAPTURED : snapshotListModel . addSnapshot ( event . getSnapshot ( ) ) ; case SnapshotEvent . ID_SNAPSHOT_CAPTURE_FAILED : name . setEditable ( true ) ; port . setEditable ( true ) ; host . setEditable ( true ) ; break ; } }
void test1 ( ) throws Throwable { SnapshotEventManager snapshotEventManager0 = new SnapshotEventManager ( ) ; YASLSwingApplicationImpl yASLSwingApplicationImpl0 = new YASLSwingApplicationImpl ( ) ; FinishSnapshotAction finishSnapshotAction0 = new FinishSnapshotAction ( "`y0U ] i ) < K'' . #mL" , snapshotEventManager0 , ( YASLSwingApplication ) yASLSwingApplicationImpl0 ) ; snapshotEventManager0 . addSnapshotEventListener ( ( SnapshotEventListener ) finishSnapshotAction0 ) ; Snapshot snapshot0 = new Snapshot ( "`y0U ] i ) < K'' . #mL" , "`y0U ] i ) < K'' . #mL" , "`y0U ] i ) < K'' . #mL" , "`y0U ] i ) < K'' . #mL" , "`y0U ] i ) < K'' . #mL" ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( ( - 1588 ) , snapshot0 ) ; snapshotEventManager0 . fireSnapshotEvent ( snapshotEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getId ( ) { return eventId ; }
void test3 ( ) throws Throwable { SnapshotEventManager snapshotEventManager0 = new SnapshotEventManager ( ) ; Snapshot snapshot0 = new Snapshot ( "7 ( 2CZCdg ) " , "7 ( 2CZCdg ) " , "7 ( 2CZCdg ) " , "" , "7 ( 2CZCdg ) " ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( 1 , snapshot0 ) ; snapshotEventManager0 . fireSnapshotEvent ( snapshotEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getId ( ) { return eventId ; }
void test0 ( ) throws Throwable { Snapshot snapshot0 = new Snapshot ( "" , "" , "" , "" , "" ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( 1838 , snapshot0 ) ; Snapshot snapshot1 = snapshotEvent0 . getSnapshot ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getId ( ) { return eventId ; }
void test1 ( ) throws Throwable { Snapshot snapshot0 = new Snapshot ( "" , "" , "" , "" , "" ) ; SnapshotEvent snapshotEvent0 = new SnapshotEvent ( 1838 , snapshot0 ) ; int int0 = snapshotEvent0 . getId ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getId ( ) { return eventId ; }
void test1 ( ) throws Throwable { Finish finish0 = new Finish ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { ClientHelper clientHelper0 = new ClientHelper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { Client client0 = new Client ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { Start start0 = new Start ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { File file0 = new File ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { Main main0 = new Main ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { Controller controller0 = new Controller ( ) ; controller0 . setFileName ( "G ( Z } sFaYb'5" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setFileName ( String fileName ) { _fileName = fileName ; }
void test1 ( ) throws Throwable { Controller controller0 = new Controller ( ) ; controller0 . close ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void close ( ) throws IOException { System . err . println ( "Controller - - shuttingdown" ) ; if ( _remote & & _socket ! = null & & ! _socket . isClosed ( ) ) { _socket . close ( ) ; } }
void test2 ( ) throws Throwable { Controller controller0 = new Controller ( ) ; controller0 . start ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void start ( String className , String methodName ) { createActionRecord ( className , methodName , Action . START ) ; }
void test3 ( ) throws Throwable { Controller controller0 = new Controller ( ) ; controller0 . stop ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void stop ( ) { / / Explain to the user why they aren't going to be seeing a profile . / / if ( _instrumentCount = = 0 ) { System . err . println ( "No classes have been instrumented for " + "profiling . There should be a previous message to this " + "effect which outlines why this is happening . " ) ; } Profile . shutdown ( ) ; }
void test0 ( ) throws Throwable { ClassAllocation classAllocation0 = new ClassAllocation ( "" ) ; int int0 = classAllocation0 . getAllocCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAllocCount ( ) { return _count ; }
void test1 ( ) throws Throwable { ClassAllocation classAllocation0 = new ClassAllocation ( "" ) ; classAllocation0 . incAllocCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAllocCount ( ) { return _count ; }
void test2 ( ) throws Throwable { ClassAllocation classAllocation0 = new ClassAllocation ( "" ) ; String string0 = classAllocation0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAllocCount ( ) { return _count ; }
void test3 ( ) throws Throwable { ClassAllocation classAllocation0 = new ClassAllocation ( "" ) ; String string0 = classAllocation0 . getInternalClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAllocCount ( ) { return _count ; }
void test0 ( ) throws Throwable { Method method0 = new Method ( " - t" , " - t" ) ; int int0 = method0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { return _className . hashCode ( ) + _methodName . hashCode ( ) ; }
void test1 ( ) throws Throwable { Method method0 = new Method ( " - t" , " - t" ) ; String string0 = method0 . getMethodName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMethodName ( ) { return _methodName ; }
void test2 ( ) throws Throwable { Method method0 = new Method ( "1" , "1" ) ; String string0 = method0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test3 ( ) throws Throwable { Method method0 = new Method ( "1" , "1" ) ; String string0 = method0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return _className ; }
void test4 ( ) throws Throwable { Method method0 = new Method ( "1" , "1" ) ; String string0 = method0 . toInvertedString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toInvertedString ( ) { String className = _className . replace ( ' / ' , ' . ' ) ; int index = className . lastIndexOf ( ' . ' ) ; String shortName = null ; String packageName = "" ; if ( index > - 1 ) { shortName = className . substring ( index + 1 ) ; packageName = className . substring ( 0 , index ) ; } else { shortName = className ; } StringBuffer b = new StringBuffer ( ) ; b . append ( shortName ) ; b . append ( ' : ' ) ; b . append ( _methodName ) ; b . append ( "\t ( " ) ; b . append ( packageName ) ; b . append ( " ) " ) ; return b . toString ( ) ; }
void test5 ( ) throws Throwable { Method method0 = new Method ( " } y\" / = } xFrY4o9X + 0" , " } y\" / = } xFrY4o9X + 0" ) ; String string0 = method0 . toInvertedString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toInvertedString ( ) { String className = _className . replace ( ' / ' , ' . ' ) ; int index = className . lastIndexOf ( ' . ' ) ; String shortName = null ; String packageName = "" ; if ( index > - 1 ) { shortName = className . substring ( index + 1 ) ; packageName = className . substring ( 0 , index ) ; } else { shortName = className ; } StringBuffer b = new StringBuffer ( ) ; b . append ( shortName ) ; b . append ( ' : ' ) ; b . append ( _methodName ) ; b . append ( "\t ( " ) ; b . append ( packageName ) ; b . append ( " ) " ) ; return b . toString ( ) ; }
void test6 ( ) throws Throwable { Method method0 = new Method ( " - t" , " - t" ) ; boolean boolean0 = method0 . equals ( ( Object ) method0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object other ) { assert other instanceof Method ; Method m = ( Method ) other ; return this . _className . equals ( m . _className ) & & this . _methodName . equals ( m . _methodName ) ; }
void test8 ( ) throws Throwable { Method method0 = new Method ( " - t" , " - t" ) ; Method method1 = new Method ( ( String ) null , " - t" ) ; boolean boolean0 = method0 . equals ( ( Object ) method1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object other ) { assert other instanceof Method ; Method m = ( Method ) other ; return this . _className . equals ( m . _className ) & & this . _methodName . equals ( m . _methodName ) ; }
void test9 ( ) throws Throwable { Method method0 = new Method ( " } y\" / = } xFrY4o9X + 0" , " } y\" / = } xFrY4o9X + 0" ) ; Method method1 = new Method ( " } y\" / = } xFrY4o9X + 0" , " = } xFrY4o9X + 0 : } y\" / = } xFrY4o9X + 0\t ( } y\" ) " ) ; boolean boolean0 = method0 . equals ( ( Object ) method1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return _className ; }
void test0 ( ) throws Throwable { ThreadDictionary threadDictionary0 = new ThreadDictionary ( ) ; Iterable < Frame > iterable0 = threadDictionary0 . interactions ( 1488L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Iterable < Frame > interactions ( long threadId ) { return _threadDictionary . interactions ( ( threadId ) ) ; }
void test2 ( ) throws Throwable { ThreadDictionary threadDictionary0 = new ThreadDictionary ( ) ; Iterable < Long > iterable0 = threadDictionary0 . threads ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Iterable < Long > threads ( ) { return _threadDictionary . threads ( ) ; }
void test3 ( ) throws Throwable { ThreadDictionary threadDictionary0 = new ThreadDictionary ( ) ; threadDictionary0 . add ( 16L , ( Frame ) null ) ; threadDictionary0 . add ( 16L , ( Frame ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test0 ( ) throws Throwable { Metrics metrics0 = new Metrics ( ) ; String string0 = metrics0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test1 ( ) throws Throwable { Metrics metrics0 = new Metrics ( ) ; long long0 = metrics0 . getCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test2 ( ) throws Throwable { Metrics metrics0 = new Metrics ( ) ; long long0 = metrics0 . getTotalTime ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test3 ( ) throws Throwable { Metrics metrics0 = new Metrics ( ) ; metrics0 . inc ( 0L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getCount ( ) { return _count ; }
void test4 ( ) throws Throwable { Metrics metrics0 = new Metrics ( ) ; metrics0 . inc ( 1914L ) ; metrics0 . inc ( 1914L ) ; metrics0 . adjust ( 1914L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalTime ( ) { return _totalTime ; }
void test5 ( ) throws Throwable { Metrics metrics0 = new Metrics ( ) ; metrics0 . adjust ( 0L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test6 ( ) throws Throwable { Metrics metrics0 = new Metrics ( ) ; metrics0 . adjust ( 1914L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalTime ( ) { return _totalTime ; }
void test0 ( ) throws Throwable { ProfileTextDump profileTextDump0 = new ProfileTextDump ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { FrameDump frameDump0 = new FrameDump ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { double double0 = Math . nanoToMilli ( ( - 1L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double nanoToMilli ( long time ) { return ( ( double ) time ) / 1000000 ; }
void test1 ( ) throws Throwable { double double0 = Math . toPercent ( 1L , 1L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double toPercent ( long num , double denom ) { return ( ( ( double ) num ) / denom ) * 100 ; }
void test2 ( ) throws Throwable { Math math0 = new Math ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { ProfileDump profileDump0 = new ProfileDump ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { ProfileXMLDump profileXMLDump0 = new ProfileXMLDump ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { Transformer transformer0 = new Transformer ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; Class < ? > class0 = SocketAddress . class ; byte [ ] byteArray0 = new byte [ 1 ] ; byte [ ] byteArray1 = transformer0 . transform ( classLoader0 , "com / mentorgen / tools / profile#gcRvi_Oi@9OfSM3L6Q" , class0 , ( ProtectionDomain ) null , byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] transform ( ClassLoader loader , String className , Class < ? > classBeingRedefined , ProtectionDomain protectionDomain , byte [ ] classfileBuffer ) throws IllegalClassFormatException { / / can't profile yourself / / if ( className . startsWith ( "com / mentorgen / tools / profile" ) | | className . startsWith ( "net / sourceforge / jiprof" ) ) { return classfileBuffer ; } / / include / / if ( Controller . _includeList . length > 0 ) { boolean toInclude = false ; for ( String include : Controller . _includeList ) { if ( className . startsWith ( include ) ) { toInclude = true ; break ; } } if ( ! toInclude ) { if ( Controller . _debug ) { debug ( loader , className , false ) ; } return classfileBuffer ; } } if ( ! Controller . _filter . accept ( loader ) ) { if ( Controller . _debug ) { debug ( loader , className , false ) ; } return classfileBuffer ; } / / exclude / / for ( String exclude : Controller . _excludeList ) { if ( className . startsWith ( exclude ) ) { if ( Controller . _debug ) { debug ( loader , className , false ) ; } return classfileBuffer ; } } byte [ ] result = classfileBuffer ; try { if ( Controller . _debug ) { debug ( loader , className , true ) ; } Controller . _instrumentCount + + ; ClassReader reader = new ClassReader ( classfileBuffer ) ; ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE_MAXS ) ; ClassAdapter adapter = new PerfClassAdapter ( writer , className ) ; reader . accept ( adapter , ClassReader . SKIP_DEBUG ) ; result = writer . toByteArray ( ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; throw new RuntimeException ( t ) ; } return result ; }
void test1 ( ) throws Throwable { ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; byte [ ] byteArray0 = new byte [ 4 ] ; Transformer transformer0 = new Transformer ( ) ; Class < ? > class0 = Transformer . class ; byte [ ] byteArray1 = transformer0 . transform ( classLoader0 , "net / sourceforge / jiprofHoX * e - jF03`Kc" , class0 , ( ProtectionDomain ) null , byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] transform ( ClassLoader loader , String className , Class < ? > classBeingRedefined , ProtectionDomain protectionDomain , byte [ ] classfileBuffer ) throws IllegalClassFormatException { / / can't profile yourself / / if ( className . startsWith ( "com / mentorgen / tools / profile" ) | | className . startsWith ( "net / sourceforge / jiprof" ) ) { return classfileBuffer ; } / / include / / if ( Controller . _includeList . length > 0 ) { boolean toInclude = false ; for ( String include : Controller . _includeList ) { if ( className . startsWith ( include ) ) { toInclude = true ; break ; } } if ( ! toInclude ) { if ( Controller . _debug ) { debug ( loader , className , false ) ; } return classfileBuffer ; } } if ( ! Controller . _filter . accept ( loader ) ) { if ( Controller . _debug ) { debug ( loader , className , false ) ; } return classfileBuffer ; } / / exclude / / for ( String exclude : Controller . _excludeList ) { if ( className . startsWith ( exclude ) ) { if ( Controller . _debug ) { debug ( loader , className , false ) ; } return classfileBuffer ; } } byte [ ] result = classfileBuffer ; try { if ( Controller . _debug ) { debug ( loader , className , true ) ; } Controller . _instrumentCount + + ; ClassReader reader = new ClassReader ( classfileBuffer ) ; ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE_MAXS ) ; ClassAdapter adapter = new PerfClassAdapter ( writer , className ) ; reader . accept ( adapter , ClassReader . SKIP_DEBUG ) ; result = writer . toByteArray ( ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; throw new RuntimeException ( t ) ; } return result ; }
void test2 ( ) throws Throwable { Transformer transformer0 = new Transformer ( ) ; Class < ? > class0 = Transformer . class ; byte [ ] byteArray0 = new byte [ 5 ] ; byte [ ] byteArray1 = transformer0 . transform ( ( ClassLoader ) null , "0hX" , class0 , ( ProtectionDomain ) null , byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] transform ( ClassLoader loader , String className , Class < ? > classBeingRedefined , ProtectionDomain protectionDomain , byte [ ] classfileBuffer ) throws IllegalClassFormatException { / / can't profile yourself / / if ( className . startsWith ( "com / mentorgen / tools / profile" ) | | className . startsWith ( "net / sourceforge / jiprof" ) ) { return classfileBuffer ; } / / include / / if ( Controller . _includeList . length > 0 ) { boolean toInclude = false ; for ( String include : Controller . _includeList ) { if ( className . startsWith ( include ) ) { toInclude = true ; break ; } } if ( ! toInclude ) { if ( Controller . _debug ) { debug ( loader , className , false ) ; } return classfileBuffer ; } } if ( ! Controller . _filter . accept ( loader ) ) { if ( Controller . _debug ) { debug ( loader , className , false ) ; } return classfileBuffer ; } / / exclude / / for ( String exclude : Controller . _excludeList ) { if ( className . startsWith ( exclude ) ) { if ( Controller . _debug ) { debug ( loader , className , false ) ; } return classfileBuffer ; } } byte [ ] result = classfileBuffer ; try { if ( Controller . _debug ) { debug ( loader , className , true ) ; } Controller . _instrumentCount + + ; ClassReader reader = new ClassReader ( classfileBuffer ) ; ClassWriter writer = new ClassWriter ( ClassWriter . COMPUTE_MAXS ) ; ClassAdapter adapter = new PerfClassAdapter ( writer , className ) ; reader . accept ( adapter , ClassReader . SKIP_DEBUG ) ; result = writer . toByteArray ( ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; throw new RuntimeException ( t ) ; } return result ; }
void test0 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 8 ) ) ; String [ ] stringArray0 = new String [ 3 ] ; stringArray0 [ 0 ] = "#J\"" ; stringArray0 [ 1 ] = "#J\"" ; stringArray0 [ 2 ] = "#J\"" ; PerfClassAdapter perfClassAdapter0 = new PerfClassAdapter ( ( ClassVisitor ) classWriter0 , "#J\"" ) ; PerfMethodAdapter perfMethodAdapter0 = ( PerfMethodAdapter ) perfClassAdapter0 . visitMethod ( ( - 8 ) , "#J\"" , "#J\"" , "#J\"" , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" MethodVisitor visitMethod ( int arg , String name , String descriptor , String signature , String [ ] exceptions ) { MethodVisitor mv = super . visitMethod ( arg , name , descriptor , signature , exceptions ) ; if ( Controller . _outputMethodSignatures & & descriptor ! = null ) { return new PerfMethodAdapter ( mv , className , name + descriptor ) ; } else { return new PerfMethodAdapter ( mv , className , name ) ; } }
void test0 ( ) throws Throwable { WebAppClassLoaderFilter webAppClassLoaderFilter0 = new WebAppClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = webAppClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test1 ( ) throws Throwable { WebAppClassLoaderFilter webAppClassLoaderFilter0 = new WebAppClassLoaderFilter ( ) ; boolean boolean0 = webAppClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test0 ( ) throws Throwable { ExtensionsClassLoaderFilter extensionsClassLoaderFilter0 = new ExtensionsClassLoaderFilter ( ) ; boolean boolean0 = extensionsClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test1 ( ) throws Throwable { ExtensionsClassLoaderFilter extensionsClassLoaderFilter0 = new ExtensionsClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = extensionsClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test2 ( ) throws Throwable { ExtensionsClassLoaderFilter extensionsClassLoaderFilter0 = new ExtensionsClassLoaderFilter ( ) ; boolean boolean0 = extensionsClassLoaderFilter0 . accept ( ( ClassLoader ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test0 ( ) throws Throwable { JettyClassLoaderFilter jettyClassLoaderFilter0 = new JettyClassLoaderFilter ( ) ; boolean boolean0 = jettyClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test1 ( ) throws Throwable { JettyClassLoaderFilter jettyClassLoaderFilter0 = new JettyClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = jettyClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test0 ( ) throws Throwable { AntTaskClassLoaderFilter antTaskClassLoaderFilter0 = new AntTaskClassLoaderFilter ( ) ; boolean boolean0 = antTaskClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test1 ( ) throws Throwable { AntTaskClassLoaderFilter antTaskClassLoaderFilter0 = new AntTaskClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = antTaskClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test0 ( ) throws Throwable { CustomMultiClassLoaderFilter customMultiClassLoaderFilter0 = new CustomMultiClassLoaderFilter ( ) ; boolean boolean0 = customMultiClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test1 ( ) throws Throwable { CustomMultiClassLoaderFilter customMultiClassLoaderFilter0 = new CustomMultiClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = customMultiClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test0 ( ) throws Throwable { TomcatInternalClassLoaderFilter tomcatInternalClassLoaderFilter0 = new TomcatInternalClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = tomcatInternalClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test1 ( ) throws Throwable { TomcatInternalClassLoaderFilter tomcatInternalClassLoaderFilter0 = new TomcatInternalClassLoaderFilter ( ) ; boolean boolean0 = tomcatInternalClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test0 ( ) throws Throwable { StandardClassLoaderFilter standardClassLoaderFilter0 = new StandardClassLoaderFilter ( ) ; boolean boolean0 = standardClassLoaderFilter0 . canFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canFilter ( ) { return true ; }
void test1 ( ) throws Throwable { StandardClassLoaderFilter standardClassLoaderFilter0 = new StandardClassLoaderFilter ( ) ; boolean boolean0 = standardClassLoaderFilter0 . accept ( ( ClassLoader ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test2 ( ) throws Throwable { StandardClassLoaderFilter standardClassLoaderFilter0 = new StandardClassLoaderFilter ( ) ; ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; boolean boolean0 = standardClassLoaderFilter0 . accept ( classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean accept ( ClassLoader loader ) { return loader . getClass ( ) . getName ( ) . equals ( CLASSLOADER ) ; }
void test0 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { RemoteController remoteController0 = new RemoteController ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Item get ( Item key ) { Item i = items [ key . hashCode % items . length ] ; while ( i ! = null & & ( i . type ! = key . type | | ! key . isEqualTo ( i ) ) ) { i = i . next ; } return i ; }
void test1 ( ) throws Throwable { RemoteController remoteController0 = new RemoteController ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void actionPerformed ( ActionEvent e ) { String cmd = e . getActionCommand ( ) ; if ( cmd . equals ( "start" ) | | cmd . equals ( "stop" ) ) { changeState ( cmd ) ; } else { throw new RuntimeException ( "unexpected button cmd ( " + cmd + " ) " ) ; } }
void test0 ( ) throws Throwable { JipMethod jipMethod0 = new JipMethod ( "4" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMethodName ( ) { return _methodName ; }
void test1 ( ) throws Throwable { JipMethod jipMethod0 = new JipMethod ( "4" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMethodName ( ) { return _methodName ; }
void test2 ( ) throws Throwable { JipMethod jipMethod0 = new JipMethod ( " ? e" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMethodName ( ) { return _methodName ; }
void test3 ( ) throws Throwable { JipMethod jipMethod0 = new JipMethod ( " ) : v\" - gOEA [ 5~GFeck" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return _className ; }
void test4 ( ) throws Throwable { JipMethod jipMethod0 = new JipMethod ( " ? e" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMethodName ( ) { return _methodName ; }
void test5 ( ) throws Throwable { JipMethod jipMethod0 = new JipMethod ( " ? e" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMethodName ( ) { return _methodName ; }
void test6 ( ) throws Throwable { JipMethod jipMethod0 = new JipMethod ( "Rj ! lRm% & [ 8L . 4 : J^ ] " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return _className ; }
void test7 ( ) throws Throwable { JipMethod jipMethod0 = new JipMethod ( " ? e" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMethodName ( ) { return _methodName ; }
void test8 ( ) throws Throwable { JipMethod jipMethod0 = new JipMethod ( " ? e" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object other ) { assert other instanceof Method ; Method m = ( Method ) other ; return this . _className . equals ( m . _className ) & & this . _methodName . equals ( m . _methodName ) ; }
void test0 ( ) throws Throwable { MethodRowTableModel methodRowTableModel0 = new MethodRowTableModel ( ) ; int int0 = methodRowTableModel0 . getRowCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return ( tableModel = = null ) ? 0 : tableModel . getRowCount ( ) ; }
void test2 ( ) throws Throwable { MethodRowTableModel methodRowTableModel0 = new MethodRowTableModel ( ) ; methodRowTableModel0 . clear ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) { return ( tableModel = = null ) ? 0 : tableModel . getColumnCount ( ) ; }
void test3 ( ) throws Throwable { MethodRowTableModel methodRowTableModel0 = new MethodRowTableModel ( ) ; methodRowTableModel0 . findColumn ( " } yBFu2C : x~ } / Dj" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) { return ( tableModel = = null ) ? 0 : tableModel . getColumnCount ( ) ; }
void test5 ( ) throws Throwable { MethodRowTableModel methodRowTableModel0 = new MethodRowTableModel ( ) ; Class < Object > class0 = methodRowTableModel0 . getColumnClass ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return name ; }
void test6 ( ) throws Throwable { MethodRowTableModel methodRowTableModel0 = new MethodRowTableModel ( ) ; Class < Object > class0 = methodRowTableModel0 . getColumnClass ( 4 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Class getColumnClass ( int column ) { return tableModel . getColumnClass ( column ) ; }
void test7 ( ) throws Throwable { MethodRowTableModel methodRowTableModel0 = new MethodRowTableModel ( ) ; Class < Object > class0 = methodRowTableModel0 . getColumnClass ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test8 ( ) throws Throwable { MethodRowTableModel methodRowTableModel0 = new MethodRowTableModel ( ) ; Class < Object > class0 = methodRowTableModel0 . getColumnClass ( 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Class getColumnClass ( int column ) { return tableModel . getColumnClass ( column ) ; }
void test9 ( ) throws Throwable { MethodRowTableModel methodRowTableModel0 = new MethodRowTableModel ( ) ; Class < Object > class0 = methodRowTableModel0 . getColumnClass ( 3 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Class getColumnClass ( int column ) { return tableModel . getColumnClass ( column ) ; }
void test10 ( ) throws Throwable { MethodRowTableModel methodRowTableModel0 = new MethodRowTableModel ( ) ; Class < Object > class0 = methodRowTableModel0 . getColumnClass ( 5 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Class getColumnClass ( int column ) { return tableModel . getColumnClass ( column ) ; }
void test11 ( ) throws Throwable { MethodRowTableModel methodRowTableModel0 = new MethodRowTableModel ( ) ; Class < Object > class0 = methodRowTableModel0 . getColumnClass ( 6 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return name ; }
void test12 ( ) throws Throwable { MethodRowTableModel methodRowTableModel0 = new MethodRowTableModel ( ) ; Class < Object > class0 = methodRowTableModel0 . getColumnClass ( 7 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Class getColumnClass ( int column ) { return tableModel . getColumnClass ( column ) ; }
void test0 ( ) throws Throwable { JipRun jipRun0 = new JipRun ( ) ; List < JipRun . PerMethodInfo > list0 = jipRun0 . perMethodsInTotalTimeOrder ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < PerMethodInfo > perMethodsInTotalTimeOrder ( ) { Comparator cmp = new Comparator < PerMethodInfo > ( ) { int compare ( PerMethodInfo a , PerMethodInfo b ) { long timeA = a . getAllThreadAllFramesTime ( ) ; long timeB = b . getAllThreadAllFramesTime ( ) ; if ( timeA < timeB ) { return - 1 ; } else if ( timeA > timeB ) { return 1 ; } else { String nameA = a . getMethod ( ) . getMethodName ( ) ; String nameB = a . getMethod ( ) . getMethodName ( ) ; return nameA . compareToIgnoreCase ( nameB ) ; } } } ; List v = new ArrayList ( mPerMethods . values ( ) ) ; Collections . sort ( v , cmp ) ; return v ; }
void test1 ( ) throws Throwable { JipRun . PerMethodInfo jipRun_PerMethodInfo0 = new JipRun . PerMethodInfo ( ( JipMethod ) null ) ; Iterable < JipFrame > iterable0 = jipRun_PerMethodInfo0 . allFrames ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test2 ( ) throws Throwable { JipRun . PerMethodInfo jipRun_PerMethodInfo0 = new JipRun . PerMethodInfo ( ( JipMethod ) null ) ; long long0 = jipRun_PerMethodInfo0 . getAllThreadAllFramesTime ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test4 ( ) throws Throwable { JipRun . PerMethodInfo jipRun_PerMethodInfo0 = new JipRun . PerMethodInfo ( ( JipMethod ) null ) ; long long0 = jipRun_PerMethodInfo0 . getAllThreadAllFramesTimeIncludingReentrant ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test5 ( ) throws Throwable { JipRun jipRun0 = new JipRun ( ) ; jipRun0 . addToClassMap ( "ex" , "JipRun\n { \n * thread 0 interaction 1\ncom . tivo . jipviewer . JipFrame@6188fe9b } \n" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalTimeForAllThreads ( ) { long total = 0 ; for ( Long threadId : threads ( ) ) { for ( JipFrame frame : mThreads . get ( threadId . longValue ( ) ) ) { total + = frame . getTotalTime ( ) ; } } return total ; }
void test6 ( ) throws Throwable { JipRun jipRun0 = new JipRun ( ) ; Iterable < JipFrame > iterable0 = jipRun0 . interactions ( ( - 1918L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Iterable < Frame > interactions ( long threadId ) { return _threadDictionary . interactions ( ( threadId ) ) ; }
void test8 ( ) throws Throwable { JipRun jipRun0 = new JipRun ( ) ; jipRun0 . startThread ( 1061L ) ; jipRun0 . endThread ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test11 ( ) throws Throwable { JipRun jipRun0 = new JipRun ( ) ; jipRun0 . startInteraction ( 1061L ) ; jipRun0 . endInteraction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalTimeForAllThreads ( ) { long total = 0 ; for ( Long threadId : threads ( ) ) { for ( JipFrame frame : mThreads . get ( threadId . longValue ( ) ) ) { total + = frame . getTotalTime ( ) ; } } return total ; }
void test14 ( ) throws Throwable { JipRun jipRun0 = new JipRun ( ) ; jipRun0 . startFrame ( "Min2^ractio " , "Min2^ractio " , ( - 1207L ) , ( - 1207L ) ) ; jipRun0 . startFrame ( "Min2^ractio " , "Min2^ractio " , ( - 1207L ) , ( - 1207L ) ) ; jipRun0 . endFrame ( ) ; jipRun0 . endFrame ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalTimeForAllThreads ( ) { long total = 0 ; for ( Long threadId : threads ( ) ) { for ( JipFrame frame : mThreads . get ( threadId . longValue ( ) ) ) { total + = frame . getTotalTime ( ) ; } } return total ; }
void test15 ( ) throws Throwable { JipRun jipRun0 = new JipRun ( ) ; jipRun0 . startFrame ( "ex" , "ex" , ( - 1918L ) , ( - 1918L ) ) ; jipRun0 . endFrame ( ) ; jipRun0 . startFrame ( "JipRun\n { \n * thread 0 interaction 1\ncom . tivo . jipviewer . JipFrame@6188fe9b } \n" , "JipRun\n { \n * thread 0 interaction 1\ncom . tivo . jipviewer . JipFrame@6188fe9b } \n" , ( - 1918L ) , ( - 1918L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalTimeForAllThreads ( ) { long total = 0 ; for ( Long threadId : threads ( ) ) { for ( JipFrame frame : mThreads . get ( threadId . longValue ( ) ) ) { total + = frame . getTotalTime ( ) ; } } return total ; }
void test16 ( ) throws Throwable { JipRun jipRun0 = new JipRun ( ) ; jipRun0 . startFrame ( "ex" , "ex" , ( - 1918L ) , ( - 1918L ) ) ; jipRun0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalTimeForAllThreads ( ) { long total = 0 ; for ( Long threadId : threads ( ) ) { for ( JipFrame frame : mThreads . get ( threadId . longValue ( ) ) ) { total + = frame . getTotalTime ( ) ; } } return total ; }
void test17 ( ) throws Throwable { JipRun jipRun0 = new JipRun ( ) ; jipRun0 . startFrame ( "ex" , "ex" , ( - 1918L ) , ( - 1918L ) ) ; long long0 = jipRun0 . getTotalTimeForAllThreads ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalTimeForAllThreads ( ) { long total = 0 ; for ( Long threadId : threads ( ) ) { for ( JipFrame frame : mThreads . get ( threadId . longValue ( ) ) ) { total + = frame . getTotalTime ( ) ; } } return total ; }
void test18 ( ) throws Throwable { JipRun jipRun0 = new JipRun ( ) ; Iterable < JipFrame > iterable0 = jipRun0 . allCallers ( ( JipMethod ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Iterable < JipFrame > allCallers ( JipMethod method ) { Set < JipFrame > set = new HashSet < JipFrame > ( ) ; PerMethodInfo perMethod = mPerMethods . get ( method ) ; if ( perMethod ! = null ) { for ( JipFrame frame : perMethod . allFrames ( ) ) { JipFrame parent = frame . getParentOrNull ( ) ; if ( parent ! = null ) { set . add ( parent ) ; } } } return set ; }
void test19 ( ) throws Throwable { JipRun jipRun0 = new JipRun ( ) ; Iterable < JipFrame > iterable0 = jipRun0 . allCallees ( ( JipMethod ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Iterable < JipFrame > allCallees ( JipMethod method ) { Set set = new HashSet < JipFrame > ( ) ; PerMethodInfo perMethod = mPerMethods . get ( method ) ; if ( perMethod ! = null ) { for ( JipFrame frame : perMethod . allFrames ( ) ) { for ( JipFrame callee : frame . getChildren ( ) ) { set . add ( callee ) ; } } } return set ; }
void test0 ( ) throws Throwable { MethodRow methodRow0 = new MethodRow ( ( JipMethod ) null ) ; double double0 = methodRow0 . getPercentNet ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPercentNet ( ) { return toPercent ( mNetTime / mTimeDenominator ) ; }
void test1 ( ) throws Throwable { MethodRow methodRow0 = new MethodRow ( ( JipMethod ) null ) ; long long0 = methodRow0 . getCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPercentNet ( ) { return toPercent ( mNetTime / mTimeDenominator ) ; }
void test2 ( ) throws Throwable { MethodRow methodRow0 = new MethodRow ( ( JipMethod ) null ) ; long long0 = methodRow0 . getTotalTime ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPercentTotal ( ) { double percent = toPercent ( mTotalTime / mTimeDenominator ) ; return percent ; }
void test3 ( ) throws Throwable { MethodRow methodRow0 = new MethodRow ( ( JipMethod ) null ) ; double double0 = methodRow0 . getPercentTotal ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPercentTotal ( ) { double percent = toPercent ( mTotalTime / mTimeDenominator ) ; return percent ; }
void test5 ( ) throws Throwable { MethodRow methodRow0 = new MethodRow ( ( JipMethod ) null ) ; long long0 = methodRow0 . getNetTime ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPercentNet ( ) { return toPercent ( mNetTime / mTimeDenominator ) ; }
void test6 ( ) throws Throwable { MethodRow methodRow0 = new MethodRow ( ( JipMethod ) null ) ; methodRow0 . setTimeDenominator ( 1 . 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double getPercentNet ( ) { return toPercent ( mNetTime / mTimeDenominator ) ; }
void test0 ( ) throws Throwable { ValueModel < Object > valueModel0 = new ValueModel < Object > ( ) ; Object object0 = valueModel0 . getValue ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Type getValue ( ) { return mValue ; }
void test0 ( ) throws Throwable { HelpViewer helpViewer0 = new HelpViewer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" HelpViewer ( ) { String path = "com / tivo / jipviewer / help . html" ; InputStream in = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( path ) ; JTextPane textPane = new JTextPane ( ) ; textPane . setEditable ( false ) ; String errorText = null ; if ( in = = null ) { errorText = "couldn't read help text from '" + path + "' ! " ; } else { try { HTMLEditorKit kit = new HTMLEditorKit ( ) ; textPane . setEditorKit ( kit ) ; kit . read ( in , textPane . getDocument ( ) , 0 ) ; } catch ( IOException e ) { errorText = e . toString ( ) ; } catch ( BadLocationException e ) { errorText = e . toString ( ) ; } } if ( errorText ! = null ) { textPane . setText ( errorText ) ; } add ( new JScrollPane ( textPane ) ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; }
void test2 ( ) throws Throwable { ByPackageViewer . TreeNode byPackageViewer_TreeNode0 = new ByPackageViewer . TreeNode ( "" ) ; String string0 = byPackageViewer_TreeNode0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test3 ( ) throws Throwable { ByPackageViewer . TreeNode byPackageViewer_TreeNode0 = new ByPackageViewer . TreeNode ( "parameter\"clazz must not be null" ) ; String string0 = byPackageViewer_TreeNode0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test4 ( ) throws Throwable { ByPackageViewer . TreeNode byPackageViewer_TreeNode0 = new ByPackageViewer . TreeNode ( "IYIlV ] tUY" ) ; ByPackageViewer . TreeNode byPackageViewer_TreeNode1 = new ByPackageViewer . TreeNode ( "IYIlV ] tUY" ) ; byPackageViewer_TreeNode1 . add ( ( MutableTreeNode ) byPackageViewer_TreeNode0 ) ; String string0 = byPackageViewer_TreeNode1 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test0 ( ) throws Throwable { MethodViewer . MyDoubleRenderer methodViewer_MyDoubleRenderer0 = new MethodViewer . MyDoubleRenderer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setValue ( JTextField label , String value ) { Runnable runner = new Runnable ( ) { void run ( ) { label . setText ( value ) ; } } ; SwingUtilities . invokeLater ( runner ) ; }
void test2 ( ) throws Throwable { Vector < TableSorter > vector0 = new Vector < TableSorter > ( ) ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( vector0 , vector0 ) ; TableSorter tableSorter0 = new TableSorter ( ( TableModel ) defaultTableModel0 ) ; defaultTableModel0 . setRowCount ( 8 ) ; JTable jTable0 = MethodViewer . makeTableForMethodRows ( ( TableModel ) tableSorter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTable makeTableForMethodRows ( TableModel model ) { TableSorter sorter = new TableSorter ( model ) ; JTable table = new JTable ( sorter ) ; sorter . setTableHeader ( table . getTableHeader ( ) ) ; TableColumnModel colModel = table . getColumnModel ( ) ; int nCol = model . getColumnCount ( ) ; for ( int iCol = 0 ; iCol < nCol ; iCol + + ) { TableColumn col = colModel . getColumn ( iCol ) ; if ( iCol < svWidth . length ) { col . setPreferredWidth ( svWidth [ iCol ] ) ; } } table . doLayout ( ) ; table . setDefaultRenderer ( Double . class , new MyDoubleRenderer ( ) ) ; return table ; }
void test0 ( ) throws Throwable { JipFrame jipFrame0 = new JipFrame ( ( JipFrame ) null , ( JipMethod ) null , ( - 892L ) , ( - 892L ) , ( - 892L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalTime ( ) { return _totalTime ; }
void test1 ( ) throws Throwable { JipFrame jipFrame0 = new JipFrame ( ( JipFrame ) null , ( JipMethod ) null , ( - 892L ) , ( - 892L ) , ( - 892L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getCount ( ) { return _count ; }
void test2 ( ) throws Throwable { JipFrame jipFrame0 = new JipFrame ( ( JipFrame ) null , ( JipMethod ) null , ( - 892L ) , ( - 892L ) , ( - 892L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalTime ( ) { return _totalTime ; }
void test3 ( ) throws Throwable { JipFrame jipFrame0 = new JipFrame ( ( JipFrame ) null , ( JipMethod ) null , ( - 892L ) , ( - 892L ) , ( - 892L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getNetTime ( ) { return mNetTime ; }
void test4 ( ) throws Throwable { JipFrame jipFrame0 = new JipFrame ( ( JipFrame ) null , ( JipMethod ) null , ( - 892L ) , ( - 892L ) , ( - 892L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalTime ( ) { return _totalTime ; }
void test5 ( ) throws Throwable { JipFrame jipFrame0 = new JipFrame ( ( JipFrame ) null , ( JipMethod ) null , ( - 892L ) , ( - 892L ) , ( - 892L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isReentrant ( ) { JipFrame scan = mParent ; while ( scan ! = null ) { if ( scan . getMethod ( ) . equals ( mMethod ) ) { return true ; } scan = scan . getParentOrNull ( ) ; } return false ; }
void test6 ( ) throws Throwable { JipFrame jipFrame0 = new JipFrame ( ( JipFrame ) null , ( JipMethod ) null , ( - 892L ) , ( - 892L ) , ( - 892L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getCount ( ) { return _count ; }
void test7 ( ) throws Throwable { JipFrame jipFrame0 = new JipFrame ( ( JipFrame ) null , ( JipMethod ) null , ( - 892L ) , ( - 892L ) , ( - 892L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getNetTime ( ) { return mNetTime ; }
void test0 ( ) throws Throwable { JipViewer . TreeNode jipViewer_TreeNode0 = new JipViewer . TreeNode ( ( JipFrame ) null ) ; String string0 = jipViewer_TreeNode0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test1 ( ) throws Throwable { JipViewer . TreeNode jipViewer_TreeNode0 = new JipViewer . TreeNode ( ( JipFrame ) null ) ; JipViewer . TreeNode jipViewer_TreeNode1 = new JipViewer . TreeNode ( ( String ) null ) ; jipViewer_TreeNode0 . insert ( ( MutableTreeNode ) jipViewer_TreeNode1 , 0 ) ; TreePath treePath0 = jipViewer_TreeNode0 . findPathForMethod ( ( JipMethod ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JipViewer ( String title , JipRun run ) { super ( title ) ; addKeyListener ( this ) ; mMethodModel . addChangeListener ( this ) ; / / build the call tree mCallTreeRoot = new TreeNode ( title ) ; buildTree ( run , mCallTreeRoot ) ; mCallTree = new JTree ( mCallTreeRoot ) ; mCallTree . getSelectionModel ( ) . setSelectionMode ( TreeSelectionModel . SINGLE_TREE_SELECTION ) ; mCallTree . addTreeSelectionListener ( this ) ; mCallTree . addKeyListener ( this ) ; / / build the allMethods table Collection < JipRun . PerMethodInfo > perMethodInfos = run . perMethodsInTotalTimeOrder ( ) ; long totalTimeForAllThreads = run . getTotalTimeForAllThreads ( ) ; for ( JipRun . PerMethodInfo perMethod : perMethodInfos ) { MethodRow row = new MethodRow ( perMethod . getMethod ( ) ) ; for ( JipFrame frame : perMethod . allFrames ( ) ) { if ( ! frame . isReentrant ( ) ) { row . addFrame ( frame ) ; } row . setTimeDenominator ( totalTimeForAllThreads ) ; } mAllMethodsModel . add ( row ) ; } mMethods = MethodViewer . makeTableForMethodRows ( mAllMethodsModel ) ; mMethods . getSelectionModel ( ) . addListSelectionListener ( this ) ; mMethods . addKeyListener ( this ) ; mAllMethodsSorterModel = ( TableSorter ) mMethods . getModel ( ) ; / / make the ByPackageViewer mPkgViewer = new ByPackageViewer ( run ) ; mPkgViewer . addKeyListener ( this ) ; / / make the RemoteController mRemoteController = new RemoteController ( ) ; mRemoteController . addKeyListener ( this ) ; / / make the methodViewer MethodViewer methodViewer = new MethodViewer ( run , mMethodModel ) ; / / combine all the views JTabbedPane tabPane = new JTabbedPane ( ) ; tabPane . addTab ( "call tree" , new JScrollPane ( mCallTree ) ) ; tabPane . addTab ( "methods" , new JScrollPane ( mMethods ) ) ; tabPane . addTab ( "by package" , new JScrollPane ( mPkgViewer ) ) ; tabPane . addTab ( "remote control" , mRemoteController ) ; tabPane . addTab ( "help" , new HelpViewer ( ) ) ; tabPane . addKeyListener ( this ) ; tabPane . setMinimumSize ( new Dimension ( 100 , 200 ) ) ; JSplitPane split = new JSplitPane ( JSplitPane . VERTICAL_SPLIT , tabPane , methodViewer ) ; setContentPane ( split ) ; pack ( ) ; setSize ( new Dimension ( 1024 , 768 ) ) ; setVisible ( true ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; }
void test1 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "\"u + b | D * uj" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "\"u + b | D * uj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test3 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; ClassReader classReader0 = new ClassReader ( "java / lang / Object" ) ; classReader0 . accept ( ( ClassVisitor ) classWriter0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return _className ; }
void test6 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 73 , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test7 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1381 ) ; String [ ] stringArray0 = new String [ 1 ] ; stringArray0 [ 0 ] = "" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "" , "H , { z1 + z } @b ) 't * gN5" , "" , stringArray0 , false , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test8 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 831 ) ; ClassReader classReader0 = new ClassReader ( "java / lang / Object" ) ; classReader0 . accept ( ( ClassVisitor ) classWriter0 , 928 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAccess ( ) { return readUnsignedShort ( header ) ; }
void test9 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1381 ) ; String [ ] stringArray0 = new String [ 7 ] ; stringArray0 [ 0 ] = " , h & + BD9~icujSt + m" ; stringArray0 [ 1 ] = " , h & + BD9~icujSt + m" ; stringArray0 [ 2 ] = "n - OAuprG" ; stringArray0 [ 3 ] = "n - OAuprG" ; stringArray0 [ 4 ] = "2lBMs ; Do - " ; stringArray0 [ 5 ] = " , h & + BD9~icujSt + m" ; stringArray0 [ 6 ] = " , h & + BD9~icujSt + m" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 31 , "n - OAuprG" , " , h & + BD9~icujSt + m" , "n - OAuprG" , stringArray0 , false , false ) ; methodWriter0 . visitAnnotation ( "2lBMs ; Do - " , true ) ; byte [ ] byteArray0 = classWriter0 . toByteArray ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] toByteArray ( ) { / / computes the real size of the bytecode of this class int size = 24 + 2 * interfaceCount ; int nbFields = 0 ; FieldWriter fb = firstField ; while ( fb ! = null ) { + + nbFields ; size + = fb . getSize ( ) ; fb = fb . next ; } int nbMethods = 0 ; MethodWriter mb = firstMethod ; while ( mb ! = null ) { + + nbMethods ; size + = mb . getSize ( ) ; mb = mb . next ; } int attributeCount = 0 ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "Signature" ) ; } if ( sourceFile ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "SourceFile" ) ; } if ( sourceDebug ! = null ) { + + attributeCount ; size + = sourceDebug . length + 4 ; newUTF8 ( "SourceDebugExtension" ) ; } if ( enclosingMethodOwner ! = 0 ) { + + attributeCount ; size + = 10 ; newUTF8 ( "EnclosingMethod" ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Deprecated" ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Synthetic" ) ; } if ( innerClasses ! = null ) { + + attributeCount ; size + = 8 + innerClasses . length ; newUTF8 ( "InnerClasses" ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; size + = 8 + anns . getSize ( ) ; newUTF8 ( "RuntimeVisibleAnnotations" ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; size + = 8 + ianns . getSize ( ) ; newUTF8 ( "RuntimeInvisibleAnnotations" ) ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; size + = attrs . getSize ( this , null , 0 , - 1 , - 1 ) ; } size + = pool . length ; / / allocates a byte vector of this size , in order to avoid unnecessary / / arraycopy operations in the ByteVector . enlarge ( ) method ByteVector out = new ByteVector ( size ) ; out . putInt ( 0xCAFEBABE ) . putInt ( version ) ; out . putShort ( index ) . putByteArray ( pool . data , 0 , pool . length ) ; out . putShort ( access ) . putShort ( name ) . putShort ( superName ) ; out . putShort ( interfaceCount ) ; for ( int i = 0 ; i < interfaceCount ; + + i ) { out . putShort ( interfaces [ i ] ) ; } out . putShort ( nbFields ) ; fb = firstField ; while ( fb ! = null ) { fb . put ( out ) ; fb = fb . next ; } out . putShort ( nbMethods ) ; mb = firstMethod ; while ( mb ! = null ) { mb . put ( out ) ; mb = mb . next ; } out . putShort ( attributeCount ) ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { out . putShort ( newUTF8 ( "Signature" ) ) . putInt ( 2 ) . putShort ( signature ) ; } if ( sourceFile ! = 0 ) { out . putShort ( newUTF8 ( "SourceFile" ) ) . putInt ( 2 ) . putShort ( sourceFile ) ; } if ( sourceDebug ! = null ) { int len = sourceDebug . length - 2 ; out . putShort ( newUTF8 ( "SourceDebugExtension" ) ) . putInt ( len ) ; out . putByteArray ( sourceDebug . data , 2 , len ) ; } if ( enclosingMethodOwner ! = 0 ) { out . putShort ( newUTF8 ( "EnclosingMethod" ) ) . putInt ( 4 ) ; out . putShort ( enclosingMethodOwner ) . putShort ( enclosingMethod ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { out . putShort ( newUTF8 ( "Deprecated" ) ) . putInt ( 0 ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { out . putShort ( newUTF8 ( "Synthetic" ) ) . putInt ( 0 ) ; } if ( innerClasses ! = null ) { out . putShort ( newUTF8 ( "InnerClasses" ) ) ; out . putInt ( innerClasses . length + 2 ) . putShort ( innerClassesCount ) ; out . putByteArray ( innerClasses . data , 0 , innerClasses . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( newUTF8 ( "RuntimeVisibleAnnotations" ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( newUTF8 ( "RuntimeInvisibleAnnotations" ) ) ; ianns . put ( out ) ; } if ( attrs ! = null ) { attrs . put ( this , null , 0 , - 1 , - 1 , out ) ; } if ( invalidFrames ) { ClassWriter cw = new ClassWriter ( COMPUTE_FRAMES ) ; new ClassReader ( out . data ) . accept ( cw , ClassReader . SKIP_FRAMES ) ; return cw . toByteArray ( ) ; } return out . data ; }
void test10 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 73 , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" AnnotationVisitor visitParameterAnnotation ( int parameter , String desc , boolean visible ) { if ( ! ClassReader . ANNOTATIONS ) { return null ; } ByteVector bv = new ByteVector ( ) ; if ( "Ljava / lang / Synthetic ; " . equals ( desc ) ) { / / workaround for a bug in javac with synthetic parameters / / see ClassReader . readParameterAnnotations synthetics = Math . max ( synthetics , parameter + 1 ) ; return new AnnotationWriter ( cw , false , bv , null , 0 ) ; } / / write type , and reserve space for values count bv . putShort ( cw . newUTF8 ( desc ) ) . putShort ( 0 ) ; AnnotationWriter aw = new AnnotationWriter ( cw , true , bv , bv , 2 ) ; if ( visible ) { if ( panns = = null ) { panns = new AnnotationWriter [ Type . getArgumentTypes ( descriptor ) . length ] ; } aw . next = panns [ parameter ] ; panns [ parameter ] = aw ; } else { if ( ipanns = = null ) { ipanns = new AnnotationWriter [ Type . getArgumentTypes ( descriptor ) . length ] ; } aw . next = ipanns [ parameter ] ; ipanns [ parameter ] = aw ; } return aw ; }
void test11 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 831 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , ( - 955 ) , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" AnnotationVisitor visitParameterAnnotation ( int parameter , String desc , boolean visible ) { if ( ! ClassReader . ANNOTATIONS ) { return null ; } ByteVector bv = new ByteVector ( ) ; if ( "Ljava / lang / Synthetic ; " . equals ( desc ) ) { / / workaround for a bug in javac with synthetic parameters / / see ClassReader . readParameterAnnotations synthetics = Math . max ( synthetics , parameter + 1 ) ; return new AnnotationWriter ( cw , false , bv , null , 0 ) ; } / / write type , and reserve space for values count bv . putShort ( cw . newUTF8 ( desc ) ) . putShort ( 0 ) ; AnnotationWriter aw = new AnnotationWriter ( cw , true , bv , bv , 2 ) ; if ( visible ) { if ( panns = = null ) { panns = new AnnotationWriter [ Type . getArgumentTypes ( descriptor ) . length ] ; } aw . next = panns [ parameter ] ; panns [ parameter ] = aw ; } else { if ( ipanns = = null ) { ipanns = new AnnotationWriter [ Type . getArgumentTypes ( descriptor ) . length ] ; } aw . next = ipanns [ parameter ] ; ipanns [ parameter ] = aw ; } return aw ; }
void test12 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 22 ] ; String [ ] stringArray1 = new String [ 4 ] ; stringArray1 [ 0 ] = "java / lang / Object" ; stringArray1 [ 1 ] = "java / lang / Object" ; stringArray1 [ 2 ] = "java / lang / Object" ; stringArray1 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 73 , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray1 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visitFrame ( int type , int nLocal , Object [ ] local , int nStack , Object [ ] stack ) { if ( ! ClassReader . FRAMES | | compute = = FRAMES ) { return ; } if ( type = = Opcodes . F_NEW ) { startFrame ( code . length , nLocal , nStack ) ; for ( int i = 0 ; i < nLocal ; + + i ) { if ( local [ i ] instanceof String ) { frame [ frameIndex + + ] = Frame . OBJECT | cw . addType ( ( String ) local [ i ] ) ; } else if ( local [ i ] instanceof Integer ) { frame [ frameIndex + + ] = ( ( Integer ) local [ i ] ) . intValue ( ) ; } else { frame [ frameIndex + + ] = Frame . UNINITIALIZED | cw . addUninitializedType ( "" , ( ( Label ) local [ i ] ) . position ) ; } } for ( int i = 0 ; i < nStack ; + + i ) { if ( stack [ i ] instanceof String ) { frame [ frameIndex + + ] = Frame . OBJECT | cw . addType ( ( String ) stack [ i ] ) ; } else if ( stack [ i ] instanceof Integer ) { frame [ frameIndex + + ] = ( ( Integer ) stack [ i ] ) . intValue ( ) ; } else { frame [ frameIndex + + ] = Frame . UNINITIALIZED | cw . addUninitializedType ( "" , ( ( Label ) stack [ i ] ) . position ) ; } } endFrame ( ) ; } else { int delta ; if ( stackMap = = null ) { stackMap = new ByteVector ( ) ; delta = code . length ; } else { delta = code . length - previousFrameOffset - 1 ; if ( delta < 0 ) { if ( type = = Opcodes . F_SAME ) { return ; } else { throw new IllegalStateException ( ) ; } } } switch ( type ) { case Opcodes . F_FULL : stackMap . putByte ( FULL_FRAME ) . putShort ( delta ) . putShort ( nLocal ) ; for ( int i = 0 ; i < nLocal ; + + i ) { writeFrameType ( local [ i ] ) ; } stackMap . putShort ( nStack ) ; for ( int i = 0 ; i < nStack ; + + i ) { writeFrameType ( stack [ i ] ) ; } break ; case Opcodes . F_APPEND : stackMap . putByte ( SAME_FRAME_EXTENDED + nLocal ) . putShort ( delta ) ; for ( int i = 0 ; i < nLocal ; + + i ) { writeFrameType ( local [ i ] ) ; } break ; case Opcodes . F_CHOP : stackMap . putByte ( SAME_FRAME_EXTENDED - nLocal ) . putShort ( delta ) ; break ; case Opcodes . F_SAME : if ( delta < 64 ) { stackMap . putByte ( delta ) ; } else { stackMap . putByte ( SAME_FRAME_EXTENDED ) . putShort ( delta ) ; } break ; case Opcodes . F_SAME1 : if ( delta < 64 ) { stackMap . putByte ( SAME_LOCALS_1_STACK_ITEM_FRAME + delta ) ; } else { stackMap . putByte ( SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED ) . putShort ( delta ) ; } writeFrameType ( stack [ 0 ] ) ; break ; } previousFrameOffset = code . length ; + + frameCount ; } }
void test13 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 22 ] ; String [ ] stringArray1 = new String [ 4 ] ; stringArray1 [ 0 ] = "java / lang / Object" ; stringArray1 [ 1 ] = "java / lang / Object" ; stringArray1 [ 2 ] = "java / lang / Object" ; stringArray1 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 73 , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray1 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test14 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "\"u + b | D * uj" ; stringArray0 [ 1 ] = "a * _ { ` ) 1 + I < } @ / [ V1 > f" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "\"u + b | D * uj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test15 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "\"u + b | D * uj" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "\"u + b | D * uj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test16 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , ( - 955 ) , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test17 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 831 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , ( - 955 ) , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test18 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; stringArray0 [ 2 ] = "\"uVb | Dguj" ; stringArray0 [ 3 ] = "\"uVb | Dguj" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 9 , "\"uVb | Dguj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test19 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , ( - 955 ) , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test20 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "\"u + b | D * uj" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "\"u + b | D * uj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test21 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; stringArray0 [ 2 ] = "\"uVb | Dguj" ; stringArray0 [ 3 ] = "\"uVb | Dguj" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 9 , "\"uVb | Dguj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test22 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 831 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , ( - 955 ) , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test23 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "\"u + b | D * uj" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "\"u + b | D * uj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test24 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; stringArray0 [ 2 ] = "\"uVb | Dguj" ; stringArray0 [ 3 ] = "\"uVb | Dguj" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 9 , "\"uVb | Dguj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test25 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 831 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , ( - 955 ) , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test26 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , ( - 955 ) , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test27 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; stringArray0 [ 2 ] = "\"uVb | Dguj" ; stringArray0 [ 3 ] = "\"uVb | Dguj" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 9 , "\"uVb | Dguj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test28 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 73 , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test29 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "\"u + b | D * uj" ; stringArray0 [ 1 ] = "a * _ { ` ) 1 + I < } @ / [ V1 > f" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "\"u + b | D * uj" , stringArray0 , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test30 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "\"u + b | D * uj" ; stringArray0 [ 1 ] = "a * _ { ` ) 1 + I < } @ / [ V1 > f" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "\"u + b | D * uj" , stringArray0 , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test31 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "\"u + b | D * uj" ; stringArray0 [ 1 ] = "a * _ { ` ) 1 + I < } @ / [ V1 > f" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "\"u + b | D * uj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test32 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "\"u + b | D * uj" ; stringArray0 [ 1 ] = "a * _ { ` ) 1 + I < } @ / [ V1 > f" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "\"u + b | D * uj" , stringArray0 , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test33 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 8 ] ; String [ ] stringArray1 = new String [ 4 ] ; stringArray1 [ 0 ] = "java / lang / Object" ; stringArray1 [ 1 ] = "java / lang / Object" ; stringArray1 [ 2 ] = "java / lang / Object" ; stringArray1 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , ( - 944 ) , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray1 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visitFrame ( int type , int nLocal , Object [ ] local , int nStack , Object [ ] stack ) { if ( ! ClassReader . FRAMES | | compute = = FRAMES ) { return ; } if ( type = = Opcodes . F_NEW ) { startFrame ( code . length , nLocal , nStack ) ; for ( int i = 0 ; i < nLocal ; + + i ) { if ( local [ i ] instanceof String ) { frame [ frameIndex + + ] = Frame . OBJECT | cw . addType ( ( String ) local [ i ] ) ; } else if ( local [ i ] instanceof Integer ) { frame [ frameIndex + + ] = ( ( Integer ) local [ i ] ) . intValue ( ) ; } else { frame [ frameIndex + + ] = Frame . UNINITIALIZED | cw . addUninitializedType ( "" , ( ( Label ) local [ i ] ) . position ) ; } } for ( int i = 0 ; i < nStack ; + + i ) { if ( stack [ i ] instanceof String ) { frame [ frameIndex + + ] = Frame . OBJECT | cw . addType ( ( String ) stack [ i ] ) ; } else if ( stack [ i ] instanceof Integer ) { frame [ frameIndex + + ] = ( ( Integer ) stack [ i ] ) . intValue ( ) ; } else { frame [ frameIndex + + ] = Frame . UNINITIALIZED | cw . addUninitializedType ( "" , ( ( Label ) stack [ i ] ) . position ) ; } } endFrame ( ) ; } else { int delta ; if ( stackMap = = null ) { stackMap = new ByteVector ( ) ; delta = code . length ; } else { delta = code . length - previousFrameOffset - 1 ; if ( delta < 0 ) { if ( type = = Opcodes . F_SAME ) { return ; } else { throw new IllegalStateException ( ) ; } } } switch ( type ) { case Opcodes . F_FULL : stackMap . putByte ( FULL_FRAME ) . putShort ( delta ) . putShort ( nLocal ) ; for ( int i = 0 ; i < nLocal ; + + i ) { writeFrameType ( local [ i ] ) ; } stackMap . putShort ( nStack ) ; for ( int i = 0 ; i < nStack ; + + i ) { writeFrameType ( stack [ i ] ) ; } break ; case Opcodes . F_APPEND : stackMap . putByte ( SAME_FRAME_EXTENDED + nLocal ) . putShort ( delta ) ; for ( int i = 0 ; i < nLocal ; + + i ) { writeFrameType ( local [ i ] ) ; } break ; case Opcodes . F_CHOP : stackMap . putByte ( SAME_FRAME_EXTENDED - nLocal ) . putShort ( delta ) ; break ; case Opcodes . F_SAME : if ( delta < 64 ) { stackMap . putByte ( delta ) ; } else { stackMap . putByte ( SAME_FRAME_EXTENDED ) . putShort ( delta ) ; } break ; case Opcodes . F_SAME1 : if ( delta < 64 ) { stackMap . putByte ( SAME_LOCALS_1_STACK_ITEM_FRAME + delta ) ; } else { stackMap . putByte ( SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED ) . putShort ( delta ) ; } writeFrameType ( stack [ 0 ] ) ; break ; } previousFrameOffset = code . length ; + + frameCount ; } }
void test34 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 73 , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test35 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 22 ] ; String [ ] stringArray1 = new String [ 4 ] ; stringArray1 [ 0 ] = "java / lang / Object" ; stringArray1 [ 1 ] = "java / lang / Object" ; stringArray1 [ 2 ] = "java / lang / Object" ; stringArray1 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 73 , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray1 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test36 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , ( - 955 ) , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test37 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; classWriter0 . version = 73 ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , ( - 955 ) , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test38 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "\"u + b | D * uj" ; stringArray0 [ 1 ] = "a * _ { ` ) 1 + I < } @ / [ V1 > f" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "\"u + b | D * uj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test39 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 73 , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test40 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 73 , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test41 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "java / lang / Object" ; stringArray0 [ 1 ] = "java / lang / Object" ; stringArray0 [ 2 ] = "java / lang / Object" ; stringArray0 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , ( - 944 ) , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray0 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test42 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 73 ) ; String [ ] stringArray0 = new String [ 22 ] ; String [ ] stringArray1 = new String [ 4 ] ; stringArray1 [ 0 ] = "java / lang / Object" ; stringArray1 [ 1 ] = "java / lang / Object" ; stringArray1 [ 2 ] = "java / lang / Object" ; stringArray1 [ 3 ] = "java / lang / Object" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 73 , "java / lang / Object" , "java / lang / Object" , "java / lang / Object" , stringArray1 , false , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test43 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "\"u + b | D * uj" ; stringArray0 [ 1 ] = "a * _ { ` ) 1 + I < } @ / [ V1 > f" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "\"u + b | D * uj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void put ( ByteVector out ) { out . putShort ( access ) . putShort ( name ) . putShort ( desc ) ; if ( classReaderOffset ! = 0 ) { out . putByteArray ( cw . cr . b , classReaderOffset , classReaderLength ) ; return ; } int attributeCount = 0 ; if ( code . length > 0 ) { + + attributeCount ; } if ( exceptionCount > 0 ) { + + attributeCount ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( cw . version & 0xffff ) < Opcodes . V1_5 ) { + + attributeCount ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { + + attributeCount ; } if ( ClassReader . SIGNATURES & & signature ! = null ) { + + attributeCount ; } if ( ClassReader . ANNOTATIONS & & annd ! = null ) { + + attributeCount ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; } if ( ClassReader . ANNOTATIONS & & panns ! = null ) { + + attributeCount ; } if ( ClassReader . ANNOTATIONS & & ipanns ! = null ) { + + attributeCount ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; } out . putShort ( attributeCount ) ; if ( code . length > 0 ) { int size = 12 + code . length + 8 * handlerCount ; if ( localVar ! = null ) { size + = 8 + localVar . length ; } if ( localVarType ! = null ) { size + = 8 + localVarType . length ; } if ( lineNumber ! = null ) { size + = 8 + lineNumber . length ; } if ( stackMap ! = null ) { size + = 8 + stackMap . length ; } if ( cattrs ! = null ) { size + = cattrs . getSize ( cw , code . data , code . length , maxStack , maxLocals ) ; } out . putShort ( cw . newUTF8 ( "Code" ) ) . putInt ( size ) ; out . putShort ( maxStack ) . putShort ( maxLocals ) ; out . putInt ( code . length ) . putByteArray ( code . data , 0 , code . length ) ; out . putShort ( handlerCount ) ; if ( handlerCount > 0 ) { Handler h = firstHandler ; while ( h ! = null ) { out . putShort ( h . start . position ) . putShort ( h . end . position ) . putShort ( h . handler . position ) . putShort ( h . type ) ; h = h . next ; } } attributeCount = 0 ; if ( localVar ! = null ) { + + attributeCount ; } if ( localVarType ! = null ) { + + attributeCount ; } if ( lineNumber ! = null ) { + + attributeCount ; } if ( stackMap ! = null ) { + + attributeCount ; } if ( cattrs ! = null ) { attributeCount + = cattrs . getCount ( ) ; } out . putShort ( attributeCount ) ; if ( localVar ! = null ) { out . putShort ( cw . newUTF8 ( "LocalVariableTable" ) ) ; out . putInt ( localVar . length + 2 ) . putShort ( localVarCount ) ; out . putByteArray ( localVar . data , 0 , localVar . length ) ; } if ( localVarType ! = null ) { out . putShort ( cw . newUTF8 ( "LocalVariableTypeTable" ) ) ; out . putInt ( localVarType . length + 2 ) . putShort ( localVarTypeCount ) ; out . putByteArray ( localVarType . data , 0 , localVarType . length ) ; } if ( lineNumber ! = null ) { out . putShort ( cw . newUTF8 ( "LineNumberTable" ) ) ; out . putInt ( lineNumber . length + 2 ) . putShort ( lineNumberCount ) ; out . putByteArray ( lineNumber . data , 0 , lineNumber . length ) ; } if ( stackMap ! = null ) { boolean zip = ( cw . version & 0xFFFF ) > = Opcodes . V1_6 ; out . putShort ( cw . newUTF8 ( zip ? "StackMapTable" : "StackMap" ) ) ; out . putInt ( stackMap . length + 2 ) . putShort ( frameCount ) ; out . putByteArray ( stackMap . data , 0 , stackMap . length ) ; } if ( cattrs ! = null ) { cattrs . put ( cw , code . data , code . length , maxLocals , maxStack , out ) ; } } if ( exceptionCount > 0 ) { out . putShort ( cw . newUTF8 ( "Exceptions" ) ) . putInt ( 2 * exceptionCount + 2 ) ; out . putShort ( exceptionCount ) ; for ( int i = 0 ; i < exceptionCount ; + + i ) { out . putShort ( exceptions [ i ] ) ; } } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( cw . version & 0xffff ) < Opcodes . V1_5 ) { out . putShort ( cw . newUTF8 ( "Synthetic" ) ) . putInt ( 0 ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { out . putShort ( cw . newUTF8 ( "Deprecated" ) ) . putInt ( 0 ) ; } if ( ClassReader . SIGNATURES & & signature ! = null ) { out . putShort ( cw . newUTF8 ( "Signature" ) ) . putInt ( 2 ) . putShort ( cw . newUTF8 ( signature ) ) ; } if ( ClassReader . ANNOTATIONS & & annd ! = null ) { out . putShort ( cw . newUTF8 ( "AnnotationDefault" ) ) ; out . putInt ( annd . length ) ; out . putByteArray ( annd . data , 0 , annd . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( cw . newUTF8 ( "RuntimeVisibleAnnotations" ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( cw . newUTF8 ( "RuntimeInvisibleAnnotations" ) ) ; ianns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & panns ! = null ) { out . putShort ( cw . newUTF8 ( "RuntimeVisibleParameterAnnotations" ) ) ; AnnotationWriter . put ( panns , synthetics , out ) ; } if ( ClassReader . ANNOTATIONS & & ipanns ! = null ) { out . putShort ( cw . newUTF8 ( "RuntimeInvisibleParameterAnnotations" ) ) ; AnnotationWriter . put ( ipanns , synthetics , out ) ; } if ( attrs ! = null ) { attrs . put ( cw , null , 0 , - 1 , - 1 , out ) ; } }
void test44 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "\"u + b | D * uj" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "\"u + b | D * uj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test45 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1283 ) ; String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; stringArray0 [ 2 ] = "\"u + b | D * uj" ; stringArray0 [ 3 ] = "\"u + b | D * uj" ; MethodWriter methodWriter0 = new MethodWriter ( classWriter0 , 0 , "\"u + b | D * uj" , "a * _ { ` ) 1 + I < } @ / [ V1 > f" , "" , stringArray0 , true , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test46 ( ) throws Throwable { int [ ] intArray0 = new int [ 4 ] ; intArray0 [ 3 ] = 1024 ; int int0 = MethodWriter . getNewOffset ( intArray0 , intArray0 , 0 , 1024 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getNewOffset ( int [ ] indexes , int [ ] sizes , int begin , int end ) { int offset = end - begin ; for ( int i = 0 ; i < indexes . length ; + + i ) { if ( begin < indexes [ i ] & & indexes [ i ] < = end ) { / / forward jump offset + = sizes [ i ] ; } else if ( end < indexes [ i ] & & indexes [ i ] < = begin ) { / / backward jump offset - = sizes [ i ] ; } } return offset ; }
void test47 ( ) throws Throwable { int [ ] intArray0 = new int [ 7 ] ; int int0 = MethodWriter . getNewOffset ( intArray0 , intArray0 , 0 , ( - 85 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getNewOffset ( int [ ] indexes , int [ ] sizes , int begin , int end ) { int offset = end - begin ; for ( int i = 0 ; i < indexes . length ; + + i ) { if ( begin < indexes [ i ] & & indexes [ i ] < = end ) { / / forward jump offset + = sizes [ i ] ; } else if ( end < indexes [ i ] & & indexes [ i ] < = begin ) { / / backward jump offset - = sizes [ i ] ; } } return offset ; }
void test48 ( ) throws Throwable { int [ ] intArray0 = new int [ 5 ] ; Label label0 = new Label ( ) ; MethodWriter . getNewOffset ( intArray0 , intArray0 , label0 ) ; MethodWriter . getNewOffset ( intArray0 , intArray0 , label0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test1 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 224 ) ; ClassAdapter classAdapter0 = new ClassAdapter ( ( ClassVisitor ) classWriter0 ) ; AnnotationVisitor annotationVisitor0 = classAdapter0 . visitAnnotation ( "eG ( qO75" , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" AnnotationVisitor visitAnnotation ( String desc , boolean visible ) { return cv . visitAnnotation ( desc , visible ) ; }
void test8 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 847 ) ) ; ClassAdapter classAdapter0 = new ClassAdapter ( ( ClassVisitor ) classWriter0 ) ; FieldVisitor fieldVisitor0 = classAdapter0 . visitField ( 0 , "" , "" , "" , ( Object ) "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FieldVisitor visitField ( int access , String name , String desc , String signature , Object value ) { return cv . visitField ( access , name , desc , signature , value ) ; }
void test0 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector putByte ( int b ) { int length = this . length ; if ( length + 1 > data . length ) { enlarge ( 1 ) ; } data [ length + + ] = ( byte ) b ; this . length = length ; return this ; }
void test1 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector ( ) { data = new byte [ 64 ] ; }
void test2 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector putByte ( int b ) { int length = this . length ; if ( length + 1 > data . length ) { enlarge ( 1 ) ; } data [ length + + ] = ( byte ) b ; this . length = length ; return this ; }
void test3 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector put11 ( int b1 , int b2 ) { int length = this . length ; if ( length + 2 > data . length ) { enlarge ( 2 ) ; } byte [ ] data = this . data ; data [ length + + ] = ( byte ) b1 ; data [ length + + ] = ( byte ) b2 ; this . length = length ; return this ; }
void test4 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 115 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector putShort ( int s ) { int length = this . length ; if ( length + 2 > data . length ) { enlarge ( 2 ) ; } byte [ ] data = this . data ; data [ length + + ] = ( byte ) ( s > > > 8 ) ; data [ length + + ] = ( byte ) s ; this . length = length ; return this ; }
void test5 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 115 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector put12 ( int b , int s ) { int length = this . length ; if ( length + 3 > data . length ) { enlarge ( 3 ) ; } byte [ ] data = this . data ; data [ length + + ] = ( byte ) b ; data [ length + + ] = ( byte ) ( s > > > 8 ) ; data [ length + + ] = ( byte ) s ; this . length = length ; return this ; }
void test6 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 115 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector putInt ( int i ) { int length = this . length ; if ( length + 4 > data . length ) { enlarge ( 4 ) ; } byte [ ] data = this . data ; data [ length + + ] = ( byte ) ( i > > > 24 ) ; data [ length + + ] = ( byte ) ( i > > > 16 ) ; data [ length + + ] = ( byte ) ( i > > > 8 ) ; data [ length + + ] = ( byte ) i ; this . length = length ; return this ; }
void test7 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 115 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector putLong ( long l ) { int length = this . length ; if ( length + 8 > data . length ) { enlarge ( 8 ) ; } byte [ ] data = this . data ; int i = ( int ) ( l > > > 32 ) ; data [ length + + ] = ( byte ) ( i > > > 24 ) ; data [ length + + ] = ( byte ) ( i > > > 16 ) ; data [ length + + ] = ( byte ) ( i > > > 8 ) ; data [ length + + ] = ( byte ) i ; i = ( int ) l ; data [ length + + ] = ( byte ) ( i > > > 24 ) ; data [ length + + ] = ( byte ) ( i > > > 16 ) ; data [ length + + ] = ( byte ) ( i > > > 8 ) ; data [ length + + ] = ( byte ) i ; this . length = length ; return this ; }
void test8 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 0 ) ; byteVector0 . putLong ( ( long ) 15 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector putLong ( long l ) { int length = this . length ; if ( length + 8 > data . length ) { enlarge ( 8 ) ; } byte [ ] data = this . data ; int i = ( int ) ( l > > > 32 ) ; data [ length + + ] = ( byte ) ( i > > > 24 ) ; data [ length + + ] = ( byte ) ( i > > > 16 ) ; data [ length + + ] = ( byte ) ( i > > > 8 ) ; data [ length + + ] = ( byte ) i ; i = ( int ) l ; data [ length + + ] = ( byte ) ( i > > > 24 ) ; data [ length + + ] = ( byte ) ( i > > > 16 ) ; data [ length + + ] = ( byte ) ( i > > > 8 ) ; data [ length + + ] = ( byte ) i ; this . length = length ; return this ; }
void test9 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 115 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector putUTF8 ( String s ) { int charLength = s . length ( ) ; int len = length ; if ( len + 2 + charLength > data . length ) { enlarge ( 2 + charLength ) ; } byte [ ] data = this . data ; / / optimistic algorithm : instead of computing the byte length and then / / serializing the string ( which requires two loops ) , we assume the byte / / length is equal to char length ( which is the most frequent case ) , and / / we start serializing the string right away . During the serialization , / / if we find that this assumption is wrong , we continue with the / / general method . data [ len + + ] = ( byte ) ( charLength > > > 8 ) ; data [ len + + ] = ( byte ) charLength ; for ( int i = 0 ; i < charLength ; + + i ) { char c = s . charAt ( i ) ; if ( c > = '\001' & & c < = '\177' ) { data [ len + + ] = ( byte ) c ; } else { int byteLength = i ; for ( int j = i ; j < charLength ; + + j ) { c = s . charAt ( j ) ; if ( c > = '\001' & & c < = '\177' ) { byteLength + + ; } else if ( c > '\u07FF' ) { byteLength + = 3 ; } else { byteLength + = 2 ; } } data [ length ] = ( byte ) ( byteLength > > > 8 ) ; data [ length + 1 ] = ( byte ) byteLength ; if ( length + 2 + byteLength > data . length ) { length = len ; enlarge ( 2 + byteLength ) ; data = this . data ; } for ( int j = i ; j < charLength ; + + j ) { c = s . charAt ( j ) ; if ( c > = '\001' & & c < = '\177' ) { data [ len + + ] = ( byte ) c ; } else if ( c > '\u07FF' ) { data [ len + + ] = ( byte ) ( 0xE0 | c > > 12 & 0xF ) ; data [ len + + ] = ( byte ) ( 0x80 | c > > 6 & 0x3F ) ; data [ len + + ] = ( byte ) ( 0x80 | c & 0x3F ) ; } else { data [ len + + ] = ( byte ) ( 0xC0 | c > > 6 & 0x1F ) ; data [ len + + ] = ( byte ) ( 0x80 | c & 0x3F ) ; } } break ; } } length = len ; return this ; }
void test10 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector putByteArray ( byte [ ] b , int off , int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b ! = null ) { System . arraycopy ( b , off , data , length , len ) ; } length + = len ; return this ; }
void test11 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 115 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector putByteArray ( byte [ ] b , int off , int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b ! = null ) { System . arraycopy ( b , off , data , length , len ) ; } length + = len ; return this ; }
void test0 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 1437 ) ) ; ByteVector byteVector0 = new ByteVector ( ) ; AnnotationWriter annotationWriter0 = new AnnotationWriter ( classWriter0 , false , byteVector0 , byteVector0 , 47 ) ; annotationWriter0 . visit ( "" , " : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test2 ( ) throws Throwable { AnnotationWriter [ ] annotationWriterArray0 = new AnnotationWriter [ 23 ] ; ClassWriter classWriter0 = new ClassWriter ( ( - 1437 ) ) ; ByteVector byteVector0 = new ByteVector ( ) ; AnnotationWriter annotationWriter0 = new AnnotationWriter ( classWriter0 , false , byteVector0 , byteVector0 , 47 ) ; annotationWriterArray0 [ 15 ] = annotationWriter0 ; Byte byte0 = new Byte ( ( byte ) ( - 121 ) ) ; annotationWriterArray0 [ 15 ] . visit ( "" , ( Object ) byte0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visit ( int version , int access , String name , String signature , String superName , String [ ] interfaces ) { cv . visit ( version , access , name , signature , superName , interfaces ) ; }
void test4 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; ByteVector byteVector0 = new ByteVector ( ) ; AnnotationWriter annotationWriter0 = new AnnotationWriter ( classWriter0 , false , byteVector0 , byteVector0 , 1500 ) ; Boolean boolean0 = Boolean . TRUE ; annotationWriter0 . visit ( "" , ( Object ) boolean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test5 ( ) throws Throwable { AnnotationWriter [ ] annotationWriterArray0 = new AnnotationWriter [ 23 ] ; ClassWriter classWriter0 = new ClassWriter ( ( - 1437 ) ) ; ByteVector byteVector0 = new ByteVector ( ) ; AnnotationWriter annotationWriter0 = new AnnotationWriter ( classWriter0 , false , byteVector0 , byteVector0 , 47 ) ; annotationWriterArray0 [ 10 ] = annotationWriter0 ; Character character0 = Character . valueOf ( 'e' ) ; annotationWriterArray0 [ 10 ] . visit ( "" , ( Object ) character0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test7 ( ) throws Throwable { AnnotationWriter [ ] annotationWriterArray0 = new AnnotationWriter [ 23 ] ; ClassWriter classWriter0 = new ClassWriter ( ( - 1437 ) ) ; ByteVector byteVector0 = new ByteVector ( ) ; AnnotationWriter annotationWriter0 = new AnnotationWriter ( classWriter0 , false , byteVector0 , byteVector0 , 47 ) ; annotationWriterArray0 [ 2 ] = annotationWriter0 ; Type type0 = Type . CHAR_TYPE ; annotationWriterArray0 [ 2 ] . visit ( "M_K { [ C~M > kyXL" , ( Object ) type0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDescriptor ( ) { StringBuffer buf = new StringBuffer ( ) ; getDescriptor ( buf ) ; return buf . toString ( ) ; }
void test8 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 1437 ) ) ; ByteVector byteVector0 = new ByteVector ( ) ; AnnotationWriter annotationWriter0 = new AnnotationWriter ( classWriter0 , false , byteVector0 , byteVector0 , 47 ) ; annotationWriter0 . visitEnum ( "" , " : " , " : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test9 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 1437 ) ) ; ByteVector byteVector0 = new ByteVector ( ) ; AnnotationWriter annotationWriter0 = new AnnotationWriter ( classWriter0 , true , byteVector0 , byteVector0 , 498 ) ; annotationWriter0 . visitEnum ( " < HE" , " < HE" , " < HE" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test10 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; ByteVector byteVector0 = new ByteVector ( ) ; AnnotationWriter annotationWriter0 = new AnnotationWriter ( classWriter0 , false , byteVector0 , byteVector0 , 1500 ) ; AnnotationWriter annotationWriter1 = ( AnnotationWriter ) annotationWriter0 . visitAnnotation ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test12 ( ) throws Throwable { ByteVector byteVector0 = new ByteVector ( 332 ) ; AnnotationWriter annotationWriter0 = new AnnotationWriter ( ( ClassWriter ) null , false , byteVector0 , byteVector0 , 1943 ) ; AnnotationWriter annotationWriter1 = ( AnnotationWriter ) annotationWriter0 . visitArray ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test13 ( ) throws Throwable { AnnotationWriter [ ] annotationWriterArray0 = new AnnotationWriter [ 23 ] ; ClassWriter classWriter0 = new ClassWriter ( 1072 ) ; ByteVector byteVector0 = new ByteVector ( 1072 ) ; AnnotationWriter annotationWriter0 = new AnnotationWriter ( classWriter0 , true , byteVector0 , byteVector0 , 498 ) ; annotationWriterArray0 [ 1 ] = annotationWriter0 ; AnnotationWriter annotationWriter1 = ( AnnotationWriter ) annotationWriterArray0 [ 1 ] . visitArray ( "LineNumberTable" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test0 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 908 ) ) ; classWriter0 . newField ( "" , "" , "" ) ; int int0 = classWriter0 . newField ( "" , "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newField ( String owner , String name , String desc ) { return newFieldItem ( owner , name , desc ) . index ; }
void test1 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 908 ) ) ; classWriter0 . newMethod ( "" , "" , "" , true ) ; int int0 = classWriter0 . newMethod ( "" , "" , "" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newMethod ( String owner , String name , String desc , boolean itf ) { return newMethodItem ( owner , name , desc , itf ) . index ; }
void test2 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 3 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FieldVisitor visitField ( int access , String name , String desc , String signature , Object value ) { return cv . visitField ( access , name , desc , signature , value ) ; }
void test4 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visitEnd ( ) { cv . visitEnd ( ) ; }
void test5 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visitAttribute ( Attribute attr ) { cv . visitAttribute ( attr ) ; }
void test6 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 1962 ) ) ; classWriter0 . visit ( ( int ) ( byte ) ( - 55 ) , 1068 , "htY { WRYPA < " , ( String ) null , "ta's" , ( String [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visit ( int version , int access , String name , String signature , String superName , String [ ] interfaces ) { cv . visit ( version , access , name , signature , superName , interfaces ) ; }
void test7 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; String [ ] stringArray0 = new String [ 1 ] ; stringArray0 [ 0 ] = "" ; classWriter0 . visit ( 0 , ( - 153 ) , "g% * [ gaI$ / + { 8 < lC [ e" , "" , "" , stringArray0 ) ; classWriter0 . toByteArray ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] toByteArray ( ) { / / computes the real size of the bytecode of this class int size = 24 + 2 * interfaceCount ; int nbFields = 0 ; FieldWriter fb = firstField ; while ( fb ! = null ) { + + nbFields ; size + = fb . getSize ( ) ; fb = fb . next ; } int nbMethods = 0 ; MethodWriter mb = firstMethod ; while ( mb ! = null ) { + + nbMethods ; size + = mb . getSize ( ) ; mb = mb . next ; } int attributeCount = 0 ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "Signature" ) ; } if ( sourceFile ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "SourceFile" ) ; } if ( sourceDebug ! = null ) { + + attributeCount ; size + = sourceDebug . length + 4 ; newUTF8 ( "SourceDebugExtension" ) ; } if ( enclosingMethodOwner ! = 0 ) { + + attributeCount ; size + = 10 ; newUTF8 ( "EnclosingMethod" ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Deprecated" ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Synthetic" ) ; } if ( innerClasses ! = null ) { + + attributeCount ; size + = 8 + innerClasses . length ; newUTF8 ( "InnerClasses" ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; size + = 8 + anns . getSize ( ) ; newUTF8 ( "RuntimeVisibleAnnotations" ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; size + = 8 + ianns . getSize ( ) ; newUTF8 ( "RuntimeInvisibleAnnotations" ) ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; size + = attrs . getSize ( this , null , 0 , - 1 , - 1 ) ; } size + = pool . length ; / / allocates a byte vector of this size , in order to avoid unnecessary / / arraycopy operations in the ByteVector . enlarge ( ) method ByteVector out = new ByteVector ( size ) ; out . putInt ( 0xCAFEBABE ) . putInt ( version ) ; out . putShort ( index ) . putByteArray ( pool . data , 0 , pool . length ) ; out . putShort ( access ) . putShort ( name ) . putShort ( superName ) ; out . putShort ( interfaceCount ) ; for ( int i = 0 ; i < interfaceCount ; + + i ) { out . putShort ( interfaces [ i ] ) ; } out . putShort ( nbFields ) ; fb = firstField ; while ( fb ! = null ) { fb . put ( out ) ; fb = fb . next ; } out . putShort ( nbMethods ) ; mb = firstMethod ; while ( mb ! = null ) { mb . put ( out ) ; mb = mb . next ; } out . putShort ( attributeCount ) ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { out . putShort ( newUTF8 ( "Signature" ) ) . putInt ( 2 ) . putShort ( signature ) ; } if ( sourceFile ! = 0 ) { out . putShort ( newUTF8 ( "SourceFile" ) ) . putInt ( 2 ) . putShort ( sourceFile ) ; } if ( sourceDebug ! = null ) { int len = sourceDebug . length - 2 ; out . putShort ( newUTF8 ( "SourceDebugExtension" ) ) . putInt ( len ) ; out . putByteArray ( sourceDebug . data , 2 , len ) ; } if ( enclosingMethodOwner ! = 0 ) { out . putShort ( newUTF8 ( "EnclosingMethod" ) ) . putInt ( 4 ) ; out . putShort ( enclosingMethodOwner ) . putShort ( enclosingMethod ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { out . putShort ( newUTF8 ( "Deprecated" ) ) . putInt ( 0 ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { out . putShort ( newUTF8 ( "Synthetic" ) ) . putInt ( 0 ) ; } if ( innerClasses ! = null ) { out . putShort ( newUTF8 ( "InnerClasses" ) ) ; out . putInt ( innerClasses . length + 2 ) . putShort ( innerClassesCount ) ; out . putByteArray ( innerClasses . data , 0 , innerClasses . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( newUTF8 ( "RuntimeVisibleAnnotations" ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( newUTF8 ( "RuntimeInvisibleAnnotations" ) ) ; ianns . put ( out ) ; } if ( attrs ! = null ) { attrs . put ( this , null , 0 , - 1 , - 1 , out ) ; } if ( invalidFrames ) { ClassWriter cw = new ClassWriter ( COMPUTE_FRAMES ) ; new ClassReader ( out . data ) . accept ( cw , ClassReader . SKIP_FRAMES ) ; return cw . toByteArray ( ) ; } return out . data ; }
void test8 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visitSource ( String source , String debug ) { cv . visitSource ( source , debug ) ; }
void test9 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 18 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] toByteArray ( ) { / / computes the real size of the bytecode of this class int size = 24 + 2 * interfaceCount ; int nbFields = 0 ; FieldWriter fb = firstField ; while ( fb ! = null ) { + + nbFields ; size + = fb . getSize ( ) ; fb = fb . next ; } int nbMethods = 0 ; MethodWriter mb = firstMethod ; while ( mb ! = null ) { + + nbMethods ; size + = mb . getSize ( ) ; mb = mb . next ; } int attributeCount = 0 ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "Signature" ) ; } if ( sourceFile ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "SourceFile" ) ; } if ( sourceDebug ! = null ) { + + attributeCount ; size + = sourceDebug . length + 4 ; newUTF8 ( "SourceDebugExtension" ) ; } if ( enclosingMethodOwner ! = 0 ) { + + attributeCount ; size + = 10 ; newUTF8 ( "EnclosingMethod" ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Deprecated" ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Synthetic" ) ; } if ( innerClasses ! = null ) { + + attributeCount ; size + = 8 + innerClasses . length ; newUTF8 ( "InnerClasses" ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; size + = 8 + anns . getSize ( ) ; newUTF8 ( "RuntimeVisibleAnnotations" ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; size + = 8 + ianns . getSize ( ) ; newUTF8 ( "RuntimeInvisibleAnnotations" ) ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; size + = attrs . getSize ( this , null , 0 , - 1 , - 1 ) ; } size + = pool . length ; / / allocates a byte vector of this size , in order to avoid unnecessary / / arraycopy operations in the ByteVector . enlarge ( ) method ByteVector out = new ByteVector ( size ) ; out . putInt ( 0xCAFEBABE ) . putInt ( version ) ; out . putShort ( index ) . putByteArray ( pool . data , 0 , pool . length ) ; out . putShort ( access ) . putShort ( name ) . putShort ( superName ) ; out . putShort ( interfaceCount ) ; for ( int i = 0 ; i < interfaceCount ; + + i ) { out . putShort ( interfaces [ i ] ) ; } out . putShort ( nbFields ) ; fb = firstField ; while ( fb ! = null ) { fb . put ( out ) ; fb = fb . next ; } out . putShort ( nbMethods ) ; mb = firstMethod ; while ( mb ! = null ) { mb . put ( out ) ; mb = mb . next ; } out . putShort ( attributeCount ) ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { out . putShort ( newUTF8 ( "Signature" ) ) . putInt ( 2 ) . putShort ( signature ) ; } if ( sourceFile ! = 0 ) { out . putShort ( newUTF8 ( "SourceFile" ) ) . putInt ( 2 ) . putShort ( sourceFile ) ; } if ( sourceDebug ! = null ) { int len = sourceDebug . length - 2 ; out . putShort ( newUTF8 ( "SourceDebugExtension" ) ) . putInt ( len ) ; out . putByteArray ( sourceDebug . data , 2 , len ) ; } if ( enclosingMethodOwner ! = 0 ) { out . putShort ( newUTF8 ( "EnclosingMethod" ) ) . putInt ( 4 ) ; out . putShort ( enclosingMethodOwner ) . putShort ( enclosingMethod ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { out . putShort ( newUTF8 ( "Deprecated" ) ) . putInt ( 0 ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { out . putShort ( newUTF8 ( "Synthetic" ) ) . putInt ( 0 ) ; } if ( innerClasses ! = null ) { out . putShort ( newUTF8 ( "InnerClasses" ) ) ; out . putInt ( innerClasses . length + 2 ) . putShort ( innerClassesCount ) ; out . putByteArray ( innerClasses . data , 0 , innerClasses . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( newUTF8 ( "RuntimeVisibleAnnotations" ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( newUTF8 ( "RuntimeInvisibleAnnotations" ) ) ; ianns . put ( out ) ; } if ( attrs ! = null ) { attrs . put ( this , null , 0 , - 1 , - 1 , out ) ; } if ( invalidFrames ) { ClassWriter cw = new ClassWriter ( COMPUTE_FRAMES ) ; new ClassReader ( out . data ) . accept ( cw , ClassReader . SKIP_FRAMES ) ; return cw . toByteArray ( ) ; } return out . data ; }
void test10 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 1962 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visitOuterClass ( String owner , String name , String desc ) { cv . visitOuterClass ( owner , name , desc ) ; }
void test11 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] toByteArray ( ) { / / computes the real size of the bytecode of this class int size = 24 + 2 * interfaceCount ; int nbFields = 0 ; FieldWriter fb = firstField ; while ( fb ! = null ) { + + nbFields ; size + = fb . getSize ( ) ; fb = fb . next ; } int nbMethods = 0 ; MethodWriter mb = firstMethod ; while ( mb ! = null ) { + + nbMethods ; size + = mb . getSize ( ) ; mb = mb . next ; } int attributeCount = 0 ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "Signature" ) ; } if ( sourceFile ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "SourceFile" ) ; } if ( sourceDebug ! = null ) { + + attributeCount ; size + = sourceDebug . length + 4 ; newUTF8 ( "SourceDebugExtension" ) ; } if ( enclosingMethodOwner ! = 0 ) { + + attributeCount ; size + = 10 ; newUTF8 ( "EnclosingMethod" ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Deprecated" ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Synthetic" ) ; } if ( innerClasses ! = null ) { + + attributeCount ; size + = 8 + innerClasses . length ; newUTF8 ( "InnerClasses" ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; size + = 8 + anns . getSize ( ) ; newUTF8 ( "RuntimeVisibleAnnotations" ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; size + = 8 + ianns . getSize ( ) ; newUTF8 ( "RuntimeInvisibleAnnotations" ) ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; size + = attrs . getSize ( this , null , 0 , - 1 , - 1 ) ; } size + = pool . length ; / / allocates a byte vector of this size , in order to avoid unnecessary / / arraycopy operations in the ByteVector . enlarge ( ) method ByteVector out = new ByteVector ( size ) ; out . putInt ( 0xCAFEBABE ) . putInt ( version ) ; out . putShort ( index ) . putByteArray ( pool . data , 0 , pool . length ) ; out . putShort ( access ) . putShort ( name ) . putShort ( superName ) ; out . putShort ( interfaceCount ) ; for ( int i = 0 ; i < interfaceCount ; + + i ) { out . putShort ( interfaces [ i ] ) ; } out . putShort ( nbFields ) ; fb = firstField ; while ( fb ! = null ) { fb . put ( out ) ; fb = fb . next ; } out . putShort ( nbMethods ) ; mb = firstMethod ; while ( mb ! = null ) { mb . put ( out ) ; mb = mb . next ; } out . putShort ( attributeCount ) ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { out . putShort ( newUTF8 ( "Signature" ) ) . putInt ( 2 ) . putShort ( signature ) ; } if ( sourceFile ! = 0 ) { out . putShort ( newUTF8 ( "SourceFile" ) ) . putInt ( 2 ) . putShort ( sourceFile ) ; } if ( sourceDebug ! = null ) { int len = sourceDebug . length - 2 ; out . putShort ( newUTF8 ( "SourceDebugExtension" ) ) . putInt ( len ) ; out . putByteArray ( sourceDebug . data , 2 , len ) ; } if ( enclosingMethodOwner ! = 0 ) { out . putShort ( newUTF8 ( "EnclosingMethod" ) ) . putInt ( 4 ) ; out . putShort ( enclosingMethodOwner ) . putShort ( enclosingMethod ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { out . putShort ( newUTF8 ( "Deprecated" ) ) . putInt ( 0 ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { out . putShort ( newUTF8 ( "Synthetic" ) ) . putInt ( 0 ) ; } if ( innerClasses ! = null ) { out . putShort ( newUTF8 ( "InnerClasses" ) ) ; out . putInt ( innerClasses . length + 2 ) . putShort ( innerClassesCount ) ; out . putByteArray ( innerClasses . data , 0 , innerClasses . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( newUTF8 ( "RuntimeVisibleAnnotations" ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( newUTF8 ( "RuntimeInvisibleAnnotations" ) ) ; ianns . put ( out ) ; } if ( attrs ! = null ) { attrs . put ( this , null , 0 , - 1 , - 1 , out ) ; } if ( invalidFrames ) { ClassWriter cw = new ClassWriter ( COMPUTE_FRAMES ) ; new ClassReader ( out . data ) . accept ( cw , ClassReader . SKIP_FRAMES ) ; return cw . toByteArray ( ) ; } return out . data ; }
void test12 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visitOuterClass ( String owner , String name , String desc ) { cv . visitOuterClass ( owner , name , desc ) ; }
void test13 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 18 ) ) ; classWriter0 . visitAnnotation ( "" , false ) ; classWriter0 . toByteArray ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] toByteArray ( ) { / / computes the real size of the bytecode of this class int size = 24 + 2 * interfaceCount ; int nbFields = 0 ; FieldWriter fb = firstField ; while ( fb ! = null ) { + + nbFields ; size + = fb . getSize ( ) ; fb = fb . next ; } int nbMethods = 0 ; MethodWriter mb = firstMethod ; while ( mb ! = null ) { + + nbMethods ; size + = mb . getSize ( ) ; mb = mb . next ; } int attributeCount = 0 ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "Signature" ) ; } if ( sourceFile ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "SourceFile" ) ; } if ( sourceDebug ! = null ) { + + attributeCount ; size + = sourceDebug . length + 4 ; newUTF8 ( "SourceDebugExtension" ) ; } if ( enclosingMethodOwner ! = 0 ) { + + attributeCount ; size + = 10 ; newUTF8 ( "EnclosingMethod" ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Deprecated" ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Synthetic" ) ; } if ( innerClasses ! = null ) { + + attributeCount ; size + = 8 + innerClasses . length ; newUTF8 ( "InnerClasses" ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; size + = 8 + anns . getSize ( ) ; newUTF8 ( "RuntimeVisibleAnnotations" ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; size + = 8 + ianns . getSize ( ) ; newUTF8 ( "RuntimeInvisibleAnnotations" ) ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; size + = attrs . getSize ( this , null , 0 , - 1 , - 1 ) ; } size + = pool . length ; / / allocates a byte vector of this size , in order to avoid unnecessary / / arraycopy operations in the ByteVector . enlarge ( ) method ByteVector out = new ByteVector ( size ) ; out . putInt ( 0xCAFEBABE ) . putInt ( version ) ; out . putShort ( index ) . putByteArray ( pool . data , 0 , pool . length ) ; out . putShort ( access ) . putShort ( name ) . putShort ( superName ) ; out . putShort ( interfaceCount ) ; for ( int i = 0 ; i < interfaceCount ; + + i ) { out . putShort ( interfaces [ i ] ) ; } out . putShort ( nbFields ) ; fb = firstField ; while ( fb ! = null ) { fb . put ( out ) ; fb = fb . next ; } out . putShort ( nbMethods ) ; mb = firstMethod ; while ( mb ! = null ) { mb . put ( out ) ; mb = mb . next ; } out . putShort ( attributeCount ) ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { out . putShort ( newUTF8 ( "Signature" ) ) . putInt ( 2 ) . putShort ( signature ) ; } if ( sourceFile ! = 0 ) { out . putShort ( newUTF8 ( "SourceFile" ) ) . putInt ( 2 ) . putShort ( sourceFile ) ; } if ( sourceDebug ! = null ) { int len = sourceDebug . length - 2 ; out . putShort ( newUTF8 ( "SourceDebugExtension" ) ) . putInt ( len ) ; out . putByteArray ( sourceDebug . data , 2 , len ) ; } if ( enclosingMethodOwner ! = 0 ) { out . putShort ( newUTF8 ( "EnclosingMethod" ) ) . putInt ( 4 ) ; out . putShort ( enclosingMethodOwner ) . putShort ( enclosingMethod ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { out . putShort ( newUTF8 ( "Deprecated" ) ) . putInt ( 0 ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { out . putShort ( newUTF8 ( "Synthetic" ) ) . putInt ( 0 ) ; } if ( innerClasses ! = null ) { out . putShort ( newUTF8 ( "InnerClasses" ) ) ; out . putInt ( innerClasses . length + 2 ) . putShort ( innerClassesCount ) ; out . putByteArray ( innerClasses . data , 0 , innerClasses . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( newUTF8 ( "RuntimeVisibleAnnotations" ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( newUTF8 ( "RuntimeInvisibleAnnotations" ) ) ; ianns . put ( out ) ; } if ( attrs ! = null ) { attrs . put ( this , null , 0 , - 1 , - 1 , out ) ; } if ( invalidFrames ) { ClassWriter cw = new ClassWriter ( COMPUTE_FRAMES ) ; new ClassReader ( out . data ) . accept ( cw , ClassReader . SKIP_FRAMES ) ; return cw . toByteArray ( ) ; } return out . data ; }
void test14 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 18 ) ) ; classWriter0 . visitAnnotation ( " > s { Yv6T ) %mW { q'" , true ) ; classWriter0 . toByteArray ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] toByteArray ( ) { / / computes the real size of the bytecode of this class int size = 24 + 2 * interfaceCount ; int nbFields = 0 ; FieldWriter fb = firstField ; while ( fb ! = null ) { + + nbFields ; size + = fb . getSize ( ) ; fb = fb . next ; } int nbMethods = 0 ; MethodWriter mb = firstMethod ; while ( mb ! = null ) { + + nbMethods ; size + = mb . getSize ( ) ; mb = mb . next ; } int attributeCount = 0 ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "Signature" ) ; } if ( sourceFile ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "SourceFile" ) ; } if ( sourceDebug ! = null ) { + + attributeCount ; size + = sourceDebug . length + 4 ; newUTF8 ( "SourceDebugExtension" ) ; } if ( enclosingMethodOwner ! = 0 ) { + + attributeCount ; size + = 10 ; newUTF8 ( "EnclosingMethod" ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Deprecated" ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Synthetic" ) ; } if ( innerClasses ! = null ) { + + attributeCount ; size + = 8 + innerClasses . length ; newUTF8 ( "InnerClasses" ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; size + = 8 + anns . getSize ( ) ; newUTF8 ( "RuntimeVisibleAnnotations" ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; size + = 8 + ianns . getSize ( ) ; newUTF8 ( "RuntimeInvisibleAnnotations" ) ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; size + = attrs . getSize ( this , null , 0 , - 1 , - 1 ) ; } size + = pool . length ; / / allocates a byte vector of this size , in order to avoid unnecessary / / arraycopy operations in the ByteVector . enlarge ( ) method ByteVector out = new ByteVector ( size ) ; out . putInt ( 0xCAFEBABE ) . putInt ( version ) ; out . putShort ( index ) . putByteArray ( pool . data , 0 , pool . length ) ; out . putShort ( access ) . putShort ( name ) . putShort ( superName ) ; out . putShort ( interfaceCount ) ; for ( int i = 0 ; i < interfaceCount ; + + i ) { out . putShort ( interfaces [ i ] ) ; } out . putShort ( nbFields ) ; fb = firstField ; while ( fb ! = null ) { fb . put ( out ) ; fb = fb . next ; } out . putShort ( nbMethods ) ; mb = firstMethod ; while ( mb ! = null ) { mb . put ( out ) ; mb = mb . next ; } out . putShort ( attributeCount ) ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { out . putShort ( newUTF8 ( "Signature" ) ) . putInt ( 2 ) . putShort ( signature ) ; } if ( sourceFile ! = 0 ) { out . putShort ( newUTF8 ( "SourceFile" ) ) . putInt ( 2 ) . putShort ( sourceFile ) ; } if ( sourceDebug ! = null ) { int len = sourceDebug . length - 2 ; out . putShort ( newUTF8 ( "SourceDebugExtension" ) ) . putInt ( len ) ; out . putByteArray ( sourceDebug . data , 2 , len ) ; } if ( enclosingMethodOwner ! = 0 ) { out . putShort ( newUTF8 ( "EnclosingMethod" ) ) . putInt ( 4 ) ; out . putShort ( enclosingMethodOwner ) . putShort ( enclosingMethod ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { out . putShort ( newUTF8 ( "Deprecated" ) ) . putInt ( 0 ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { out . putShort ( newUTF8 ( "Synthetic" ) ) . putInt ( 0 ) ; } if ( innerClasses ! = null ) { out . putShort ( newUTF8 ( "InnerClasses" ) ) ; out . putInt ( innerClasses . length + 2 ) . putShort ( innerClassesCount ) ; out . putByteArray ( innerClasses . data , 0 , innerClasses . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( newUTF8 ( "RuntimeVisibleAnnotations" ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( newUTF8 ( "RuntimeInvisibleAnnotations" ) ) ; ianns . put ( out ) ; } if ( attrs ! = null ) { attrs . put ( this , null , 0 , - 1 , - 1 , out ) ; } if ( invalidFrames ) { ClassWriter cw = new ClassWriter ( COMPUTE_FRAMES ) ; new ClassReader ( out . data ) . accept ( cw , ClassReader . SKIP_FRAMES ) ; return cw . toByteArray ( ) ; } return out . data ; }
void test15 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 1962 ) ) ; classWriter0 . visitInnerClass ( ( String ) null , ( String ) null , ( String ) null , ( int ) ( byte ) ( - 55 ) ) ; classWriter0 . visitInnerClass ( "htY { WRYPA < " , ( String ) null , "htY { WRYPA < " , ( int ) ( byte ) ( - 55 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visitInnerClass ( String name , String outerName , String innerName , int access ) { cv . visitInnerClass ( name , outerName , innerName , access ) ; }
void test16 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( int ) ( byte ) ( - 55 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visitInnerClass ( String name , String outerName , String innerName , int access ) { cv . visitInnerClass ( name , outerName , innerName , access ) ; }
void test17 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; classWriter0 . visitField ( ( - 153 ) , "g% * [ gaI$ / + { 8 < lC [ e" , "g% * [ gaI$ / + { 8 < lC [ e" , "g% * [ gaI$ / + { 8 < lC [ e" , ( Object ) classWriter0 . invalidFrames ) ; classWriter0 . toByteArray ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] toByteArray ( ) { / / computes the real size of the bytecode of this class int size = 24 + 2 * interfaceCount ; int nbFields = 0 ; FieldWriter fb = firstField ; while ( fb ! = null ) { + + nbFields ; size + = fb . getSize ( ) ; fb = fb . next ; } int nbMethods = 0 ; MethodWriter mb = firstMethod ; while ( mb ! = null ) { + + nbMethods ; size + = mb . getSize ( ) ; mb = mb . next ; } int attributeCount = 0 ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "Signature" ) ; } if ( sourceFile ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "SourceFile" ) ; } if ( sourceDebug ! = null ) { + + attributeCount ; size + = sourceDebug . length + 4 ; newUTF8 ( "SourceDebugExtension" ) ; } if ( enclosingMethodOwner ! = 0 ) { + + attributeCount ; size + = 10 ; newUTF8 ( "EnclosingMethod" ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Deprecated" ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Synthetic" ) ; } if ( innerClasses ! = null ) { + + attributeCount ; size + = 8 + innerClasses . length ; newUTF8 ( "InnerClasses" ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; size + = 8 + anns . getSize ( ) ; newUTF8 ( "RuntimeVisibleAnnotations" ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; size + = 8 + ianns . getSize ( ) ; newUTF8 ( "RuntimeInvisibleAnnotations" ) ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; size + = attrs . getSize ( this , null , 0 , - 1 , - 1 ) ; } size + = pool . length ; / / allocates a byte vector of this size , in order to avoid unnecessary / / arraycopy operations in the ByteVector . enlarge ( ) method ByteVector out = new ByteVector ( size ) ; out . putInt ( 0xCAFEBABE ) . putInt ( version ) ; out . putShort ( index ) . putByteArray ( pool . data , 0 , pool . length ) ; out . putShort ( access ) . putShort ( name ) . putShort ( superName ) ; out . putShort ( interfaceCount ) ; for ( int i = 0 ; i < interfaceCount ; + + i ) { out . putShort ( interfaces [ i ] ) ; } out . putShort ( nbFields ) ; fb = firstField ; while ( fb ! = null ) { fb . put ( out ) ; fb = fb . next ; } out . putShort ( nbMethods ) ; mb = firstMethod ; while ( mb ! = null ) { mb . put ( out ) ; mb = mb . next ; } out . putShort ( attributeCount ) ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { out . putShort ( newUTF8 ( "Signature" ) ) . putInt ( 2 ) . putShort ( signature ) ; } if ( sourceFile ! = 0 ) { out . putShort ( newUTF8 ( "SourceFile" ) ) . putInt ( 2 ) . putShort ( sourceFile ) ; } if ( sourceDebug ! = null ) { int len = sourceDebug . length - 2 ; out . putShort ( newUTF8 ( "SourceDebugExtension" ) ) . putInt ( len ) ; out . putByteArray ( sourceDebug . data , 2 , len ) ; } if ( enclosingMethodOwner ! = 0 ) { out . putShort ( newUTF8 ( "EnclosingMethod" ) ) . putInt ( 4 ) ; out . putShort ( enclosingMethodOwner ) . putShort ( enclosingMethod ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { out . putShort ( newUTF8 ( "Deprecated" ) ) . putInt ( 0 ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { out . putShort ( newUTF8 ( "Synthetic" ) ) . putInt ( 0 ) ; } if ( innerClasses ! = null ) { out . putShort ( newUTF8 ( "InnerClasses" ) ) ; out . putInt ( innerClasses . length + 2 ) . putShort ( innerClassesCount ) ; out . putByteArray ( innerClasses . data , 0 , innerClasses . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( newUTF8 ( "RuntimeVisibleAnnotations" ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( newUTF8 ( "RuntimeInvisibleAnnotations" ) ) ; ianns . put ( out ) ; } if ( attrs ! = null ) { attrs . put ( this , null , 0 , - 1 , - 1 , out ) ; } if ( invalidFrames ) { ClassWriter cw = new ClassWriter ( COMPUTE_FRAMES ) ; new ClassReader ( out . data ) . accept ( cw , ClassReader . SKIP_FRAMES ) ; return cw . toByteArray ( ) ; } return out . data ; }
void test18 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; String [ ] stringArray0 = new String [ 1 ] ; stringArray0 [ 0 ] = "" ; classWriter0 . visitMethod ( 0 , "" , "" , "" , stringArray0 ) ; classWriter0 . toByteArray ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] toByteArray ( ) { / / computes the real size of the bytecode of this class int size = 24 + 2 * interfaceCount ; int nbFields = 0 ; FieldWriter fb = firstField ; while ( fb ! = null ) { + + nbFields ; size + = fb . getSize ( ) ; fb = fb . next ; } int nbMethods = 0 ; MethodWriter mb = firstMethod ; while ( mb ! = null ) { + + nbMethods ; size + = mb . getSize ( ) ; mb = mb . next ; } int attributeCount = 0 ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "Signature" ) ; } if ( sourceFile ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "SourceFile" ) ; } if ( sourceDebug ! = null ) { + + attributeCount ; size + = sourceDebug . length + 4 ; newUTF8 ( "SourceDebugExtension" ) ; } if ( enclosingMethodOwner ! = 0 ) { + + attributeCount ; size + = 10 ; newUTF8 ( "EnclosingMethod" ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Deprecated" ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Synthetic" ) ; } if ( innerClasses ! = null ) { + + attributeCount ; size + = 8 + innerClasses . length ; newUTF8 ( "InnerClasses" ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; size + = 8 + anns . getSize ( ) ; newUTF8 ( "RuntimeVisibleAnnotations" ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; size + = 8 + ianns . getSize ( ) ; newUTF8 ( "RuntimeInvisibleAnnotations" ) ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; size + = attrs . getSize ( this , null , 0 , - 1 , - 1 ) ; } size + = pool . length ; / / allocates a byte vector of this size , in order to avoid unnecessary / / arraycopy operations in the ByteVector . enlarge ( ) method ByteVector out = new ByteVector ( size ) ; out . putInt ( 0xCAFEBABE ) . putInt ( version ) ; out . putShort ( index ) . putByteArray ( pool . data , 0 , pool . length ) ; out . putShort ( access ) . putShort ( name ) . putShort ( superName ) ; out . putShort ( interfaceCount ) ; for ( int i = 0 ; i < interfaceCount ; + + i ) { out . putShort ( interfaces [ i ] ) ; } out . putShort ( nbFields ) ; fb = firstField ; while ( fb ! = null ) { fb . put ( out ) ; fb = fb . next ; } out . putShort ( nbMethods ) ; mb = firstMethod ; while ( mb ! = null ) { mb . put ( out ) ; mb = mb . next ; } out . putShort ( attributeCount ) ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { out . putShort ( newUTF8 ( "Signature" ) ) . putInt ( 2 ) . putShort ( signature ) ; } if ( sourceFile ! = 0 ) { out . putShort ( newUTF8 ( "SourceFile" ) ) . putInt ( 2 ) . putShort ( sourceFile ) ; } if ( sourceDebug ! = null ) { int len = sourceDebug . length - 2 ; out . putShort ( newUTF8 ( "SourceDebugExtension" ) ) . putInt ( len ) ; out . putByteArray ( sourceDebug . data , 2 , len ) ; } if ( enclosingMethodOwner ! = 0 ) { out . putShort ( newUTF8 ( "EnclosingMethod" ) ) . putInt ( 4 ) ; out . putShort ( enclosingMethodOwner ) . putShort ( enclosingMethod ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { out . putShort ( newUTF8 ( "Deprecated" ) ) . putInt ( 0 ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { out . putShort ( newUTF8 ( "Synthetic" ) ) . putInt ( 0 ) ; } if ( innerClasses ! = null ) { out . putShort ( newUTF8 ( "InnerClasses" ) ) ; out . putInt ( innerClasses . length + 2 ) . putShort ( innerClassesCount ) ; out . putByteArray ( innerClasses . data , 0 , innerClasses . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( newUTF8 ( "RuntimeVisibleAnnotations" ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( newUTF8 ( "RuntimeInvisibleAnnotations" ) ) ; ianns . put ( out ) ; } if ( attrs ! = null ) { attrs . put ( this , null , 0 , - 1 , - 1 , out ) ; } if ( invalidFrames ) { ClassWriter cw = new ClassWriter ( COMPUTE_FRAMES ) ; new ClassReader ( out . data ) . accept ( cw , ClassReader . SKIP_FRAMES ) ; return cw . toByteArray ( ) ; } return out . data ; }
void test19 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 1962 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] toByteArray ( ) { / / computes the real size of the bytecode of this class int size = 24 + 2 * interfaceCount ; int nbFields = 0 ; FieldWriter fb = firstField ; while ( fb ! = null ) { + + nbFields ; size + = fb . getSize ( ) ; fb = fb . next ; } int nbMethods = 0 ; MethodWriter mb = firstMethod ; while ( mb ! = null ) { + + nbMethods ; size + = mb . getSize ( ) ; mb = mb . next ; } int attributeCount = 0 ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "Signature" ) ; } if ( sourceFile ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "SourceFile" ) ; } if ( sourceDebug ! = null ) { + + attributeCount ; size + = sourceDebug . length + 4 ; newUTF8 ( "SourceDebugExtension" ) ; } if ( enclosingMethodOwner ! = 0 ) { + + attributeCount ; size + = 10 ; newUTF8 ( "EnclosingMethod" ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Deprecated" ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Synthetic" ) ; } if ( innerClasses ! = null ) { + + attributeCount ; size + = 8 + innerClasses . length ; newUTF8 ( "InnerClasses" ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; size + = 8 + anns . getSize ( ) ; newUTF8 ( "RuntimeVisibleAnnotations" ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; size + = 8 + ianns . getSize ( ) ; newUTF8 ( "RuntimeInvisibleAnnotations" ) ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; size + = attrs . getSize ( this , null , 0 , - 1 , - 1 ) ; } size + = pool . length ; / / allocates a byte vector of this size , in order to avoid unnecessary / / arraycopy operations in the ByteVector . enlarge ( ) method ByteVector out = new ByteVector ( size ) ; out . putInt ( 0xCAFEBABE ) . putInt ( version ) ; out . putShort ( index ) . putByteArray ( pool . data , 0 , pool . length ) ; out . putShort ( access ) . putShort ( name ) . putShort ( superName ) ; out . putShort ( interfaceCount ) ; for ( int i = 0 ; i < interfaceCount ; + + i ) { out . putShort ( interfaces [ i ] ) ; } out . putShort ( nbFields ) ; fb = firstField ; while ( fb ! = null ) { fb . put ( out ) ; fb = fb . next ; } out . putShort ( nbMethods ) ; mb = firstMethod ; while ( mb ! = null ) { mb . put ( out ) ; mb = mb . next ; } out . putShort ( attributeCount ) ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { out . putShort ( newUTF8 ( "Signature" ) ) . putInt ( 2 ) . putShort ( signature ) ; } if ( sourceFile ! = 0 ) { out . putShort ( newUTF8 ( "SourceFile" ) ) . putInt ( 2 ) . putShort ( sourceFile ) ; } if ( sourceDebug ! = null ) { int len = sourceDebug . length - 2 ; out . putShort ( newUTF8 ( "SourceDebugExtension" ) ) . putInt ( len ) ; out . putByteArray ( sourceDebug . data , 2 , len ) ; } if ( enclosingMethodOwner ! = 0 ) { out . putShort ( newUTF8 ( "EnclosingMethod" ) ) . putInt ( 4 ) ; out . putShort ( enclosingMethodOwner ) . putShort ( enclosingMethod ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { out . putShort ( newUTF8 ( "Deprecated" ) ) . putInt ( 0 ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { out . putShort ( newUTF8 ( "Synthetic" ) ) . putInt ( 0 ) ; } if ( innerClasses ! = null ) { out . putShort ( newUTF8 ( "InnerClasses" ) ) ; out . putInt ( innerClasses . length + 2 ) . putShort ( innerClassesCount ) ; out . putByteArray ( innerClasses . data , 0 , innerClasses . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( newUTF8 ( "RuntimeVisibleAnnotations" ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( newUTF8 ( "RuntimeInvisibleAnnotations" ) ) ; ianns . put ( out ) ; } if ( attrs ! = null ) { attrs . put ( this , null , 0 , - 1 , - 1 , out ) ; } if ( invalidFrames ) { ClassWriter cw = new ClassWriter ( COMPUTE_FRAMES ) ; new ClassReader ( out . data ) . accept ( cw , ClassReader . SKIP_FRAMES ) ; return cw . toByteArray ( ) ; } return out . data ; }
void test20 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 18 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" byte [ ] toByteArray ( ) { / / computes the real size of the bytecode of this class int size = 24 + 2 * interfaceCount ; int nbFields = 0 ; FieldWriter fb = firstField ; while ( fb ! = null ) { + + nbFields ; size + = fb . getSize ( ) ; fb = fb . next ; } int nbMethods = 0 ; MethodWriter mb = firstMethod ; while ( mb ! = null ) { + + nbMethods ; size + = mb . getSize ( ) ; mb = mb . next ; } int attributeCount = 0 ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "Signature" ) ; } if ( sourceFile ! = 0 ) { + + attributeCount ; size + = 8 ; newUTF8 ( "SourceFile" ) ; } if ( sourceDebug ! = null ) { + + attributeCount ; size + = sourceDebug . length + 4 ; newUTF8 ( "SourceDebugExtension" ) ; } if ( enclosingMethodOwner ! = 0 ) { + + attributeCount ; size + = 10 ; newUTF8 ( "EnclosingMethod" ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Deprecated" ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { + + attributeCount ; size + = 6 ; newUTF8 ( "Synthetic" ) ; } if ( innerClasses ! = null ) { + + attributeCount ; size + = 8 + innerClasses . length ; newUTF8 ( "InnerClasses" ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { + + attributeCount ; size + = 8 + anns . getSize ( ) ; newUTF8 ( "RuntimeVisibleAnnotations" ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { + + attributeCount ; size + = 8 + ianns . getSize ( ) ; newUTF8 ( "RuntimeInvisibleAnnotations" ) ; } if ( attrs ! = null ) { attributeCount + = attrs . getCount ( ) ; size + = attrs . getSize ( this , null , 0 , - 1 , - 1 ) ; } size + = pool . length ; / / allocates a byte vector of this size , in order to avoid unnecessary / / arraycopy operations in the ByteVector . enlarge ( ) method ByteVector out = new ByteVector ( size ) ; out . putInt ( 0xCAFEBABE ) . putInt ( version ) ; out . putShort ( index ) . putByteArray ( pool . data , 0 , pool . length ) ; out . putShort ( access ) . putShort ( name ) . putShort ( superName ) ; out . putShort ( interfaceCount ) ; for ( int i = 0 ; i < interfaceCount ; + + i ) { out . putShort ( interfaces [ i ] ) ; } out . putShort ( nbFields ) ; fb = firstField ; while ( fb ! = null ) { fb . put ( out ) ; fb = fb . next ; } out . putShort ( nbMethods ) ; mb = firstMethod ; while ( mb ! = null ) { mb . put ( out ) ; mb = mb . next ; } out . putShort ( attributeCount ) ; if ( ClassReader . SIGNATURES & & signature ! = 0 ) { out . putShort ( newUTF8 ( "Signature" ) ) . putInt ( 2 ) . putShort ( signature ) ; } if ( sourceFile ! = 0 ) { out . putShort ( newUTF8 ( "SourceFile" ) ) . putInt ( 2 ) . putShort ( sourceFile ) ; } if ( sourceDebug ! = null ) { int len = sourceDebug . length - 2 ; out . putShort ( newUTF8 ( "SourceDebugExtension" ) ) . putInt ( len ) ; out . putByteArray ( sourceDebug . data , 2 , len ) ; } if ( enclosingMethodOwner ! = 0 ) { out . putShort ( newUTF8 ( "EnclosingMethod" ) ) . putInt ( 4 ) ; out . putShort ( enclosingMethodOwner ) . putShort ( enclosingMethod ) ; } if ( ( access & Opcodes . ACC_DEPRECATED ) ! = 0 ) { out . putShort ( newUTF8 ( "Deprecated" ) ) . putInt ( 0 ) ; } if ( ( access & Opcodes . ACC_SYNTHETIC ) ! = 0 & & ( version & 0xffff ) < Opcodes . V1_5 ) { out . putShort ( newUTF8 ( "Synthetic" ) ) . putInt ( 0 ) ; } if ( innerClasses ! = null ) { out . putShort ( newUTF8 ( "InnerClasses" ) ) ; out . putInt ( innerClasses . length + 2 ) . putShort ( innerClassesCount ) ; out . putByteArray ( innerClasses . data , 0 , innerClasses . length ) ; } if ( ClassReader . ANNOTATIONS & & anns ! = null ) { out . putShort ( newUTF8 ( "RuntimeVisibleAnnotations" ) ) ; anns . put ( out ) ; } if ( ClassReader . ANNOTATIONS & & ianns ! = null ) { out . putShort ( newUTF8 ( "RuntimeInvisibleAnnotations" ) ) ; ianns . put ( out ) ; } if ( attrs ! = null ) { attrs . put ( this , null , 0 , - 1 , - 1 , out ) ; } if ( invalidFrames ) { ClassWriter cw = new ClassWriter ( COMPUTE_FRAMES ) ; new ClassReader ( out . data ) . accept ( cw , ClassReader . SKIP_FRAMES ) ; return cw . toByteArray ( ) ; } return out . data ; }
void test21 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newConst ( Object cst ) { return newConstItem ( cst ) . index ; }
void test22 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 992 ) ; Byte byte0 = new Byte ( ( byte ) 68 ) ; int int0 = classWriter0 . newConst ( ( Object ) byte0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newConst ( Object cst ) { return newConstItem ( cst ) . index ; }
void test23 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 992 ) ; Character character0 = new Character ( 'p' ) ; classWriter0 . newConst ( ( Object ) character0 ) ; int int0 = classWriter0 . newConst ( ( Object ) character0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newConst ( Object cst ) { return newConstItem ( cst ) . index ; }
void test24 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( int ) ( byte ) ( - 55 ) ) ; Short short0 = new Short ( ( short ) 0 ) ; int int0 = classWriter0 . newConst ( ( Object ) short0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newConst ( Object cst ) { return newConstItem ( cst ) . index ; }
void test25 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newConst ( Object cst ) { return newConstItem ( cst ) . index ; }
void test26 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( int ) ( byte ) ( - 55 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newConst ( Object cst ) { return newConstItem ( cst ) . index ; }
void test27 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( int ) ( byte ) ( - 55 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FieldVisitor visitField ( int access , String name , String desc , String signature , Object value ) { return cv . visitField ( access , name , desc , signature , value ) ; }
void test28 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newConst ( Object cst ) { return newConstItem ( cst ) . index ; }
void test29 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 1970 ) ) ; Class < ? > class0 = Type . class ; Type type0 = Type . getType ( class0 ) ; int int0 = classWriter0 . newConst ( ( Object ) type0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newConst ( Object cst ) { return newConstItem ( cst ) . index ; }
void test31 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 908 ) ) ; classWriter0 . newField ( "" , "" , "" ) ; int int0 = classWriter0 . newMethod ( "" , "" , "" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newMethod ( String owner , String name , String desc , boolean itf ) { return newMethodItem ( owner , name , desc , itf ) . index ; }
void test32 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 992 ) ; classWriter0 . addType ( "Lorg / objectweb / asm / jip / ClassWriter ; " ) ; int int0 = classWriter0 . addUninitializedType ( "" , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int addUninitializedType ( String type , int offset ) { key . type = TYPE_UNINIT ; key . intVal = offset ; key . strVal1 = type ; key . hashCode = 0x7FFFFFFF & ( TYPE_UNINIT + type . hashCode ( ) + offset ) ; Item result = get ( key ) ; if ( result = = null ) { result = addType ( key ) ; } return result . index ; }
void test33 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 992 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int addUninitializedType ( String type , int offset ) { key . type = TYPE_UNINIT ; key . intVal = offset ; key . strVal1 = type ; key . hashCode = 0x7FFFFFFF & ( TYPE_UNINIT + type . hashCode ( ) + offset ) ; Item result = get ( key ) ; if ( result = = null ) { result = addType ( key ) ; } return result . index ; }
void test35 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 992 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FieldVisitor visitField ( int access , String name , String desc , String signature , Object value ) { return cv . visitField ( access , name , desc , signature , value ) ; }
void test36 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 908 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newField ( String owner , String name , String desc ) { return newFieldItem ( owner , name , desc ) . index ; }
void test0 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 5 ) ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , 0 , "" , "" , "" , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visitAttribute ( Attribute attr ) { cv . visitAttribute ( attr ) ; }
void test1 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 5 ) ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , 0 , "" , "" , "" , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test2 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 5 ) ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , 0 , "" , "" , "" , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test3 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , ( - 705 ) , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , ( Object ) " / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test4 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , ( - 705 ) , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , ( Object ) " / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test5 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 5 ) ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , 0 , "" , "" , "" , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test6 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , ( - 705 ) , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , ( Object ) " / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test7 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 5 ) ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , ( - 5 ) , "" , "" , ( String ) null , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test8 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 5 ) ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , 0 , "" , "" , "" , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test9 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , ( - 705 ) , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , ( Object ) " / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test10 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 5 ) ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , ( - 5 ) , "" , "" , ( String ) null , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test11 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , ( - 705 ) , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , ( Object ) " / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test12 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; FieldWriter fieldWriter0 = new FieldWriter ( classWriter0 , ( - 705 ) , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , "C . ; > 44 . / 7f_l < ( d" , ( Object ) " / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test1 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 10 ] ; ClassReader classReader0 = new ClassReader ( byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int readByte ( int index ) { return b [ index ] & 0xFF ; }
void test3 ( ) throws Throwable { ClassReader classReader0 = new ClassReader ( "java / lang / String" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return _className ; }
void test4 ( ) throws Throwable { ClassReader classReader0 = new ClassReader ( "java / lang / String" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSuperName ( ) { int n = items [ readUnsignedShort ( header + 4 ) ] ; return n = = 0 ? null : readUTF8 ( n , new char [ maxStringLength ] ) ; }
void test5 ( ) throws Throwable { ClassReader classReader0 = new ClassReader ( "java / lang / String" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAccess ( ) { return readUnsignedShort ( header ) ; }
void test6 ( ) throws Throwable { ClassReader classReader0 = new ClassReader ( "java / lang / String" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAccess ( ) { return readUnsignedShort ( header ) ; }
void test8 ( ) throws Throwable { ClassReader classReader0 = new ClassReader ( "java / lang / String" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSuperName ( ) { int n = items [ readUnsignedShort ( header + 4 ) ] ; return n = = 0 ? null : readUTF8 ( n , new char [ maxStringLength ] ) ; }
void test9 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 23 ] ; ClassReader classReader0 = new ClassReader ( byteArray0 ) ; String [ ] stringArray0 = classReader0 . getInterfaces ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getInterfaces ( ) { int index = header + 6 ; int n = readUnsignedShort ( index ) ; String [ ] interfaces = new String [ n ] ; if ( n > 0 ) { char [ ] buf = new char [ maxStringLength ] ; for ( int i = 0 ; i < n ; + + i ) { index + = 2 ; interfaces [ i ] = readClass ( index , buf ) ; } } return interfaces ; }
void test10 ( ) throws Throwable { ClassReader classReader0 = new ClassReader ( "java / lang / String" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return _className ; }
void test12 ( ) throws Throwable { ClassReader classReader0 = new ClassReader ( "java / lang / String" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getAccess ( ) { return readUnsignedShort ( header ) ; }
void test13 ( ) throws Throwable { ClassReader classReader0 = new ClassReader ( "java / lang / String" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return _className ; }
void test0 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( ( double ) 0 ) ; boolean boolean0 = item0 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test1 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( 3 ) ; boolean boolean0 = item0 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test2 ( ) throws Throwable { Item item0 = new Item ( ( - 15 ) ) ; Item item1 = new Item ( 12 , item0 ) ; item0 . set ( ( long ) 12 ) ; boolean boolean0 = item0 . isEqualTo ( item1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test3 ( ) throws Throwable { Item item0 = new Item ( ( - 15 ) ) ; item0 . set ( ( long ) 12 ) ; boolean boolean0 = item0 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test4 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( ( float ) 1091567616 ) ; boolean boolean0 = item0 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test6 ( ) throws Throwable { Item item0 = new Item ( ( - 15 ) ) ; item0 . set ( 12 , "" , "" , "" ) ; boolean boolean0 = item0 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test8 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( 4 , "_ W > [ BhU" , "_ W > [ BhU" , "_ W > [ BhU" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void set ( int intVal ) { this . type = ClassWriter . INT ; this . intVal = intVal ; this . hashCode = 0x7FFFFFFF & ( type + intVal ) ; }
void test10 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( 6 , "_ W > hU" , "_ W > hU" , "_ W > hU" ) ; Item item1 = new Item ( ) ; item1 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test12 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( 8 , "N : Vbn * eddqH%rucHZ" , "N : Vbn * eddqH%rucHZ" , "4" ) ; boolean boolean0 = item0 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test13 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( 9 , "_ W > [ BhU" , "_ W > [ BhU" , "_ W > [ BhU" ) ; boolean boolean0 = item0 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test14 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( 11 , "_ W > hU" , "_ W > hU" , "_ W > hU" ) ; boolean boolean0 = item0 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test16 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( 14 , "_ W > [ BhU" , "_ W > [ BhU" , "_ W > [ BhU" ) ; boolean boolean0 = item0 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test18 ( ) throws Throwable { Item item0 = new Item ( ) ; Item item1 = new Item ( ) ; item0 . set ( ( float ) 1091567616 ) ; boolean boolean0 = item0 . isEqualTo ( item1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test19 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( 14 , "_ W > [ BhU" , "_ W > [ BhU" , "_ W > [ BhU" ) ; item0 . intVal = 941485518 ; Item item1 = new Item ( ) ; boolean boolean0 = item0 . isEqualTo ( item1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test20 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( 14 , "_ W > [ BhU" , "_ W > [ BhU" , "_ W > [ BhU" ) ; Item item1 = new Item ( 941485518 , item0 ) ; item0 . strVal1 = "_ WB`hU" ; boolean boolean0 = item0 . isEqualTo ( item1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test21 ( ) throws Throwable { Item item0 = new Item ( ( - 15 ) ) ; item0 . set ( 12 , "" , "" , "" ) ; Item item1 = new Item ( 12 , item0 ) ; String string0 = "N : Vbn * eddqH%\\ucZ" ; item1 . set ( 12 , "" , string0 , item0 . strVal2 ) ; boolean boolean0 = item1 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test22 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( 2 , " W > W [ BhU" , " W > W [ BhU" , " W > W [ BhU" ) ; Item item1 = new Item ( 0 , item0 ) ; item0 . set ( 0 , " W > W [ BhU" , "b > #`x" , "b > #`x" ) ; boolean boolean0 = item1 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test23 ( ) throws Throwable { Item item0 = new Item ( ) ; item0 . set ( 8 , "N : Vbn * eddqH%rucHZ" , "N : Vbn * eddqH%rucHZ" , "4" ) ; Item item1 = new Item ( ) ; item1 . set ( 0 , "N : Vbn * eddqH%rucHZ" , "N : Vbn * eddqH%rucHZ" , "N : Vbn * eddqH%rucHZ" ) ; boolean boolean0 = item1 . isEqualTo ( item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEqualTo ( Item i ) { switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . TYPE_NORMAL : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . TYPE_MERGED : case ClassWriter . LONG : case ClassWriter . DOUBLE : return i . longVal = = longVal ; case ClassWriter . INT : case ClassWriter . FLOAT : return i . intVal = = intVal ; case ClassWriter . TYPE_UNINIT : return i . intVal = = intVal & & i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) ; / / case ClassWriter . FIELD : / / case ClassWriter . METH : / / case ClassWriter . IMETH : default : return i . strVal1 . equals ( strVal1 ) & & i . strVal2 . equals ( strVal2 ) & & i . strVal3 . equals ( strVal3 ) ; } }
void test1 ( ) throws Throwable { Type type0 = Type . getReturnType ( " [ N\" : ? < G , 5_9b ? I2 ; < " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDescriptor ( ) { StringBuffer buf = new StringBuffer ( ) ; getDescriptor ( buf ) ; return buf . toString ( ) ; }
void test2 ( ) throws Throwable { Type type0 = Type . getObjectType ( "% [ . } T } pjOFY > " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getInternalName ( ) { return new String ( buf , off , len ) ; }
void test3 ( ) throws Throwable { Type type0 = Type . getType ( " [ ] " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test4 ( ) throws Throwable { Class < ? > class0 = Type . class ; Type type0 = Type . getType ( class0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return _className ; }
void test5 ( ) throws Throwable { Type type0 = Type . getReturnType ( " ) V" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getInternalName ( ) { return new String ( buf , off , len ) ; }
void test6 ( ) throws Throwable { Class < ? > class0 = Constructor . class ; String string0 = Type . getInternalName ( class0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getInternalName ( ) { return new String ( buf , off , len ) ; }
void test7 ( ) throws Throwable { Type type0 = Type . getObjectType ( " [ B ] " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test8 ( ) throws Throwable { Type [ ] typeArray0 = Type . getArgumentTypes ( " ( SSSSSSSSSS ) S" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Type [ ] getArgumentTypes ( String methodDescriptor ) { char [ ] buf = methodDescriptor . toCharArray ( ) ; int off = 1 ; int size = 0 ; while ( true ) { char car = buf [ off + + ] ; if ( car = = ' ) ' ) { break ; } else if ( car = = 'L' ) { while ( buf [ off + + ] ! = ' ; ' ) { } + + size ; } else if ( car ! = ' [ ' ) { + + size ; } } Type [ ] args = new Type [ size ] ; off = 1 ; size = 0 ; while ( buf [ off ] ! = ' ) ' ) { args [ size ] = getType ( buf , off ) ; off + = args [ size ] . len + ( args [ size ] . sort = = OBJECT ? 2 : 0 ) ; size + = 1 ; } return args ; }
void test11 ( ) throws Throwable { int int0 = Type . getArgumentsAndReturnSizes ( " ( VVVV ) V" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getArgumentsAndReturnSizes ( String desc ) { int n = 1 ; int c = 1 ; while ( true ) { char car = desc . charAt ( c + + ) ; if ( car = = ' ) ' ) { car = desc . charAt ( c ) ; return n < < 2 | ( car = = 'V' ? 0 : ( car = = 'D' | | car = = 'J' ? 2 : 1 ) ) ; } else if ( car = = 'L' ) { while ( desc . charAt ( c + + ) ! = ' ; ' ) { } n + = 1 ; } else if ( car = = ' [ ' ) { while ( ( car = desc . charAt ( c ) ) = = ' [ ' ) { + + c ; } if ( car = = 'D' | | car = = 'J' ) { n - = 1 ; } } else if ( car = = 'D' | | car = = 'J' ) { n + = 2 ; } else { n + = 1 ; } } }
void test12 ( ) throws Throwable { int int0 = Type . getArgumentsAndReturnSizes ( " ( Lint ; Lint ; Lint ; Lint ; Lint ; Lint ; Lint ; ) Lint ; " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getArgumentsAndReturnSizes ( String desc ) { int n = 1 ; int c = 1 ; while ( true ) { char car = desc . charAt ( c + + ) ; if ( car = = ' ) ' ) { car = desc . charAt ( c ) ; return n < < 2 | ( car = = 'V' ? 0 : ( car = = 'D' | | car = = 'J' ? 2 : 1 ) ) ; } else if ( car = = 'L' ) { while ( desc . charAt ( c + + ) ! = ' ; ' ) { } n + = 1 ; } else if ( car = = ' [ ' ) { while ( ( car = desc . charAt ( c ) ) = = ' [ ' ) { + + c ; } if ( car = = 'D' | | car = = 'J' ) { n - = 1 ; } } else if ( car = = 'D' | | car = = 'J' ) { n + = 2 ; } else { n + = 1 ; } } }
void test1 ( ) throws Throwable { Attribute attribute0 = new Attribute ( "j$GQ , ( JMb + " ) ; Label [ ] labelArray0 = attribute0 . getLabels ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Label [ ] getLabels ( ) { return null ; }
void test2 ( ) throws Throwable { Attribute attribute0 = new Attribute ( "j$GQ , ( JMb + " ) ; boolean boolean0 = attribute0 . isUnknown ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUnknown ( ) { return true ; }
void test3 ( ) throws Throwable { Attribute attribute0 = new Attribute ( "" ) ; boolean boolean0 = attribute0 . isCodeAttribute ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCodeAttribute ( ) { return false ; }
void test4 ( ) throws Throwable { Attribute attribute0 = new Attribute ( "j$GQ , ( JMb + " ) ; int int0 = attribute0 . getCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getCount ( ) { return _count ; }
void test5 ( ) throws Throwable { Attribute attribute0 = new Attribute ( "" ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 1804 ) ) ; byte [ ] byteArray0 = new byte [ 4 ] ; attribute0 . value = byteArray0 ; int int0 = attribute0 . getSize ( classWriter0 , byteArray0 , ( int ) ( byte ) 11 , 63 , 166 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test6 ( ) throws Throwable { Attribute attribute0 = new Attribute ( "" ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 1804 ) ) ; byte [ ] byteArray0 = new byte [ 4 ] ; attribute0 . value = byteArray0 ; ByteVector byteVector0 = new ByteVector ( ) ; attribute0 . put ( classWriter0 , byteArray0 , ( int ) ( byte ) ( - 31 ) , ( - 1804 ) , ( int ) ( byte ) ( - 31 ) , byteVector0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUnknown ( ) { return true ; }
void test2 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; String [ ] stringArray0 = new String [ 2 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; MethodVisitor methodVisitor0 = classWriter0 . visitMethod ( 0 , "" , "" , "" , stringArray0 ) ; MethodAdapter methodAdapter0 = new MethodAdapter ( methodVisitor0 ) ; Label label0 = new Label ( ) ; methodAdapter0 . visitLocalVariable ( "" , "" , "" , label0 , label0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test10 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( ( - 544 ) ) ; String [ ] stringArray0 = new String [ 1 ] ; stringArray0 [ 0 ] = "`Q > rTq + ea" ; MethodVisitor methodVisitor0 = classWriter0 . visitMethod ( ( - 544 ) , "`Q > rTq + ea" , "`Q > rTq + ea" , "`Q > rTq + ea" , stringArray0 ) ; MethodAdapter methodAdapter0 = new MethodAdapter ( methodVisitor0 ) ; AnnotationVisitor annotationVisitor0 = methodAdapter0 . visitAnnotationDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" AnnotationVisitor visitAnnotationDefault ( ) { if ( ! ClassReader . ANNOTATIONS ) { return null ; } annd = new ByteVector ( ) ; return new AnnotationWriter ( cw , false , annd , null , 0 ) ; }
void test11 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; ClassAdapter classAdapter0 = new ClassAdapter ( ( ClassVisitor ) classWriter0 ) ; String [ ] stringArray0 = new String [ 1 ] ; stringArray0 [ 0 ] = "" ; MethodVisitor methodVisitor0 = classAdapter0 . visitMethod ( 0 , "" , "" , "" , stringArray0 ) ; MethodAdapter methodAdapter0 = new MethodAdapter ( methodVisitor0 ) ; Label label0 = new Label ( ) ; methodAdapter0 . visitLineNumber ( 0 , label0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test13 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; String [ ] stringArray0 = new String [ 2 ] ; stringArray0 [ 0 ] = "" ; stringArray0 [ 1 ] = "" ; MethodVisitor methodVisitor0 = classWriter0 . visitMethod ( 0 , "" , "" , "" , stringArray0 ) ; MethodAdapter methodAdapter0 = new MethodAdapter ( methodVisitor0 ) ; AnnotationVisitor annotationVisitor0 = methodAdapter0 . visitAnnotation ( "" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" AnnotationVisitor visitAnnotation ( String desc , boolean visible ) { return cv . visitAnnotation ( desc , visible ) ; }
void test0 ( ) throws Throwable { Label label0 = new Label ( ) ; String string0 = label0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test1 ( ) throws Throwable { Label label0 = new Label ( ) ; byte [ ] byteArray0 = new byte [ 9 ] ; label0 . resolve ( ( MethodWriter ) null , 0 , byteArray0 ) ; int int0 = label0 . getOffset ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getOffset ( ) { if ( ( status & RESOLVED ) = = 0 ) { throw new IllegalStateException ( "Label offset position has not been resolved yet" ) ; } return position ; }
void test3 ( ) throws Throwable { Label label0 = new Label ( ) ; ByteVector byteVector0 = new ByteVector ( 0 ) ; byte [ ] byteArray0 = new byte [ 7 ] ; label0 . resolve ( ( MethodWriter ) null , 0 , byteArray0 ) ; label0 . put ( ( MethodWriter ) null , byteVector0 , 0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test4 ( ) throws Throwable { Label label0 = new Label ( ) ; ByteVector byteVector0 = new ByteVector ( 0 ) ; byte [ ] byteArray0 = new byte [ 9 ] ; label0 . resolve ( ( MethodWriter ) null , 0 , byteArray0 ) ; label0 . put ( ( MethodWriter ) null , byteVector0 , 2 , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test7 ( ) throws Throwable { Label label0 = new Label ( ) ; ByteVector byteVector0 = new ByteVector ( 0 ) ; byteVector0 . put12 ( 0 , 0 ) ; label0 . put ( ( MethodWriter ) null , byteVector0 , 0 , false ) ; byte [ ] byteArray0 = new byte [ 19 ] ; byteArray0 [ 2 ] = ( byte ) ( - 50 ) ; boolean boolean0 = label0 . resolve ( ( MethodWriter ) null , 251658240 , byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolve ( MethodWriter owner , int position , byte [ ] data ) { boolean needUpdate = false ; this . status | = RESOLVED ; this . position = position ; int i = 0 ; while ( i < referenceCount ) { int source = srcAndRefPositions [ i + + ] ; int reference = srcAndRefPositions [ i + + ] ; int offset ; if ( source > = 0 ) { offset = position - source ; if ( offset < Short . MIN_VALUE | | offset > Short . MAX_VALUE ) { / * * changes the opcode of the jump instruction , in order to * be able to find it later ( see resizeInstructions in * MethodWriter ) . These temporary opcodes are similar to * jump instruction opcodes , except that the 2 bytes offset * is unsigned ( and can therefore represent values from 0 to * 65535 , which is sufficient since the size of a method is * limited to 65535 bytes ) . * / int opcode = data [ reference - 1 ] & 0xFF ; if ( opcode < = Opcodes . JSR ) { / / changes IFEQ . . . JSR to opcodes 202 to 217 data [ reference - 1 ] = ( byte ) ( opcode + 49 ) ; } else { / / changes IFNULL and IFNONNULL to opcodes 218 and 219 data [ reference - 1 ] = ( byte ) ( opcode + 20 ) ; } needUpdate = true ; } data [ reference + + ] = ( byte ) ( offset > > > 8 ) ; data [ reference ] = ( byte ) offset ; } else { offset = position + source + 1 ; data [ reference + + ] = ( byte ) ( offset > > > 24 ) ; data [ reference + + ] = ( byte ) ( offset > > > 16 ) ; data [ reference + + ] = ( byte ) ( offset > > > 8 ) ; data [ reference ] = ( byte ) offset ; } } return needUpdate ; }
void test8 ( ) throws Throwable { Label label0 = new Label ( ) ; ByteVector byteVector0 = new ByteVector ( 0 ) ; byteVector0 . put12 ( 0 , 0 ) ; label0 . put ( ( MethodWriter ) null , byteVector0 , 0 , false ) ; byte [ ] byteArray0 = new byte [ 19 ] ; boolean boolean0 = label0 . resolve ( ( MethodWriter ) null , 251658240 , byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean resolve ( MethodWriter owner , int position , byte [ ] data ) { boolean needUpdate = false ; this . status | = RESOLVED ; this . position = position ; int i = 0 ; while ( i < referenceCount ) { int source = srcAndRefPositions [ i + + ] ; int reference = srcAndRefPositions [ i + + ] ; int offset ; if ( source > = 0 ) { offset = position - source ; if ( offset < Short . MIN_VALUE | | offset > Short . MAX_VALUE ) { / * * changes the opcode of the jump instruction , in order to * be able to find it later ( see resizeInstructions in * MethodWriter ) . These temporary opcodes are similar to * jump instruction opcodes , except that the 2 bytes offset * is unsigned ( and can therefore represent values from 0 to * 65535 , which is sufficient since the size of a method is * limited to 65535 bytes ) . * / int opcode = data [ reference - 1 ] & 0xFF ; if ( opcode < = Opcodes . JSR ) { / / changes IFEQ . . . JSR to opcodes 202 to 217 data [ reference - 1 ] = ( byte ) ( opcode + 49 ) ; } else { / / changes IFNULL and IFNONNULL to opcodes 218 and 219 data [ reference - 1 ] = ( byte ) ( opcode + 20 ) ; } needUpdate = true ; } data [ reference + + ] = ( byte ) ( offset > > > 8 ) ; data [ reference ] = ( byte ) offset ; } else { offset = position + source + 1 ; data [ reference + + ] = ( byte ) ( offset > > > 24 ) ; data [ reference + + ] = ( byte ) ( offset > > > 16 ) ; data [ reference + + ] = ( byte ) ( offset > > > 8 ) ; data [ reference ] = ( byte ) offset ; } } return needUpdate ; }
void test9 ( ) throws Throwable { Label label0 = new Label ( ) ; Label label1 = label0 . getFirst ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test10 ( ) throws Throwable { Label label0 = new Label ( ) ; label0 . visitSubroutine ( ( Label ) null , ( long ) 0 , 0 ) ; label0 . visitSubroutine ( ( Label ) null , ( long ) 1838 , 1838 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test11 ( ) throws Throwable { Label label0 = new Label ( ) ; label0 . addToSubroutine ( 672L , 0 ) ; label0 . visitSubroutine ( ( Label ) null , 1987L , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test12 ( ) throws Throwable { Label label0 = new Label ( ) ; boolean boolean0 = label0 . inSameSubroutine ( label0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test14 ( ) throws Throwable { Label label0 = new Label ( ) ; label0 . addToSubroutine ( ( long ) 0 , 0 ) ; boolean boolean0 = label0 . inSameSubroutine ( label0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean inSameSubroutine ( Label block ) { if ( ( status & VISITED ) = = 0 | | ( block . status & VISITED ) = = 0 ) { return false ; } for ( int i = 0 ; i < srcAndRefPositions . length ; + + i ) { if ( ( srcAndRefPositions [ i ] & block . srcAndRefPositions [ i ] ) ! = 0 ) { return true ; } } return false ; }
void test15 ( ) throws Throwable { Label label0 = new Label ( ) ; label0 . addToSubroutine ( 672L , 0 ) ; boolean boolean0 = label0 . inSameSubroutine ( label0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean inSameSubroutine ( Label block ) { if ( ( status & VISITED ) = = 0 | | ( block . status & VISITED ) = = 0 ) { return false ; } for ( int i = 0 ; i < srcAndRefPositions . length ; + + i ) { if ( ( srcAndRefPositions [ i ] & block . srcAndRefPositions [ i ] ) ! = 0 ) { return true ; } } return false ; }
void test16 ( ) throws Throwable { Label label0 = new Label ( ) ; label0 . visitSubroutine ( label0 , ( long ) 0 , 0 ) ; label0 . visitSubroutine ( label0 , ( long ) 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test16 ( ) throws Throwable { Frame frame0 = new Frame ( ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 15 ) ) ; Frame frame1 = new Frame ( ) ; Type [ ] typeArray0 = new Type [ 3 ] ; Type type0 = Type . FLOAT_TYPE ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = typeArray0 [ 0 ] ; typeArray0 [ 2 ] = typeArray0 [ 0 ] ; frame0 . initInputFrame ( classWriter0 , ( - 269 ) , typeArray0 , 170 ) ; frame0 . merge ( classWriter0 , frame1 , 170 ) ; boolean boolean0 = frame0 . merge ( classWriter0 , frame1 , 90 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean merge ( ClassWriter cw , Frame frame , int edge ) { boolean changed = false ; int i , s , dim , kind , t ; int nLocal = inputLocals . length ; int nStack = inputStack . length ; if ( frame . inputLocals = = null ) { frame . inputLocals = new int [ nLocal ] ; changed = true ; } for ( i = 0 ; i < nLocal ; + + i ) { if ( outputLocals ! = null & & i < outputLocals . length ) { s = outputLocals [ i ] ; if ( s = = 0 ) { t = inputLocals [ i ] ; } else { dim = s & DIM ; kind = s & KIND ; if ( kind = = BASE ) { t = s ; } else { if ( kind = = LOCAL ) { t = dim + inputLocals [ s & VALUE ] ; } else { t = dim + inputStack [ nStack - ( s & VALUE ) ] ; } if ( ( s & TOP_IF_LONG_OR_DOUBLE ) ! = 0 & & ( t = = LONG | | t = = DOUBLE ) ) { t = TOP ; } } } } else { t = inputLocals [ i ] ; } if ( initializations ! = null ) { t = init ( cw , t ) ; } changed | = merge ( cw , t , frame . inputLocals , i ) ; } if ( edge > 0 ) { for ( i = 0 ; i < nLocal ; + + i ) { t = inputLocals [ i ] ; changed | = merge ( cw , t , frame . inputLocals , i ) ; } if ( frame . inputStack = = null ) { frame . inputStack = new int [ 1 ] ; changed = true ; } changed | = merge ( cw , edge , frame . inputStack , 0 ) ; return changed ; } int nInputStack = inputStack . length + owner . inputStackTop ; if ( frame . inputStack = = null ) { frame . inputStack = new int [ nInputStack + outputStackTop ] ; changed = true ; } for ( i = 0 ; i < nInputStack ; + + i ) { t = inputStack [ i ] ; if ( initializations ! = null ) { t = init ( cw , t ) ; } changed | = merge ( cw , t , frame . inputStack , i ) ; } for ( i = 0 ; i < outputStackTop ; + + i ) { s = outputStack [ i ] ; dim = s & DIM ; kind = s & KIND ; if ( kind = = BASE ) { t = s ; } else { if ( kind = = LOCAL ) { t = dim + inputLocals [ s & VALUE ] ; } else { t = dim + inputStack [ nStack - ( s & VALUE ) ] ; } if ( ( s & TOP_IF_LONG_OR_DOUBLE ) ! = 0 & & ( t = = LONG | | t = = DOUBLE ) ) { t = TOP ; } } if ( initializations ! = null ) { t = init ( cw , t ) ; } changed | = merge ( cw , t , frame . inputStack , nInputStack + i ) ; } return changed ; }
void test0 ( ) throws Throwable { Method method0 = new Method ( "I" , "I" ) ; String string0 = method0 . getDescriptor ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDescriptor ( ) { StringBuffer buf = new StringBuffer ( ) ; getDescriptor ( buf ) ; return buf . toString ( ) ; }
void test1 ( ) throws Throwable { Method method0 = new Method ( "I" , "I" ) ; String string0 = method0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test3 ( ) throws Throwable { Method method0 = new Method ( "I" , "I" ) ; int int0 = method0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { return _className . hashCode ( ) + _methodName . hashCode ( ) ; }
void test5 ( ) throws Throwable { Class < ? > class0 = Method . class ; Type type0 = Type . getType ( class0 ) ; Type [ ] typeArray0 = new Type [ 10 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = typeArray0 [ 0 ] ; typeArray0 [ 2 ] = type0 ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; typeArray0 [ 6 ] = typeArray0 [ 0 ] ; typeArray0 [ 7 ] = typeArray0 [ 1 ] ; typeArray0 [ 8 ] = type0 ; typeArray0 [ 9 ] = typeArray0 [ 1 ] ; Method method0 = new Method ( "bhWGWs" , type0 , typeArray0 ) ; Type [ ] typeArray1 = method0 . getArgumentTypes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDescriptor ( ) { StringBuffer buf = new StringBuffer ( ) ; getDescriptor ( buf ) ; return buf . toString ( ) ; }
void test6 ( ) throws Throwable { Method method0 = new Method ( "I" , "I" ) ; Type type0 = method0 . getReturnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return name ; }
void test7 ( ) throws Throwable { Method method0 = new Method ( "I" , "I" ) ; String string0 = method0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return name ; }
void test10 ( ) throws Throwable { Method method0 = Method . getMethod ( " ( L s ( o . : A5``q < ; SL s ( o . : A5``q < ; L s ( o . : A5``q < ; ) L s ( o . : A5``q < ; " , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test11 ( ) throws Throwable { Method method0 = Method . getMethod ( " ( L s ( o . : A5``q < ; SL s ( o . : A5``q < ; L s ( o . : A5``q < ; ) L s ( o . : A5``q < ; " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test12 ( ) throws Throwable { Method method0 = new Method ( "I" , "I" ) ; boolean boolean0 = method0 . equals ( ( Object ) method0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object other ) { assert other instanceof Method ; Method m = ( Method ) other ; return this . _className . equals ( m . _className ) & & this . _methodName . equals ( m . _methodName ) ; }
void test13 ( ) throws Throwable { Class < ? > class0 = Method . class ; Type type0 = Type . getType ( class0 ) ; Type [ ] typeArray0 = new Type [ 10 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = typeArray0 [ 0 ] ; typeArray0 [ 2 ] = type0 ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; typeArray0 [ 6 ] = typeArray0 [ 0 ] ; typeArray0 [ 7 ] = typeArray0 [ 1 ] ; typeArray0 [ 8 ] = type0 ; typeArray0 [ 9 ] = typeArray0 [ 1 ] ; Method method0 = new Method ( "bhWGWs" , type0 , typeArray0 ) ; boolean boolean0 = method0 . equals ( ( Object ) "org . objectweb . asm . jip . commons . Method" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test14 ( ) throws Throwable { Method method0 = new Method ( "I" , "I" ) ; Method method1 = new Method ( "II" , "II" ) ; boolean boolean0 = method0 . equals ( ( Object ) method1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object other ) { assert other instanceof Method ; Method m = ( Method ) other ; return this . _className . equals ( m . _className ) & & this . _methodName . equals ( m . _methodName ) ; }
void test0 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1 ) ; SerialVersionUIDAdder serialVersionUIDAdder0 = new SerialVersionUIDAdder ( ( ClassVisitor ) classWriter0 ) ; String [ ] stringArray0 = new String [ 7 ] ; stringArray0 [ 3 ] = " ) gP~v Inl F`yq ] Of } " ; stringArray0 [ 0 ] = " - F`z" ; stringArray0 [ 1 ] = " - F`z" ; stringArray0 [ 2 ] = " - F`z" ; stringArray0 [ 4 ] = " - F`z" ; stringArray0 [ 5 ] = " - F`z" ; stringArray0 [ 6 ] = " - F`z" ; serialVersionUIDAdder0 . visit ( 1 , 1 , " - F`z" , " - F`z" , " - F`z" , stringArray0 ) ; serialVersionUIDAdder0 . visitField ( 1 , " ) gP~v Inl F`yq ] Of } " , " ) gP~v Inl F`yq ] Of } " , " ) gP~v Inl F`yq ] Of } " , ( Object ) " + & l : " ) ; long long0 = serialVersionUIDAdder0 . computeSVUID ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long computeSVUID ( ) throws IOException { ByteArrayOutputStream bos ; DataOutputStream dos = null ; long svuid = 0 ; try { bos = new ByteArrayOutputStream ( ) ; dos = new DataOutputStream ( bos ) ; / * * 1 . The class name written using UTF encoding . * / dos . writeUTF ( name . replace ( ' / ' , ' . ' ) ) ; / * * 2 . The class modifiers written as a 32 - bit integer . * / dos . writeInt ( access & ( Opcodes . ACC_PUBLIC | Opcodes . ACC_FINAL | Opcodes . ACC_INTERFACE | Opcodes . ACC_ABSTRACT ) ) ; / * * 3 . The name of each interface sorted by name written using UTF * encoding . * / Arrays . sort ( interfaces ) ; for ( int i = 0 ; i < interfaces . length ; i + + ) { dos . writeUTF ( interfaces [ i ] . replace ( ' / ' , ' . ' ) ) ; } / * * 4 . For each field of the class sorted by field name ( except * and fields ) : * * 1 . The name of the field in UTF encoding . 2 . The modifiers of the * field written as a 32 - bit integer . 3 . The descriptor of the field * in UTF encoding * * Note that field signatures are not dot separated . Method and * constructor signatures are dot separated . Go figure . . . * / writeItems ( svuidFields , dos , false ) ; / * * 5 . If a class initializer exists , write out the following : 1 . The * name of the method , < clinit > , in UTF encoding . 2 . The modifier of * the method , java . lang . reflect . Modifier . STATIC , written as a * 32 - bit integer . 3 . The descriptor of the method , ( ) V , in UTF * encoding . * / if ( hasStaticInitializer ) { dos . writeUTF ( " < clinit > " ) ; dos . writeInt ( Opcodes . ACC_STATIC ) ; dos . writeUTF ( " ( ) V" ) ; } / / if . . / * * 6 . For each non - constructor sorted by method name and * signature : 1 . The name of the method , < init > , in UTF encoding . 2 . * The modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidConstructors , dos , true ) ; / * * 7 . For each non - method sorted by method name and * signature : 1 . The name of the method in UTF encoding . 2 . The * modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidMethods , dos , true ) ; dos . flush ( ) ; / * * 8 . The SHA - 1 algorithm is executed on the stream of bytes * produced by DataOutputStream and produces five 32 - bit values * sha [ 0 . . 4 ] . * / byte [ ] hashBytes = computeSHAdigest ( bos . toByteArray ( ) ) ; / * * 9 . The hash value is assembled from the first and second 32 - bit * values of the SHA - 1 message digest . If the result of the message * digest , the five 32 - bit words H0 H1 H2 H3 H4 , is in an array of * five int values named sha , the hash value would be computed as * follows : * * long hash = ( ( sha [ 0 ] > > > 24 ) & 0xFF ) | ( ( sha [ 0 ] > > > 16 ) & 0xFF ) < < * 8 | ( ( sha [ 0 ] > > > 8 ) & 0xFF ) < < 16 | ( ( sha [ 0 ] > > > 0 ) & 0xFF ) < < * 24 | ( ( sha [ 1 ] > > > 24 ) & 0xFF ) < < 32 | ( ( sha [ 1 ] > > > 16 ) & 0xFF ) < < * 40 | ( ( sha [ 1 ] > > > 8 ) & 0xFF ) < < 48 | ( ( sha [ 1 ] > > > 0 ) & 0xFF ) < < * 56 ; * / for ( int i = Math . min ( hashBytes . length , 8 ) - 1 ; i > = 0 ; i - - ) { svuid = ( svuid < < 8 ) | ( hashBytes [ i ] & 0xFF ) ; } } finally { / / close the stream ( if open ) if ( dos ! = null ) { dos . close ( ) ; } } return svuid ; }
void test3 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1 ) ; SerialVersionUIDAdder serialVersionUIDAdder0 = new SerialVersionUIDAdder ( ( ClassVisitor ) classWriter0 ) ; String [ ] stringArray0 = new String [ 7 ] ; stringArray0 [ 3 ] = " ) gP~v Inl F`yq ] Of } " ; stringArray0 [ 0 ] = " - F`z" ; stringArray0 [ 1 ] = " - F`z" ; stringArray0 [ 2 ] = " - F`z" ; stringArray0 [ 4 ] = " - F`z" ; stringArray0 [ 5 ] = " - F`z" ; stringArray0 [ 6 ] = " - F`z" ; serialVersionUIDAdder0 . visit ( 1 , 1 , " - F`z" , " - F`z" , " - F`z" , stringArray0 ) ; serialVersionUIDAdder0 . visitMethod ( 1 , " + & l : " , " * 4R3_UPr ) c } } 3LMo" , " ) gP~v Inl F`yq ] Of } " , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long computeSVUID ( ) throws IOException { ByteArrayOutputStream bos ; DataOutputStream dos = null ; long svuid = 0 ; try { bos = new ByteArrayOutputStream ( ) ; dos = new DataOutputStream ( bos ) ; / * * 1 . The class name written using UTF encoding . * / dos . writeUTF ( name . replace ( ' / ' , ' . ' ) ) ; / * * 2 . The class modifiers written as a 32 - bit integer . * / dos . writeInt ( access & ( Opcodes . ACC_PUBLIC | Opcodes . ACC_FINAL | Opcodes . ACC_INTERFACE | Opcodes . ACC_ABSTRACT ) ) ; / * * 3 . The name of each interface sorted by name written using UTF * encoding . * / Arrays . sort ( interfaces ) ; for ( int i = 0 ; i < interfaces . length ; i + + ) { dos . writeUTF ( interfaces [ i ] . replace ( ' / ' , ' . ' ) ) ; } / * * 4 . For each field of the class sorted by field name ( except * and fields ) : * * 1 . The name of the field in UTF encoding . 2 . The modifiers of the * field written as a 32 - bit integer . 3 . The descriptor of the field * in UTF encoding * * Note that field signatures are not dot separated . Method and * constructor signatures are dot separated . Go figure . . . * / writeItems ( svuidFields , dos , false ) ; / * * 5 . If a class initializer exists , write out the following : 1 . The * name of the method , < clinit > , in UTF encoding . 2 . The modifier of * the method , java . lang . reflect . Modifier . STATIC , written as a * 32 - bit integer . 3 . The descriptor of the method , ( ) V , in UTF * encoding . * / if ( hasStaticInitializer ) { dos . writeUTF ( " < clinit > " ) ; dos . writeInt ( Opcodes . ACC_STATIC ) ; dos . writeUTF ( " ( ) V" ) ; } / / if . . / * * 6 . For each non - constructor sorted by method name and * signature : 1 . The name of the method , < init > , in UTF encoding . 2 . * The modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidConstructors , dos , true ) ; / * * 7 . For each non - method sorted by method name and * signature : 1 . The name of the method in UTF encoding . 2 . The * modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidMethods , dos , true ) ; dos . flush ( ) ; / * * 8 . The SHA - 1 algorithm is executed on the stream of bytes * produced by DataOutputStream and produces five 32 - bit values * sha [ 0 . . 4 ] . * / byte [ ] hashBytes = computeSHAdigest ( bos . toByteArray ( ) ) ; / * * 9 . The hash value is assembled from the first and second 32 - bit * values of the SHA - 1 message digest . If the result of the message * digest , the five 32 - bit words H0 H1 H2 H3 H4 , is in an array of * five int values named sha , the hash value would be computed as * follows : * * long hash = ( ( sha [ 0 ] > > > 24 ) & 0xFF ) | ( ( sha [ 0 ] > > > 16 ) & 0xFF ) < < * 8 | ( ( sha [ 0 ] > > > 8 ) & 0xFF ) < < 16 | ( ( sha [ 0 ] > > > 0 ) & 0xFF ) < < * 24 | ( ( sha [ 1 ] > > > 24 ) & 0xFF ) < < 32 | ( ( sha [ 1 ] > > > 16 ) & 0xFF ) < < * 40 | ( ( sha [ 1 ] > > > 8 ) & 0xFF ) < < 48 | ( ( sha [ 1 ] > > > 0 ) & 0xFF ) < < * 56 ; * / for ( int i = Math . min ( hashBytes . length , 8 ) - 1 ; i > = 0 ; i - - ) { svuid = ( svuid < < 8 ) | ( hashBytes [ i ] & 0xFF ) ; } } finally { / / close the stream ( if open ) if ( dos ! = null ) { dos . close ( ) ; } } return svuid ; }
void test5 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1 ) ; SerialVersionUIDAdder serialVersionUIDAdder0 = new SerialVersionUIDAdder ( ( ClassVisitor ) classWriter0 ) ; FieldVisitor fieldVisitor0 = serialVersionUIDAdder0 . visitField ( ( - 366 ) , " - F`z" , " ) gP~v Inl F`yq ] Of } " , " ) gP~v Inl F`yq ] Of } " , ( Object ) " - F`z" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FieldVisitor visitField ( int access , String name , String desc , String signature , Object value ) { return cv . visitField ( access , name , desc , signature , value ) ; }
void test6 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 1 ) ; SerialVersionUIDAdder serialVersionUIDAdder0 = new SerialVersionUIDAdder ( ( ClassVisitor ) classWriter0 ) ; String [ ] stringArray0 = new String [ 7 ] ; stringArray0 [ 3 ] = " ) gP~v Inl F`yq ] Of } " ; stringArray0 [ 0 ] = " - F`z" ; stringArray0 [ 1 ] = " - F`z" ; stringArray0 [ 2 ] = " - F`z" ; stringArray0 [ 4 ] = " - F`z" ; stringArray0 [ 5 ] = " - F`z" ; stringArray0 [ 6 ] = " - F`z" ; serialVersionUIDAdder0 . visit ( 1 , 1 , " - F`z" , " - F`z" , " - F`z" , stringArray0 ) ; serialVersionUIDAdder0 . visitField ( ( - 366 ) , " - F`z" , " ) gP~v Inl F`yq ] Of } " , " ) gP~v Inl F`yq ] Of } " , ( Object ) " - F`z" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long computeSVUID ( ) throws IOException { ByteArrayOutputStream bos ; DataOutputStream dos = null ; long svuid = 0 ; try { bos = new ByteArrayOutputStream ( ) ; dos = new DataOutputStream ( bos ) ; / * * 1 . The class name written using UTF encoding . * / dos . writeUTF ( name . replace ( ' / ' , ' . ' ) ) ; / * * 2 . The class modifiers written as a 32 - bit integer . * / dos . writeInt ( access & ( Opcodes . ACC_PUBLIC | Opcodes . ACC_FINAL | Opcodes . ACC_INTERFACE | Opcodes . ACC_ABSTRACT ) ) ; / * * 3 . The name of each interface sorted by name written using UTF * encoding . * / Arrays . sort ( interfaces ) ; for ( int i = 0 ; i < interfaces . length ; i + + ) { dos . writeUTF ( interfaces [ i ] . replace ( ' / ' , ' . ' ) ) ; } / * * 4 . For each field of the class sorted by field name ( except * and fields ) : * * 1 . The name of the field in UTF encoding . 2 . The modifiers of the * field written as a 32 - bit integer . 3 . The descriptor of the field * in UTF encoding * * Note that field signatures are not dot separated . Method and * constructor signatures are dot separated . Go figure . . . * / writeItems ( svuidFields , dos , false ) ; / * * 5 . If a class initializer exists , write out the following : 1 . The * name of the method , < clinit > , in UTF encoding . 2 . The modifier of * the method , java . lang . reflect . Modifier . STATIC , written as a * 32 - bit integer . 3 . The descriptor of the method , ( ) V , in UTF * encoding . * / if ( hasStaticInitializer ) { dos . writeUTF ( " < clinit > " ) ; dos . writeInt ( Opcodes . ACC_STATIC ) ; dos . writeUTF ( " ( ) V" ) ; } / / if . . / * * 6 . For each non - constructor sorted by method name and * signature : 1 . The name of the method , < init > , in UTF encoding . 2 . * The modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidConstructors , dos , true ) ; / * * 7 . For each non - method sorted by method name and * signature : 1 . The name of the method in UTF encoding . 2 . The * modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidMethods , dos , true ) ; dos . flush ( ) ; / * * 8 . The SHA - 1 algorithm is executed on the stream of bytes * produced by DataOutputStream and produces five 32 - bit values * sha [ 0 . . 4 ] . * / byte [ ] hashBytes = computeSHAdigest ( bos . toByteArray ( ) ) ; / * * 9 . The hash value is assembled from the first and second 32 - bit * values of the SHA - 1 message digest . If the result of the message * digest , the five 32 - bit words H0 H1 H2 H3 H4 , is in an array of * five int values named sha , the hash value would be computed as * follows : * * long hash = ( ( sha [ 0 ] > > > 24 ) & 0xFF ) | ( ( sha [ 0 ] > > > 16 ) & 0xFF ) < < * 8 | ( ( sha [ 0 ] > > > 8 ) & 0xFF ) < < 16 | ( ( sha [ 0 ] > > > 0 ) & 0xFF ) < < * 24 | ( ( sha [ 1 ] > > > 24 ) & 0xFF ) < < 32 | ( ( sha [ 1 ] > > > 16 ) & 0xFF ) < < * 40 | ( ( sha [ 1 ] > > > 8 ) & 0xFF ) < < 48 | ( ( sha [ 1 ] > > > 0 ) & 0xFF ) < < * 56 ; * / for ( int i = Math . min ( hashBytes . length , 8 ) - 1 ; i > = 0 ; i - - ) { svuid = ( svuid < < 8 ) | ( hashBytes [ i ] & 0xFF ) ; } } finally { / / close the stream ( if open ) if ( dos ! = null ) { dos . close ( ) ; } } return svuid ; }
void test7 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 6 ) ; SerialVersionUIDAdder serialVersionUIDAdder0 = new SerialVersionUIDAdder ( ( ClassVisitor ) classWriter0 ) ; String [ ] stringArray0 = new String [ 1 ] ; stringArray0 [ 0 ] = "Innerlascs" ; serialVersionUIDAdder0 . visit ( 6 , 6 , "Innerlascs" , "Innerlascs" , "Innerlascs" , stringArray0 ) ; serialVersionUIDAdder0 . visitField ( 6 , "Innerlascs" , "Innerlascs" , "Innerlascs" , ( Object ) "Innerlascs" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long computeSVUID ( ) throws IOException { ByteArrayOutputStream bos ; DataOutputStream dos = null ; long svuid = 0 ; try { bos = new ByteArrayOutputStream ( ) ; dos = new DataOutputStream ( bos ) ; / * * 1 . The class name written using UTF encoding . * / dos . writeUTF ( name . replace ( ' / ' , ' . ' ) ) ; / * * 2 . The class modifiers written as a 32 - bit integer . * / dos . writeInt ( access & ( Opcodes . ACC_PUBLIC | Opcodes . ACC_FINAL | Opcodes . ACC_INTERFACE | Opcodes . ACC_ABSTRACT ) ) ; / * * 3 . The name of each interface sorted by name written using UTF * encoding . * / Arrays . sort ( interfaces ) ; for ( int i = 0 ; i < interfaces . length ; i + + ) { dos . writeUTF ( interfaces [ i ] . replace ( ' / ' , ' . ' ) ) ; } / * * 4 . For each field of the class sorted by field name ( except * and fields ) : * * 1 . The name of the field in UTF encoding . 2 . The modifiers of the * field written as a 32 - bit integer . 3 . The descriptor of the field * in UTF encoding * * Note that field signatures are not dot separated . Method and * constructor signatures are dot separated . Go figure . . . * / writeItems ( svuidFields , dos , false ) ; / * * 5 . If a class initializer exists , write out the following : 1 . The * name of the method , < clinit > , in UTF encoding . 2 . The modifier of * the method , java . lang . reflect . Modifier . STATIC , written as a * 32 - bit integer . 3 . The descriptor of the method , ( ) V , in UTF * encoding . * / if ( hasStaticInitializer ) { dos . writeUTF ( " < clinit > " ) ; dos . writeInt ( Opcodes . ACC_STATIC ) ; dos . writeUTF ( " ( ) V" ) ; } / / if . . / * * 6 . For each non - constructor sorted by method name and * signature : 1 . The name of the method , < init > , in UTF encoding . 2 . * The modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidConstructors , dos , true ) ; / * * 7 . For each non - method sorted by method name and * signature : 1 . The name of the method in UTF encoding . 2 . The * modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidMethods , dos , true ) ; dos . flush ( ) ; / * * 8 . The SHA - 1 algorithm is executed on the stream of bytes * produced by DataOutputStream and produces five 32 - bit values * sha [ 0 . . 4 ] . * / byte [ ] hashBytes = computeSHAdigest ( bos . toByteArray ( ) ) ; / * * 9 . The hash value is assembled from the first and second 32 - bit * values of the SHA - 1 message digest . If the result of the message * digest , the five 32 - bit words H0 H1 H2 H3 H4 , is in an array of * five int values named sha , the hash value would be computed as * follows : * * long hash = ( ( sha [ 0 ] > > > 24 ) & 0xFF ) | ( ( sha [ 0 ] > > > 16 ) & 0xFF ) < < * 8 | ( ( sha [ 0 ] > > > 8 ) & 0xFF ) < < 16 | ( ( sha [ 0 ] > > > 0 ) & 0xFF ) < < * 24 | ( ( sha [ 1 ] > > > 24 ) & 0xFF ) < < 32 | ( ( sha [ 1 ] > > > 16 ) & 0xFF ) < < * 40 | ( ( sha [ 1 ] > > > 8 ) & 0xFF ) < < 48 | ( ( sha [ 1 ] > > > 0 ) & 0xFF ) < < * 56 ; * / for ( int i = Math . min ( hashBytes . length , 8 ) - 1 ; i > = 0 ; i - - ) { svuid = ( svuid < < 8 ) | ( hashBytes [ i ] & 0xFF ) ; } } finally { / / close the stream ( if open ) if ( dos ! = null ) { dos . close ( ) ; } } return svuid ; }
void test9 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 14 ) ; SerialVersionUIDAdder serialVersionUIDAdder0 = new SerialVersionUIDAdder ( ( ClassVisitor ) classWriter0 ) ; String [ ] stringArray0 = new String [ 6 ] ; stringArray0 [ 0 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; stringArray0 [ 1 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; stringArray0 [ 2 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; stringArray0 [ 3 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; stringArray0 [ 4 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; stringArray0 [ 5 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; serialVersionUIDAdder0 . visit ( 14 , 14 , "k ? h`r > 6 [ WD ; Xtp ; j" , "k ? h`r > 6 [ WD ; Xtp ; j" , "k ? h`r > 6 [ WD ; Xtp ; j" , stringArray0 ) ; serialVersionUIDAdder0 . visitInnerClass ( " + & l : M" , " + & l : M" , " + & l : M" , 14 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long computeSVUID ( ) throws IOException { ByteArrayOutputStream bos ; DataOutputStream dos = null ; long svuid = 0 ; try { bos = new ByteArrayOutputStream ( ) ; dos = new DataOutputStream ( bos ) ; / * * 1 . The class name written using UTF encoding . * / dos . writeUTF ( name . replace ( ' / ' , ' . ' ) ) ; / * * 2 . The class modifiers written as a 32 - bit integer . * / dos . writeInt ( access & ( Opcodes . ACC_PUBLIC | Opcodes . ACC_FINAL | Opcodes . ACC_INTERFACE | Opcodes . ACC_ABSTRACT ) ) ; / * * 3 . The name of each interface sorted by name written using UTF * encoding . * / Arrays . sort ( interfaces ) ; for ( int i = 0 ; i < interfaces . length ; i + + ) { dos . writeUTF ( interfaces [ i ] . replace ( ' / ' , ' . ' ) ) ; } / * * 4 . For each field of the class sorted by field name ( except * and fields ) : * * 1 . The name of the field in UTF encoding . 2 . The modifiers of the * field written as a 32 - bit integer . 3 . The descriptor of the field * in UTF encoding * * Note that field signatures are not dot separated . Method and * constructor signatures are dot separated . Go figure . . . * / writeItems ( svuidFields , dos , false ) ; / * * 5 . If a class initializer exists , write out the following : 1 . The * name of the method , < clinit > , in UTF encoding . 2 . The modifier of * the method , java . lang . reflect . Modifier . STATIC , written as a * 32 - bit integer . 3 . The descriptor of the method , ( ) V , in UTF * encoding . * / if ( hasStaticInitializer ) { dos . writeUTF ( " < clinit > " ) ; dos . writeInt ( Opcodes . ACC_STATIC ) ; dos . writeUTF ( " ( ) V" ) ; } / / if . . / * * 6 . For each non - constructor sorted by method name and * signature : 1 . The name of the method , < init > , in UTF encoding . 2 . * The modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidConstructors , dos , true ) ; / * * 7 . For each non - method sorted by method name and * signature : 1 . The name of the method in UTF encoding . 2 . The * modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidMethods , dos , true ) ; dos . flush ( ) ; / * * 8 . The SHA - 1 algorithm is executed on the stream of bytes * produced by DataOutputStream and produces five 32 - bit values * sha [ 0 . . 4 ] . * / byte [ ] hashBytes = computeSHAdigest ( bos . toByteArray ( ) ) ; / * * 9 . The hash value is assembled from the first and second 32 - bit * values of the SHA - 1 message digest . If the result of the message * digest , the five 32 - bit words H0 H1 H2 H3 H4 , is in an array of * five int values named sha , the hash value would be computed as * follows : * * long hash = ( ( sha [ 0 ] > > > 24 ) & 0xFF ) | ( ( sha [ 0 ] > > > 16 ) & 0xFF ) < < * 8 | ( ( sha [ 0 ] > > > 8 ) & 0xFF ) < < 16 | ( ( sha [ 0 ] > > > 0 ) & 0xFF ) < < * 24 | ( ( sha [ 1 ] > > > 24 ) & 0xFF ) < < 32 | ( ( sha [ 1 ] > > > 16 ) & 0xFF ) < < * 40 | ( ( sha [ 1 ] > > > 8 ) & 0xFF ) < < 48 | ( ( sha [ 1 ] > > > 0 ) & 0xFF ) < < * 56 ; * / for ( int i = Math . min ( hashBytes . length , 8 ) - 1 ; i > = 0 ; i - - ) { svuid = ( svuid < < 8 ) | ( hashBytes [ i ] & 0xFF ) ; } } finally { / / close the stream ( if open ) if ( dos ! = null ) { dos . close ( ) ; } } return svuid ; }
void test10 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 6 ) ; SerialVersionUIDAdder serialVersionUIDAdder0 = new SerialVersionUIDAdder ( ( ClassVisitor ) classWriter0 ) ; String [ ] stringArray0 = new String [ 1 ] ; stringArray0 [ 0 ] = "Innerlascs" ; serialVersionUIDAdder0 . visit ( 6 , 6 , "Innerlascs" , "Innerlascs" , "Innerlascs" , stringArray0 ) ; serialVersionUIDAdder0 . visitInnerClass ( "Innerlascs" , "Innerlascs" , "Innerlascs" , 6 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long computeSVUID ( ) throws IOException { ByteArrayOutputStream bos ; DataOutputStream dos = null ; long svuid = 0 ; try { bos = new ByteArrayOutputStream ( ) ; dos = new DataOutputStream ( bos ) ; / * * 1 . The class name written using UTF encoding . * / dos . writeUTF ( name . replace ( ' / ' , ' . ' ) ) ; / * * 2 . The class modifiers written as a 32 - bit integer . * / dos . writeInt ( access & ( Opcodes . ACC_PUBLIC | Opcodes . ACC_FINAL | Opcodes . ACC_INTERFACE | Opcodes . ACC_ABSTRACT ) ) ; / * * 3 . The name of each interface sorted by name written using UTF * encoding . * / Arrays . sort ( interfaces ) ; for ( int i = 0 ; i < interfaces . length ; i + + ) { dos . writeUTF ( interfaces [ i ] . replace ( ' / ' , ' . ' ) ) ; } / * * 4 . For each field of the class sorted by field name ( except * and fields ) : * * 1 . The name of the field in UTF encoding . 2 . The modifiers of the * field written as a 32 - bit integer . 3 . The descriptor of the field * in UTF encoding * * Note that field signatures are not dot separated . Method and * constructor signatures are dot separated . Go figure . . . * / writeItems ( svuidFields , dos , false ) ; / * * 5 . If a class initializer exists , write out the following : 1 . The * name of the method , < clinit > , in UTF encoding . 2 . The modifier of * the method , java . lang . reflect . Modifier . STATIC , written as a * 32 - bit integer . 3 . The descriptor of the method , ( ) V , in UTF * encoding . * / if ( hasStaticInitializer ) { dos . writeUTF ( " < clinit > " ) ; dos . writeInt ( Opcodes . ACC_STATIC ) ; dos . writeUTF ( " ( ) V" ) ; } / / if . . / * * 6 . For each non - constructor sorted by method name and * signature : 1 . The name of the method , < init > , in UTF encoding . 2 . * The modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidConstructors , dos , true ) ; / * * 7 . For each non - method sorted by method name and * signature : 1 . The name of the method in UTF encoding . 2 . The * modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidMethods , dos , true ) ; dos . flush ( ) ; / * * 8 . The SHA - 1 algorithm is executed on the stream of bytes * produced by DataOutputStream and produces five 32 - bit values * sha [ 0 . . 4 ] . * / byte [ ] hashBytes = computeSHAdigest ( bos . toByteArray ( ) ) ; / * * 9 . The hash value is assembled from the first and second 32 - bit * values of the SHA - 1 message digest . If the result of the message * digest , the five 32 - bit words H0 H1 H2 H3 H4 , is in an array of * five int values named sha , the hash value would be computed as * follows : * * long hash = ( ( sha [ 0 ] > > > 24 ) & 0xFF ) | ( ( sha [ 0 ] > > > 16 ) & 0xFF ) < < * 8 | ( ( sha [ 0 ] > > > 8 ) & 0xFF ) < < 16 | ( ( sha [ 0 ] > > > 0 ) & 0xFF ) < < * 24 | ( ( sha [ 1 ] > > > 24 ) & 0xFF ) < < 32 | ( ( sha [ 1 ] > > > 16 ) & 0xFF ) < < * 40 | ( ( sha [ 1 ] > > > 8 ) & 0xFF ) < < 48 | ( ( sha [ 1 ] > > > 0 ) & 0xFF ) < < * 56 ; * / for ( int i = Math . min ( hashBytes . length , 8 ) - 1 ; i > = 0 ; i - - ) { svuid = ( svuid < < 8 ) | ( hashBytes [ i ] & 0xFF ) ; } } finally { / / close the stream ( if open ) if ( dos ! = null ) { dos . close ( ) ; } } return svuid ; }
void test12 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 14 ) ; SerialVersionUIDAdder serialVersionUIDAdder0 = new SerialVersionUIDAdder ( ( ClassVisitor ) classWriter0 ) ; String [ ] stringArray0 = new String [ 6 ] ; stringArray0 [ 0 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; stringArray0 [ 1 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; stringArray0 [ 2 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; stringArray0 [ 3 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; stringArray0 [ 4 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; stringArray0 [ 5 ] = "k ? h`r > 6 [ WD ; Xtp ; j" ; serialVersionUIDAdder0 . visit ( 14 , 14 , "k ? h`r > 6 [ WD ; Xtp ; j" , "k ? h`r > 6 [ WD ; Xtp ; j" , "k ? h`r > 6 [ WD ; Xtp ; j" , stringArray0 ) ; serialVersionUIDAdder0 . visitEnd ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long computeSVUID ( ) throws IOException { ByteArrayOutputStream bos ; DataOutputStream dos = null ; long svuid = 0 ; try { bos = new ByteArrayOutputStream ( ) ; dos = new DataOutputStream ( bos ) ; / * * 1 . The class name written using UTF encoding . * / dos . writeUTF ( name . replace ( ' / ' , ' . ' ) ) ; / * * 2 . The class modifiers written as a 32 - bit integer . * / dos . writeInt ( access & ( Opcodes . ACC_PUBLIC | Opcodes . ACC_FINAL | Opcodes . ACC_INTERFACE | Opcodes . ACC_ABSTRACT ) ) ; / * * 3 . The name of each interface sorted by name written using UTF * encoding . * / Arrays . sort ( interfaces ) ; for ( int i = 0 ; i < interfaces . length ; i + + ) { dos . writeUTF ( interfaces [ i ] . replace ( ' / ' , ' . ' ) ) ; } / * * 4 . For each field of the class sorted by field name ( except * and fields ) : * * 1 . The name of the field in UTF encoding . 2 . The modifiers of the * field written as a 32 - bit integer . 3 . The descriptor of the field * in UTF encoding * * Note that field signatures are not dot separated . Method and * constructor signatures are dot separated . Go figure . . . * / writeItems ( svuidFields , dos , false ) ; / * * 5 . If a class initializer exists , write out the following : 1 . The * name of the method , < clinit > , in UTF encoding . 2 . The modifier of * the method , java . lang . reflect . Modifier . STATIC , written as a * 32 - bit integer . 3 . The descriptor of the method , ( ) V , in UTF * encoding . * / if ( hasStaticInitializer ) { dos . writeUTF ( " < clinit > " ) ; dos . writeInt ( Opcodes . ACC_STATIC ) ; dos . writeUTF ( " ( ) V" ) ; } / / if . . / * * 6 . For each non - constructor sorted by method name and * signature : 1 . The name of the method , < init > , in UTF encoding . 2 . * The modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidConstructors , dos , true ) ; / * * 7 . For each non - method sorted by method name and * signature : 1 . The name of the method in UTF encoding . 2 . The * modifiers of the method written as a 32 - bit integer . 3 . The * descriptor of the method in UTF encoding . * / writeItems ( svuidMethods , dos , true ) ; dos . flush ( ) ; / * * 8 . The SHA - 1 algorithm is executed on the stream of bytes * produced by DataOutputStream and produces five 32 - bit values * sha [ 0 . . 4 ] . * / byte [ ] hashBytes = computeSHAdigest ( bos . toByteArray ( ) ) ; / * * 9 . The hash value is assembled from the first and second 32 - bit * values of the SHA - 1 message digest . If the result of the message * digest , the five 32 - bit words H0 H1 H2 H3 H4 , is in an array of * five int values named sha , the hash value would be computed as * follows : * * long hash = ( ( sha [ 0 ] > > > 24 ) & 0xFF ) | ( ( sha [ 0 ] > > > 16 ) & 0xFF ) < < * 8 | ( ( sha [ 0 ] > > > 8 ) & 0xFF ) < < 16 | ( ( sha [ 0 ] > > > 0 ) & 0xFF ) < < * 24 | ( ( sha [ 1 ] > > > 24 ) & 0xFF ) < < 32 | ( ( sha [ 1 ] > > > 16 ) & 0xFF ) < < * 40 | ( ( sha [ 1 ] > > > 8 ) & 0xFF ) < < 48 | ( ( sha [ 1 ] > > > 0 ) & 0xFF ) < < * 56 ; * / for ( int i = Math . min ( hashBytes . length , 8 ) - 1 ; i > = 0 ; i - - ) { svuid = ( svuid < < 8 ) | ( hashBytes [ i ] & 0xFF ) ; } } finally { / / close the stream ( if open ) if ( dos ! = null ) { dos . close ( ) ; } } return svuid ; }
void test14 ( ) throws Throwable { SerialVersionUIDAdder . Item serialVersionUIDAdder_Item0 = new SerialVersionUIDAdder . Item ( "pM ( " , 32767 , "pM ( " ) ; SerialVersionUIDAdder . Item serialVersionUIDAdder_Item1 = new SerialVersionUIDAdder . Item ( "" , 32767 , "" ) ; int int0 = serialVersionUIDAdder_Item0 . compareTo ( ( Object ) serialVersionUIDAdder_Item1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SerialVersionUIDAdder ( ClassVisitor cv ) { super ( cv ) ; svuidFields = new ArrayList ( ) ; svuidConstructors = new ArrayList ( ) ; svuidMethods = new ArrayList ( ) ; }
void test15 ( ) throws Throwable { SerialVersionUIDAdder . Item serialVersionUIDAdder_Item0 = new SerialVersionUIDAdder . Item ( "pM ( " , 32767 , "pM ( " ) ; int int0 = serialVersionUIDAdder_Item0 . compareTo ( ( Object ) serialVersionUIDAdder_Item0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SerialVersionUIDAdder ( ClassVisitor cv ) { super ( cv ) ; svuidFields = new ArrayList ( ) ; svuidConstructors = new ArrayList ( ) ; svuidMethods = new ArrayList ( ) ; }
void test1 ( ) throws Throwable { LocalVariablesSorter localVariablesSorter0 = new LocalVariablesSorter ( ( - 510 ) , "# ) sy_9BLkb" , ( MethodVisitor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void visitLocalVariable ( String name , String desc , String signature , Label start , Label end , int index ) { if ( signature ! = null ) { if ( localVarType = = null ) { localVarType = new ByteVector ( ) ; } + + localVarTypeCount ; localVarType . putShort ( start . position ) . putShort ( end . position - start . position ) . putShort ( cw . newUTF8 ( name ) ) . putShort ( cw . newUTF8 ( signature ) ) . putShort ( index ) ; } if ( localVar = = null ) { localVar = new ByteVector ( ) ; } + + localVarCount ; localVar . putShort ( start . position ) . putShort ( end . position - start . position ) . putShort ( cw . newUTF8 ( name ) ) . putShort ( cw . newUTF8 ( desc ) ) . putShort ( index ) ; if ( compute ! = NOTHING ) { / / updates max locals char c = desc . charAt ( 0 ) ; int n = index + ( c = = 'J' | | c = = 'D' ? 2 : 1 ) ; if ( n > maxLocals ) { maxLocals = n ; } } }
void test7 ( ) throws Throwable { LocalVariablesSorter localVariablesSorter0 = new LocalVariablesSorter ( ( - 510 ) , "# ) sy_9BLkb" , ( MethodVisitor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newLocal ( Type type ) { Object t ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : case Type . CHAR : case Type . BYTE : case Type . SHORT : case Type . INT : t = Opcodes . INTEGER ; break ; case Type . FLOAT : t = Opcodes . FLOAT ; break ; case Type . LONG : t = Opcodes . LONG ; break ; case Type . DOUBLE : t = Opcodes . DOUBLE ; break ; case Type . ARRAY : t = type . getDescriptor ( ) ; break ; / / case Type . OBJECT : default : t = type . getInternalName ( ) ; break ; } int local = nextLocal ; nextLocal + = type . getSize ( ) ; setLocalType ( local , type ) ; setFrameLocal ( local , t ) ; return local ; }
void test8 ( ) throws Throwable { LocalVariablesSorter localVariablesSorter0 = new LocalVariablesSorter ( ( - 510 ) , "# ) sy_9BLkb" , ( MethodVisitor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newLocal ( Type type ) { Object t ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : case Type . CHAR : case Type . BYTE : case Type . SHORT : case Type . INT : t = Opcodes . INTEGER ; break ; case Type . FLOAT : t = Opcodes . FLOAT ; break ; case Type . LONG : t = Opcodes . LONG ; break ; case Type . DOUBLE : t = Opcodes . DOUBLE ; break ; case Type . ARRAY : t = type . getDescriptor ( ) ; break ; / / case Type . OBJECT : default : t = type . getInternalName ( ) ; break ; } int local = nextLocal ; nextLocal + = type . getSize ( ) ; setLocalType ( local , type ) ; setFrameLocal ( local , t ) ; return local ; }
void test9 ( ) throws Throwable { LocalVariablesSorter localVariablesSorter0 = new LocalVariablesSorter ( 1568 , "# ) sy_9BLkb" , ( MethodVisitor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newLocal ( Type type ) { Object t ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : case Type . CHAR : case Type . BYTE : case Type . SHORT : case Type . INT : t = Opcodes . INTEGER ; break ; case Type . FLOAT : t = Opcodes . FLOAT ; break ; case Type . LONG : t = Opcodes . LONG ; break ; case Type . DOUBLE : t = Opcodes . DOUBLE ; break ; case Type . ARRAY : t = type . getDescriptor ( ) ; break ; / / case Type . OBJECT : default : t = type . getInternalName ( ) ; break ; } int local = nextLocal ; nextLocal + = type . getSize ( ) ; setLocalType ( local , type ) ; setFrameLocal ( local , t ) ; return local ; }
void test10 ( ) throws Throwable { LocalVariablesSorter localVariablesSorter0 = new LocalVariablesSorter ( ( - 8 ) , "c ) `kHY@h0e3wHxCc ] x" , ( MethodVisitor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newLocal ( Type type ) { Object t ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : case Type . CHAR : case Type . BYTE : case Type . SHORT : case Type . INT : t = Opcodes . INTEGER ; break ; case Type . FLOAT : t = Opcodes . FLOAT ; break ; case Type . LONG : t = Opcodes . LONG ; break ; case Type . DOUBLE : t = Opcodes . DOUBLE ; break ; case Type . ARRAY : t = type . getDescriptor ( ) ; break ; / / case Type . OBJECT : default : t = type . getInternalName ( ) ; break ; } int local = nextLocal ; nextLocal + = type . getSize ( ) ; setLocalType ( local , type ) ; setFrameLocal ( local , t ) ; return local ; }
void test11 ( ) throws Throwable { LocalVariablesSorter localVariablesSorter0 = new LocalVariablesSorter ( 1568 , "# ) sy_9BLkb" , ( MethodVisitor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newLocal ( Type type ) { Object t ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : case Type . CHAR : case Type . BYTE : case Type . SHORT : case Type . INT : t = Opcodes . INTEGER ; break ; case Type . FLOAT : t = Opcodes . FLOAT ; break ; case Type . LONG : t = Opcodes . LONG ; break ; case Type . DOUBLE : t = Opcodes . DOUBLE ; break ; case Type . ARRAY : t = type . getDescriptor ( ) ; break ; / / case Type . OBJECT : default : t = type . getInternalName ( ) ; break ; } int local = nextLocal ; nextLocal + = type . getSize ( ) ; setLocalType ( local , type ) ; setFrameLocal ( local , t ) ; return local ; }
void test12 ( ) throws Throwable { Type type0 = Type . FLOAT_TYPE ; LocalVariablesSorter localVariablesSorter0 = new LocalVariablesSorter ( 145 , "# ) sy_9BLvb" , ( MethodVisitor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newLocal ( Type type ) { Object t ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : case Type . CHAR : case Type . BYTE : case Type . SHORT : case Type . INT : t = Opcodes . INTEGER ; break ; case Type . FLOAT : t = Opcodes . FLOAT ; break ; case Type . LONG : t = Opcodes . LONG ; break ; case Type . DOUBLE : t = Opcodes . DOUBLE ; break ; case Type . ARRAY : t = type . getDescriptor ( ) ; break ; / / case Type . OBJECT : default : t = type . getInternalName ( ) ; break ; } int local = nextLocal ; nextLocal + = type . getSize ( ) ; setLocalType ( local , type ) ; setFrameLocal ( local , t ) ; return local ; }
void test13 ( ) throws Throwable { LocalVariablesSorter localVariablesSorter0 = new LocalVariablesSorter ( 102 , "# ) sy_\b" , ( MethodVisitor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newLocal ( Type type ) { Object t ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : case Type . CHAR : case Type . BYTE : case Type . SHORT : case Type . INT : t = Opcodes . INTEGER ; break ; case Type . FLOAT : t = Opcodes . FLOAT ; break ; case Type . LONG : t = Opcodes . LONG ; break ; case Type . DOUBLE : t = Opcodes . DOUBLE ; break ; case Type . ARRAY : t = type . getDescriptor ( ) ; break ; / / case Type . OBJECT : default : t = type . getInternalName ( ) ; break ; } int local = nextLocal ; nextLocal + = type . getSize ( ) ; setLocalType ( local , type ) ; setFrameLocal ( local , t ) ; return local ; }
void test14 ( ) throws Throwable { LocalVariablesSorter localVariablesSorter0 = new LocalVariablesSorter ( 350 , "# ) sy_9BL0b" , ( MethodVisitor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newLocal ( Type type ) { Object t ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : case Type . CHAR : case Type . BYTE : case Type . SHORT : case Type . INT : t = Opcodes . INTEGER ; break ; case Type . FLOAT : t = Opcodes . FLOAT ; break ; case Type . LONG : t = Opcodes . LONG ; break ; case Type . DOUBLE : t = Opcodes . DOUBLE ; break ; case Type . ARRAY : t = type . getDescriptor ( ) ; break ; / / case Type . OBJECT : default : t = type . getInternalName ( ) ; break ; } int local = nextLocal ; nextLocal + = type . getSize ( ) ; setLocalType ( local , type ) ; setFrameLocal ( local , t ) ; return local ; }
void test15 ( ) throws Throwable { LocalVariablesSorter localVariablesSorter0 = new LocalVariablesSorter ( 1052 , "# ) #y_9\u0000BLkb" , ( MethodVisitor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int newLocal ( Type type ) { Object t ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : case Type . CHAR : case Type . BYTE : case Type . SHORT : case Type . INT : t = Opcodes . INTEGER ; break ; case Type . FLOAT : t = Opcodes . FLOAT ; break ; case Type . LONG : t = Opcodes . LONG ; break ; case Type . DOUBLE : t = Opcodes . DOUBLE ; break ; case Type . ARRAY : t = type . getDescriptor ( ) ; break ; / / case Type . OBJECT : default : t = type . getInternalName ( ) ; break ; } int local = nextLocal ; nextLocal + = type . getSize ( ) ; setLocalType ( local , type ) ; setFrameLocal ( local , t ) ; return local ; }
void test1 ( ) throws Throwable { ClassWriter classWriter0 = new ClassWriter ( 0 ) ; StaticInitMerger staticInitMerger0 = new StaticInitMerger ( " < clinit > " , ( ClassVisitor ) classWriter0 ) ; String [ ] stringArray0 = new String [ 3 ] ; stringArray0 [ 0 ] = " < clinit > " ; stringArray0 [ 1 ] = " < clinit > " ; stringArray0 [ 2 ] = " < clinit > " ; staticInitMerger0 . visit ( 0 , 1 , " < clinit > " , " < clinit > " , " < clinit > " , stringArray0 ) ; MethodVisitor methodVisitor0 = staticInitMerger0 . visitMethod ( ( - 1044 ) , " < clinit > " , " < clinit > " , " < clinit > " , stringArray0 ) ; MethodVisitor methodVisitor1 = staticInitMerger0 . visitMethod ( 0 , " < clinit > " , " < clinit > " , " < clinit > " , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" MethodVisitor visitMethod ( int arg , String name , String descriptor , String signature , String [ ] exceptions ) { MethodVisitor mv = super . visitMethod ( arg , name , descriptor , signature , exceptions ) ; if ( Controller . _outputMethodSignatures & & descriptor ! = null ) { return new PerfMethodAdapter ( mv , className , name + descriptor ) ; } else { return new PerfMethodAdapter ( mv , className , name ) ; } }
void test11 ( ) throws Throwable { Type type0 = Type . getObjectType ( "Et ! | + c" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = type0 ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( "Et ! | + c" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( ( - 836 ) , method0 , "Et ! | + c" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; Type type1 = Type . LONG_TYPE ; generatorAdapter0 . swap ( type1 , typeArray0 [ 4 ] ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDescriptor ( ) { StringBuffer buf = new StringBuffer ( ) ; getDescriptor ( buf ) ; return buf . toString ( ) ; }
void test12 ( ) throws Throwable { Type type0 = Type . getObjectType ( " ? tu ! 5r8" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = typeArray0 [ 1 ] ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( " ? tu ! 5r8" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( 88 , method0 , " ? tu ! 5r8" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test13 ( ) throws Throwable { Type type0 = Type . getObjectType ( " ? tu ! 5r8" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = typeArray0 [ 1 ] ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( " ? tu ! 5r8" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( 88 , method0 , " ? tu ! 5r8" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; generatorAdapter0 . invokeStatic ( typeArray0 [ 4 ] , method0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) { return name ; }
void test16 ( ) throws Throwable { Type type0 = Type . getObjectType ( "VOo9a4 & $ ( " ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = typeArray0 [ 1 ] ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = typeArray0 [ 1 ] ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( "VOo9a4 & $ ( " , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( ( - 836 ) , method0 , "VOo9a4 & $ ( " , typeArray0 , ( ClassVisitor ) classWriter0 ) ; generatorAdapter0 . invokeVirtual ( typeArray0 [ 1 ] , method0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test22 ( ) throws Throwable { Type type0 = Type . getObjectType ( "Et ! | + c" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = type0 ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( "Et ! | + c" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( ( - 836 ) , method0 , "Et ! | + c" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test25 ( ) throws Throwable { Type type0 = Type . getObjectType ( " ? tu ! 5r8" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = typeArray0 [ 1 ] ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( " ? tu ! 5r8" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( 88 , method0 , " ? tu ! 5r8" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test27 ( ) throws Throwable { Type type0 = Type . getObjectType ( "Et ! | + c" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = type0 ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( "Et ! | + c" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( ( - 836 ) , method0 , "Et ! | + c" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; generatorAdapter0 . invokeInterface ( typeArray0 [ 1 ] , method0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test28 ( ) throws Throwable { Type type0 = Type . getObjectType ( "Et ! | + c" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = type0 ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( "Et ! | + c" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( ( - 836 ) , method0 , "Et ! | + c" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; generatorAdapter0 . invokeDynamic ( method0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test29 ( ) throws Throwable { Type type0 = Type . getObjectType ( "Et ! | + c" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = type0 ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( "Et ! | + c" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( ( - 836 ) , method0 , "Et ! | + c" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test45 ( ) throws Throwable { Type type0 = Type . getObjectType ( " ? tu ! 5r8" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = typeArray0 [ 1 ] ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( " ? tu ! 5r8" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( 88 , method0 , " ? tu ! 5r8" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; generatorAdapter0 . push ( type0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { int size = 0 ; ( itemsList ) { size = itemsList . size ( ) ; } return size ; }
void test49 ( ) throws Throwable { Type type0 = Type . getObjectType ( "Et ! | + c" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = type0 ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( "Et ! | + c" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( ( - 836 ) , method0 , "Et ! | + c" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; generatorAdapter0 . cast ( type0 , typeArray0 [ 2 ] ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return _className ; }
void test51 ( ) throws Throwable { Type type0 = Type . getObjectType ( "Et ! | + c" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = type0 ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( "Et ! | + c" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( ( - 836 ) , method0 , "Et ! | + c" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; Type type1 = Type . VOID_TYPE ; generatorAdapter0 . unbox ( type1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object other ) { assert other instanceof Method ; Method m = ( Method ) other ; return this . _className . equals ( m . _className ) & & this . _methodName . equals ( m . _methodName ) ; }
void test53 ( ) throws Throwable { Type type0 = Type . getObjectType ( "Et ! | + c" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = type0 ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( "Et ! | + c" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( ( - 836 ) , method0 , "Et ! | + c" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void ifCmp ( Type type , int mode , Label label ) { switch ( type . getSort ( ) ) { case Type . LONG : mv . visitInsn ( Opcodes . LCMP ) ; break ; case Type . DOUBLE : mv . visitInsn ( mode = = GE | | mode = = GT ? Opcodes . DCMPG : Opcodes . DCMPL ) ; break ; case Type . FLOAT : mv . visitInsn ( mode = = GE | | mode = = GT ? Opcodes . FCMPG : Opcodes . FCMPL ) ; break ; case Type . ARRAY : case Type . OBJECT : switch ( mode ) { case EQ : mv . visitJumpInsn ( Opcodes . IF_ACMPEQ , label ) ; return ; case NE : mv . visitJumpInsn ( Opcodes . IF_ACMPNE , label ) ; return ; } throw new IllegalArgumentException ( "Bad comparison for type " + type ) ; default : int intOp = - 1 ; switch ( mode ) { case EQ : intOp = Opcodes . IF_ICMPEQ ; break ; case NE : intOp = Opcodes . IF_ICMPNE ; break ; case GE : intOp = Opcodes . IF_ICMPGE ; break ; case LT : intOp = Opcodes . IF_ICMPLT ; break ; case LE : intOp = Opcodes . IF_ICMPLE ; break ; case GT : intOp = Opcodes . IF_ICMPGT ; break ; } mv . visitJumpInsn ( intOp , label ) ; return ; } mv . visitJumpInsn ( mode , label ) ; }
void test57 ( ) throws Throwable { Type type0 = Type . getObjectType ( "Et ! | + c" ) ; Type [ ] typeArray0 = new Type [ 6 ] ; typeArray0 [ 0 ] = type0 ; typeArray0 [ 1 ] = type0 ; typeArray0 [ 2 ] = type0 ; typeArray0 [ 3 ] = type0 ; typeArray0 [ 4 ] = type0 ; typeArray0 [ 5 ] = type0 ; Method method0 = new Method ( "Et ! | + c" , type0 , typeArray0 ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 836 ) ) ; GeneratorAdapter generatorAdapter0 = new GeneratorAdapter ( ( - 836 ) , method0 , "Et ! | + c" , typeArray0 , ( ClassVisitor ) classWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test0 ( ) throws Throwable { StackMapAttribute stackMapAttribute0 = new StackMapAttribute ( ) ; List < Object > list0 = stackMapAttribute0 . getFrames ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List getFrames ( ) { return frames ; }
void test3 ( ) throws Throwable { StackMapAttribute stackMapAttribute0 = new StackMapAttribute ( ) ; boolean boolean0 = stackMapAttribute0 . isCodeAttribute ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCodeAttribute ( ) { return false ; }
void test5 ( ) throws Throwable { StackMapAttribute stackMapAttribute0 = new StackMapAttribute ( ) ; boolean boolean0 = stackMapAttribute0 . isUnknown ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUnknown ( ) { return true ; }
void test6 ( ) throws Throwable { StackMapAttribute stackMapAttribute0 = new StackMapAttribute ( ) ; Label label0 = new Label ( ) ; stackMapAttribute0 . getFrame ( label0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test7 ( ) throws Throwable { StackMapAttribute stackMapAttribute0 = new StackMapAttribute ( ) ; Label [ ] labelArray0 = stackMapAttribute0 . getLabels ( ) ; byte [ ] byteArray0 = new byte [ 36 ] ; ClassReader classReader0 = new ClassReader ( byteArray0 ) ; char [ ] charArray0 = new char [ 7 ] ; byteArray0 [ 31 ] = ( byte ) 1 ; StackMapAttribute stackMapAttribute1 = ( StackMapAttribute ) stackMapAttribute0 . read ( classReader0 , ( int ) ( byte ) 1 , 1 , charArray0 , ( int ) ( byte ) 27 , labelArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test10 ( ) throws Throwable { StackMapAttribute stackMapAttribute0 = new StackMapAttribute ( ) ; ClassWriter classWriter0 = new ClassWriter ( ( - 11 ) ) ; ByteVector byteVector0 = stackMapAttribute0 . write ( classWriter0 , ( byte [ ] ) null , ( - 370 ) , ( - 377 ) , ( int ) '\u0000' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ByteVector write ( ClassWriter cw , byte [ ] code , int len , int maxStack , int maxLocals ) { ByteVector v = new ByteVector ( ) ; v . data = value ; v . length = value . length ; return v ; }
void test11 ( ) throws Throwable { LinkedList < String > linkedList0 = new LinkedList < String > ( ) ; linkedList0 . add ( ( String ) null ) ; StackMapAttribute stackMapAttribute0 = new StackMapAttribute ( ( List ) linkedList0 ) ; String string0 = stackMapAttribute0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test0 ( ) throws Throwable { StackMapType stackMapType0 = StackMapType . getTypeInfo ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Type getType ( String typeDescriptor ) { return getType ( typeDescriptor . toCharArray ( ) , 0 ) ; }
void test1 ( ) throws Throwable { StackMapType stackMapType0 = StackMapType . getTypeInfo ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test2 ( ) throws Throwable { StackMapType stackMapType0 = StackMapType . getTypeInfo ( 8 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Type getType ( String typeDescriptor ) { return getType ( typeDescriptor . toCharArray ( ) , 0 ) ; }
void test3 ( ) throws Throwable { StackMapType stackMapType0 = StackMapType . getTypeInfo ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Type getType ( String typeDescriptor ) { return getType ( typeDescriptor . toCharArray ( ) , 0 ) ; }
void test4 ( ) throws Throwable { StackMapType stackMapType0 = StackMapType . getTypeInfo ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Type getType ( String typeDescriptor ) { return getType ( typeDescriptor . toCharArray ( ) , 0 ) ; }
void test7 ( ) throws Throwable { StackMapType stackMapType0 = StackMapType . getTypeInfo ( 8 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test8 ( ) throws Throwable { StackMapType stackMapType0 = StackMapType . getTypeInfo ( 7 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
void test0 ( ) throws Throwable { Label label0 = new Label ( ) ; LinkedList < Object > linkedList0 = new LinkedList < Object > ( ) ; StackMapFrame stackMapFrame0 = new StackMapFrame ( label0 , ( List ) linkedList0 , ( List ) linkedList0 ) ; String string0 = stackMapFrame0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "path = " ) . append ( path ) ; buf . append ( " name = " ) . append ( name ) ; buf . append ( " port = " ) . append ( port ) ; buf . append ( " host = " ) . append ( host ) ; return buf . toString ( ) ; }
