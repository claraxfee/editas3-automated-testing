void test0 ( ) throws Throwable { Arbiter arbiter0 = new Arbiter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { LocalConsoleUserInterface localConsoleUserInterface0 = new LocalConsoleUserInterface ( ) ; CardCollection cardCollection0 = new CardCollection ( ) ; Player player0 = new Player ( ( UserInterface ) localConsoleUserInterface0 , " ) B78q" , cardCollection0 ) ; player0 . hand . add ( ( Card ) null ) ; ArrayList < Decision > arrayList0 = Arbiter . getLegalPlayerDecisions ( player0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ArrayList < Decision > getLegalPlayerDecisions ( Player p ) { / / build the object ArrayList < Decision > decisions = new ArrayList < Decision > ( ) ; / / add the default action decisions . add ( new PassDecision ( ) ) ; / / TODO activated abilities / / TODO combat / / add the cards in hand for ( Card c : p . hand ) { / / TODO : switch according to type , and create decisions accordingly Spell s = new Spell ( c ) ; decisions . add ( s ) ; } / / parse the decisions according to isLegal for ( Decision d : decisions ) { if ( ! isLegal ( d , p ) ) { decisions . remove ( d ) ; } } return decisions ; }
void test0 ( ) throws Throwable { Combat combat0 = new Combat ( ( Player ) null , ( Player ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Combat ( Player AP , Player DP ) { / / init players attackingPlayer = AP ; defendingPlayer = DP ; }
void test0 ( ) throws Throwable { CardCollection cardCollection0 = new CardCollection ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { Mana mana0 = new Mana ( " { ( 4 ; DcmQG + lf } jl" ) ; Mana . Color mana_Color0 = Mana . Color . COLORLESS ; boolean boolean0 = mana0 . containsColor ( mana_Color0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean containsColor ( Color c ) { return getColorCost ( c ) ! = 0 ; }
void test1 ( ) throws Throwable { Mana mana0 = new Mana ( ( - 1485 ) , ( - 1485 ) , ( - 1485 ) , ( - 1485 ) , ( - 1485 ) , ( - 1485 ) ) ; boolean boolean0 = mana0 . canPay ( mana0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPay ( Mana m ) { int colorlessTotal = 0 ; int diff ; for ( Color c : Color . values ( ) ) { diff = this . getColorCost ( c ) - m . getColorCost ( c ) ; if ( c ! = Color . COLORLESS & & diff > = 0 ) return false ; colorlessTotal + = diff ; } if ( colorlessTotal + this . getColorCost ( Color . COLORLESS ) < m . getColorCost ( Color . COLORLESS ) ) return false ; return true ; }
void test2 ( ) throws Throwable { Mana mana0 = new Mana ( ( - 1485 ) , ( - 1485 ) , ( - 1485 ) , ( - 1485 ) , ( - 1485 ) , ( - 1485 ) ) ; Mana . Color mana_Color0 = Mana . Color . COLORLESS ; boolean boolean0 = mana0 . containsColor ( mana_Color0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean containsColor ( Color c ) { return getColorCost ( c ) ! = 0 ; }
void test3 ( ) throws Throwable { Mana mana0 = new Mana ( ( - 1485 ) , ( - 1485 ) , ( - 1485 ) , ( - 1485 ) , ( - 1485 ) , ( - 1485 ) ) ; Mana mana1 = new Mana ( " { ( 4 ; DcmQG + lf } jl" ) ; boolean boolean0 = mana0 . canPay ( mana1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPay ( Mana m ) { int colorlessTotal = 0 ; int diff ; for ( Color c : Color . values ( ) ) { diff = this . getColorCost ( c ) - m . getColorCost ( c ) ; if ( c ! = Color . COLORLESS & & diff > = 0 ) return false ; colorlessTotal + = diff ; } if ( colorlessTotal + this . getColorCost ( Color . COLORLESS ) < m . getColorCost ( Color . COLORLESS ) ) return false ; return true ; }
void test4 ( ) throws Throwable { Mana mana0 = new Mana ( ( - 23 ) , ( - 23 ) , ( - 23 ) , ( - 23 ) , ( - 23 ) , 919 ) ; Mana mana1 = new Mana ( "3T" ) ; boolean boolean0 = mana0 . canPay ( mana1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPay ( Mana m ) { int colorlessTotal = 0 ; int diff ; for ( Color c : Color . values ( ) ) { diff = this . getColorCost ( c ) - m . getColorCost ( c ) ; if ( c ! = Color . COLORLESS & & diff > = 0 ) return false ; colorlessTotal + = diff ; } if ( colorlessTotal + this . getColorCost ( Color . COLORLESS ) < m . getColorCost ( Color . COLORLESS ) ) return false ; return true ; }
void test0 ( ) throws Throwable { Player player0 = Game . getNonPlayingPlayer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Player getNonPlayingPlayer ( ) { return getOtherPlayer ( getPlayingPlayer ( ) ) ; }
void test1 ( ) throws Throwable { Player player0 = Game . getOtherPlayer ( ( Player ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Player getOtherPlayer ( Player p ) { if ( p = = player1 ) return player2 ; else return player1 ; }
void test0 ( ) throws Throwable { LocalConsoleUserInterface localConsoleUserInterface0 = new LocalConsoleUserInterface ( ) ; Player player0 = new Player ( ( UserInterface ) localConsoleUserInterface0 , " [ HRe" , ( CardCollection ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Player ( UserInterface in , String name , CardCollection deck ) { this . name = name ; input = in ; library = deck ; hand = new CardCollection ( ) ; graveyard = new CardCollection ( ) ; removedFromPlay = new CardCollection ( ) ; inPlay = new CardCollection ( ) ; }
void test0 ( ) throws Throwable { MultiCost multiCost0 = new MultiCost ( ) ; MultiCost multiCost1 = new MultiCost ( ) ; multiCost0 . addCost ( ( Cost ) multiCost1 ) ; boolean boolean0 = multiCost0 . isPayable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPayable ( ) ; void payCost ( ) ; }
void test1 ( ) throws Throwable { MultiCost multiCost0 = new MultiCost ( ) ; multiCost0 . payCost ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPayable ( ) ; void payCost ( ) ; }
void test0 ( ) throws Throwable { BasicLand basicLand0 = new BasicLand ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { Instant instant0 = new Instant ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { Instant instant0 = new Instant ( ) ; Spell spell0 = new Spell ( ( Card ) instant0 ) ; Effect effect0 = spell0 . createEffect ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Effect createEffect ( ) { / / TODO damage return null ; }
void test0 ( ) throws Throwable { Stack stack0 = new Stack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { CombatDamage combatDamage0 = new CombatDamage ( ) ; combatDamage0 . addToStack ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addToStack ( ) { Game . stack . add ( this ) ; / / TODO : other types if ( this instanceof Spell ) ( ( Spell ) this ) . card . isInStack = true ; }
void test0 ( ) throws Throwable { UntapPhase untapPhase0 = new UntapPhase ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { DeclareAttackersPhase declareAttackersPhase0 = new DeclareAttackersPhase ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { DeclareBlockersPhase declareBlockersPhase0 = new DeclareBlockersPhase ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { DeclareAttackersPhase declareAttackersPhase0 = new DeclareAttackersPhase ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
