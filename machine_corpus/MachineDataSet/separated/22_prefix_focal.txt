void test0 ( ) throws Throwable { YUICompressor yUICompressor0 = new YUICompressor ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { ScriptOrFnScope scriptOrFnScope0 = new ScriptOrFnScope ( ( - 1159 ) , ( ScriptOrFnScope ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int incrementVarCount ( ) { varcount + + ; return varcount ; }
void test1 ( ) throws Throwable { ScriptOrFnScope scriptOrFnScope0 = new ScriptOrFnScope ( 283 , ( ScriptOrFnScope ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int incrementVarCount ( ) { varcount + + ; return varcount ; }
void test2 ( ) throws Throwable { ScriptOrFnScope scriptOrFnScope0 = new ScriptOrFnScope ( ( - 1159 ) , ( ScriptOrFnScope ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int incrementVarCount ( ) { varcount + + ; return varcount ; }
void test3 ( ) throws Throwable { ScriptOrFnScope scriptOrFnScope0 = new ScriptOrFnScope ( ( - 1159 ) , ( ScriptOrFnScope ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int incrementVarCount ( ) { varcount + + ; return varcount ; }
void test4 ( ) throws Throwable { ScriptOrFnScope scriptOrFnScope0 = new ScriptOrFnScope ( ( - 1159 ) , ( ScriptOrFnScope ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getBraceNesting ( ) { return braceNesting ; }
void test5 ( ) throws Throwable { ScriptOrFnScope scriptOrFnScope0 = new ScriptOrFnScope ( 283 , ( ScriptOrFnScope ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getBraceNesting ( ) { return braceNesting ; }
void test6 ( ) throws Throwable { ScriptOrFnScope scriptOrFnScope0 = new ScriptOrFnScope ( 283 , ( ScriptOrFnScope ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int incrementVarCount ( ) { varcount + + ; return varcount ; }
void test0 ( ) throws Throwable { StringReader stringReader0 = new StringReader ( " ! lI$Huh : , I { c } f@P" ) ; CssCompressor cssCompressor0 = new CssCompressor ( ( Reader ) stringReader0 ) ; StringWriter stringWriter0 = new StringWriter ( 333 ) ; cssCompressor0 . compress ( ( Writer ) stringWriter0 , 333 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void compress ( Writer out , int linebreak , boolean munge , boolean verbose , boolean preserveAllSemiColons , boolean disableOptimizations ) throws IOException { this . munge = munge ; this . verbose = verbose ; processStringLiterals ( this . tokens , ! disableOptimizations ) ; if ( ! disableOptimizations ) { optimizeObjectMemberAccess ( this . tokens ) ; optimizeObjLitMemberDecl ( this . tokens ) ; } buildSymbolTree ( ) ; / / DO NOT TOUCH this . tokens BETWEEN THESE TWO PHASES ( BECAUSE OF this . indexedScopes ) mungeSymboltree ( ) ; StringBuffer sb = printSymbolTree ( linebreak , preserveAllSemiColons ) ; out . write ( sb . toString ( ) ) ; }
void test2 ( ) throws Throwable { StringReader stringReader0 = new StringReader ( " ! lI$Huh : , I { c } f@P" ) ; CssCompressor cssCompressor0 = new CssCompressor ( ( Reader ) stringReader0 ) ; StringWriter stringWriter0 = new StringWriter ( 333 ) ; cssCompressor0 . compress ( ( Writer ) stringWriter0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void compress ( Writer out , int linebreak , boolean munge , boolean verbose , boolean preserveAllSemiColons , boolean disableOptimizations ) throws IOException { this . munge = munge ; this . verbose = verbose ; processStringLiterals ( this . tokens , ! disableOptimizations ) ; if ( ! disableOptimizations ) { optimizeObjectMemberAccess ( this . tokens ) ; optimizeObjLitMemberDecl ( this . tokens ) ; } buildSymbolTree ( ) ; / / DO NOT TOUCH this . tokens BETWEEN THESE TWO PHASES ( BECAUSE OF this . indexedScopes ) mungeSymboltree ( ) ; StringBuffer sb = printSymbolTree ( linebreak , preserveAllSemiColons ) ; out . write ( sb . toString ( ) ) ; }
void test0 ( ) throws Throwable { JavaScriptToken javaScriptToken0 = new JavaScriptToken ( 1489 , "" ) ; int int0 = javaScriptToken0 . getType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getType ( ) { return type ; }
void test1 ( ) throws Throwable { JavaScriptToken javaScriptToken0 = new JavaScriptToken ( 1489 , "" ) ; String string0 = javaScriptToken0 . getValue ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getType ( ) { return type ; }
void test0 ( ) throws Throwable { JavaScriptIdentifier javaScriptIdentifier0 = new JavaScriptIdentifier ( "vGp < : WUcV 1M9~ , mi" , ( ScriptOrFnScope ) null ) ; boolean boolean0 = javaScriptIdentifier0 . isMarkedForMunging ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRefcount ( ) { return refcount ; }
void test1 ( ) throws Throwable { JavaScriptIdentifier javaScriptIdentifier0 = new JavaScriptIdentifier ( "vGp < : WUcV 1M9~ , mi" , ( ScriptOrFnScope ) null ) ; javaScriptIdentifier0 . incrementRefcount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRefcount ( ) { return refcount ; }
void test2 ( ) throws Throwable { JavaScriptIdentifier javaScriptIdentifier0 = new JavaScriptIdentifier ( "vGp < : WUcV 1M9~ , mi" , ( ScriptOrFnScope ) null ) ; javaScriptIdentifier0 . setMungedValue ( "vGp < : WUcV 1M9~ , mi" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRefcount ( ) { return refcount ; }
void test3 ( ) throws Throwable { JavaScriptIdentifier javaScriptIdentifier0 = new JavaScriptIdentifier ( "vGp < : WUcV 1M9~ , mi" , ( ScriptOrFnScope ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRefcount ( ) { return refcount ; }
void test4 ( ) throws Throwable { JavaScriptIdentifier javaScriptIdentifier0 = new JavaScriptIdentifier ( "vGp < : WUcV 1M9~ , mi" , ( ScriptOrFnScope ) null ) ; javaScriptIdentifier0 . getMungedValue ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMarkedForMunging ( ) { return markedForMunging ; }
void test5 ( ) throws Throwable { JavaScriptIdentifier javaScriptIdentifier0 = new JavaScriptIdentifier ( "vGp < : WUcV 1M9~ , mi" , ( ScriptOrFnScope ) null ) ; int int0 = javaScriptIdentifier0 . getRefcount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMarkedForMunging ( ) { return markedForMunging ; }
void test0 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncodedSource ( ) { return encodedSource ; }
void test1 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncodedSource ( ) { return encodedSource ; }
void test2 ( ) throws Throwable { UintMap uintMap0 = new UintMap ( ) ; String string0 = Decompiler . decompile ( "h\u0001'\u0001ph\u0017\u0001" , 129 , uintMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String decompile ( String source , int flags , UintMap properties ) { int length = source . length ( ) ; if ( length = = 0 ) { return "" ; } int indent = properties . getInt ( INITIAL_INDENT_PROP , 0 ) ; if ( indent < 0 ) throw new IllegalArgumentException ( ) ; int indentGap = properties . getInt ( INDENT_GAP_PROP , 4 ) ; if ( indentGap < 0 ) throw new IllegalArgumentException ( ) ; int caseGap = properties . getInt ( CASE_GAP_PROP , 2 ) ; if ( caseGap < 0 ) throw new IllegalArgumentException ( ) ; StringBuffer result = new StringBuffer ( ) ; boolean justFunctionBody = ( 0 ! = ( flags & Decompiler . ONLY_BODY_FLAG ) ) ; boolean toSource = ( 0 ! = ( flags & Decompiler . TO_SOURCE_FLAG ) ) ; / / Spew tokens in source , for debugging . / / as TYPE number char if ( printSource ) { System . err . println ( "length : " + length ) ; for ( int i = 0 ; i < length ; + + i ) { / / Note that tokenToName will fail unless Context . printTrees / / is true . String tokenname = null ; if ( Token . printNames ) { tokenname = Token . name ( source . charAt ( i ) ) ; } if ( tokenname = = null ) { tokenname = " - - - " ; } String pad = tokenname . length ( ) > 7 ? "\t" : "\t\t" ; System . err . println ( tokenname + pad + ( int ) source . charAt ( i ) + "\t'" + ScriptRuntime . escapeString ( source . substring ( i , i + 1 ) ) + "'" ) ; } System . err . println ( ) ; } int braceNesting = 0 ; boolean afterFirstEOL = false ; int i = 0 ; int topFunctionType ; if ( source . charAt ( i ) = = Token . SCRIPT ) { + + i ; topFunctionType = - 1 ; } else { topFunctionType = source . charAt ( i + 1 ) ; } if ( ! toSource ) { / / add an initial newline to exactly match js . result . append ( '\n' ) ; for ( int j = 0 ; j < indent ; j + + ) result . append ( ' ' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ( ' ) ; } } while ( i < length ) { switch ( source . charAt ( i ) ) { case Token . GET : case Token . SET : result . append ( source . charAt ( i ) = = Token . GET ? "get " : "set " ) ; + + i ; i = printSourceString ( source , i + 1 , false , result ) ; / / Now increment one more to get past the FUNCTION token + + i ; break ; case Token . NAME : case Token . REGEXP : / / re - wrapped in ' / 's in parser . . . i = printSourceString ( source , i + 1 , false , result ) ; continue ; case Token . STRING : i = printSourceString ( source , i + 1 , true , result ) ; continue ; case Token . NUMBER : i = printSourceNumber ( source , i + 1 , result ) ; continue ; case Token . TRUE : result . append ( "true" ) ; break ; case Token . FALSE : result . append ( "false" ) ; break ; case Token . NULL : result . append ( "null" ) ; break ; case Token . THIS : result . append ( "this" ) ; break ; case Token . FUNCTION : + + i ; / / skip function type result . append ( "function " ) ; break ; case FUNCTION_END : / / Do nothing break ; case Token . COMMA : result . append ( " , " ) ; break ; case Token . LC : + + braceNesting ; if ( Token . EOL = = getNext ( source , length , i ) ) indent + = indentGap ; result . append ( ' { ' ) ; break ; case Token . RC : { - - braceNesting ; / * don't print the closing RC if it closes the * toplevel function and we're called from * decompileFunctionBody . * / if ( justFunctionBody & & braceNesting = = 0 ) break ; result . append ( ' } ' ) ; switch ( getNext ( source , length , i ) ) { case Token . EOL : case FUNCTION_END : indent - = indentGap ; break ; case Token . WHILE : case Token . ELSE : indent - = indentGap ; result . append ( ' ' ) ; break ; } break ; } case Token . LP : result . append ( ' ( ' ) ; break ; case Token . RP : result . append ( ' ) ' ) ; if ( Token . LC = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . LB : result . append ( ' [ ' ) ; break ; case Token . RB : result . append ( ' ] ' ) ; break ; case Token . EOL : { if ( toSource ) break ; boolean newLine = true ; if ( ! afterFirstEOL ) { afterFirstEOL = true ; if ( justFunctionBody ) { / * throw away just added 'function name ( . . . ) { ' * and restore the original indent * / result . setLength ( 0 ) ; indent - = indentGap ; newLine = false ; } } if ( newLine ) { result . append ( '\n' ) ; } / * add indent if any tokens remain , * less setback if next token is * a label , case or default . * / if ( i + 1 < length ) { int less = 0 ; int nextToken = source . charAt ( i + 1 ) ; if ( nextToken = = Token . CASE | | nextToken = = Token . DEFAULT ) { less = indentGap - caseGap ; } else if ( nextToken = = Token . RC ) { less = indentGap ; } / * elaborate check against label . . . skip past a * following inlined NAME and look for a COLON . * / else if ( nextToken = = Token . NAME ) { int afterName = getSourceStringEnd ( source , i + 2 ) ; if ( source . charAt ( afterName ) = = Token . COLON ) less = indentGap ; } for ( ; less < indent ; less + + ) result . append ( ' ' ) ; } break ; } case Token . DOT : result . append ( ' . ' ) ; break ; case Token . NEW : result . append ( "new " ) ; break ; case Token . DELPROP : result . append ( "delete " ) ; break ; case Token . IF : result . append ( "if " ) ; break ; case Token . ELSE : result . append ( "else " ) ; break ; case Token . FOR : result . append ( "for " ) ; break ; case Token . IN : result . append ( " in " ) ; break ; case Token . WITH : result . append ( "with " ) ; break ; case Token . WHILE : result . append ( "while " ) ; break ; case Token . DO : result . append ( "do " ) ; break ; case Token . TRY : result . append ( "try " ) ; break ; case Token . CATCH : result . append ( "catch " ) ; break ; case Token . FINALLY : result . append ( "finally " ) ; break ; case Token . THROW : result . append ( "throw " ) ; break ; case Token . SWITCH : result . append ( "switch " ) ; break ; case Token . BREAK : result . append ( "break" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CONTINUE : result . append ( "continue" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CASE : result . append ( "case " ) ; break ; case Token . DEFAULT : result . append ( "default" ) ; break ; case Token . RETURN : result . append ( "return" ) ; if ( Token . SEMI ! = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . VAR : result . append ( "var " ) ; break ; case Token . LET : result . append ( "let " ) ; break ; case Token . SEMI : result . append ( ' ; ' ) ; if ( Token . EOL ! = getNext ( source , length , i ) ) { / / separators in FOR result . append ( ' ' ) ; } break ; case Token . ASSIGN : result . append ( " = " ) ; break ; case Token . ASSIGN_ADD : result . append ( " + = " ) ; break ; case Token . ASSIGN_SUB : result . append ( " - = " ) ; break ; case Token . ASSIGN_MUL : result . append ( " * = " ) ; break ; case Token . ASSIGN_DIV : result . append ( " / = " ) ; break ; case Token . ASSIGN_MOD : result . append ( " % = " ) ; break ; case Token . ASSIGN_BITOR : result . append ( " | = " ) ; break ; case Token . ASSIGN_BITXOR : result . append ( " ^ = " ) ; break ; case Token . ASSIGN_BITAND : result . append ( " & = " ) ; break ; case Token . ASSIGN_LSH : result . append ( " < < = " ) ; break ; case Token . ASSIGN_RSH : result . append ( " > > = " ) ; break ; case Token . ASSIGN_URSH : result . append ( " > > > = " ) ; break ; case Token . HOOK : result . append ( " ? " ) ; break ; case Token . OBJECTLIT : / / pun OBJECTLIT to mean colon in objlit property / / initialization . / / This needs to be distinct from COLON in the general case / / to distinguish from the colon in a ternary . . . which needs / / different spacing . result . append ( ' : ' ) ; break ; case Token . COLON : if ( Token . EOL = = getNext ( source , length , i ) ) / / it's the end of a label result . append ( ' : ' ) ; else / / it's the middle part of a ternary result . append ( " : " ) ; break ; case Token . OR : result . append ( " | | " ) ; break ; case Token . AND : result . append ( " & & " ) ; break ; case Token . BITOR : result . append ( " | " ) ; break ; case Token . BITXOR : result . append ( " ^ " ) ; break ; case Token . BITAND : result . append ( " & " ) ; break ; case Token . SHEQ : result . append ( " = = = " ) ; break ; case Token . SHNE : result . append ( " ! = = " ) ; break ; case Token . EQ : result . append ( " = = " ) ; break ; case Token . NE : result . append ( " ! = " ) ; break ; case Token . LE : result . append ( " < = " ) ; break ; case Token . LT : result . append ( " < " ) ; break ; case Token . GE : result . append ( " > = " ) ; break ; case Token . GT : result . append ( " > " ) ; break ; case Token . INSTANCEOF : result . append ( " instanceof " ) ; break ; case Token . LSH : result . append ( " < < " ) ; break ; case Token . RSH : result . append ( " > > " ) ; break ; case Token . URSH : result . append ( " > > > " ) ; break ; case Token . TYPEOF : result . append ( "typeof " ) ; break ; case Token . VOID : result . append ( "void " ) ; break ; case Token . CONST : result . append ( "const " ) ; break ; case Token . YIELD : result . append ( "yield " ) ; break ; case Token . NOT : result . append ( ' ! ' ) ; break ; case Token . BITNOT : result . append ( '~' ) ; break ; case Token . POS : result . append ( ' + ' ) ; break ; case Token . NEG : result . append ( ' - ' ) ; break ; case Token . INC : result . append ( " + + " ) ; break ; case Token . DEC : result . append ( " - - " ) ; break ; case Token . ADD : result . append ( " + " ) ; break ; case Token . SUB : result . append ( " - " ) ; break ; case Token . MUL : result . append ( " * " ) ; break ; case Token . DIV : result . append ( " / " ) ; break ; case Token . MOD : result . append ( " % " ) ; break ; case Token . COLONCOLON : result . append ( " : : " ) ; break ; case Token . DOTDOT : result . append ( " . . " ) ; break ; case Token . DOTQUERY : result . append ( " . ( " ) ; break ; case Token . XMLATTR : result . append ( '@' ) ; break ; default : / / If we don't know how to decompile it , raise an exception . throw new RuntimeException ( "Token : " + Token . name ( source . charAt ( i ) ) ) ; } + + i ; } if ( ! toSource ) { / / add that trailing newline if it's an outermost function . if ( ! justFunctionBody ) result . append ( '\n' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ) ' ) ; } } return result . toString ( ) ; } int getNext ( String source , int length , int i ) { return ( i + 1 < length ) ? source . charAt ( i + 1 ) : Token . EOF ; } int getSourceStringEnd ( String source , int offset ) { return printSourceString ( source , offset , false , null ) ; } int printSourceString ( String source , int offset , boolean asQuotedString , StringBuffer sb ) { int length = source . charAt ( offset ) ; + + offset ; if ( ( 0x8000 & length ) ! = 0 ) { length = ( ( 0x7FFF & length ) < < 16 ) | source . charAt ( offset ) ; + + offset ; } if ( sb ! = null ) { String str = source . substring ( offset , offset + length ) ; if ( ! asQuotedString ) { sb . append ( str ) ; } else { sb . append ( '"' ) ; sb . append ( ScriptRuntime . escapeString ( str ) ) ; sb . append ( '"' ) ; } } return offset + length ; } int printSourceNumber ( String source , int offset , StringBuffer sb ) { double number = 0 . 0 ; char type = source . charAt ( offset ) ; + + offset ; if ( type = = 'S' ) { if ( sb ! = null ) { int ival = source . charAt ( offset ) ; number = ival ; } + + offset ; } else if ( type = = 'J' | | type = = 'D' ) { if ( sb ! = null ) { long lbits ; lbits = ( long ) source . charAt ( offset ) < < 48 ; lbits | = ( long ) source . charAt ( offset + 1 ) < < 32 ; lbits | = ( long ) source . charAt ( offset + 2 ) < < 16 ; lbits | = source . charAt ( offset + 3 ) ; if ( type = = 'J' ) { number = lbits ; } else { number = Double . longBitsToDouble ( lbits ) ; } } offset + = 4 ; } else { / / Bad source throw new RuntimeException ( ) ; } if ( sb ! = null ) { sb . append ( ScriptRuntime . numberToString ( number , 10 ) ) ; } return offset ; } char [ ] sourceBuffer = new char [ 128 ] ; / / Per script / function source buffer top : parent source does not include a / / nested functions source and uses function index as a reference instead . int sourceTop ; / / whether to do a debug print of the source information , when decompiling . boolean printSource = false ; }
void test3 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncodedSource ( ) { return encodedSource ; }
void test4 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addToken ( int token ) { if ( ! ( 0 < = token & & token < = Token . LAST_TOKEN ) ) throw new IllegalArgumentException ( ) ; append ( ( char ) token ) ; }
void test5 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addToken ( int token ) { if ( ! ( 0 < = token & & token < = Token . LAST_TOKEN ) ) throw new IllegalArgumentException ( ) ; append ( ( char ) token ) ; }
void test6 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addEOL ( int token ) { if ( ! ( 0 < = token & & token < = Token . LAST_TOKEN ) ) throw new IllegalArgumentException ( ) ; append ( ( char ) token ) ; append ( ( char ) Token . EOL ) ; }
void test7 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncodedSource ( ) { return encodedSource ; }
void test8 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addEOL ( int token ) { if ( ! ( 0 < = token & & token < = Token . LAST_TOKEN ) ) throw new IllegalArgumentException ( ) ; append ( ( char ) token ) ; append ( ( char ) Token . EOL ) ; }
void test9 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addNumber ( double n ) { addToken ( Token . NUMBER ) ; / * encode the number in the source stream . * Save as NUMBER type ( char | char char char char ) * where type is * 'D' - double , 'S' - short , 'J' - long . * We need to retain float vs . integer type info to keep the * behavior of liveconnect type - guessing the same after * decompilation . ( Liveconnect tries to present 1 . 0 to Java * as a float / double ) * OPT : This is no longer true . We could compress the format . * This may not be the most space - efficient encoding ; * the chars created below may take up to 3 bytes in * constant pool UTF - 8 encoding , so a Double could take * up to 12 bytes . * / long lbits = ( long ) n ; if ( lbits ! = n ) { / / if it's floating point , save as a Double bit pattern . / / ( 12 / 15 / 97 our scanner only returns Double for f . p . ) lbits = Double . doubleToLongBits ( n ) ; append ( 'D' ) ; append ( ( char ) ( lbits > > 48 ) ) ; append ( ( char ) ( lbits > > 32 ) ) ; append ( ( char ) ( lbits > > 16 ) ) ; append ( ( char ) lbits ) ; } else { / / we can ignore negative values , bc they're already prefixed / / by NEG if ( lbits < 0 ) Kit . codeBug ( ) ; / / will it fit in a char ? / / this gives a short encoding for integer values up to 2^16 . if ( lbits < = Character . MAX_VALUE ) { append ( 'S' ) ; append ( ( char ) lbits ) ; } else { / / Integral , but won't fit in a char . Store as a long . append ( 'J' ) ; append ( ( char ) ( lbits > > 48 ) ) ; append ( ( char ) ( lbits > > 32 ) ) ; append ( ( char ) ( lbits > > 16 ) ) ; append ( ( char ) lbits ) ; } } }
void test10 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentOffset ( ) { return sourceTop ; }
void test11 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncodedSource ( ) { return encodedSource ; }
void test12 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncodedSource ( ) { return encodedSource ; }
void test13 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; decompiler0 . addRegexp ( "" , "" ) ; decompiler0 . addRegexp ( " ( Lorg / mozilla / javascript / Context ; Lorg / mozilla / javascript / Scriptable ; ILjava / lang / Object ; Ljava / lang / Object ; ) Ljava / lang / Object ; " , " ( Lorg / mozilla / javascript / Context ; Lorg / mozilla / javascript / Scriptable ; ILjava / lang / Object ; Ljava / lang / Object ; ) Ljava / lang / Object ; " ) ; int int0 = decompiler0 . markFunctionEnd ( 1787 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentOffset ( ) { return sourceTop ; }
void test14 ( ) throws Throwable { Decompiler decompiler0 = new Decompiler ( ) ; decompiler0 . addName ( "" ) ; decompiler0 . addRegexp ( "" , "" ) ; decompiler0 . addRegexp ( " ( Lorg / mozilla / javascript / Context ; Lorg / mozilla / javascript / Scriptable ; ILjava / lang / Object ; Ljava / lang / Object ; ) Ljava / lang / Object ; " , " ( Lorg / mozilla / javascript / Context ; Lorg / mozilla / javascript / Scriptable ; ILjava / lang / Object ; Ljava / lang / Object ; ) Ljava / lang / Object ; " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentOffset ( ) { return sourceTop ; }
void test15 ( ) throws Throwable { UintMap uintMap0 = new UintMap ( ) ; String string0 = Decompiler . decompile ( "" , 1229 , uintMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String decompile ( String source , int flags , UintMap properties ) { int length = source . length ( ) ; if ( length = = 0 ) { return "" ; } int indent = properties . getInt ( INITIAL_INDENT_PROP , 0 ) ; if ( indent < 0 ) throw new IllegalArgumentException ( ) ; int indentGap = properties . getInt ( INDENT_GAP_PROP , 4 ) ; if ( indentGap < 0 ) throw new IllegalArgumentException ( ) ; int caseGap = properties . getInt ( CASE_GAP_PROP , 2 ) ; if ( caseGap < 0 ) throw new IllegalArgumentException ( ) ; StringBuffer result = new StringBuffer ( ) ; boolean justFunctionBody = ( 0 ! = ( flags & Decompiler . ONLY_BODY_FLAG ) ) ; boolean toSource = ( 0 ! = ( flags & Decompiler . TO_SOURCE_FLAG ) ) ; / / Spew tokens in source , for debugging . / / as TYPE number char if ( printSource ) { System . err . println ( "length : " + length ) ; for ( int i = 0 ; i < length ; + + i ) { / / Note that tokenToName will fail unless Context . printTrees / / is true . String tokenname = null ; if ( Token . printNames ) { tokenname = Token . name ( source . charAt ( i ) ) ; } if ( tokenname = = null ) { tokenname = " - - - " ; } String pad = tokenname . length ( ) > 7 ? "\t" : "\t\t" ; System . err . println ( tokenname + pad + ( int ) source . charAt ( i ) + "\t'" + ScriptRuntime . escapeString ( source . substring ( i , i + 1 ) ) + "'" ) ; } System . err . println ( ) ; } int braceNesting = 0 ; boolean afterFirstEOL = false ; int i = 0 ; int topFunctionType ; if ( source . charAt ( i ) = = Token . SCRIPT ) { + + i ; topFunctionType = - 1 ; } else { topFunctionType = source . charAt ( i + 1 ) ; } if ( ! toSource ) { / / add an initial newline to exactly match js . result . append ( '\n' ) ; for ( int j = 0 ; j < indent ; j + + ) result . append ( ' ' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ( ' ) ; } } while ( i < length ) { switch ( source . charAt ( i ) ) { case Token . GET : case Token . SET : result . append ( source . charAt ( i ) = = Token . GET ? "get " : "set " ) ; + + i ; i = printSourceString ( source , i + 1 , false , result ) ; / / Now increment one more to get past the FUNCTION token + + i ; break ; case Token . NAME : case Token . REGEXP : / / re - wrapped in ' / 's in parser . . . i = printSourceString ( source , i + 1 , false , result ) ; continue ; case Token . STRING : i = printSourceString ( source , i + 1 , true , result ) ; continue ; case Token . NUMBER : i = printSourceNumber ( source , i + 1 , result ) ; continue ; case Token . TRUE : result . append ( "true" ) ; break ; case Token . FALSE : result . append ( "false" ) ; break ; case Token . NULL : result . append ( "null" ) ; break ; case Token . THIS : result . append ( "this" ) ; break ; case Token . FUNCTION : + + i ; / / skip function type result . append ( "function " ) ; break ; case FUNCTION_END : / / Do nothing break ; case Token . COMMA : result . append ( " , " ) ; break ; case Token . LC : + + braceNesting ; if ( Token . EOL = = getNext ( source , length , i ) ) indent + = indentGap ; result . append ( ' { ' ) ; break ; case Token . RC : { - - braceNesting ; / * don't print the closing RC if it closes the * toplevel function and we're called from * decompileFunctionBody . * / if ( justFunctionBody & & braceNesting = = 0 ) break ; result . append ( ' } ' ) ; switch ( getNext ( source , length , i ) ) { case Token . EOL : case FUNCTION_END : indent - = indentGap ; break ; case Token . WHILE : case Token . ELSE : indent - = indentGap ; result . append ( ' ' ) ; break ; } break ; } case Token . LP : result . append ( ' ( ' ) ; break ; case Token . RP : result . append ( ' ) ' ) ; if ( Token . LC = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . LB : result . append ( ' [ ' ) ; break ; case Token . RB : result . append ( ' ] ' ) ; break ; case Token . EOL : { if ( toSource ) break ; boolean newLine = true ; if ( ! afterFirstEOL ) { afterFirstEOL = true ; if ( justFunctionBody ) { / * throw away just added 'function name ( . . . ) { ' * and restore the original indent * / result . setLength ( 0 ) ; indent - = indentGap ; newLine = false ; } } if ( newLine ) { result . append ( '\n' ) ; } / * add indent if any tokens remain , * less setback if next token is * a label , case or default . * / if ( i + 1 < length ) { int less = 0 ; int nextToken = source . charAt ( i + 1 ) ; if ( nextToken = = Token . CASE | | nextToken = = Token . DEFAULT ) { less = indentGap - caseGap ; } else if ( nextToken = = Token . RC ) { less = indentGap ; } / * elaborate check against label . . . skip past a * following inlined NAME and look for a COLON . * / else if ( nextToken = = Token . NAME ) { int afterName = getSourceStringEnd ( source , i + 2 ) ; if ( source . charAt ( afterName ) = = Token . COLON ) less = indentGap ; } for ( ; less < indent ; less + + ) result . append ( ' ' ) ; } break ; } case Token . DOT : result . append ( ' . ' ) ; break ; case Token . NEW : result . append ( "new " ) ; break ; case Token . DELPROP : result . append ( "delete " ) ; break ; case Token . IF : result . append ( "if " ) ; break ; case Token . ELSE : result . append ( "else " ) ; break ; case Token . FOR : result . append ( "for " ) ; break ; case Token . IN : result . append ( " in " ) ; break ; case Token . WITH : result . append ( "with " ) ; break ; case Token . WHILE : result . append ( "while " ) ; break ; case Token . DO : result . append ( "do " ) ; break ; case Token . TRY : result . append ( "try " ) ; break ; case Token . CATCH : result . append ( "catch " ) ; break ; case Token . FINALLY : result . append ( "finally " ) ; break ; case Token . THROW : result . append ( "throw " ) ; break ; case Token . SWITCH : result . append ( "switch " ) ; break ; case Token . BREAK : result . append ( "break" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CONTINUE : result . append ( "continue" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CASE : result . append ( "case " ) ; break ; case Token . DEFAULT : result . append ( "default" ) ; break ; case Token . RETURN : result . append ( "return" ) ; if ( Token . SEMI ! = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . VAR : result . append ( "var " ) ; break ; case Token . LET : result . append ( "let " ) ; break ; case Token . SEMI : result . append ( ' ; ' ) ; if ( Token . EOL ! = getNext ( source , length , i ) ) { / / separators in FOR result . append ( ' ' ) ; } break ; case Token . ASSIGN : result . append ( " = " ) ; break ; case Token . ASSIGN_ADD : result . append ( " + = " ) ; break ; case Token . ASSIGN_SUB : result . append ( " - = " ) ; break ; case Token . ASSIGN_MUL : result . append ( " * = " ) ; break ; case Token . ASSIGN_DIV : result . append ( " / = " ) ; break ; case Token . ASSIGN_MOD : result . append ( " % = " ) ; break ; case Token . ASSIGN_BITOR : result . append ( " | = " ) ; break ; case Token . ASSIGN_BITXOR : result . append ( " ^ = " ) ; break ; case Token . ASSIGN_BITAND : result . append ( " & = " ) ; break ; case Token . ASSIGN_LSH : result . append ( " < < = " ) ; break ; case Token . ASSIGN_RSH : result . append ( " > > = " ) ; break ; case Token . ASSIGN_URSH : result . append ( " > > > = " ) ; break ; case Token . HOOK : result . append ( " ? " ) ; break ; case Token . OBJECTLIT : / / pun OBJECTLIT to mean colon in objlit property / / initialization . / / This needs to be distinct from COLON in the general case / / to distinguish from the colon in a ternary . . . which needs / / different spacing . result . append ( ' : ' ) ; break ; case Token . COLON : if ( Token . EOL = = getNext ( source , length , i ) ) / / it's the end of a label result . append ( ' : ' ) ; else / / it's the middle part of a ternary result . append ( " : " ) ; break ; case Token . OR : result . append ( " | | " ) ; break ; case Token . AND : result . append ( " & & " ) ; break ; case Token . BITOR : result . append ( " | " ) ; break ; case Token . BITXOR : result . append ( " ^ " ) ; break ; case Token . BITAND : result . append ( " & " ) ; break ; case Token . SHEQ : result . append ( " = = = " ) ; break ; case Token . SHNE : result . append ( " ! = = " ) ; break ; case Token . EQ : result . append ( " = = " ) ; break ; case Token . NE : result . append ( " ! = " ) ; break ; case Token . LE : result . append ( " < = " ) ; break ; case Token . LT : result . append ( " < " ) ; break ; case Token . GE : result . append ( " > = " ) ; break ; case Token . GT : result . append ( " > " ) ; break ; case Token . INSTANCEOF : result . append ( " instanceof " ) ; break ; case Token . LSH : result . append ( " < < " ) ; break ; case Token . RSH : result . append ( " > > " ) ; break ; case Token . URSH : result . append ( " > > > " ) ; break ; case Token . TYPEOF : result . append ( "typeof " ) ; break ; case Token . VOID : result . append ( "void " ) ; break ; case Token . CONST : result . append ( "const " ) ; break ; case Token . YIELD : result . append ( "yield " ) ; break ; case Token . NOT : result . append ( ' ! ' ) ; break ; case Token . BITNOT : result . append ( '~' ) ; break ; case Token . POS : result . append ( ' + ' ) ; break ; case Token . NEG : result . append ( ' - ' ) ; break ; case Token . INC : result . append ( " + + " ) ; break ; case Token . DEC : result . append ( " - - " ) ; break ; case Token . ADD : result . append ( " + " ) ; break ; case Token . SUB : result . append ( " - " ) ; break ; case Token . MUL : result . append ( " * " ) ; break ; case Token . DIV : result . append ( " / " ) ; break ; case Token . MOD : result . append ( " % " ) ; break ; case Token . COLONCOLON : result . append ( " : : " ) ; break ; case Token . DOTDOT : result . append ( " . . " ) ; break ; case Token . DOTQUERY : result . append ( " . ( " ) ; break ; case Token . XMLATTR : result . append ( '@' ) ; break ; default : / / If we don't know how to decompile it , raise an exception . throw new RuntimeException ( "Token : " + Token . name ( source . charAt ( i ) ) ) ; } + + i ; } if ( ! toSource ) { / / add that trailing newline if it's an outermost function . if ( ! justFunctionBody ) result . append ( '\n' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ) ' ) ; } } return result . toString ( ) ; } int getNext ( String source , int length , int i ) { return ( i + 1 < length ) ? source . charAt ( i + 1 ) : Token . EOF ; } int getSourceStringEnd ( String source , int offset ) { return printSourceString ( source , offset , false , null ) ; } int printSourceString ( String source , int offset , boolean asQuotedString , StringBuffer sb ) { int length = source . charAt ( offset ) ; + + offset ; if ( ( 0x8000 & length ) ! = 0 ) { length = ( ( 0x7FFF & length ) < < 16 ) | source . charAt ( offset ) ; + + offset ; } if ( sb ! = null ) { String str = source . substring ( offset , offset + length ) ; if ( ! asQuotedString ) { sb . append ( str ) ; } else { sb . append ( '"' ) ; sb . append ( ScriptRuntime . escapeString ( str ) ) ; sb . append ( '"' ) ; } } return offset + length ; } int printSourceNumber ( String source , int offset , StringBuffer sb ) { double number = 0 . 0 ; char type = source . charAt ( offset ) ; + + offset ; if ( type = = 'S' ) { if ( sb ! = null ) { int ival = source . charAt ( offset ) ; number = ival ; } + + offset ; } else if ( type = = 'J' | | type = = 'D' ) { if ( sb ! = null ) { long lbits ; lbits = ( long ) source . charAt ( offset ) < < 48 ; lbits | = ( long ) source . charAt ( offset + 1 ) < < 32 ; lbits | = ( long ) source . charAt ( offset + 2 ) < < 16 ; lbits | = source . charAt ( offset + 3 ) ; if ( type = = 'J' ) { number = lbits ; } else { number = Double . longBitsToDouble ( lbits ) ; } } offset + = 4 ; } else { / / Bad source throw new RuntimeException ( ) ; } if ( sb ! = null ) { sb . append ( ScriptRuntime . numberToString ( number , 10 ) ) ; } return offset ; } char [ ] sourceBuffer = new char [ 128 ] ; / / Per script / function source buffer top : parent source does not include a / / nested functions source and uses function index as a reference instead . int sourceTop ; / / whether to do a debug print of the source information , when decompiling . boolean printSource = false ; }
void test18 ( ) throws Throwable { UintMap uintMap0 = new UintMap ( 1426 ) ; String string0 = Decompiler . decompile ( "\tat " , 1287 , uintMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String decompile ( String source , int flags , UintMap properties ) { int length = source . length ( ) ; if ( length = = 0 ) { return "" ; } int indent = properties . getInt ( INITIAL_INDENT_PROP , 0 ) ; if ( indent < 0 ) throw new IllegalArgumentException ( ) ; int indentGap = properties . getInt ( INDENT_GAP_PROP , 4 ) ; if ( indentGap < 0 ) throw new IllegalArgumentException ( ) ; int caseGap = properties . getInt ( CASE_GAP_PROP , 2 ) ; if ( caseGap < 0 ) throw new IllegalArgumentException ( ) ; StringBuffer result = new StringBuffer ( ) ; boolean justFunctionBody = ( 0 ! = ( flags & Decompiler . ONLY_BODY_FLAG ) ) ; boolean toSource = ( 0 ! = ( flags & Decompiler . TO_SOURCE_FLAG ) ) ; / / Spew tokens in source , for debugging . / / as TYPE number char if ( printSource ) { System . err . println ( "length : " + length ) ; for ( int i = 0 ; i < length ; + + i ) { / / Note that tokenToName will fail unless Context . printTrees / / is true . String tokenname = null ; if ( Token . printNames ) { tokenname = Token . name ( source . charAt ( i ) ) ; } if ( tokenname = = null ) { tokenname = " - - - " ; } String pad = tokenname . length ( ) > 7 ? "\t" : "\t\t" ; System . err . println ( tokenname + pad + ( int ) source . charAt ( i ) + "\t'" + ScriptRuntime . escapeString ( source . substring ( i , i + 1 ) ) + "'" ) ; } System . err . println ( ) ; } int braceNesting = 0 ; boolean afterFirstEOL = false ; int i = 0 ; int topFunctionType ; if ( source . charAt ( i ) = = Token . SCRIPT ) { + + i ; topFunctionType = - 1 ; } else { topFunctionType = source . charAt ( i + 1 ) ; } if ( ! toSource ) { / / add an initial newline to exactly match js . result . append ( '\n' ) ; for ( int j = 0 ; j < indent ; j + + ) result . append ( ' ' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ( ' ) ; } } while ( i < length ) { switch ( source . charAt ( i ) ) { case Token . GET : case Token . SET : result . append ( source . charAt ( i ) = = Token . GET ? "get " : "set " ) ; + + i ; i = printSourceString ( source , i + 1 , false , result ) ; / / Now increment one more to get past the FUNCTION token + + i ; break ; case Token . NAME : case Token . REGEXP : / / re - wrapped in ' / 's in parser . . . i = printSourceString ( source , i + 1 , false , result ) ; continue ; case Token . STRING : i = printSourceString ( source , i + 1 , true , result ) ; continue ; case Token . NUMBER : i = printSourceNumber ( source , i + 1 , result ) ; continue ; case Token . TRUE : result . append ( "true" ) ; break ; case Token . FALSE : result . append ( "false" ) ; break ; case Token . NULL : result . append ( "null" ) ; break ; case Token . THIS : result . append ( "this" ) ; break ; case Token . FUNCTION : + + i ; / / skip function type result . append ( "function " ) ; break ; case FUNCTION_END : / / Do nothing break ; case Token . COMMA : result . append ( " , " ) ; break ; case Token . LC : + + braceNesting ; if ( Token . EOL = = getNext ( source , length , i ) ) indent + = indentGap ; result . append ( ' { ' ) ; break ; case Token . RC : { - - braceNesting ; / * don't print the closing RC if it closes the * toplevel function and we're called from * decompileFunctionBody . * / if ( justFunctionBody & & braceNesting = = 0 ) break ; result . append ( ' } ' ) ; switch ( getNext ( source , length , i ) ) { case Token . EOL : case FUNCTION_END : indent - = indentGap ; break ; case Token . WHILE : case Token . ELSE : indent - = indentGap ; result . append ( ' ' ) ; break ; } break ; } case Token . LP : result . append ( ' ( ' ) ; break ; case Token . RP : result . append ( ' ) ' ) ; if ( Token . LC = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . LB : result . append ( ' [ ' ) ; break ; case Token . RB : result . append ( ' ] ' ) ; break ; case Token . EOL : { if ( toSource ) break ; boolean newLine = true ; if ( ! afterFirstEOL ) { afterFirstEOL = true ; if ( justFunctionBody ) { / * throw away just added 'function name ( . . . ) { ' * and restore the original indent * / result . setLength ( 0 ) ; indent - = indentGap ; newLine = false ; } } if ( newLine ) { result . append ( '\n' ) ; } / * add indent if any tokens remain , * less setback if next token is * a label , case or default . * / if ( i + 1 < length ) { int less = 0 ; int nextToken = source . charAt ( i + 1 ) ; if ( nextToken = = Token . CASE | | nextToken = = Token . DEFAULT ) { less = indentGap - caseGap ; } else if ( nextToken = = Token . RC ) { less = indentGap ; } / * elaborate check against label . . . skip past a * following inlined NAME and look for a COLON . * / else if ( nextToken = = Token . NAME ) { int afterName = getSourceStringEnd ( source , i + 2 ) ; if ( source . charAt ( afterName ) = = Token . COLON ) less = indentGap ; } for ( ; less < indent ; less + + ) result . append ( ' ' ) ; } break ; } case Token . DOT : result . append ( ' . ' ) ; break ; case Token . NEW : result . append ( "new " ) ; break ; case Token . DELPROP : result . append ( "delete " ) ; break ; case Token . IF : result . append ( "if " ) ; break ; case Token . ELSE : result . append ( "else " ) ; break ; case Token . FOR : result . append ( "for " ) ; break ; case Token . IN : result . append ( " in " ) ; break ; case Token . WITH : result . append ( "with " ) ; break ; case Token . WHILE : result . append ( "while " ) ; break ; case Token . DO : result . append ( "do " ) ; break ; case Token . TRY : result . append ( "try " ) ; break ; case Token . CATCH : result . append ( "catch " ) ; break ; case Token . FINALLY : result . append ( "finally " ) ; break ; case Token . THROW : result . append ( "throw " ) ; break ; case Token . SWITCH : result . append ( "switch " ) ; break ; case Token . BREAK : result . append ( "break" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CONTINUE : result . append ( "continue" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CASE : result . append ( "case " ) ; break ; case Token . DEFAULT : result . append ( "default" ) ; break ; case Token . RETURN : result . append ( "return" ) ; if ( Token . SEMI ! = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . VAR : result . append ( "var " ) ; break ; case Token . LET : result . append ( "let " ) ; break ; case Token . SEMI : result . append ( ' ; ' ) ; if ( Token . EOL ! = getNext ( source , length , i ) ) { / / separators in FOR result . append ( ' ' ) ; } break ; case Token . ASSIGN : result . append ( " = " ) ; break ; case Token . ASSIGN_ADD : result . append ( " + = " ) ; break ; case Token . ASSIGN_SUB : result . append ( " - = " ) ; break ; case Token . ASSIGN_MUL : result . append ( " * = " ) ; break ; case Token . ASSIGN_DIV : result . append ( " / = " ) ; break ; case Token . ASSIGN_MOD : result . append ( " % = " ) ; break ; case Token . ASSIGN_BITOR : result . append ( " | = " ) ; break ; case Token . ASSIGN_BITXOR : result . append ( " ^ = " ) ; break ; case Token . ASSIGN_BITAND : result . append ( " & = " ) ; break ; case Token . ASSIGN_LSH : result . append ( " < < = " ) ; break ; case Token . ASSIGN_RSH : result . append ( " > > = " ) ; break ; case Token . ASSIGN_URSH : result . append ( " > > > = " ) ; break ; case Token . HOOK : result . append ( " ? " ) ; break ; case Token . OBJECTLIT : / / pun OBJECTLIT to mean colon in objlit property / / initialization . / / This needs to be distinct from COLON in the general case / / to distinguish from the colon in a ternary . . . which needs / / different spacing . result . append ( ' : ' ) ; break ; case Token . COLON : if ( Token . EOL = = getNext ( source , length , i ) ) / / it's the end of a label result . append ( ' : ' ) ; else / / it's the middle part of a ternary result . append ( " : " ) ; break ; case Token . OR : result . append ( " | | " ) ; break ; case Token . AND : result . append ( " & & " ) ; break ; case Token . BITOR : result . append ( " | " ) ; break ; case Token . BITXOR : result . append ( " ^ " ) ; break ; case Token . BITAND : result . append ( " & " ) ; break ; case Token . SHEQ : result . append ( " = = = " ) ; break ; case Token . SHNE : result . append ( " ! = = " ) ; break ; case Token . EQ : result . append ( " = = " ) ; break ; case Token . NE : result . append ( " ! = " ) ; break ; case Token . LE : result . append ( " < = " ) ; break ; case Token . LT : result . append ( " < " ) ; break ; case Token . GE : result . append ( " > = " ) ; break ; case Token . GT : result . append ( " > " ) ; break ; case Token . INSTANCEOF : result . append ( " instanceof " ) ; break ; case Token . LSH : result . append ( " < < " ) ; break ; case Token . RSH : result . append ( " > > " ) ; break ; case Token . URSH : result . append ( " > > > " ) ; break ; case Token . TYPEOF : result . append ( "typeof " ) ; break ; case Token . VOID : result . append ( "void " ) ; break ; case Token . CONST : result . append ( "const " ) ; break ; case Token . YIELD : result . append ( "yield " ) ; break ; case Token . NOT : result . append ( ' ! ' ) ; break ; case Token . BITNOT : result . append ( '~' ) ; break ; case Token . POS : result . append ( ' + ' ) ; break ; case Token . NEG : result . append ( ' - ' ) ; break ; case Token . INC : result . append ( " + + " ) ; break ; case Token . DEC : result . append ( " - - " ) ; break ; case Token . ADD : result . append ( " + " ) ; break ; case Token . SUB : result . append ( " - " ) ; break ; case Token . MUL : result . append ( " * " ) ; break ; case Token . DIV : result . append ( " / " ) ; break ; case Token . MOD : result . append ( " % " ) ; break ; case Token . COLONCOLON : result . append ( " : : " ) ; break ; case Token . DOTDOT : result . append ( " . . " ) ; break ; case Token . DOTQUERY : result . append ( " . ( " ) ; break ; case Token . XMLATTR : result . append ( '@' ) ; break ; default : / / If we don't know how to decompile it , raise an exception . throw new RuntimeException ( "Token : " + Token . name ( source . charAt ( i ) ) ) ; } + + i ; } if ( ! toSource ) { / / add that trailing newline if it's an outermost function . if ( ! justFunctionBody ) result . append ( '\n' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ) ' ) ; } } return result . toString ( ) ; } int getNext ( String source , int length , int i ) { return ( i + 1 < length ) ? source . charAt ( i + 1 ) : Token . EOF ; } int getSourceStringEnd ( String source , int offset ) { return printSourceString ( source , offset , false , null ) ; } int printSourceString ( String source , int offset , boolean asQuotedString , StringBuffer sb ) { int length = source . charAt ( offset ) ; + + offset ; if ( ( 0x8000 & length ) ! = 0 ) { length = ( ( 0x7FFF & length ) < < 16 ) | source . charAt ( offset ) ; + + offset ; } if ( sb ! = null ) { String str = source . substring ( offset , offset + length ) ; if ( ! asQuotedString ) { sb . append ( str ) ; } else { sb . append ( '"' ) ; sb . append ( ScriptRuntime . escapeString ( str ) ) ; sb . append ( '"' ) ; } } return offset + length ; } int printSourceNumber ( String source , int offset , StringBuffer sb ) { double number = 0 . 0 ; char type = source . charAt ( offset ) ; + + offset ; if ( type = = 'S' ) { if ( sb ! = null ) { int ival = source . charAt ( offset ) ; number = ival ; } + + offset ; } else if ( type = = 'J' | | type = = 'D' ) { if ( sb ! = null ) { long lbits ; lbits = ( long ) source . charAt ( offset ) < < 48 ; lbits | = ( long ) source . charAt ( offset + 1 ) < < 32 ; lbits | = ( long ) source . charAt ( offset + 2 ) < < 16 ; lbits | = source . charAt ( offset + 3 ) ; if ( type = = 'J' ) { number = lbits ; } else { number = Double . longBitsToDouble ( lbits ) ; } } offset + = 4 ; } else { / / Bad source throw new RuntimeException ( ) ; } if ( sb ! = null ) { sb . append ( ScriptRuntime . numberToString ( number , 10 ) ) ; } return offset ; } char [ ] sourceBuffer = new char [ 128 ] ; / / Per script / function source buffer top : parent source does not include a / / nested functions source and uses function index as a reference instead . int sourceTop ; / / whether to do a debug print of the source information , when decompiling . boolean printSource = false ; }
void test20 ( ) throws Throwable { UintMap uintMap0 = new UintMap ( ) ; String string0 = Decompiler . decompile ( " ( D\u409B\u2E42\u7068\uE403h\u0001'\u0001p\u0011\u0001\u00A0" , 141 , uintMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String decompile ( String source , int flags , UintMap properties ) { int length = source . length ( ) ; if ( length = = 0 ) { return "" ; } int indent = properties . getInt ( INITIAL_INDENT_PROP , 0 ) ; if ( indent < 0 ) throw new IllegalArgumentException ( ) ; int indentGap = properties . getInt ( INDENT_GAP_PROP , 4 ) ; if ( indentGap < 0 ) throw new IllegalArgumentException ( ) ; int caseGap = properties . getInt ( CASE_GAP_PROP , 2 ) ; if ( caseGap < 0 ) throw new IllegalArgumentException ( ) ; StringBuffer result = new StringBuffer ( ) ; boolean justFunctionBody = ( 0 ! = ( flags & Decompiler . ONLY_BODY_FLAG ) ) ; boolean toSource = ( 0 ! = ( flags & Decompiler . TO_SOURCE_FLAG ) ) ; / / Spew tokens in source , for debugging . / / as TYPE number char if ( printSource ) { System . err . println ( "length : " + length ) ; for ( int i = 0 ; i < length ; + + i ) { / / Note that tokenToName will fail unless Context . printTrees / / is true . String tokenname = null ; if ( Token . printNames ) { tokenname = Token . name ( source . charAt ( i ) ) ; } if ( tokenname = = null ) { tokenname = " - - - " ; } String pad = tokenname . length ( ) > 7 ? "\t" : "\t\t" ; System . err . println ( tokenname + pad + ( int ) source . charAt ( i ) + "\t'" + ScriptRuntime . escapeString ( source . substring ( i , i + 1 ) ) + "'" ) ; } System . err . println ( ) ; } int braceNesting = 0 ; boolean afterFirstEOL = false ; int i = 0 ; int topFunctionType ; if ( source . charAt ( i ) = = Token . SCRIPT ) { + + i ; topFunctionType = - 1 ; } else { topFunctionType = source . charAt ( i + 1 ) ; } if ( ! toSource ) { / / add an initial newline to exactly match js . result . append ( '\n' ) ; for ( int j = 0 ; j < indent ; j + + ) result . append ( ' ' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ( ' ) ; } } while ( i < length ) { switch ( source . charAt ( i ) ) { case Token . GET : case Token . SET : result . append ( source . charAt ( i ) = = Token . GET ? "get " : "set " ) ; + + i ; i = printSourceString ( source , i + 1 , false , result ) ; / / Now increment one more to get past the FUNCTION token + + i ; break ; case Token . NAME : case Token . REGEXP : / / re - wrapped in ' / 's in parser . . . i = printSourceString ( source , i + 1 , false , result ) ; continue ; case Token . STRING : i = printSourceString ( source , i + 1 , true , result ) ; continue ; case Token . NUMBER : i = printSourceNumber ( source , i + 1 , result ) ; continue ; case Token . TRUE : result . append ( "true" ) ; break ; case Token . FALSE : result . append ( "false" ) ; break ; case Token . NULL : result . append ( "null" ) ; break ; case Token . THIS : result . append ( "this" ) ; break ; case Token . FUNCTION : + + i ; / / skip function type result . append ( "function " ) ; break ; case FUNCTION_END : / / Do nothing break ; case Token . COMMA : result . append ( " , " ) ; break ; case Token . LC : + + braceNesting ; if ( Token . EOL = = getNext ( source , length , i ) ) indent + = indentGap ; result . append ( ' { ' ) ; break ; case Token . RC : { - - braceNesting ; / * don't print the closing RC if it closes the * toplevel function and we're called from * decompileFunctionBody . * / if ( justFunctionBody & & braceNesting = = 0 ) break ; result . append ( ' } ' ) ; switch ( getNext ( source , length , i ) ) { case Token . EOL : case FUNCTION_END : indent - = indentGap ; break ; case Token . WHILE : case Token . ELSE : indent - = indentGap ; result . append ( ' ' ) ; break ; } break ; } case Token . LP : result . append ( ' ( ' ) ; break ; case Token . RP : result . append ( ' ) ' ) ; if ( Token . LC = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . LB : result . append ( ' [ ' ) ; break ; case Token . RB : result . append ( ' ] ' ) ; break ; case Token . EOL : { if ( toSource ) break ; boolean newLine = true ; if ( ! afterFirstEOL ) { afterFirstEOL = true ; if ( justFunctionBody ) { / * throw away just added 'function name ( . . . ) { ' * and restore the original indent * / result . setLength ( 0 ) ; indent - = indentGap ; newLine = false ; } } if ( newLine ) { result . append ( '\n' ) ; } / * add indent if any tokens remain , * less setback if next token is * a label , case or default . * / if ( i + 1 < length ) { int less = 0 ; int nextToken = source . charAt ( i + 1 ) ; if ( nextToken = = Token . CASE | | nextToken = = Token . DEFAULT ) { less = indentGap - caseGap ; } else if ( nextToken = = Token . RC ) { less = indentGap ; } / * elaborate check against label . . . skip past a * following inlined NAME and look for a COLON . * / else if ( nextToken = = Token . NAME ) { int afterName = getSourceStringEnd ( source , i + 2 ) ; if ( source . charAt ( afterName ) = = Token . COLON ) less = indentGap ; } for ( ; less < indent ; less + + ) result . append ( ' ' ) ; } break ; } case Token . DOT : result . append ( ' . ' ) ; break ; case Token . NEW : result . append ( "new " ) ; break ; case Token . DELPROP : result . append ( "delete " ) ; break ; case Token . IF : result . append ( "if " ) ; break ; case Token . ELSE : result . append ( "else " ) ; break ; case Token . FOR : result . append ( "for " ) ; break ; case Token . IN : result . append ( " in " ) ; break ; case Token . WITH : result . append ( "with " ) ; break ; case Token . WHILE : result . append ( "while " ) ; break ; case Token . DO : result . append ( "do " ) ; break ; case Token . TRY : result . append ( "try " ) ; break ; case Token . CATCH : result . append ( "catch " ) ; break ; case Token . FINALLY : result . append ( "finally " ) ; break ; case Token . THROW : result . append ( "throw " ) ; break ; case Token . SWITCH : result . append ( "switch " ) ; break ; case Token . BREAK : result . append ( "break" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CONTINUE : result . append ( "continue" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CASE : result . append ( "case " ) ; break ; case Token . DEFAULT : result . append ( "default" ) ; break ; case Token . RETURN : result . append ( "return" ) ; if ( Token . SEMI ! = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . VAR : result . append ( "var " ) ; break ; case Token . LET : result . append ( "let " ) ; break ; case Token . SEMI : result . append ( ' ; ' ) ; if ( Token . EOL ! = getNext ( source , length , i ) ) { / / separators in FOR result . append ( ' ' ) ; } break ; case Token . ASSIGN : result . append ( " = " ) ; break ; case Token . ASSIGN_ADD : result . append ( " + = " ) ; break ; case Token . ASSIGN_SUB : result . append ( " - = " ) ; break ; case Token . ASSIGN_MUL : result . append ( " * = " ) ; break ; case Token . ASSIGN_DIV : result . append ( " / = " ) ; break ; case Token . ASSIGN_MOD : result . append ( " % = " ) ; break ; case Token . ASSIGN_BITOR : result . append ( " | = " ) ; break ; case Token . ASSIGN_BITXOR : result . append ( " ^ = " ) ; break ; case Token . ASSIGN_BITAND : result . append ( " & = " ) ; break ; case Token . ASSIGN_LSH : result . append ( " < < = " ) ; break ; case Token . ASSIGN_RSH : result . append ( " > > = " ) ; break ; case Token . ASSIGN_URSH : result . append ( " > > > = " ) ; break ; case Token . HOOK : result . append ( " ? " ) ; break ; case Token . OBJECTLIT : / / pun OBJECTLIT to mean colon in objlit property / / initialization . / / This needs to be distinct from COLON in the general case / / to distinguish from the colon in a ternary . . . which needs / / different spacing . result . append ( ' : ' ) ; break ; case Token . COLON : if ( Token . EOL = = getNext ( source , length , i ) ) / / it's the end of a label result . append ( ' : ' ) ; else / / it's the middle part of a ternary result . append ( " : " ) ; break ; case Token . OR : result . append ( " | | " ) ; break ; case Token . AND : result . append ( " & & " ) ; break ; case Token . BITOR : result . append ( " | " ) ; break ; case Token . BITXOR : result . append ( " ^ " ) ; break ; case Token . BITAND : result . append ( " & " ) ; break ; case Token . SHEQ : result . append ( " = = = " ) ; break ; case Token . SHNE : result . append ( " ! = = " ) ; break ; case Token . EQ : result . append ( " = = " ) ; break ; case Token . NE : result . append ( " ! = " ) ; break ; case Token . LE : result . append ( " < = " ) ; break ; case Token . LT : result . append ( " < " ) ; break ; case Token . GE : result . append ( " > = " ) ; break ; case Token . GT : result . append ( " > " ) ; break ; case Token . INSTANCEOF : result . append ( " instanceof " ) ; break ; case Token . LSH : result . append ( " < < " ) ; break ; case Token . RSH : result . append ( " > > " ) ; break ; case Token . URSH : result . append ( " > > > " ) ; break ; case Token . TYPEOF : result . append ( "typeof " ) ; break ; case Token . VOID : result . append ( "void " ) ; break ; case Token . CONST : result . append ( "const " ) ; break ; case Token . YIELD : result . append ( "yield " ) ; break ; case Token . NOT : result . append ( ' ! ' ) ; break ; case Token . BITNOT : result . append ( '~' ) ; break ; case Token . POS : result . append ( ' + ' ) ; break ; case Token . NEG : result . append ( ' - ' ) ; break ; case Token . INC : result . append ( " + + " ) ; break ; case Token . DEC : result . append ( " - - " ) ; break ; case Token . ADD : result . append ( " + " ) ; break ; case Token . SUB : result . append ( " - " ) ; break ; case Token . MUL : result . append ( " * " ) ; break ; case Token . DIV : result . append ( " / " ) ; break ; case Token . MOD : result . append ( " % " ) ; break ; case Token . COLONCOLON : result . append ( " : : " ) ; break ; case Token . DOTDOT : result . append ( " . . " ) ; break ; case Token . DOTQUERY : result . append ( " . ( " ) ; break ; case Token . XMLATTR : result . append ( '@' ) ; break ; default : / / If we don't know how to decompile it , raise an exception . throw new RuntimeException ( "Token : " + Token . name ( source . charAt ( i ) ) ) ; } + + i ; } if ( ! toSource ) { / / add that trailing newline if it's an outermost function . if ( ! justFunctionBody ) result . append ( '\n' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ) ' ) ; } } return result . toString ( ) ; } int getNext ( String source , int length , int i ) { return ( i + 1 < length ) ? source . charAt ( i + 1 ) : Token . EOF ; } int getSourceStringEnd ( String source , int offset ) { return printSourceString ( source , offset , false , null ) ; } int printSourceString ( String source , int offset , boolean asQuotedString , StringBuffer sb ) { int length = source . charAt ( offset ) ; + + offset ; if ( ( 0x8000 & length ) ! = 0 ) { length = ( ( 0x7FFF & length ) < < 16 ) | source . charAt ( offset ) ; + + offset ; } if ( sb ! = null ) { String str = source . substring ( offset , offset + length ) ; if ( ! asQuotedString ) { sb . append ( str ) ; } else { sb . append ( '"' ) ; sb . append ( ScriptRuntime . escapeString ( str ) ) ; sb . append ( '"' ) ; } } return offset + length ; } int printSourceNumber ( String source , int offset , StringBuffer sb ) { double number = 0 . 0 ; char type = source . charAt ( offset ) ; + + offset ; if ( type = = 'S' ) { if ( sb ! = null ) { int ival = source . charAt ( offset ) ; number = ival ; } + + offset ; } else if ( type = = 'J' | | type = = 'D' ) { if ( sb ! = null ) { long lbits ; lbits = ( long ) source . charAt ( offset ) < < 48 ; lbits | = ( long ) source . charAt ( offset + 1 ) < < 32 ; lbits | = ( long ) source . charAt ( offset + 2 ) < < 16 ; lbits | = source . charAt ( offset + 3 ) ; if ( type = = 'J' ) { number = lbits ; } else { number = Double . longBitsToDouble ( lbits ) ; } } offset + = 4 ; } else { / / Bad source throw new RuntimeException ( ) ; } if ( sb ! = null ) { sb . append ( ScriptRuntime . numberToString ( number , 10 ) ) ; } return offset ; } char [ ] sourceBuffer = new char [ 128 ] ; / / Per script / function source buffer top : parent source does not include a / / nested functions source and uses function index as a reference instead . int sourceTop ; / / whether to do a debug print of the source information , when decompiling . boolean printSource = false ; }
void test21 ( ) throws Throwable { UintMap uintMap0 = new UintMap ( 27 ) ; String string0 = Decompiler . decompile ( "l\u0458 ( J#\u86F2\u6FC1\u0014'\u0011N6D ] { Yulrh & F9 . FT2l\u0000\u001B\u0001 ( S\u001B0$ / N6D ] { Yulrh & F9 . FT2 / N6D ] { Yulrh & F9 . FT2" , 0 , uintMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String decompile ( String source , int flags , UintMap properties ) { int length = source . length ( ) ; if ( length = = 0 ) { return "" ; } int indent = properties . getInt ( INITIAL_INDENT_PROP , 0 ) ; if ( indent < 0 ) throw new IllegalArgumentException ( ) ; int indentGap = properties . getInt ( INDENT_GAP_PROP , 4 ) ; if ( indentGap < 0 ) throw new IllegalArgumentException ( ) ; int caseGap = properties . getInt ( CASE_GAP_PROP , 2 ) ; if ( caseGap < 0 ) throw new IllegalArgumentException ( ) ; StringBuffer result = new StringBuffer ( ) ; boolean justFunctionBody = ( 0 ! = ( flags & Decompiler . ONLY_BODY_FLAG ) ) ; boolean toSource = ( 0 ! = ( flags & Decompiler . TO_SOURCE_FLAG ) ) ; / / Spew tokens in source , for debugging . / / as TYPE number char if ( printSource ) { System . err . println ( "length : " + length ) ; for ( int i = 0 ; i < length ; + + i ) { / / Note that tokenToName will fail unless Context . printTrees / / is true . String tokenname = null ; if ( Token . printNames ) { tokenname = Token . name ( source . charAt ( i ) ) ; } if ( tokenname = = null ) { tokenname = " - - - " ; } String pad = tokenname . length ( ) > 7 ? "\t" : "\t\t" ; System . err . println ( tokenname + pad + ( int ) source . charAt ( i ) + "\t'" + ScriptRuntime . escapeString ( source . substring ( i , i + 1 ) ) + "'" ) ; } System . err . println ( ) ; } int braceNesting = 0 ; boolean afterFirstEOL = false ; int i = 0 ; int topFunctionType ; if ( source . charAt ( i ) = = Token . SCRIPT ) { + + i ; topFunctionType = - 1 ; } else { topFunctionType = source . charAt ( i + 1 ) ; } if ( ! toSource ) { / / add an initial newline to exactly match js . result . append ( '\n' ) ; for ( int j = 0 ; j < indent ; j + + ) result . append ( ' ' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ( ' ) ; } } while ( i < length ) { switch ( source . charAt ( i ) ) { case Token . GET : case Token . SET : result . append ( source . charAt ( i ) = = Token . GET ? "get " : "set " ) ; + + i ; i = printSourceString ( source , i + 1 , false , result ) ; / / Now increment one more to get past the FUNCTION token + + i ; break ; case Token . NAME : case Token . REGEXP : / / re - wrapped in ' / 's in parser . . . i = printSourceString ( source , i + 1 , false , result ) ; continue ; case Token . STRING : i = printSourceString ( source , i + 1 , true , result ) ; continue ; case Token . NUMBER : i = printSourceNumber ( source , i + 1 , result ) ; continue ; case Token . TRUE : result . append ( "true" ) ; break ; case Token . FALSE : result . append ( "false" ) ; break ; case Token . NULL : result . append ( "null" ) ; break ; case Token . THIS : result . append ( "this" ) ; break ; case Token . FUNCTION : + + i ; / / skip function type result . append ( "function " ) ; break ; case FUNCTION_END : / / Do nothing break ; case Token . COMMA : result . append ( " , " ) ; break ; case Token . LC : + + braceNesting ; if ( Token . EOL = = getNext ( source , length , i ) ) indent + = indentGap ; result . append ( ' { ' ) ; break ; case Token . RC : { - - braceNesting ; / * don't print the closing RC if it closes the * toplevel function and we're called from * decompileFunctionBody . * / if ( justFunctionBody & & braceNesting = = 0 ) break ; result . append ( ' } ' ) ; switch ( getNext ( source , length , i ) ) { case Token . EOL : case FUNCTION_END : indent - = indentGap ; break ; case Token . WHILE : case Token . ELSE : indent - = indentGap ; result . append ( ' ' ) ; break ; } break ; } case Token . LP : result . append ( ' ( ' ) ; break ; case Token . RP : result . append ( ' ) ' ) ; if ( Token . LC = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . LB : result . append ( ' [ ' ) ; break ; case Token . RB : result . append ( ' ] ' ) ; break ; case Token . EOL : { if ( toSource ) break ; boolean newLine = true ; if ( ! afterFirstEOL ) { afterFirstEOL = true ; if ( justFunctionBody ) { / * throw away just added 'function name ( . . . ) { ' * and restore the original indent * / result . setLength ( 0 ) ; indent - = indentGap ; newLine = false ; } } if ( newLine ) { result . append ( '\n' ) ; } / * add indent if any tokens remain , * less setback if next token is * a label , case or default . * / if ( i + 1 < length ) { int less = 0 ; int nextToken = source . charAt ( i + 1 ) ; if ( nextToken = = Token . CASE | | nextToken = = Token . DEFAULT ) { less = indentGap - caseGap ; } else if ( nextToken = = Token . RC ) { less = indentGap ; } / * elaborate check against label . . . skip past a * following inlined NAME and look for a COLON . * / else if ( nextToken = = Token . NAME ) { int afterName = getSourceStringEnd ( source , i + 2 ) ; if ( source . charAt ( afterName ) = = Token . COLON ) less = indentGap ; } for ( ; less < indent ; less + + ) result . append ( ' ' ) ; } break ; } case Token . DOT : result . append ( ' . ' ) ; break ; case Token . NEW : result . append ( "new " ) ; break ; case Token . DELPROP : result . append ( "delete " ) ; break ; case Token . IF : result . append ( "if " ) ; break ; case Token . ELSE : result . append ( "else " ) ; break ; case Token . FOR : result . append ( "for " ) ; break ; case Token . IN : result . append ( " in " ) ; break ; case Token . WITH : result . append ( "with " ) ; break ; case Token . WHILE : result . append ( "while " ) ; break ; case Token . DO : result . append ( "do " ) ; break ; case Token . TRY : result . append ( "try " ) ; break ; case Token . CATCH : result . append ( "catch " ) ; break ; case Token . FINALLY : result . append ( "finally " ) ; break ; case Token . THROW : result . append ( "throw " ) ; break ; case Token . SWITCH : result . append ( "switch " ) ; break ; case Token . BREAK : result . append ( "break" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CONTINUE : result . append ( "continue" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CASE : result . append ( "case " ) ; break ; case Token . DEFAULT : result . append ( "default" ) ; break ; case Token . RETURN : result . append ( "return" ) ; if ( Token . SEMI ! = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . VAR : result . append ( "var " ) ; break ; case Token . LET : result . append ( "let " ) ; break ; case Token . SEMI : result . append ( ' ; ' ) ; if ( Token . EOL ! = getNext ( source , length , i ) ) { / / separators in FOR result . append ( ' ' ) ; } break ; case Token . ASSIGN : result . append ( " = " ) ; break ; case Token . ASSIGN_ADD : result . append ( " + = " ) ; break ; case Token . ASSIGN_SUB : result . append ( " - = " ) ; break ; case Token . ASSIGN_MUL : result . append ( " * = " ) ; break ; case Token . ASSIGN_DIV : result . append ( " / = " ) ; break ; case Token . ASSIGN_MOD : result . append ( " % = " ) ; break ; case Token . ASSIGN_BITOR : result . append ( " | = " ) ; break ; case Token . ASSIGN_BITXOR : result . append ( " ^ = " ) ; break ; case Token . ASSIGN_BITAND : result . append ( " & = " ) ; break ; case Token . ASSIGN_LSH : result . append ( " < < = " ) ; break ; case Token . ASSIGN_RSH : result . append ( " > > = " ) ; break ; case Token . ASSIGN_URSH : result . append ( " > > > = " ) ; break ; case Token . HOOK : result . append ( " ? " ) ; break ; case Token . OBJECTLIT : / / pun OBJECTLIT to mean colon in objlit property / / initialization . / / This needs to be distinct from COLON in the general case / / to distinguish from the colon in a ternary . . . which needs / / different spacing . result . append ( ' : ' ) ; break ; case Token . COLON : if ( Token . EOL = = getNext ( source , length , i ) ) / / it's the end of a label result . append ( ' : ' ) ; else / / it's the middle part of a ternary result . append ( " : " ) ; break ; case Token . OR : result . append ( " | | " ) ; break ; case Token . AND : result . append ( " & & " ) ; break ; case Token . BITOR : result . append ( " | " ) ; break ; case Token . BITXOR : result . append ( " ^ " ) ; break ; case Token . BITAND : result . append ( " & " ) ; break ; case Token . SHEQ : result . append ( " = = = " ) ; break ; case Token . SHNE : result . append ( " ! = = " ) ; break ; case Token . EQ : result . append ( " = = " ) ; break ; case Token . NE : result . append ( " ! = " ) ; break ; case Token . LE : result . append ( " < = " ) ; break ; case Token . LT : result . append ( " < " ) ; break ; case Token . GE : result . append ( " > = " ) ; break ; case Token . GT : result . append ( " > " ) ; break ; case Token . INSTANCEOF : result . append ( " instanceof " ) ; break ; case Token . LSH : result . append ( " < < " ) ; break ; case Token . RSH : result . append ( " > > " ) ; break ; case Token . URSH : result . append ( " > > > " ) ; break ; case Token . TYPEOF : result . append ( "typeof " ) ; break ; case Token . VOID : result . append ( "void " ) ; break ; case Token . CONST : result . append ( "const " ) ; break ; case Token . YIELD : result . append ( "yield " ) ; break ; case Token . NOT : result . append ( ' ! ' ) ; break ; case Token . BITNOT : result . append ( '~' ) ; break ; case Token . POS : result . append ( ' + ' ) ; break ; case Token . NEG : result . append ( ' - ' ) ; break ; case Token . INC : result . append ( " + + " ) ; break ; case Token . DEC : result . append ( " - - " ) ; break ; case Token . ADD : result . append ( " + " ) ; break ; case Token . SUB : result . append ( " - " ) ; break ; case Token . MUL : result . append ( " * " ) ; break ; case Token . DIV : result . append ( " / " ) ; break ; case Token . MOD : result . append ( " % " ) ; break ; case Token . COLONCOLON : result . append ( " : : " ) ; break ; case Token . DOTDOT : result . append ( " . . " ) ; break ; case Token . DOTQUERY : result . append ( " . ( " ) ; break ; case Token . XMLATTR : result . append ( '@' ) ; break ; default : / / If we don't know how to decompile it , raise an exception . throw new RuntimeException ( "Token : " + Token . name ( source . charAt ( i ) ) ) ; } + + i ; } if ( ! toSource ) { / / add that trailing newline if it's an outermost function . if ( ! justFunctionBody ) result . append ( '\n' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ) ' ) ; } } return result . toString ( ) ; } int getNext ( String source , int length , int i ) { return ( i + 1 < length ) ? source . charAt ( i + 1 ) : Token . EOF ; } int getSourceStringEnd ( String source , int offset ) { return printSourceString ( source , offset , false , null ) ; } int printSourceString ( String source , int offset , boolean asQuotedString , StringBuffer sb ) { int length = source . charAt ( offset ) ; + + offset ; if ( ( 0x8000 & length ) ! = 0 ) { length = ( ( 0x7FFF & length ) < < 16 ) | source . charAt ( offset ) ; + + offset ; } if ( sb ! = null ) { String str = source . substring ( offset , offset + length ) ; if ( ! asQuotedString ) { sb . append ( str ) ; } else { sb . append ( '"' ) ; sb . append ( ScriptRuntime . escapeString ( str ) ) ; sb . append ( '"' ) ; } } return offset + length ; } int printSourceNumber ( String source , int offset , StringBuffer sb ) { double number = 0 . 0 ; char type = source . charAt ( offset ) ; + + offset ; if ( type = = 'S' ) { if ( sb ! = null ) { int ival = source . charAt ( offset ) ; number = ival ; } + + offset ; } else if ( type = = 'J' | | type = = 'D' ) { if ( sb ! = null ) { long lbits ; lbits = ( long ) source . charAt ( offset ) < < 48 ; lbits | = ( long ) source . charAt ( offset + 1 ) < < 32 ; lbits | = ( long ) source . charAt ( offset + 2 ) < < 16 ; lbits | = source . charAt ( offset + 3 ) ; if ( type = = 'J' ) { number = lbits ; } else { number = Double . longBitsToDouble ( lbits ) ; } } offset + = 4 ; } else { / / Bad source throw new RuntimeException ( ) ; } if ( sb ! = null ) { sb . append ( ScriptRuntime . numberToString ( number , 10 ) ) ; } return offset ; } char [ ] sourceBuffer = new char [ 128 ] ; / / Per script / function source buffer top : parent source does not include a / / nested functions source and uses function index as a reference instead . int sourceTop ; / / whether to do a debug print of the source information , when decompiling . boolean printSource = false ; }
void test28 ( ) throws Throwable { UintMap uintMap0 = new UintMap ( ) ; String string0 = Decompiler . decompile ( " ) \u000B , : r%U - ` - wdj ( STT\u0001 ) \u000B , : r%U - ` - wdj\u00A0" , 168 , uintMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String decompile ( String source , int flags , UintMap properties ) { int length = source . length ( ) ; if ( length = = 0 ) { return "" ; } int indent = properties . getInt ( INITIAL_INDENT_PROP , 0 ) ; if ( indent < 0 ) throw new IllegalArgumentException ( ) ; int indentGap = properties . getInt ( INDENT_GAP_PROP , 4 ) ; if ( indentGap < 0 ) throw new IllegalArgumentException ( ) ; int caseGap = properties . getInt ( CASE_GAP_PROP , 2 ) ; if ( caseGap < 0 ) throw new IllegalArgumentException ( ) ; StringBuffer result = new StringBuffer ( ) ; boolean justFunctionBody = ( 0 ! = ( flags & Decompiler . ONLY_BODY_FLAG ) ) ; boolean toSource = ( 0 ! = ( flags & Decompiler . TO_SOURCE_FLAG ) ) ; / / Spew tokens in source , for debugging . / / as TYPE number char if ( printSource ) { System . err . println ( "length : " + length ) ; for ( int i = 0 ; i < length ; + + i ) { / / Note that tokenToName will fail unless Context . printTrees / / is true . String tokenname = null ; if ( Token . printNames ) { tokenname = Token . name ( source . charAt ( i ) ) ; } if ( tokenname = = null ) { tokenname = " - - - " ; } String pad = tokenname . length ( ) > 7 ? "\t" : "\t\t" ; System . err . println ( tokenname + pad + ( int ) source . charAt ( i ) + "\t'" + ScriptRuntime . escapeString ( source . substring ( i , i + 1 ) ) + "'" ) ; } System . err . println ( ) ; } int braceNesting = 0 ; boolean afterFirstEOL = false ; int i = 0 ; int topFunctionType ; if ( source . charAt ( i ) = = Token . SCRIPT ) { + + i ; topFunctionType = - 1 ; } else { topFunctionType = source . charAt ( i + 1 ) ; } if ( ! toSource ) { / / add an initial newline to exactly match js . result . append ( '\n' ) ; for ( int j = 0 ; j < indent ; j + + ) result . append ( ' ' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ( ' ) ; } } while ( i < length ) { switch ( source . charAt ( i ) ) { case Token . GET : case Token . SET : result . append ( source . charAt ( i ) = = Token . GET ? "get " : "set " ) ; + + i ; i = printSourceString ( source , i + 1 , false , result ) ; / / Now increment one more to get past the FUNCTION token + + i ; break ; case Token . NAME : case Token . REGEXP : / / re - wrapped in ' / 's in parser . . . i = printSourceString ( source , i + 1 , false , result ) ; continue ; case Token . STRING : i = printSourceString ( source , i + 1 , true , result ) ; continue ; case Token . NUMBER : i = printSourceNumber ( source , i + 1 , result ) ; continue ; case Token . TRUE : result . append ( "true" ) ; break ; case Token . FALSE : result . append ( "false" ) ; break ; case Token . NULL : result . append ( "null" ) ; break ; case Token . THIS : result . append ( "this" ) ; break ; case Token . FUNCTION : + + i ; / / skip function type result . append ( "function " ) ; break ; case FUNCTION_END : / / Do nothing break ; case Token . COMMA : result . append ( " , " ) ; break ; case Token . LC : + + braceNesting ; if ( Token . EOL = = getNext ( source , length , i ) ) indent + = indentGap ; result . append ( ' { ' ) ; break ; case Token . RC : { - - braceNesting ; / * don't print the closing RC if it closes the * toplevel function and we're called from * decompileFunctionBody . * / if ( justFunctionBody & & braceNesting = = 0 ) break ; result . append ( ' } ' ) ; switch ( getNext ( source , length , i ) ) { case Token . EOL : case FUNCTION_END : indent - = indentGap ; break ; case Token . WHILE : case Token . ELSE : indent - = indentGap ; result . append ( ' ' ) ; break ; } break ; } case Token . LP : result . append ( ' ( ' ) ; break ; case Token . RP : result . append ( ' ) ' ) ; if ( Token . LC = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . LB : result . append ( ' [ ' ) ; break ; case Token . RB : result . append ( ' ] ' ) ; break ; case Token . EOL : { if ( toSource ) break ; boolean newLine = true ; if ( ! afterFirstEOL ) { afterFirstEOL = true ; if ( justFunctionBody ) { / * throw away just added 'function name ( . . . ) { ' * and restore the original indent * / result . setLength ( 0 ) ; indent - = indentGap ; newLine = false ; } } if ( newLine ) { result . append ( '\n' ) ; } / * add indent if any tokens remain , * less setback if next token is * a label , case or default . * / if ( i + 1 < length ) { int less = 0 ; int nextToken = source . charAt ( i + 1 ) ; if ( nextToken = = Token . CASE | | nextToken = = Token . DEFAULT ) { less = indentGap - caseGap ; } else if ( nextToken = = Token . RC ) { less = indentGap ; } / * elaborate check against label . . . skip past a * following inlined NAME and look for a COLON . * / else if ( nextToken = = Token . NAME ) { int afterName = getSourceStringEnd ( source , i + 2 ) ; if ( source . charAt ( afterName ) = = Token . COLON ) less = indentGap ; } for ( ; less < indent ; less + + ) result . append ( ' ' ) ; } break ; } case Token . DOT : result . append ( ' . ' ) ; break ; case Token . NEW : result . append ( "new " ) ; break ; case Token . DELPROP : result . append ( "delete " ) ; break ; case Token . IF : result . append ( "if " ) ; break ; case Token . ELSE : result . append ( "else " ) ; break ; case Token . FOR : result . append ( "for " ) ; break ; case Token . IN : result . append ( " in " ) ; break ; case Token . WITH : result . append ( "with " ) ; break ; case Token . WHILE : result . append ( "while " ) ; break ; case Token . DO : result . append ( "do " ) ; break ; case Token . TRY : result . append ( "try " ) ; break ; case Token . CATCH : result . append ( "catch " ) ; break ; case Token . FINALLY : result . append ( "finally " ) ; break ; case Token . THROW : result . append ( "throw " ) ; break ; case Token . SWITCH : result . append ( "switch " ) ; break ; case Token . BREAK : result . append ( "break" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CONTINUE : result . append ( "continue" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CASE : result . append ( "case " ) ; break ; case Token . DEFAULT : result . append ( "default" ) ; break ; case Token . RETURN : result . append ( "return" ) ; if ( Token . SEMI ! = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . VAR : result . append ( "var " ) ; break ; case Token . LET : result . append ( "let " ) ; break ; case Token . SEMI : result . append ( ' ; ' ) ; if ( Token . EOL ! = getNext ( source , length , i ) ) { / / separators in FOR result . append ( ' ' ) ; } break ; case Token . ASSIGN : result . append ( " = " ) ; break ; case Token . ASSIGN_ADD : result . append ( " + = " ) ; break ; case Token . ASSIGN_SUB : result . append ( " - = " ) ; break ; case Token . ASSIGN_MUL : result . append ( " * = " ) ; break ; case Token . ASSIGN_DIV : result . append ( " / = " ) ; break ; case Token . ASSIGN_MOD : result . append ( " % = " ) ; break ; case Token . ASSIGN_BITOR : result . append ( " | = " ) ; break ; case Token . ASSIGN_BITXOR : result . append ( " ^ = " ) ; break ; case Token . ASSIGN_BITAND : result . append ( " & = " ) ; break ; case Token . ASSIGN_LSH : result . append ( " < < = " ) ; break ; case Token . ASSIGN_RSH : result . append ( " > > = " ) ; break ; case Token . ASSIGN_URSH : result . append ( " > > > = " ) ; break ; case Token . HOOK : result . append ( " ? " ) ; break ; case Token . OBJECTLIT : / / pun OBJECTLIT to mean colon in objlit property / / initialization . / / This needs to be distinct from COLON in the general case / / to distinguish from the colon in a ternary . . . which needs / / different spacing . result . append ( ' : ' ) ; break ; case Token . COLON : if ( Token . EOL = = getNext ( source , length , i ) ) / / it's the end of a label result . append ( ' : ' ) ; else / / it's the middle part of a ternary result . append ( " : " ) ; break ; case Token . OR : result . append ( " | | " ) ; break ; case Token . AND : result . append ( " & & " ) ; break ; case Token . BITOR : result . append ( " | " ) ; break ; case Token . BITXOR : result . append ( " ^ " ) ; break ; case Token . BITAND : result . append ( " & " ) ; break ; case Token . SHEQ : result . append ( " = = = " ) ; break ; case Token . SHNE : result . append ( " ! = = " ) ; break ; case Token . EQ : result . append ( " = = " ) ; break ; case Token . NE : result . append ( " ! = " ) ; break ; case Token . LE : result . append ( " < = " ) ; break ; case Token . LT : result . append ( " < " ) ; break ; case Token . GE : result . append ( " > = " ) ; break ; case Token . GT : result . append ( " > " ) ; break ; case Token . INSTANCEOF : result . append ( " instanceof " ) ; break ; case Token . LSH : result . append ( " < < " ) ; break ; case Token . RSH : result . append ( " > > " ) ; break ; case Token . URSH : result . append ( " > > > " ) ; break ; case Token . TYPEOF : result . append ( "typeof " ) ; break ; case Token . VOID : result . append ( "void " ) ; break ; case Token . CONST : result . append ( "const " ) ; break ; case Token . YIELD : result . append ( "yield " ) ; break ; case Token . NOT : result . append ( ' ! ' ) ; break ; case Token . BITNOT : result . append ( '~' ) ; break ; case Token . POS : result . append ( ' + ' ) ; break ; case Token . NEG : result . append ( ' - ' ) ; break ; case Token . INC : result . append ( " + + " ) ; break ; case Token . DEC : result . append ( " - - " ) ; break ; case Token . ADD : result . append ( " + " ) ; break ; case Token . SUB : result . append ( " - " ) ; break ; case Token . MUL : result . append ( " * " ) ; break ; case Token . DIV : result . append ( " / " ) ; break ; case Token . MOD : result . append ( " % " ) ; break ; case Token . COLONCOLON : result . append ( " : : " ) ; break ; case Token . DOTDOT : result . append ( " . . " ) ; break ; case Token . DOTQUERY : result . append ( " . ( " ) ; break ; case Token . XMLATTR : result . append ( '@' ) ; break ; default : / / If we don't know how to decompile it , raise an exception . throw new RuntimeException ( "Token : " + Token . name ( source . charAt ( i ) ) ) ; } + + i ; } if ( ! toSource ) { / / add that trailing newline if it's an outermost function . if ( ! justFunctionBody ) result . append ( '\n' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ) ' ) ; } } return result . toString ( ) ; } int getNext ( String source , int length , int i ) { return ( i + 1 < length ) ? source . charAt ( i + 1 ) : Token . EOF ; } int getSourceStringEnd ( String source , int offset ) { return printSourceString ( source , offset , false , null ) ; } int printSourceString ( String source , int offset , boolean asQuotedString , StringBuffer sb ) { int length = source . charAt ( offset ) ; + + offset ; if ( ( 0x8000 & length ) ! = 0 ) { length = ( ( 0x7FFF & length ) < < 16 ) | source . charAt ( offset ) ; + + offset ; } if ( sb ! = null ) { String str = source . substring ( offset , offset + length ) ; if ( ! asQuotedString ) { sb . append ( str ) ; } else { sb . append ( '"' ) ; sb . append ( ScriptRuntime . escapeString ( str ) ) ; sb . append ( '"' ) ; } } return offset + length ; } int printSourceNumber ( String source , int offset , StringBuffer sb ) { double number = 0 . 0 ; char type = source . charAt ( offset ) ; + + offset ; if ( type = = 'S' ) { if ( sb ! = null ) { int ival = source . charAt ( offset ) ; number = ival ; } + + offset ; } else if ( type = = 'J' | | type = = 'D' ) { if ( sb ! = null ) { long lbits ; lbits = ( long ) source . charAt ( offset ) < < 48 ; lbits | = ( long ) source . charAt ( offset + 1 ) < < 32 ; lbits | = ( long ) source . charAt ( offset + 2 ) < < 16 ; lbits | = source . charAt ( offset + 3 ) ; if ( type = = 'J' ) { number = lbits ; } else { number = Double . longBitsToDouble ( lbits ) ; } } offset + = 4 ; } else { / / Bad source throw new RuntimeException ( ) ; } if ( sb ! = null ) { sb . append ( ScriptRuntime . numberToString ( number , 10 ) ) ; } return offset ; } char [ ] sourceBuffer = new char [ 128 ] ; / / Per script / function source buffer top : parent source does not include a / / nested functions source and uses function index as a reference instead . int sourceTop ; / / whether to do a debug print of the source information , when decompiling . boolean printSource = false ; }
void test29 ( ) throws Throwable { UintMap uintMap0 = new UintMap ( 0 ) ; String string0 = Decompiler . decompile ( "yP * ^ . x" , 0 , uintMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String decompile ( String source , int flags , UintMap properties ) { int length = source . length ( ) ; if ( length = = 0 ) { return "" ; } int indent = properties . getInt ( INITIAL_INDENT_PROP , 0 ) ; if ( indent < 0 ) throw new IllegalArgumentException ( ) ; int indentGap = properties . getInt ( INDENT_GAP_PROP , 4 ) ; if ( indentGap < 0 ) throw new IllegalArgumentException ( ) ; int caseGap = properties . getInt ( CASE_GAP_PROP , 2 ) ; if ( caseGap < 0 ) throw new IllegalArgumentException ( ) ; StringBuffer result = new StringBuffer ( ) ; boolean justFunctionBody = ( 0 ! = ( flags & Decompiler . ONLY_BODY_FLAG ) ) ; boolean toSource = ( 0 ! = ( flags & Decompiler . TO_SOURCE_FLAG ) ) ; / / Spew tokens in source , for debugging . / / as TYPE number char if ( printSource ) { System . err . println ( "length : " + length ) ; for ( int i = 0 ; i < length ; + + i ) { / / Note that tokenToName will fail unless Context . printTrees / / is true . String tokenname = null ; if ( Token . printNames ) { tokenname = Token . name ( source . charAt ( i ) ) ; } if ( tokenname = = null ) { tokenname = " - - - " ; } String pad = tokenname . length ( ) > 7 ? "\t" : "\t\t" ; System . err . println ( tokenname + pad + ( int ) source . charAt ( i ) + "\t'" + ScriptRuntime . escapeString ( source . substring ( i , i + 1 ) ) + "'" ) ; } System . err . println ( ) ; } int braceNesting = 0 ; boolean afterFirstEOL = false ; int i = 0 ; int topFunctionType ; if ( source . charAt ( i ) = = Token . SCRIPT ) { + + i ; topFunctionType = - 1 ; } else { topFunctionType = source . charAt ( i + 1 ) ; } if ( ! toSource ) { / / add an initial newline to exactly match js . result . append ( '\n' ) ; for ( int j = 0 ; j < indent ; j + + ) result . append ( ' ' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ( ' ) ; } } while ( i < length ) { switch ( source . charAt ( i ) ) { case Token . GET : case Token . SET : result . append ( source . charAt ( i ) = = Token . GET ? "get " : "set " ) ; + + i ; i = printSourceString ( source , i + 1 , false , result ) ; / / Now increment one more to get past the FUNCTION token + + i ; break ; case Token . NAME : case Token . REGEXP : / / re - wrapped in ' / 's in parser . . . i = printSourceString ( source , i + 1 , false , result ) ; continue ; case Token . STRING : i = printSourceString ( source , i + 1 , true , result ) ; continue ; case Token . NUMBER : i = printSourceNumber ( source , i + 1 , result ) ; continue ; case Token . TRUE : result . append ( "true" ) ; break ; case Token . FALSE : result . append ( "false" ) ; break ; case Token . NULL : result . append ( "null" ) ; break ; case Token . THIS : result . append ( "this" ) ; break ; case Token . FUNCTION : + + i ; / / skip function type result . append ( "function " ) ; break ; case FUNCTION_END : / / Do nothing break ; case Token . COMMA : result . append ( " , " ) ; break ; case Token . LC : + + braceNesting ; if ( Token . EOL = = getNext ( source , length , i ) ) indent + = indentGap ; result . append ( ' { ' ) ; break ; case Token . RC : { - - braceNesting ; / * don't print the closing RC if it closes the * toplevel function and we're called from * decompileFunctionBody . * / if ( justFunctionBody & & braceNesting = = 0 ) break ; result . append ( ' } ' ) ; switch ( getNext ( source , length , i ) ) { case Token . EOL : case FUNCTION_END : indent - = indentGap ; break ; case Token . WHILE : case Token . ELSE : indent - = indentGap ; result . append ( ' ' ) ; break ; } break ; } case Token . LP : result . append ( ' ( ' ) ; break ; case Token . RP : result . append ( ' ) ' ) ; if ( Token . LC = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . LB : result . append ( ' [ ' ) ; break ; case Token . RB : result . append ( ' ] ' ) ; break ; case Token . EOL : { if ( toSource ) break ; boolean newLine = true ; if ( ! afterFirstEOL ) { afterFirstEOL = true ; if ( justFunctionBody ) { / * throw away just added 'function name ( . . . ) { ' * and restore the original indent * / result . setLength ( 0 ) ; indent - = indentGap ; newLine = false ; } } if ( newLine ) { result . append ( '\n' ) ; } / * add indent if any tokens remain , * less setback if next token is * a label , case or default . * / if ( i + 1 < length ) { int less = 0 ; int nextToken = source . charAt ( i + 1 ) ; if ( nextToken = = Token . CASE | | nextToken = = Token . DEFAULT ) { less = indentGap - caseGap ; } else if ( nextToken = = Token . RC ) { less = indentGap ; } / * elaborate check against label . . . skip past a * following inlined NAME and look for a COLON . * / else if ( nextToken = = Token . NAME ) { int afterName = getSourceStringEnd ( source , i + 2 ) ; if ( source . charAt ( afterName ) = = Token . COLON ) less = indentGap ; } for ( ; less < indent ; less + + ) result . append ( ' ' ) ; } break ; } case Token . DOT : result . append ( ' . ' ) ; break ; case Token . NEW : result . append ( "new " ) ; break ; case Token . DELPROP : result . append ( "delete " ) ; break ; case Token . IF : result . append ( "if " ) ; break ; case Token . ELSE : result . append ( "else " ) ; break ; case Token . FOR : result . append ( "for " ) ; break ; case Token . IN : result . append ( " in " ) ; break ; case Token . WITH : result . append ( "with " ) ; break ; case Token . WHILE : result . append ( "while " ) ; break ; case Token . DO : result . append ( "do " ) ; break ; case Token . TRY : result . append ( "try " ) ; break ; case Token . CATCH : result . append ( "catch " ) ; break ; case Token . FINALLY : result . append ( "finally " ) ; break ; case Token . THROW : result . append ( "throw " ) ; break ; case Token . SWITCH : result . append ( "switch " ) ; break ; case Token . BREAK : result . append ( "break" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CONTINUE : result . append ( "continue" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CASE : result . append ( "case " ) ; break ; case Token . DEFAULT : result . append ( "default" ) ; break ; case Token . RETURN : result . append ( "return" ) ; if ( Token . SEMI ! = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . VAR : result . append ( "var " ) ; break ; case Token . LET : result . append ( "let " ) ; break ; case Token . SEMI : result . append ( ' ; ' ) ; if ( Token . EOL ! = getNext ( source , length , i ) ) { / / separators in FOR result . append ( ' ' ) ; } break ; case Token . ASSIGN : result . append ( " = " ) ; break ; case Token . ASSIGN_ADD : result . append ( " + = " ) ; break ; case Token . ASSIGN_SUB : result . append ( " - = " ) ; break ; case Token . ASSIGN_MUL : result . append ( " * = " ) ; break ; case Token . ASSIGN_DIV : result . append ( " / = " ) ; break ; case Token . ASSIGN_MOD : result . append ( " % = " ) ; break ; case Token . ASSIGN_BITOR : result . append ( " | = " ) ; break ; case Token . ASSIGN_BITXOR : result . append ( " ^ = " ) ; break ; case Token . ASSIGN_BITAND : result . append ( " & = " ) ; break ; case Token . ASSIGN_LSH : result . append ( " < < = " ) ; break ; case Token . ASSIGN_RSH : result . append ( " > > = " ) ; break ; case Token . ASSIGN_URSH : result . append ( " > > > = " ) ; break ; case Token . HOOK : result . append ( " ? " ) ; break ; case Token . OBJECTLIT : / / pun OBJECTLIT to mean colon in objlit property / / initialization . / / This needs to be distinct from COLON in the general case / / to distinguish from the colon in a ternary . . . which needs / / different spacing . result . append ( ' : ' ) ; break ; case Token . COLON : if ( Token . EOL = = getNext ( source , length , i ) ) / / it's the end of a label result . append ( ' : ' ) ; else / / it's the middle part of a ternary result . append ( " : " ) ; break ; case Token . OR : result . append ( " | | " ) ; break ; case Token . AND : result . append ( " & & " ) ; break ; case Token . BITOR : result . append ( " | " ) ; break ; case Token . BITXOR : result . append ( " ^ " ) ; break ; case Token . BITAND : result . append ( " & " ) ; break ; case Token . SHEQ : result . append ( " = = = " ) ; break ; case Token . SHNE : result . append ( " ! = = " ) ; break ; case Token . EQ : result . append ( " = = " ) ; break ; case Token . NE : result . append ( " ! = " ) ; break ; case Token . LE : result . append ( " < = " ) ; break ; case Token . LT : result . append ( " < " ) ; break ; case Token . GE : result . append ( " > = " ) ; break ; case Token . GT : result . append ( " > " ) ; break ; case Token . INSTANCEOF : result . append ( " instanceof " ) ; break ; case Token . LSH : result . append ( " < < " ) ; break ; case Token . RSH : result . append ( " > > " ) ; break ; case Token . URSH : result . append ( " > > > " ) ; break ; case Token . TYPEOF : result . append ( "typeof " ) ; break ; case Token . VOID : result . append ( "void " ) ; break ; case Token . CONST : result . append ( "const " ) ; break ; case Token . YIELD : result . append ( "yield " ) ; break ; case Token . NOT : result . append ( ' ! ' ) ; break ; case Token . BITNOT : result . append ( '~' ) ; break ; case Token . POS : result . append ( ' + ' ) ; break ; case Token . NEG : result . append ( ' - ' ) ; break ; case Token . INC : result . append ( " + + " ) ; break ; case Token . DEC : result . append ( " - - " ) ; break ; case Token . ADD : result . append ( " + " ) ; break ; case Token . SUB : result . append ( " - " ) ; break ; case Token . MUL : result . append ( " * " ) ; break ; case Token . DIV : result . append ( " / " ) ; break ; case Token . MOD : result . append ( " % " ) ; break ; case Token . COLONCOLON : result . append ( " : : " ) ; break ; case Token . DOTDOT : result . append ( " . . " ) ; break ; case Token . DOTQUERY : result . append ( " . ( " ) ; break ; case Token . XMLATTR : result . append ( '@' ) ; break ; default : / / If we don't know how to decompile it , raise an exception . throw new RuntimeException ( "Token : " + Token . name ( source . charAt ( i ) ) ) ; } + + i ; } if ( ! toSource ) { / / add that trailing newline if it's an outermost function . if ( ! justFunctionBody ) result . append ( '\n' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ) ' ) ; } } return result . toString ( ) ; } int getNext ( String source , int length , int i ) { return ( i + 1 < length ) ? source . charAt ( i + 1 ) : Token . EOF ; } int getSourceStringEnd ( String source , int offset ) { return printSourceString ( source , offset , false , null ) ; } int printSourceString ( String source , int offset , boolean asQuotedString , StringBuffer sb ) { int length = source . charAt ( offset ) ; + + offset ; if ( ( 0x8000 & length ) ! = 0 ) { length = ( ( 0x7FFF & length ) < < 16 ) | source . charAt ( offset ) ; + + offset ; } if ( sb ! = null ) { String str = source . substring ( offset , offset + length ) ; if ( ! asQuotedString ) { sb . append ( str ) ; } else { sb . append ( '"' ) ; sb . append ( ScriptRuntime . escapeString ( str ) ) ; sb . append ( '"' ) ; } } return offset + length ; } int printSourceNumber ( String source , int offset , StringBuffer sb ) { double number = 0 . 0 ; char type = source . charAt ( offset ) ; + + offset ; if ( type = = 'S' ) { if ( sb ! = null ) { int ival = source . charAt ( offset ) ; number = ival ; } + + offset ; } else if ( type = = 'J' | | type = = 'D' ) { if ( sb ! = null ) { long lbits ; lbits = ( long ) source . charAt ( offset ) < < 48 ; lbits | = ( long ) source . charAt ( offset + 1 ) < < 32 ; lbits | = ( long ) source . charAt ( offset + 2 ) < < 16 ; lbits | = source . charAt ( offset + 3 ) ; if ( type = = 'J' ) { number = lbits ; } else { number = Double . longBitsToDouble ( lbits ) ; } } offset + = 4 ; } else { / / Bad source throw new RuntimeException ( ) ; } if ( sb ! = null ) { sb . append ( ScriptRuntime . numberToString ( number , 10 ) ) ; } return offset ; } char [ ] sourceBuffer = new char [ 128 ] ; / / Per script / function source buffer top : parent source does not include a / / nested functions source and uses function index as a reference instead . int sourceTop ; / / whether to do a debug print of the source information , when decompiling . boolean printSource = false ; }
void test35 ( ) throws Throwable { UintMap uintMap0 = new UintMap ( 0 ) ; String string0 = Decompiler . decompile ( " r5 * " , 0 , uintMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String decompile ( String source , int flags , UintMap properties ) { int length = source . length ( ) ; if ( length = = 0 ) { return "" ; } int indent = properties . getInt ( INITIAL_INDENT_PROP , 0 ) ; if ( indent < 0 ) throw new IllegalArgumentException ( ) ; int indentGap = properties . getInt ( INDENT_GAP_PROP , 4 ) ; if ( indentGap < 0 ) throw new IllegalArgumentException ( ) ; int caseGap = properties . getInt ( CASE_GAP_PROP , 2 ) ; if ( caseGap < 0 ) throw new IllegalArgumentException ( ) ; StringBuffer result = new StringBuffer ( ) ; boolean justFunctionBody = ( 0 ! = ( flags & Decompiler . ONLY_BODY_FLAG ) ) ; boolean toSource = ( 0 ! = ( flags & Decompiler . TO_SOURCE_FLAG ) ) ; / / Spew tokens in source , for debugging . / / as TYPE number char if ( printSource ) { System . err . println ( "length : " + length ) ; for ( int i = 0 ; i < length ; + + i ) { / / Note that tokenToName will fail unless Context . printTrees / / is true . String tokenname = null ; if ( Token . printNames ) { tokenname = Token . name ( source . charAt ( i ) ) ; } if ( tokenname = = null ) { tokenname = " - - - " ; } String pad = tokenname . length ( ) > 7 ? "\t" : "\t\t" ; System . err . println ( tokenname + pad + ( int ) source . charAt ( i ) + "\t'" + ScriptRuntime . escapeString ( source . substring ( i , i + 1 ) ) + "'" ) ; } System . err . println ( ) ; } int braceNesting = 0 ; boolean afterFirstEOL = false ; int i = 0 ; int topFunctionType ; if ( source . charAt ( i ) = = Token . SCRIPT ) { + + i ; topFunctionType = - 1 ; } else { topFunctionType = source . charAt ( i + 1 ) ; } if ( ! toSource ) { / / add an initial newline to exactly match js . result . append ( '\n' ) ; for ( int j = 0 ; j < indent ; j + + ) result . append ( ' ' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ( ' ) ; } } while ( i < length ) { switch ( source . charAt ( i ) ) { case Token . GET : case Token . SET : result . append ( source . charAt ( i ) = = Token . GET ? "get " : "set " ) ; + + i ; i = printSourceString ( source , i + 1 , false , result ) ; / / Now increment one more to get past the FUNCTION token + + i ; break ; case Token . NAME : case Token . REGEXP : / / re - wrapped in ' / 's in parser . . . i = printSourceString ( source , i + 1 , false , result ) ; continue ; case Token . STRING : i = printSourceString ( source , i + 1 , true , result ) ; continue ; case Token . NUMBER : i = printSourceNumber ( source , i + 1 , result ) ; continue ; case Token . TRUE : result . append ( "true" ) ; break ; case Token . FALSE : result . append ( "false" ) ; break ; case Token . NULL : result . append ( "null" ) ; break ; case Token . THIS : result . append ( "this" ) ; break ; case Token . FUNCTION : + + i ; / / skip function type result . append ( "function " ) ; break ; case FUNCTION_END : / / Do nothing break ; case Token . COMMA : result . append ( " , " ) ; break ; case Token . LC : + + braceNesting ; if ( Token . EOL = = getNext ( source , length , i ) ) indent + = indentGap ; result . append ( ' { ' ) ; break ; case Token . RC : { - - braceNesting ; / * don't print the closing RC if it closes the * toplevel function and we're called from * decompileFunctionBody . * / if ( justFunctionBody & & braceNesting = = 0 ) break ; result . append ( ' } ' ) ; switch ( getNext ( source , length , i ) ) { case Token . EOL : case FUNCTION_END : indent - = indentGap ; break ; case Token . WHILE : case Token . ELSE : indent - = indentGap ; result . append ( ' ' ) ; break ; } break ; } case Token . LP : result . append ( ' ( ' ) ; break ; case Token . RP : result . append ( ' ) ' ) ; if ( Token . LC = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . LB : result . append ( ' [ ' ) ; break ; case Token . RB : result . append ( ' ] ' ) ; break ; case Token . EOL : { if ( toSource ) break ; boolean newLine = true ; if ( ! afterFirstEOL ) { afterFirstEOL = true ; if ( justFunctionBody ) { / * throw away just added 'function name ( . . . ) { ' * and restore the original indent * / result . setLength ( 0 ) ; indent - = indentGap ; newLine = false ; } } if ( newLine ) { result . append ( '\n' ) ; } / * add indent if any tokens remain , * less setback if next token is * a label , case or default . * / if ( i + 1 < length ) { int less = 0 ; int nextToken = source . charAt ( i + 1 ) ; if ( nextToken = = Token . CASE | | nextToken = = Token . DEFAULT ) { less = indentGap - caseGap ; } else if ( nextToken = = Token . RC ) { less = indentGap ; } / * elaborate check against label . . . skip past a * following inlined NAME and look for a COLON . * / else if ( nextToken = = Token . NAME ) { int afterName = getSourceStringEnd ( source , i + 2 ) ; if ( source . charAt ( afterName ) = = Token . COLON ) less = indentGap ; } for ( ; less < indent ; less + + ) result . append ( ' ' ) ; } break ; } case Token . DOT : result . append ( ' . ' ) ; break ; case Token . NEW : result . append ( "new " ) ; break ; case Token . DELPROP : result . append ( "delete " ) ; break ; case Token . IF : result . append ( "if " ) ; break ; case Token . ELSE : result . append ( "else " ) ; break ; case Token . FOR : result . append ( "for " ) ; break ; case Token . IN : result . append ( " in " ) ; break ; case Token . WITH : result . append ( "with " ) ; break ; case Token . WHILE : result . append ( "while " ) ; break ; case Token . DO : result . append ( "do " ) ; break ; case Token . TRY : result . append ( "try " ) ; break ; case Token . CATCH : result . append ( "catch " ) ; break ; case Token . FINALLY : result . append ( "finally " ) ; break ; case Token . THROW : result . append ( "throw " ) ; break ; case Token . SWITCH : result . append ( "switch " ) ; break ; case Token . BREAK : result . append ( "break" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CONTINUE : result . append ( "continue" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CASE : result . append ( "case " ) ; break ; case Token . DEFAULT : result . append ( "default" ) ; break ; case Token . RETURN : result . append ( "return" ) ; if ( Token . SEMI ! = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . VAR : result . append ( "var " ) ; break ; case Token . LET : result . append ( "let " ) ; break ; case Token . SEMI : result . append ( ' ; ' ) ; if ( Token . EOL ! = getNext ( source , length , i ) ) { / / separators in FOR result . append ( ' ' ) ; } break ; case Token . ASSIGN : result . append ( " = " ) ; break ; case Token . ASSIGN_ADD : result . append ( " + = " ) ; break ; case Token . ASSIGN_SUB : result . append ( " - = " ) ; break ; case Token . ASSIGN_MUL : result . append ( " * = " ) ; break ; case Token . ASSIGN_DIV : result . append ( " / = " ) ; break ; case Token . ASSIGN_MOD : result . append ( " % = " ) ; break ; case Token . ASSIGN_BITOR : result . append ( " | = " ) ; break ; case Token . ASSIGN_BITXOR : result . append ( " ^ = " ) ; break ; case Token . ASSIGN_BITAND : result . append ( " & = " ) ; break ; case Token . ASSIGN_LSH : result . append ( " < < = " ) ; break ; case Token . ASSIGN_RSH : result . append ( " > > = " ) ; break ; case Token . ASSIGN_URSH : result . append ( " > > > = " ) ; break ; case Token . HOOK : result . append ( " ? " ) ; break ; case Token . OBJECTLIT : / / pun OBJECTLIT to mean colon in objlit property / / initialization . / / This needs to be distinct from COLON in the general case / / to distinguish from the colon in a ternary . . . which needs / / different spacing . result . append ( ' : ' ) ; break ; case Token . COLON : if ( Token . EOL = = getNext ( source , length , i ) ) / / it's the end of a label result . append ( ' : ' ) ; else / / it's the middle part of a ternary result . append ( " : " ) ; break ; case Token . OR : result . append ( " | | " ) ; break ; case Token . AND : result . append ( " & & " ) ; break ; case Token . BITOR : result . append ( " | " ) ; break ; case Token . BITXOR : result . append ( " ^ " ) ; break ; case Token . BITAND : result . append ( " & " ) ; break ; case Token . SHEQ : result . append ( " = = = " ) ; break ; case Token . SHNE : result . append ( " ! = = " ) ; break ; case Token . EQ : result . append ( " = = " ) ; break ; case Token . NE : result . append ( " ! = " ) ; break ; case Token . LE : result . append ( " < = " ) ; break ; case Token . LT : result . append ( " < " ) ; break ; case Token . GE : result . append ( " > = " ) ; break ; case Token . GT : result . append ( " > " ) ; break ; case Token . INSTANCEOF : result . append ( " instanceof " ) ; break ; case Token . LSH : result . append ( " < < " ) ; break ; case Token . RSH : result . append ( " > > " ) ; break ; case Token . URSH : result . append ( " > > > " ) ; break ; case Token . TYPEOF : result . append ( "typeof " ) ; break ; case Token . VOID : result . append ( "void " ) ; break ; case Token . CONST : result . append ( "const " ) ; break ; case Token . YIELD : result . append ( "yield " ) ; break ; case Token . NOT : result . append ( ' ! ' ) ; break ; case Token . BITNOT : result . append ( '~' ) ; break ; case Token . POS : result . append ( ' + ' ) ; break ; case Token . NEG : result . append ( ' - ' ) ; break ; case Token . INC : result . append ( " + + " ) ; break ; case Token . DEC : result . append ( " - - " ) ; break ; case Token . ADD : result . append ( " + " ) ; break ; case Token . SUB : result . append ( " - " ) ; break ; case Token . MUL : result . append ( " * " ) ; break ; case Token . DIV : result . append ( " / " ) ; break ; case Token . MOD : result . append ( " % " ) ; break ; case Token . COLONCOLON : result . append ( " : : " ) ; break ; case Token . DOTDOT : result . append ( " . . " ) ; break ; case Token . DOTQUERY : result . append ( " . ( " ) ; break ; case Token . XMLATTR : result . append ( '@' ) ; break ; default : / / If we don't know how to decompile it , raise an exception . throw new RuntimeException ( "Token : " + Token . name ( source . charAt ( i ) ) ) ; } + + i ; } if ( ! toSource ) { / / add that trailing newline if it's an outermost function . if ( ! justFunctionBody ) result . append ( '\n' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ) ' ) ; } } return result . toString ( ) ; } int getNext ( String source , int length , int i ) { return ( i + 1 < length ) ? source . charAt ( i + 1 ) : Token . EOF ; } int getSourceStringEnd ( String source , int offset ) { return printSourceString ( source , offset , false , null ) ; } int printSourceString ( String source , int offset , boolean asQuotedString , StringBuffer sb ) { int length = source . charAt ( offset ) ; + + offset ; if ( ( 0x8000 & length ) ! = 0 ) { length = ( ( 0x7FFF & length ) < < 16 ) | source . charAt ( offset ) ; + + offset ; } if ( sb ! = null ) { String str = source . substring ( offset , offset + length ) ; if ( ! asQuotedString ) { sb . append ( str ) ; } else { sb . append ( '"' ) ; sb . append ( ScriptRuntime . escapeString ( str ) ) ; sb . append ( '"' ) ; } } return offset + length ; } int printSourceNumber ( String source , int offset , StringBuffer sb ) { double number = 0 . 0 ; char type = source . charAt ( offset ) ; + + offset ; if ( type = = 'S' ) { if ( sb ! = null ) { int ival = source . charAt ( offset ) ; number = ival ; } + + offset ; } else if ( type = = 'J' | | type = = 'D' ) { if ( sb ! = null ) { long lbits ; lbits = ( long ) source . charAt ( offset ) < < 48 ; lbits | = ( long ) source . charAt ( offset + 1 ) < < 32 ; lbits | = ( long ) source . charAt ( offset + 2 ) < < 16 ; lbits | = source . charAt ( offset + 3 ) ; if ( type = = 'J' ) { number = lbits ; } else { number = Double . longBitsToDouble ( lbits ) ; } } offset + = 4 ; } else { / / Bad source throw new RuntimeException ( ) ; } if ( sb ! = null ) { sb . append ( ScriptRuntime . numberToString ( number , 10 ) ) ; } return offset ; } char [ ] sourceBuffer = new char [ 128 ] ; / / Per script / function source buffer top : parent source does not include a / / nested functions source and uses function index as a reference instead . int sourceTop ; / / whether to do a debug print of the source information , when decompiling . boolean printSource = false ; }
void test54 ( ) throws Throwable { UintMap uintMap0 = new UintMap ( 1 ) ; String string0 = Decompiler . decompile ( "vUSbU ijU" , 1 , uintMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String decompile ( String source , int flags , UintMap properties ) { int length = source . length ( ) ; if ( length = = 0 ) { return "" ; } int indent = properties . getInt ( INITIAL_INDENT_PROP , 0 ) ; if ( indent < 0 ) throw new IllegalArgumentException ( ) ; int indentGap = properties . getInt ( INDENT_GAP_PROP , 4 ) ; if ( indentGap < 0 ) throw new IllegalArgumentException ( ) ; int caseGap = properties . getInt ( CASE_GAP_PROP , 2 ) ; if ( caseGap < 0 ) throw new IllegalArgumentException ( ) ; StringBuffer result = new StringBuffer ( ) ; boolean justFunctionBody = ( 0 ! = ( flags & Decompiler . ONLY_BODY_FLAG ) ) ; boolean toSource = ( 0 ! = ( flags & Decompiler . TO_SOURCE_FLAG ) ) ; / / Spew tokens in source , for debugging . / / as TYPE number char if ( printSource ) { System . err . println ( "length : " + length ) ; for ( int i = 0 ; i < length ; + + i ) { / / Note that tokenToName will fail unless Context . printTrees / / is true . String tokenname = null ; if ( Token . printNames ) { tokenname = Token . name ( source . charAt ( i ) ) ; } if ( tokenname = = null ) { tokenname = " - - - " ; } String pad = tokenname . length ( ) > 7 ? "\t" : "\t\t" ; System . err . println ( tokenname + pad + ( int ) source . charAt ( i ) + "\t'" + ScriptRuntime . escapeString ( source . substring ( i , i + 1 ) ) + "'" ) ; } System . err . println ( ) ; } int braceNesting = 0 ; boolean afterFirstEOL = false ; int i = 0 ; int topFunctionType ; if ( source . charAt ( i ) = = Token . SCRIPT ) { + + i ; topFunctionType = - 1 ; } else { topFunctionType = source . charAt ( i + 1 ) ; } if ( ! toSource ) { / / add an initial newline to exactly match js . result . append ( '\n' ) ; for ( int j = 0 ; j < indent ; j + + ) result . append ( ' ' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ( ' ) ; } } while ( i < length ) { switch ( source . charAt ( i ) ) { case Token . GET : case Token . SET : result . append ( source . charAt ( i ) = = Token . GET ? "get " : "set " ) ; + + i ; i = printSourceString ( source , i + 1 , false , result ) ; / / Now increment one more to get past the FUNCTION token + + i ; break ; case Token . NAME : case Token . REGEXP : / / re - wrapped in ' / 's in parser . . . i = printSourceString ( source , i + 1 , false , result ) ; continue ; case Token . STRING : i = printSourceString ( source , i + 1 , true , result ) ; continue ; case Token . NUMBER : i = printSourceNumber ( source , i + 1 , result ) ; continue ; case Token . TRUE : result . append ( "true" ) ; break ; case Token . FALSE : result . append ( "false" ) ; break ; case Token . NULL : result . append ( "null" ) ; break ; case Token . THIS : result . append ( "this" ) ; break ; case Token . FUNCTION : + + i ; / / skip function type result . append ( "function " ) ; break ; case FUNCTION_END : / / Do nothing break ; case Token . COMMA : result . append ( " , " ) ; break ; case Token . LC : + + braceNesting ; if ( Token . EOL = = getNext ( source , length , i ) ) indent + = indentGap ; result . append ( ' { ' ) ; break ; case Token . RC : { - - braceNesting ; / * don't print the closing RC if it closes the * toplevel function and we're called from * decompileFunctionBody . * / if ( justFunctionBody & & braceNesting = = 0 ) break ; result . append ( ' } ' ) ; switch ( getNext ( source , length , i ) ) { case Token . EOL : case FUNCTION_END : indent - = indentGap ; break ; case Token . WHILE : case Token . ELSE : indent - = indentGap ; result . append ( ' ' ) ; break ; } break ; } case Token . LP : result . append ( ' ( ' ) ; break ; case Token . RP : result . append ( ' ) ' ) ; if ( Token . LC = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . LB : result . append ( ' [ ' ) ; break ; case Token . RB : result . append ( ' ] ' ) ; break ; case Token . EOL : { if ( toSource ) break ; boolean newLine = true ; if ( ! afterFirstEOL ) { afterFirstEOL = true ; if ( justFunctionBody ) { / * throw away just added 'function name ( . . . ) { ' * and restore the original indent * / result . setLength ( 0 ) ; indent - = indentGap ; newLine = false ; } } if ( newLine ) { result . append ( '\n' ) ; } / * add indent if any tokens remain , * less setback if next token is * a label , case or default . * / if ( i + 1 < length ) { int less = 0 ; int nextToken = source . charAt ( i + 1 ) ; if ( nextToken = = Token . CASE | | nextToken = = Token . DEFAULT ) { less = indentGap - caseGap ; } else if ( nextToken = = Token . RC ) { less = indentGap ; } / * elaborate check against label . . . skip past a * following inlined NAME and look for a COLON . * / else if ( nextToken = = Token . NAME ) { int afterName = getSourceStringEnd ( source , i + 2 ) ; if ( source . charAt ( afterName ) = = Token . COLON ) less = indentGap ; } for ( ; less < indent ; less + + ) result . append ( ' ' ) ; } break ; } case Token . DOT : result . append ( ' . ' ) ; break ; case Token . NEW : result . append ( "new " ) ; break ; case Token . DELPROP : result . append ( "delete " ) ; break ; case Token . IF : result . append ( "if " ) ; break ; case Token . ELSE : result . append ( "else " ) ; break ; case Token . FOR : result . append ( "for " ) ; break ; case Token . IN : result . append ( " in " ) ; break ; case Token . WITH : result . append ( "with " ) ; break ; case Token . WHILE : result . append ( "while " ) ; break ; case Token . DO : result . append ( "do " ) ; break ; case Token . TRY : result . append ( "try " ) ; break ; case Token . CATCH : result . append ( "catch " ) ; break ; case Token . FINALLY : result . append ( "finally " ) ; break ; case Token . THROW : result . append ( "throw " ) ; break ; case Token . SWITCH : result . append ( "switch " ) ; break ; case Token . BREAK : result . append ( "break" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CONTINUE : result . append ( "continue" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CASE : result . append ( "case " ) ; break ; case Token . DEFAULT : result . append ( "default" ) ; break ; case Token . RETURN : result . append ( "return" ) ; if ( Token . SEMI ! = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . VAR : result . append ( "var " ) ; break ; case Token . LET : result . append ( "let " ) ; break ; case Token . SEMI : result . append ( ' ; ' ) ; if ( Token . EOL ! = getNext ( source , length , i ) ) { / / separators in FOR result . append ( ' ' ) ; } break ; case Token . ASSIGN : result . append ( " = " ) ; break ; case Token . ASSIGN_ADD : result . append ( " + = " ) ; break ; case Token . ASSIGN_SUB : result . append ( " - = " ) ; break ; case Token . ASSIGN_MUL : result . append ( " * = " ) ; break ; case Token . ASSIGN_DIV : result . append ( " / = " ) ; break ; case Token . ASSIGN_MOD : result . append ( " % = " ) ; break ; case Token . ASSIGN_BITOR : result . append ( " | = " ) ; break ; case Token . ASSIGN_BITXOR : result . append ( " ^ = " ) ; break ; case Token . ASSIGN_BITAND : result . append ( " & = " ) ; break ; case Token . ASSIGN_LSH : result . append ( " < < = " ) ; break ; case Token . ASSIGN_RSH : result . append ( " > > = " ) ; break ; case Token . ASSIGN_URSH : result . append ( " > > > = " ) ; break ; case Token . HOOK : result . append ( " ? " ) ; break ; case Token . OBJECTLIT : / / pun OBJECTLIT to mean colon in objlit property / / initialization . / / This needs to be distinct from COLON in the general case / / to distinguish from the colon in a ternary . . . which needs / / different spacing . result . append ( ' : ' ) ; break ; case Token . COLON : if ( Token . EOL = = getNext ( source , length , i ) ) / / it's the end of a label result . append ( ' : ' ) ; else / / it's the middle part of a ternary result . append ( " : " ) ; break ; case Token . OR : result . append ( " | | " ) ; break ; case Token . AND : result . append ( " & & " ) ; break ; case Token . BITOR : result . append ( " | " ) ; break ; case Token . BITXOR : result . append ( " ^ " ) ; break ; case Token . BITAND : result . append ( " & " ) ; break ; case Token . SHEQ : result . append ( " = = = " ) ; break ; case Token . SHNE : result . append ( " ! = = " ) ; break ; case Token . EQ : result . append ( " = = " ) ; break ; case Token . NE : result . append ( " ! = " ) ; break ; case Token . LE : result . append ( " < = " ) ; break ; case Token . LT : result . append ( " < " ) ; break ; case Token . GE : result . append ( " > = " ) ; break ; case Token . GT : result . append ( " > " ) ; break ; case Token . INSTANCEOF : result . append ( " instanceof " ) ; break ; case Token . LSH : result . append ( " < < " ) ; break ; case Token . RSH : result . append ( " > > " ) ; break ; case Token . URSH : result . append ( " > > > " ) ; break ; case Token . TYPEOF : result . append ( "typeof " ) ; break ; case Token . VOID : result . append ( "void " ) ; break ; case Token . CONST : result . append ( "const " ) ; break ; case Token . YIELD : result . append ( "yield " ) ; break ; case Token . NOT : result . append ( ' ! ' ) ; break ; case Token . BITNOT : result . append ( '~' ) ; break ; case Token . POS : result . append ( ' + ' ) ; break ; case Token . NEG : result . append ( ' - ' ) ; break ; case Token . INC : result . append ( " + + " ) ; break ; case Token . DEC : result . append ( " - - " ) ; break ; case Token . ADD : result . append ( " + " ) ; break ; case Token . SUB : result . append ( " - " ) ; break ; case Token . MUL : result . append ( " * " ) ; break ; case Token . DIV : result . append ( " / " ) ; break ; case Token . MOD : result . append ( " % " ) ; break ; case Token . COLONCOLON : result . append ( " : : " ) ; break ; case Token . DOTDOT : result . append ( " . . " ) ; break ; case Token . DOTQUERY : result . append ( " . ( " ) ; break ; case Token . XMLATTR : result . append ( '@' ) ; break ; default : / / If we don't know how to decompile it , raise an exception . throw new RuntimeException ( "Token : " + Token . name ( source . charAt ( i ) ) ) ; } + + i ; } if ( ! toSource ) { / / add that trailing newline if it's an outermost function . if ( ! justFunctionBody ) result . append ( '\n' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ) ' ) ; } } return result . toString ( ) ; } int getNext ( String source , int length , int i ) { return ( i + 1 < length ) ? source . charAt ( i + 1 ) : Token . EOF ; } int getSourceStringEnd ( String source , int offset ) { return printSourceString ( source , offset , false , null ) ; } int printSourceString ( String source , int offset , boolean asQuotedString , StringBuffer sb ) { int length = source . charAt ( offset ) ; + + offset ; if ( ( 0x8000 & length ) ! = 0 ) { length = ( ( 0x7FFF & length ) < < 16 ) | source . charAt ( offset ) ; + + offset ; } if ( sb ! = null ) { String str = source . substring ( offset , offset + length ) ; if ( ! asQuotedString ) { sb . append ( str ) ; } else { sb . append ( '"' ) ; sb . append ( ScriptRuntime . escapeString ( str ) ) ; sb . append ( '"' ) ; } } return offset + length ; } int printSourceNumber ( String source , int offset , StringBuffer sb ) { double number = 0 . 0 ; char type = source . charAt ( offset ) ; + + offset ; if ( type = = 'S' ) { if ( sb ! = null ) { int ival = source . charAt ( offset ) ; number = ival ; } + + offset ; } else if ( type = = 'J' | | type = = 'D' ) { if ( sb ! = null ) { long lbits ; lbits = ( long ) source . charAt ( offset ) < < 48 ; lbits | = ( long ) source . charAt ( offset + 1 ) < < 32 ; lbits | = ( long ) source . charAt ( offset + 2 ) < < 16 ; lbits | = source . charAt ( offset + 3 ) ; if ( type = = 'J' ) { number = lbits ; } else { number = Double . longBitsToDouble ( lbits ) ; } } offset + = 4 ; } else { / / Bad source throw new RuntimeException ( ) ; } if ( sb ! = null ) { sb . append ( ScriptRuntime . numberToString ( number , 10 ) ) ; } return offset ; } char [ ] sourceBuffer = new char [ 128 ] ; / / Per script / function source buffer top : parent source does not include a / / nested functions source and uses function index as a reference instead . int sourceTop ; / / whether to do a debug print of the source information , when decompiling . boolean printSource = false ; }
void test58 ( ) throws Throwable { UintMap uintMap0 = new UintMap ( 1256 ) ; String string0 = Decompiler . decompile ( "h\u0001h\u0001 ) \u000B , : r%U - ` - wdj\u00A0" , 135 , uintMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String decompile ( String source , int flags , UintMap properties ) { int length = source . length ( ) ; if ( length = = 0 ) { return "" ; } int indent = properties . getInt ( INITIAL_INDENT_PROP , 0 ) ; if ( indent < 0 ) throw new IllegalArgumentException ( ) ; int indentGap = properties . getInt ( INDENT_GAP_PROP , 4 ) ; if ( indentGap < 0 ) throw new IllegalArgumentException ( ) ; int caseGap = properties . getInt ( CASE_GAP_PROP , 2 ) ; if ( caseGap < 0 ) throw new IllegalArgumentException ( ) ; StringBuffer result = new StringBuffer ( ) ; boolean justFunctionBody = ( 0 ! = ( flags & Decompiler . ONLY_BODY_FLAG ) ) ; boolean toSource = ( 0 ! = ( flags & Decompiler . TO_SOURCE_FLAG ) ) ; / / Spew tokens in source , for debugging . / / as TYPE number char if ( printSource ) { System . err . println ( "length : " + length ) ; for ( int i = 0 ; i < length ; + + i ) { / / Note that tokenToName will fail unless Context . printTrees / / is true . String tokenname = null ; if ( Token . printNames ) { tokenname = Token . name ( source . charAt ( i ) ) ; } if ( tokenname = = null ) { tokenname = " - - - " ; } String pad = tokenname . length ( ) > 7 ? "\t" : "\t\t" ; System . err . println ( tokenname + pad + ( int ) source . charAt ( i ) + "\t'" + ScriptRuntime . escapeString ( source . substring ( i , i + 1 ) ) + "'" ) ; } System . err . println ( ) ; } int braceNesting = 0 ; boolean afterFirstEOL = false ; int i = 0 ; int topFunctionType ; if ( source . charAt ( i ) = = Token . SCRIPT ) { + + i ; topFunctionType = - 1 ; } else { topFunctionType = source . charAt ( i + 1 ) ; } if ( ! toSource ) { / / add an initial newline to exactly match js . result . append ( '\n' ) ; for ( int j = 0 ; j < indent ; j + + ) result . append ( ' ' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ( ' ) ; } } while ( i < length ) { switch ( source . charAt ( i ) ) { case Token . GET : case Token . SET : result . append ( source . charAt ( i ) = = Token . GET ? "get " : "set " ) ; + + i ; i = printSourceString ( source , i + 1 , false , result ) ; / / Now increment one more to get past the FUNCTION token + + i ; break ; case Token . NAME : case Token . REGEXP : / / re - wrapped in ' / 's in parser . . . i = printSourceString ( source , i + 1 , false , result ) ; continue ; case Token . STRING : i = printSourceString ( source , i + 1 , true , result ) ; continue ; case Token . NUMBER : i = printSourceNumber ( source , i + 1 , result ) ; continue ; case Token . TRUE : result . append ( "true" ) ; break ; case Token . FALSE : result . append ( "false" ) ; break ; case Token . NULL : result . append ( "null" ) ; break ; case Token . THIS : result . append ( "this" ) ; break ; case Token . FUNCTION : + + i ; / / skip function type result . append ( "function " ) ; break ; case FUNCTION_END : / / Do nothing break ; case Token . COMMA : result . append ( " , " ) ; break ; case Token . LC : + + braceNesting ; if ( Token . EOL = = getNext ( source , length , i ) ) indent + = indentGap ; result . append ( ' { ' ) ; break ; case Token . RC : { - - braceNesting ; / * don't print the closing RC if it closes the * toplevel function and we're called from * decompileFunctionBody . * / if ( justFunctionBody & & braceNesting = = 0 ) break ; result . append ( ' } ' ) ; switch ( getNext ( source , length , i ) ) { case Token . EOL : case FUNCTION_END : indent - = indentGap ; break ; case Token . WHILE : case Token . ELSE : indent - = indentGap ; result . append ( ' ' ) ; break ; } break ; } case Token . LP : result . append ( ' ( ' ) ; break ; case Token . RP : result . append ( ' ) ' ) ; if ( Token . LC = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . LB : result . append ( ' [ ' ) ; break ; case Token . RB : result . append ( ' ] ' ) ; break ; case Token . EOL : { if ( toSource ) break ; boolean newLine = true ; if ( ! afterFirstEOL ) { afterFirstEOL = true ; if ( justFunctionBody ) { / * throw away just added 'function name ( . . . ) { ' * and restore the original indent * / result . setLength ( 0 ) ; indent - = indentGap ; newLine = false ; } } if ( newLine ) { result . append ( '\n' ) ; } / * add indent if any tokens remain , * less setback if next token is * a label , case or default . * / if ( i + 1 < length ) { int less = 0 ; int nextToken = source . charAt ( i + 1 ) ; if ( nextToken = = Token . CASE | | nextToken = = Token . DEFAULT ) { less = indentGap - caseGap ; } else if ( nextToken = = Token . RC ) { less = indentGap ; } / * elaborate check against label . . . skip past a * following inlined NAME and look for a COLON . * / else if ( nextToken = = Token . NAME ) { int afterName = getSourceStringEnd ( source , i + 2 ) ; if ( source . charAt ( afterName ) = = Token . COLON ) less = indentGap ; } for ( ; less < indent ; less + + ) result . append ( ' ' ) ; } break ; } case Token . DOT : result . append ( ' . ' ) ; break ; case Token . NEW : result . append ( "new " ) ; break ; case Token . DELPROP : result . append ( "delete " ) ; break ; case Token . IF : result . append ( "if " ) ; break ; case Token . ELSE : result . append ( "else " ) ; break ; case Token . FOR : result . append ( "for " ) ; break ; case Token . IN : result . append ( " in " ) ; break ; case Token . WITH : result . append ( "with " ) ; break ; case Token . WHILE : result . append ( "while " ) ; break ; case Token . DO : result . append ( "do " ) ; break ; case Token . TRY : result . append ( "try " ) ; break ; case Token . CATCH : result . append ( "catch " ) ; break ; case Token . FINALLY : result . append ( "finally " ) ; break ; case Token . THROW : result . append ( "throw " ) ; break ; case Token . SWITCH : result . append ( "switch " ) ; break ; case Token . BREAK : result . append ( "break" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CONTINUE : result . append ( "continue" ) ; if ( Token . NAME = = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . CASE : result . append ( "case " ) ; break ; case Token . DEFAULT : result . append ( "default" ) ; break ; case Token . RETURN : result . append ( "return" ) ; if ( Token . SEMI ! = getNext ( source , length , i ) ) result . append ( ' ' ) ; break ; case Token . VAR : result . append ( "var " ) ; break ; case Token . LET : result . append ( "let " ) ; break ; case Token . SEMI : result . append ( ' ; ' ) ; if ( Token . EOL ! = getNext ( source , length , i ) ) { / / separators in FOR result . append ( ' ' ) ; } break ; case Token . ASSIGN : result . append ( " = " ) ; break ; case Token . ASSIGN_ADD : result . append ( " + = " ) ; break ; case Token . ASSIGN_SUB : result . append ( " - = " ) ; break ; case Token . ASSIGN_MUL : result . append ( " * = " ) ; break ; case Token . ASSIGN_DIV : result . append ( " / = " ) ; break ; case Token . ASSIGN_MOD : result . append ( " % = " ) ; break ; case Token . ASSIGN_BITOR : result . append ( " | = " ) ; break ; case Token . ASSIGN_BITXOR : result . append ( " ^ = " ) ; break ; case Token . ASSIGN_BITAND : result . append ( " & = " ) ; break ; case Token . ASSIGN_LSH : result . append ( " < < = " ) ; break ; case Token . ASSIGN_RSH : result . append ( " > > = " ) ; break ; case Token . ASSIGN_URSH : result . append ( " > > > = " ) ; break ; case Token . HOOK : result . append ( " ? " ) ; break ; case Token . OBJECTLIT : / / pun OBJECTLIT to mean colon in objlit property / / initialization . / / This needs to be distinct from COLON in the general case / / to distinguish from the colon in a ternary . . . which needs / / different spacing . result . append ( ' : ' ) ; break ; case Token . COLON : if ( Token . EOL = = getNext ( source , length , i ) ) / / it's the end of a label result . append ( ' : ' ) ; else / / it's the middle part of a ternary result . append ( " : " ) ; break ; case Token . OR : result . append ( " | | " ) ; break ; case Token . AND : result . append ( " & & " ) ; break ; case Token . BITOR : result . append ( " | " ) ; break ; case Token . BITXOR : result . append ( " ^ " ) ; break ; case Token . BITAND : result . append ( " & " ) ; break ; case Token . SHEQ : result . append ( " = = = " ) ; break ; case Token . SHNE : result . append ( " ! = = " ) ; break ; case Token . EQ : result . append ( " = = " ) ; break ; case Token . NE : result . append ( " ! = " ) ; break ; case Token . LE : result . append ( " < = " ) ; break ; case Token . LT : result . append ( " < " ) ; break ; case Token . GE : result . append ( " > = " ) ; break ; case Token . GT : result . append ( " > " ) ; break ; case Token . INSTANCEOF : result . append ( " instanceof " ) ; break ; case Token . LSH : result . append ( " < < " ) ; break ; case Token . RSH : result . append ( " > > " ) ; break ; case Token . URSH : result . append ( " > > > " ) ; break ; case Token . TYPEOF : result . append ( "typeof " ) ; break ; case Token . VOID : result . append ( "void " ) ; break ; case Token . CONST : result . append ( "const " ) ; break ; case Token . YIELD : result . append ( "yield " ) ; break ; case Token . NOT : result . append ( ' ! ' ) ; break ; case Token . BITNOT : result . append ( '~' ) ; break ; case Token . POS : result . append ( ' + ' ) ; break ; case Token . NEG : result . append ( ' - ' ) ; break ; case Token . INC : result . append ( " + + " ) ; break ; case Token . DEC : result . append ( " - - " ) ; break ; case Token . ADD : result . append ( " + " ) ; break ; case Token . SUB : result . append ( " - " ) ; break ; case Token . MUL : result . append ( " * " ) ; break ; case Token . DIV : result . append ( " / " ) ; break ; case Token . MOD : result . append ( " % " ) ; break ; case Token . COLONCOLON : result . append ( " : : " ) ; break ; case Token . DOTDOT : result . append ( " . . " ) ; break ; case Token . DOTQUERY : result . append ( " . ( " ) ; break ; case Token . XMLATTR : result . append ( '@' ) ; break ; default : / / If we don't know how to decompile it , raise an exception . throw new RuntimeException ( "Token : " + Token . name ( source . charAt ( i ) ) ) ; } + + i ; } if ( ! toSource ) { / / add that trailing newline if it's an outermost function . if ( ! justFunctionBody ) result . append ( '\n' ) ; } else { if ( topFunctionType = = FunctionNode . FUNCTION_EXPRESSION ) { result . append ( ' ) ' ) ; } } return result . toString ( ) ; } int getNext ( String source , int length , int i ) { return ( i + 1 < length ) ? source . charAt ( i + 1 ) : Token . EOF ; } int getSourceStringEnd ( String source , int offset ) { return printSourceString ( source , offset , false , null ) ; } int printSourceString ( String source , int offset , boolean asQuotedString , StringBuffer sb ) { int length = source . charAt ( offset ) ; + + offset ; if ( ( 0x8000 & length ) ! = 0 ) { length = ( ( 0x7FFF & length ) < < 16 ) | source . charAt ( offset ) ; + + offset ; } if ( sb ! = null ) { String str = source . substring ( offset , offset + length ) ; if ( ! asQuotedString ) { sb . append ( str ) ; } else { sb . append ( '"' ) ; sb . append ( ScriptRuntime . escapeString ( str ) ) ; sb . append ( '"' ) ; } } return offset + length ; } int printSourceNumber ( String source , int offset , StringBuffer sb ) { double number = 0 . 0 ; char type = source . charAt ( offset ) ; + + offset ; if ( type = = 'S' ) { if ( sb ! = null ) { int ival = source . charAt ( offset ) ; number = ival ; } + + offset ; } else if ( type = = 'J' | | type = = 'D' ) { if ( sb ! = null ) { long lbits ; lbits = ( long ) source . charAt ( offset ) < < 48 ; lbits | = ( long ) source . charAt ( offset + 1 ) < < 32 ; lbits | = ( long ) source . charAt ( offset + 2 ) < < 16 ; lbits | = source . charAt ( offset + 3 ) ; if ( type = = 'J' ) { number = lbits ; } else { number = Double . longBitsToDouble ( lbits ) ; } } offset + = 4 ; } else { / / Bad source throw new RuntimeException ( ) ; } if ( sb ! = null ) { sb . append ( ScriptRuntime . numberToString ( number , 10 ) ) ; } return offset ; } char [ ] sourceBuffer = new char [ 128 ] ; / / Per script / function source buffer top : parent source does not include a / / nested functions source and uses function index as a reference instead . int sourceTop ; / / whether to do a debug print of the source information , when decompiling . boolean printSource = false ; }
void test2 ( ) throws Throwable { CompilerEnvirons compilerEnvirons0 = new CompilerEnvirons ( ) ; Parser parser0 = new Parser ( compilerEnvirons0 , ( ErrorReporter ) null ) ; StringReader stringReader0 = new StringReader ( "msg . method . not . found" ) ; parser0 . parse ( ( Reader ) stringReader0 , "msg . method . not . found" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void defineSymbol ( int declType , boolean ignoreNotInBlock , String name ) { Node . Scope definingScope = currentScope . getDefiningScope ( name ) ; Node . Scope . Symbol symbol = definingScope ! = null ? definingScope . getSymbol ( name ) : null ; boolean error = false ; if ( symbol ! = null & & ( symbol . declType = = Token . CONST | | declType = = Token . CONST ) ) { error = true ; } else { switch ( declType ) { case Token . LET : if ( symbol ! = null & & definingScope = = currentScope ) { error = symbol . declType = = Token . LET ; } int currentScopeType = currentScope . getType ( ) ; if ( ! ignoreNotInBlock & & ( ( currentScopeType = = Token . LOOP ) | | ( currentScopeType = = Token . IF ) ) ) { addError ( "msg . let . decl . not . in . block" ) ; } currentScope . putSymbol ( name , new Node . Scope . Symbol ( declType , name ) ) ; break ; case Token . VAR : case Token . CONST : case Token . FUNCTION : if ( symbol ! = null ) { if ( symbol . declType = = Token . VAR ) addStrictWarning ( "msg . var . redecl" , name ) ; else if ( symbol . declType = = Token . LP ) { addStrictWarning ( "msg . var . hides . arg" , name ) ; } } else { currentScriptOrFn . putSymbol ( name , new Node . Scope . Symbol ( declType , name ) ) ; } break ; case Token . LP : if ( symbol ! = null ) { / / must be duplicate parameter . Second parameter hides the / / first , so go ahead and add the second pararameter addWarning ( "msg . dup . parms" , name ) ; } currentScriptOrFn . putSymbol ( name , new Node . Scope . Symbol ( declType , name ) ) ; break ; default : throw Kit . codeBug ( ) ; } } if ( error ) { addError ( symbol . declType = = Token . CONST ? "msg . const . redecl" : symbol . declType = = Token . LET ? "msg . let . redecl" : symbol . declType = = Token . VAR ? "msg . var . redecl" : symbol . declType = = Token . FUNCTION ? "msg . fn . redecl" : "msg . parm . redecl" , name ) ; } }
void test6 ( ) throws Throwable { Parser parser0 = new Parser ( ( CompilerEnvirons ) null , ( ErrorReporter ) null ) ; String string0 = parser0 . getEncodedSource ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncodedSource ( ) { return encodedSource ; }
void test8 ( ) throws Throwable { CompilerEnvirons compilerEnvirons0 = new CompilerEnvirons ( ) ; Parser parser0 = new Parser ( compilerEnvirons0 , ( ErrorReporter ) null ) ; parser0 . addStrictWarning ( "msg . method . not . found" , "msg . method . not . found" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncodedSource ( ) { return encodedSource ; }
void test0 ( ) throws Throwable { String string0 = Token . name ( 564 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String name ( int token ) { if ( ! printNames ) { return String . valueOf ( token ) ; } switch ( token ) { case ERROR : return "ERROR" ; case EOF : return "EOF" ; case EOL : return "EOL" ; case ENTERWITH : return "ENTERWITH" ; case LEAVEWITH : return "LEAVEWITH" ; case RETURN : return "RETURN" ; case GOTO : return "GOTO" ; case IFEQ : return "IFEQ" ; case IFNE : return "IFNE" ; case SETNAME : return "SETNAME" ; case BITOR : return "BITOR" ; case BITXOR : return "BITXOR" ; case BITAND : return "BITAND" ; case EQ : return "EQ" ; case NE : return "NE" ; case LT : return "LT" ; case LE : return "LE" ; case GT : return "GT" ; case GE : return "GE" ; case LSH : return "LSH" ; case RSH : return "RSH" ; case URSH : return "URSH" ; case ADD : return "ADD" ; case SUB : return "SUB" ; case MUL : return "MUL" ; case DIV : return "DIV" ; case MOD : return "MOD" ; case NOT : return "NOT" ; case BITNOT : return "BITNOT" ; case POS : return "POS" ; case NEG : return "NEG" ; case NEW : return "NEW" ; case DELPROP : return "DELPROP" ; case TYPEOF : return "TYPEOF" ; case GETPROP : return "GETPROP" ; case GETPROPNOWARN : return "GETPROPNOWARN" ; case SETPROP : return "SETPROP" ; case GETELEM : return "GETELEM" ; case SETELEM : return "SETELEM" ; case CALL : return "CALL" ; case NAME : return "NAME" ; case NUMBER : return "NUMBER" ; case STRING : return "STRING" ; case NULL : return "NULL" ; case THIS : return "THIS" ; case FALSE : return "FALSE" ; case TRUE : return "TRUE" ; case SHEQ : return "SHEQ" ; case SHNE : return "SHNE" ; case REGEXP : return "OBJECT" ; case BINDNAME : return "BINDNAME" ; case THROW : return "THROW" ; case RETHROW : return "RETHROW" ; case IN : return "IN" ; case INSTANCEOF : return "INSTANCEOF" ; case LOCAL_LOAD : return "LOCAL_LOAD" ; case GETVAR : return "GETVAR" ; case SETVAR : return "SETVAR" ; case CATCH_SCOPE : return "CATCH_SCOPE" ; case ENUM_INIT_KEYS : return "ENUM_INIT_KEYS" ; case ENUM_INIT_VALUES : return "ENUM_INIT_VALUES" ; case ENUM_INIT_ARRAY : return "ENUM_INIT_ARRAY" ; case ENUM_NEXT : return "ENUM_NEXT" ; case ENUM_ID : return "ENUM_ID" ; case THISFN : return "THISFN" ; case RETURN_RESULT : return "RETURN_RESULT" ; case ARRAYLIT : return "ARRAYLIT" ; case OBJECTLIT : return "OBJECTLIT" ; case GET_REF : return "GET_REF" ; case SET_REF : return "SET_REF" ; case DEL_REF : return "DEL_REF" ; case REF_CALL : return "REF_CALL" ; case REF_SPECIAL : return "REF_SPECIAL" ; case DEFAULTNAMESPACE : return "DEFAULTNAMESPACE" ; case ESCXMLTEXT : return "ESCXMLTEXT" ; case ESCXMLATTR : return "ESCXMLATTR" ; case REF_MEMBER : return "REF_MEMBER" ; case REF_NS_MEMBER : return "REF_NS_MEMBER" ; case REF_NAME : return "REF_NAME" ; case REF_NS_NAME : return "REF_NS_NAME" ; case TRY : return "TRY" ; case SEMI : return "SEMI" ; case LB : return "LB" ; case RB : return "RB" ; case LC : return "LC" ; case RC : return "RC" ; case LP : return "LP" ; case RP : return "RP" ; case COMMA : return "COMMA" ; case ASSIGN : return "ASSIGN" ; case ASSIGN_BITOR : return "ASSIGN_BITOR" ; case ASSIGN_BITXOR : return "ASSIGN_BITXOR" ; case ASSIGN_BITAND : return "ASSIGN_BITAND" ; case ASSIGN_LSH : return "ASSIGN_LSH" ; case ASSIGN_RSH : return "ASSIGN_RSH" ; case ASSIGN_URSH : return "ASSIGN_URSH" ; case ASSIGN_ADD : return "ASSIGN_ADD" ; case ASSIGN_SUB : return "ASSIGN_SUB" ; case ASSIGN_MUL : return "ASSIGN_MUL" ; case ASSIGN_DIV : return "ASSIGN_DIV" ; case ASSIGN_MOD : return "ASSIGN_MOD" ; case HOOK : return "HOOK" ; case COLON : return "COLON" ; case OR : return "OR" ; case AND : return "AND" ; case INC : return "INC" ; case DEC : return "DEC" ; case DOT : return "DOT" ; case FUNCTION : return "FUNCTION" ; case EXPORT : return "EXPORT" ; case IMPORT : return "IMPORT" ; case IF : return "IF" ; case ELSE : return "ELSE" ; case SWITCH : return "SWITCH" ; case CASE : return "CASE" ; case DEFAULT : return "DEFAULT" ; case WHILE : return "WHILE" ; case DO : return "DO" ; case FOR : return "FOR" ; case BREAK : return "BREAK" ; case CONTINUE : return "CONTINUE" ; case VAR : return "VAR" ; case WITH : return "WITH" ; case CATCH : return "CATCH" ; case FINALLY : return "FINALLY" ; case VOID : return "VOID" ; case RESERVED : return "RESERVED" ; case EMPTY : return "EMPTY" ; case BLOCK : return "BLOCK" ; case LABEL : return "LABEL" ; case TARGET : return "TARGET" ; case LOOP : return "LOOP" ; case EXPR_VOID : return "EXPR_VOID" ; case EXPR_RESULT : return "EXPR_RESULT" ; case JSR : return "JSR" ; case SCRIPT : return "SCRIPT" ; case TYPEOFNAME : return "TYPEOFNAME" ; case USE_STACK : return "USE_STACK" ; case SETPROP_OP : return "SETPROP_OP" ; case SETELEM_OP : return "SETELEM_OP" ; case LOCAL_BLOCK : return "LOCAL_BLOCK" ; case SET_REF_OP : return "SET_REF_OP" ; case DOTDOT : return "DOTDOT" ; case COLONCOLON : return "COLONCOLON" ; case XML : return "XML" ; case DOTQUERY : return "DOTQUERY" ; case XMLATTR : return "XMLATTR" ; case XMLEND : return "XMLEND" ; case TO_OBJECT : return "TO_OBJECT" ; case TO_DOUBLE : return "TO_DOUBLE" ; case GET : return "GET" ; case SET : return "SET" ; case LET : return "LET" ; case YIELD : return "YIELD" ; case CONST : return "CONST" ; case SETCONST : return "SETCONST" ; case ARRAYCOMP : return "ARRAYCOMP" ; case WITHEXPR : return "WITHEXPR" ; case LETEXPR : return "LETEXPR" ; case DEBUGGER : return "DEBUGGER" ; } / / Token without name throw new IllegalStateException ( String . valueOf ( token ) ) ; }
void test1 ( ) throws Throwable { Token token0 = new Token ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { TokenStream tokenStream0 = new TokenStream ( ( Parser ) null , ( Reader ) null , "kgt" , 1199 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getOffset ( ) { int n = sourceCursor - lineStart ; if ( lineEndChar > = 0 ) { - - n ; } return n ; }
void test1 ( ) throws Throwable { CompilerEnvirons compilerEnvirons0 = new CompilerEnvirons ( ) ; ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter ( false ) ; Parser parser0 = new Parser ( compilerEnvirons0 , ( ErrorReporter ) toolErrorReporter0 ) ; TokenStream tokenStream0 = new TokenStream ( parser0 , ( Reader ) null , "throw" , ( int ) ' ? ' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLineno ( ) { return lineno ; }
void test3 ( ) throws Throwable { CompilerEnvirons compilerEnvirons0 = new CompilerEnvirons ( ) ; ErrorReporter errorReporter0 = compilerEnvirons0 . getErrorReporter ( ) ; Parser parser0 = new Parser ( ( CompilerEnvirons ) null , errorReporter0 ) ; TokenStream tokenStream0 = new TokenStream ( parser0 , ( Reader ) null , "YYKz%5 ] O = 'yx > " , 1399 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isXMLAttribute ( ) { return xmlIsAttribute ; }
void test6 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test7 ( ) throws Throwable { CompilerEnvirons compilerEnvirons0 = new CompilerEnvirons ( ) ; ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter ( false ) ; Parser parser0 = new Parser ( compilerEnvirons0 , ( ErrorReporter ) toolErrorReporter0 ) ; TokenStream tokenStream0 = new TokenStream ( parser0 , ( Reader ) null , "thr : ow" , ( int ) ' ? ' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getOffset ( ) { int n = sourceCursor - lineStart ; if ( lineEndChar > = 0 ) { - - n ; } return n ; }
void test8 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "js : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test10 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "Ja > 0 : _ : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test11 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "getMonth" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test12 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "J ! Ca > = : _ : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test13 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "% { 9N / / ( 5V " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test14 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "msg . no . paren" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test15 ( ) throws Throwable { CompilerEnvirons compilerEnvirons0 = new CompilerEnvirons ( ) ; ErrorReporter errorReporter0 = compilerEnvirons0 . getErrorReporter ( ) ; Parser parser0 = new Parser ( compilerEnvirons0 , errorReporter0 ) ; ScriptOrFnNode scriptOrFnNode0 = parser0 . parse ( "msg . no . paren" , "msg . no . paren" , ( int ) 'U' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncodedSource ( ) { return encodedSource ; }
void test16 ( ) throws Throwable { TokenStream tokenStream0 = new TokenStream ( ( Parser ) null , ( Reader ) null , "for " , 184 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getOffset ( ) { int n = sourceCursor - lineStart ; if ( lineEndChar > = 0 ) { - - n ; } return n ; }
void test17 ( ) throws Throwable { CompilerEnvirons compilerEnvirons0 = new CompilerEnvirons ( ) ; ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter ( false ) ; Parser parser0 = new Parser ( compilerEnvirons0 , ( ErrorReporter ) toolErrorReporter0 ) ; char [ ] charArray0 = new char [ 6 ] ; charArray0 [ 0 ] = 'g' ; charArray0 [ 3 ] = ' ? ' ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 ) ; TokenStream tokenStream0 = new TokenStream ( parser0 , ( Reader ) charArrayReader0 , ( String ) null , ( int ) ' ? ' ) ; int int0 = tokenStream0 . getToken ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JavaScriptToken getToken ( int delta ) { return ( JavaScriptToken ) tokens . get ( offset + delta ) ; }
void test18 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "kgt" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test19 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "y9j" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test20 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "for " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test22 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "lIkg" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test23 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "main" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test24 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "ok > c" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test25 ( ) throws Throwable { CompilerEnvirons compilerEnvirons0 = new CompilerEnvirons ( ) ; ErrorReporter errorReporter0 = compilerEnvirons0 . getErrorReporter ( ) ; Parser parser0 = new Parser ( compilerEnvirons0 , errorReporter0 ) ; ScriptOrFnNode scriptOrFnNode0 = parser0 . parse ( "v6Gv" , "v6Gv" , 41 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEncodedSource ( ) { return encodedSource ; }
void test27 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( " * 'cvT" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test28 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "gMnth" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test29 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "fAor " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test31 ( ) throws Throwable { CompilerEnvirons compilerEnvirons0 = new CompilerEnvirons ( ) ; ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter ( false ) ; Parser parser0 = new Parser ( compilerEnvirons0 , ( ErrorReporter ) toolErrorReporter0 ) ; char [ ] charArray0 = new char [ 6 ] ; charArray0 [ 0 ] = 'g' ; charArray0 [ 1 ] = 'g' ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 ) ; TokenStream tokenStream0 = new TokenStream ( parser0 , ( Reader ) charArrayReader0 , ( String ) null , ( int ) 'V' ) ; int int0 = tokenStream0 . getToken ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JavaScriptToken getToken ( int delta ) { return ( JavaScriptToken ) tokens . get ( offset + delta ) ; }
void test32 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "Rmwtu = " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test33 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "KqFCib" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test34 ( ) throws Throwable { boolean boolean0 = TokenStream . isKeyword ( "Q6 + DEaW" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( String s ) { return Token . EOF ! = stringToKeyword ( s ) ; }
void test38 ( ) throws Throwable { CompilerEnvirons compilerEnvirons0 = new CompilerEnvirons ( ) ; ErrorReporter errorReporter0 = compilerEnvirons0 . getErrorReporter ( ) ; Parser parser0 = new Parser ( compilerEnvirons0 , errorReporter0 ) ; TokenStream tokenStream0 = new TokenStream ( parser0 , ( Reader ) null , " / " , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getOffset ( ) { int n = sourceCursor - lineStart ; if ( lineEndChar > = 0 ) { - - n ; } return n ; }
void test40 ( ) throws Throwable { TokenStream tokenStream0 = new TokenStream ( ( Parser ) null , ( Reader ) null , "^v%`ioc ) | le'q2 - jCD" , 1199 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getOffset ( ) { int n = sourceCursor - lineStart ; if ( lineEndChar > = 0 ) { - - n ; } return n ; }
void test41 ( ) throws Throwable { ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter ( true ) ; Parser parser0 = new Parser ( ( CompilerEnvirons ) null , ( ErrorReporter ) toolErrorReporter0 ) ; TokenStream tokenStream0 = new TokenStream ( parser0 , ( Reader ) null , " ( Lorg / mozilla / javascript / Context ; Lorg / mozilla / javascript / Scriptable ; Lorg / mozilla / javascript / Scriptable ; [ Ljava / lang / Object ; ) Ljava / lang / Object ; " , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void readRegExp ( int startToken ) throws IOException { stringBufferTop = 0 ; if ( startToken = = Token . ASSIGN_DIV ) { / / Miss - scanned / = addToString ( ' = ' ) ; } else { if ( startToken ! = Token . DIV ) Kit . codeBug ( ) ; } int c ; boolean inClass = false ; while ( ( c = getChar ( ) ) ! = ' / ' | | inClass ) { if ( c = = '\n' | | c = = EOF_CHAR ) { ungetChar ( c ) ; throw parser . reportError ( "msg . unterminated . re . lit" ) ; } if ( c = = '\\' ) { addToString ( c ) ; c = getChar ( ) ; } else if ( c = = ' [ ' ) { inClass = true ; } else if ( c = = ' ] ' ) { inClass = false ; } addToString ( c ) ; } int reEnd = stringBufferTop ; while ( true ) { if ( matchChar ( 'g' ) ) addToString ( 'g' ) ; else if ( matchChar ( 'i' ) ) addToString ( 'i' ) ; else if ( matchChar ( 'm' ) ) addToString ( 'm' ) ; else break ; } if ( isAlpha ( peekChar ( ) ) ) { throw parser . reportError ( "msg . invalid . re . flag" ) ; } this . string = new String ( stringBuffer , 0 , reEnd ) ; this . regExpFlags = new String ( stringBuffer , reEnd , stringBufferTop - reEnd ) ; }
void test43 ( ) throws Throwable { boolean boolean0 = TokenStream . isJSSpace ( 11 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJSSpace ( int c ) { if ( c < = 127 ) { return c = = 0x20 | | c = = 0x9 | | c = = 0xC | | c = = 0xB ; } else { return c = = 0xA0 | | Character . getType ( ( char ) c ) = = Character . SPACE_SEPARATOR ; } }
void test44 ( ) throws Throwable { TokenStream tokenStream0 = new TokenStream ( ( Parser ) null , ( Reader ) null , "catch" , 8232 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void readRegExp ( int startToken ) throws IOException { stringBufferTop = 0 ; if ( startToken = = Token . ASSIGN_DIV ) { / / Miss - scanned / = addToString ( ' = ' ) ; } else { if ( startToken ! = Token . DIV ) Kit . codeBug ( ) ; } int c ; boolean inClass = false ; while ( ( c = getChar ( ) ) ! = ' / ' | | inClass ) { if ( c = = '\n' | | c = = EOF_CHAR ) { ungetChar ( c ) ; throw parser . reportError ( "msg . unterminated . re . lit" ) ; } if ( c = = '\\' ) { addToString ( c ) ; c = getChar ( ) ; } else if ( c = = ' [ ' ) { inClass = true ; } else if ( c = = ' ] ' ) { inClass = false ; } addToString ( c ) ; } int reEnd = stringBufferTop ; while ( true ) { if ( matchChar ( 'g' ) ) addToString ( 'g' ) ; else if ( matchChar ( 'i' ) ) addToString ( 'i' ) ; else if ( matchChar ( 'm' ) ) addToString ( 'm' ) ; else break ; } if ( isAlpha ( peekChar ( ) ) ) { throw parser . reportError ( "msg . invalid . re . flag" ) ; } this . string = new String ( stringBuffer , 0 , reEnd ) ; this . regExpFlags = new String ( stringBuffer , reEnd , stringBufferTop - reEnd ) ; }
void test45 ( ) throws Throwable { ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter ( true ) ; Parser parser0 = new Parser ( ( CompilerEnvirons ) null , ( ErrorReporter ) toolErrorReporter0 ) ; TokenStream tokenStream0 = new TokenStream ( parser0 , ( Reader ) null , "xVO > Euo" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void readRegExp ( int startToken ) throws IOException { stringBufferTop = 0 ; if ( startToken = = Token . ASSIGN_DIV ) { / / Miss - scanned / = addToString ( ' = ' ) ; } else { if ( startToken ! = Token . DIV ) Kit . codeBug ( ) ; } int c ; boolean inClass = false ; while ( ( c = getChar ( ) ) ! = ' / ' | | inClass ) { if ( c = = '\n' | | c = = EOF_CHAR ) { ungetChar ( c ) ; throw parser . reportError ( "msg . unterminated . re . lit" ) ; } if ( c = = '\\' ) { addToString ( c ) ; c = getChar ( ) ; } else if ( c = = ' [ ' ) { inClass = true ; } else if ( c = = ' ] ' ) { inClass = false ; } addToString ( c ) ; } int reEnd = stringBufferTop ; while ( true ) { if ( matchChar ( 'g' ) ) addToString ( 'g' ) ; else if ( matchChar ( 'i' ) ) addToString ( 'i' ) ; else if ( matchChar ( 'm' ) ) addToString ( 'm' ) ; else break ; } if ( isAlpha ( peekChar ( ) ) ) { throw parser . reportError ( "msg . invalid . re . flag" ) ; } this . string = new String ( stringBuffer , 0 , reEnd ) ; this . regExpFlags = new String ( stringBuffer , reEnd , stringBufferTop - reEnd ) ; }
void test46 ( ) throws Throwable { TokenStream tokenStream0 = new TokenStream ( ( Parser ) null , ( Reader ) null , "for " , 184 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFirstXMLToken ( ) throws IOException { xmlOpenTagsCount = 0 ; xmlIsAttribute = false ; xmlIsTagContent = false ; ungetChar ( ' < ' ) ; return getNextXMLToken ( ) ; }
void test47 ( ) throws Throwable { TokenStream tokenStream0 = new TokenStream ( ( Parser ) null , ( Reader ) null , "YYEz%5 ] O = 'yx > oz" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFirstXMLToken ( ) throws IOException { xmlOpenTagsCount = 0 ; xmlIsAttribute = false ; xmlIsTagContent = false ; ungetChar ( ' < ' ) ; return getNextXMLToken ( ) ; }
void test48 ( ) throws Throwable { CompilerEnvirons compilerEnvirons0 = new CompilerEnvirons ( ) ; ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter ( false ) ; Parser parser0 = new Parser ( compilerEnvirons0 , ( ErrorReporter ) toolErrorReporter0 ) ; TokenStream tokenStream0 = new TokenStream ( parser0 , ( Reader ) null , "zOt > G & C# , 88Pd" , ( - 192 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFirstXMLToken ( ) throws IOException { xmlOpenTagsCount = 0 ; xmlIsAttribute = false ; xmlIsTagContent = false ; ungetChar ( ' < ' ) ; return getNextXMLToken ( ) ; }
void test49 ( ) throws Throwable { TokenStream tokenStream0 = new TokenStream ( ( Parser ) null , ( Reader ) null , "% { 9N / / ( 5V " , 667 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JavaScriptToken getToken ( int delta ) { return ( JavaScriptToken ) tokens . get ( offset + delta ) ; }
