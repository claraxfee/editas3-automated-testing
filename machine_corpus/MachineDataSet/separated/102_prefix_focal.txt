void test0 ( ) throws Throwable { String string0 = Version . getApplicationName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getApplicationName ( ) { return APP_NAME ; }
void test1 ( ) throws Throwable { String string0 = Version . getCopyrightStatement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCopyrightStatement ( ) { return COPYRIGHT ; }
void test2 ( ) throws Throwable { String string0 = Version . getVersion ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getVersion ( ) { return "0 . 1" ; }
void test3 ( ) throws Throwable { String string0 = Version . getUnsupportedJDKMessage ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUnsupportedJDKMessage ( ) { String [ ] params = new String [ ] { System . getProperty ( "java . vm . version" ) , System . getProperty ( "java . home" ) } ; return s_stringMgr . getString ( "Application . error . unsupportedJDKVersion" , params ) ; }
void test4 ( ) throws Throwable { String string0 = Version . getWebSite ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWebSite ( ) { return WEB_SITE ; }
void test5 ( ) throws Throwable { Version version0 = new Version ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getApplicationName ( ) { return APP_NAME ; }
void test6 ( ) throws Throwable { boolean boolean0 = Version . supportsUsedJDK ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUsedJDK ( ) { String vmVer = System . getProperty ( "java . vm . version" ) ; if ( vmVer . startsWith ( "0" ) | | vmVer . startsWith ( "1 . 0" ) | | vmVer . startsWith ( "1 . 1" ) | | vmVer . startsWith ( "1 . 2" ) | | vmVer . startsWith ( "1 . 3" ) | | vmVer . startsWith ( "1 . 4" ) | | vmVer . startsWith ( "1 . 5" ) ) { return false ; } else { return true ; } }
void test7 ( ) throws Throwable { boolean boolean0 = Version . isJDK14 ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJDK14 ( ) { String vmVer = System . getProperty ( "java . vm . version" ) ; if ( vmVer . startsWith ( "1 . 4" ) ) { return true ; } else { return false ; } }
void test8 ( ) throws Throwable { boolean boolean0 = Version . isJDK16OrAbove ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJDK16OrAbove ( ) { String vmVer = System . getProperty ( "java . vm . version" ) . substring ( 0 , 3 ) ; if ( vmVer . compareTo ( "1 . 6" ) > = 0 ) { return true ; } else { return false ; } }
void test0 ( ) throws Throwable { FontInfoStore fontInfoStore0 = new FontInfoStore ( ) ; fontInfoStore0 . setStatusBarFontInfo ( ( FontInfo ) null ) ; FontInfo fontInfo0 = fontInfoStore0 . getStatusBarFontInfo ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFamily ( ) { return _familyName ; }
void test1 ( ) throws Throwable { FontInfoStore fontInfoStore0 = new FontInfoStore ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test0 ( ) throws Throwable { DummyAppPlugin dummyAppPlugin0 = new DummyAppPlugin ( ) ; String string0 = dummyAppPlugin0 . getVersion ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getVersion ( ) { return "0 . 1" ; }
void test1 ( ) throws Throwable { DummyAppPlugin dummyAppPlugin0 = new DummyAppPlugin ( ) ; String string0 = dummyAppPlugin0 . getDescriptiveName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDescriptiveName ( ) { return "Dummy Application Plugin" ; }
void test2 ( ) throws Throwable { DummyAppPlugin dummyAppPlugin0 = new DummyAppPlugin ( ) ; String string0 = dummyAppPlugin0 . getInternalName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getInternalName ( ) { return "app" ; }
void test3 ( ) throws Throwable { DummyAppPlugin dummyAppPlugin0 = new DummyAppPlugin ( ) ; String string0 = dummyAppPlugin0 . getAuthor ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAuthor ( ) { return "Colin Bell" ; }
void test0 ( ) throws Throwable { OutOfMemoryErrorHandler outOfMemoryErrorHandler0 = new OutOfMemoryErrorHandler ( ) ; IApplication iApplication0 = outOfMemoryErrorHandler0 . getApplication ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IApplication getApplication ( ) { return application ; }
void test0 ( ) throws Throwable { ApplicationArguments applicationArguments0 = ApplicationArguments . getInstance ( ) ; applicationArguments0 . printHelp ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLoggingConfigFileName ( ) ; / * * * @return < TT > true < / TT > if the plugins should be loaded . * / boolean getLoadPlugins ( ) ; / * * * @return < TT > true < / TT > if the default metal theme should be used * rather than the SQuirreL metal theme . * / boolean useDefaultMetalTheme ( ) ; / * * * Retrieve whether to use the Look and Feel . * * @return < TT > true < / TT > to use the LAF . * / boolean useNativeLAF ( ) ; / * * * @return The raw arguments passed on the command line . * / String [ ] getRawArguments ( ) ; / * * * @return a boolean indicating whether or not to enable user interface debugging mode * / boolean getUserInterfaceDebugEnabled ( ) ; / * * * @return * / List < String > getPluginList ( ) ; }
void test1 ( ) throws Throwable { ApplicationArguments applicationArguments0 = ApplicationArguments . getInstance ( ) ; boolean boolean0 = applicationArguments0 . useNativeLAF ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useNativeLAF ( ) ; / * * * @return The raw arguments passed on the command line . * / String [ ] getRawArguments ( ) ; / * * * @return a boolean indicating whether or not to enable user interface debugging mode * / boolean getUserInterfaceDebugEnabled ( ) ; / * * * @return * / List < String > getPluginList ( ) ; }
void test2 ( ) throws Throwable { ApplicationArguments applicationArguments0 = ApplicationArguments . getInstance ( ) ; String [ ] stringArray0 = applicationArguments0 . getRawArguments ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void initialize ( FileAppender fa , boolean doStartupLogging ) { String configFileName = ApplicationArguments . getInstance ( ) . getLoggingConfigFileName ( ) ; if ( configFileName ! = null ) { PropertyConfigurator . configure ( configFileName ) ; } else { Properties props = new Properties ( ) ; props . setProperty ( "log4j . rootLogger" , "debug , SquirrelAppender" ) ; props . setProperty ( "log4j . appender . SquirrelAppender" , "net . sourceforge . squirrel_sql . client . SquirrelFileSizeRollingAppender" ) ; props . setProperty ( "log4j . appender . SquirrelAppender . layout" , "org . apache . log4j . PatternLayout" ) ; props . setProperty ( "log4j . appender . SquirrelAppender . layout . ConversionPattern" , "%d { ISO8601 } [ %t ] % - 5p %c %x - %m%n" ) ; PropertyConfigurator . configure ( props ) ; / / Logger . getRootLogger ( ) . removeAllAppenders ( ) ; / / BasicConfigurator . configure ( fa ) ; / / ILogger log = createLogger ( getClass ( ) ) ; / / if ( log . isInfoEnabled ( ) ) { / / log . info ( "No logger configuration file passed on command line arguments . Using default log file : " / / + fa . getFile ( ) ) ; / / } } if ( doStartupLogging ) { doStartupLogging ( ) ; } }
void test4 ( ) throws Throwable { ApplicationArguments applicationArguments0 = ApplicationArguments . getInstance ( ) ; String string0 = applicationArguments0 . getLoggingConfigFileName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLoggingConfigFileName ( ) ; / * * * @return < TT > true < / TT > if the plugins should be loaded . * / boolean getLoadPlugins ( ) ; / * * * @return < TT > true < / TT > if the default metal theme should be used * rather than the SQuirreL metal theme . * / boolean useDefaultMetalTheme ( ) ; / * * * Retrieve whether to use the Look and Feel . * * @return < TT > true < / TT > to use the LAF . * / boolean useNativeLAF ( ) ; / * * * @return The raw arguments passed on the command line . * / String [ ] getRawArguments ( ) ; / * * * @return a boolean indicating whether or not to enable user interface debugging mode * / boolean getUserInterfaceDebugEnabled ( ) ; / * * * @return * / List < String > getPluginList ( ) ; }
void test5 ( ) throws Throwable { ApplicationArguments applicationArguments0 = ApplicationArguments . getInstance ( ) ; boolean boolean0 = applicationArguments0 . useDefaultMetalTheme ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useDefaultMetalTheme ( ) ; / * * * Retrieve whether to use the Look and Feel . * * @return < TT > true < / TT > to use the LAF . * / boolean useNativeLAF ( ) ; / * * * @return The raw arguments passed on the command line . * / String [ ] getRawArguments ( ) ; / * * * @return a boolean indicating whether or not to enable user interface debugging mode * / boolean getUserInterfaceDebugEnabled ( ) ; / * * * @return * / List < String > getPluginList ( ) ; }
void test6 ( ) throws Throwable { ApplicationArguments applicationArguments0 = ApplicationArguments . getInstance ( ) ; String string0 = applicationArguments0 . getUserSettingsDirectoryOverride ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUserSettingsDirectoryOverride ( ) ; / * * * @return < TT > true < / TT > if splashscreen should be shown . * / boolean getShowSplashScreen ( ) ; / * * * @return < TT > true < / TT > if help information should be written to * standard output . * / boolean getShowHelp ( ) ; / * * * @return the logging configuration file name . Will be * < TT > null < / TT > if not passed . * / String getLoggingConfigFileName ( ) ; / * * * @return < TT > true < / TT > if the plugins should be loaded . * / boolean getLoadPlugins ( ) ; / * * * @return < TT > true < / TT > if the default metal theme should be used * rather than the SQuirreL metal theme . * / boolean useDefaultMetalTheme ( ) ; / * * * Retrieve whether to use the Look and Feel . * * @return < TT > true < / TT > to use the LAF . * / boolean useNativeLAF ( ) ; / * * * @return The raw arguments passed on the command line . * / String [ ] getRawArguments ( ) ; / * * * @return a boolean indicating whether or not to enable user interface debugging mode * / boolean getUserInterfaceDebugEnabled ( ) ; / * * * @return * / List < String > getPluginList ( ) ; }
void test7 ( ) throws Throwable { ApplicationArguments applicationArguments0 = ApplicationArguments . getInstance ( ) ; boolean boolean0 = applicationArguments0 . getShowHelp ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowHelp ( ) ; / * * * @return the logging configuration file name . Will be * < TT > null < / TT > if not passed . * / String getLoggingConfigFileName ( ) ; / * * * @return < TT > true < / TT > if the plugins should be loaded . * / boolean getLoadPlugins ( ) ; / * * * @return < TT > true < / TT > if the default metal theme should be used * rather than the SQuirreL metal theme . * / boolean useDefaultMetalTheme ( ) ; / * * * Retrieve whether to use the Look and Feel . * * @return < TT > true < / TT > to use the LAF . * / boolean useNativeLAF ( ) ; / * * * @return The raw arguments passed on the command line . * / String [ ] getRawArguments ( ) ; / * * * @return a boolean indicating whether or not to enable user interface debugging mode * / boolean getUserInterfaceDebugEnabled ( ) ; / * * * @return * / List < String > getPluginList ( ) ; }
void test8 ( ) throws Throwable { ApplicationArguments applicationArguments0 = ApplicationArguments . getInstance ( ) ; String string0 = applicationArguments0 . getSquirrelHomeDirectory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSquirrelHomeDirectory ( ) ; / * * * @return The name of the directory that Squirrel is installed into . * / String getUserSettingsDirectoryOverride ( ) ; / * * * @return < TT > true < / TT > if splashscreen should be shown . * / boolean getShowSplashScreen ( ) ; / * * * @return < TT > true < / TT > if help information should be written to * standard output . * / boolean getShowHelp ( ) ; / * * * @return the logging configuration file name . Will be * < TT > null < / TT > if not passed . * / String getLoggingConfigFileName ( ) ; / * * * @return < TT > true < / TT > if the plugins should be loaded . * / boolean getLoadPlugins ( ) ; / * * * @return < TT > true < / TT > if the default metal theme should be used * rather than the SQuirreL metal theme . * / boolean useDefaultMetalTheme ( ) ; / * * * Retrieve whether to use the Look and Feel . * * @return < TT > true < / TT > to use the LAF . * / boolean useNativeLAF ( ) ; / * * * @return The raw arguments passed on the command line . * / String [ ] getRawArguments ( ) ; / * * * @return a boolean indicating whether or not to enable user interface debugging mode * / boolean getUserInterfaceDebugEnabled ( ) ; / * * * @return * / List < String > getPluginList ( ) ; }
void test9 ( ) throws Throwable { ApplicationArguments applicationArguments0 = ApplicationArguments . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowSplashScreen ( ) ; / * * * @return < TT > true < / TT > if help information should be written to * standard output . * / boolean getShowHelp ( ) ; / * * * @return the logging configuration file name . Will be * < TT > null < / TT > if not passed . * / String getLoggingConfigFileName ( ) ; / * * * @return < TT > true < / TT > if the plugins should be loaded . * / boolean getLoadPlugins ( ) ; / * * * @return < TT > true < / TT > if the default metal theme should be used * rather than the SQuirreL metal theme . * / boolean useDefaultMetalTheme ( ) ; / * * * Retrieve whether to use the Look and Feel . * * @return < TT > true < / TT > to use the LAF . * / boolean useNativeLAF ( ) ; / * * * @return The raw arguments passed on the command line . * / String [ ] getRawArguments ( ) ; / * * * @return a boolean indicating whether or not to enable user interface debugging mode * / boolean getUserInterfaceDebugEnabled ( ) ; / * * * @return * / List < String > getPluginList ( ) ; }
void test11 ( ) throws Throwable { ApplicationArguments applicationArguments0 = ApplicationArguments . getInstance ( ) ; boolean boolean0 = applicationArguments0 . getUserInterfaceDebugEnabled ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getUserInterfaceDebugEnabled ( ) ; / * * * @return * / List < String > getPluginList ( ) ; }
void test12 ( ) throws Throwable { String [ ] stringArray0 = new String [ 5 ] ; boolean boolean0 = ApplicationArguments . initialize ( stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void initialize ( FileAppender fa , boolean doStartupLogging ) { String configFileName = ApplicationArguments . getInstance ( ) . getLoggingConfigFileName ( ) ; if ( configFileName ! = null ) { PropertyConfigurator . configure ( configFileName ) ; } else { Properties props = new Properties ( ) ; props . setProperty ( "log4j . rootLogger" , "debug , SquirrelAppender" ) ; props . setProperty ( "log4j . appender . SquirrelAppender" , "net . sourceforge . squirrel_sql . client . SquirrelFileSizeRollingAppender" ) ; props . setProperty ( "log4j . appender . SquirrelAppender . layout" , "org . apache . log4j . PatternLayout" ) ; props . setProperty ( "log4j . appender . SquirrelAppender . layout . ConversionPattern" , "%d { ISO8601 } [ %t ] % - 5p %c %x - %m%n" ) ; PropertyConfigurator . configure ( props ) ; / / Logger . getRootLogger ( ) . removeAllAppenders ( ) ; / / BasicConfigurator . configure ( fa ) ; / / ILogger log = createLogger ( getClass ( ) ) ; / / if ( log . isInfoEnabled ( ) ) { / / log . info ( "No logger configuration file passed on command line arguments . Using default log file : " / / + fa . getFile ( ) ) ; / / } } if ( doStartupLogging ) { doStartupLogging ( ) ; } }
void test13 ( ) throws Throwable { ApplicationArguments applicationArguments0 = ApplicationArguments . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadPlugins ( ) ; / * * * @return < TT > true < / TT > if the default metal theme should be used * rather than the SQuirreL metal theme . * / boolean useDefaultMetalTheme ( ) ; / * * * Retrieve whether to use the Look and Feel . * * @return < TT > true < / TT > to use the LAF . * / boolean useNativeLAF ( ) ; / * * * @return The raw arguments passed on the command line . * / String [ ] getRawArguments ( ) ; / * * * @return a boolean indicating whether or not to enable user interface debugging mode * / boolean getUserInterfaceDebugEnabled ( ) ; / * * * @return * / List < String > getPluginList ( ) ; }
void test0 ( ) throws Throwable { FileTransformer fileTransformer0 = new FileTransformer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; String string0 = FileTransformer . transform ( applicationFiles0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String transform ( ApplicationFiles appFiles ) { return convertAliases_2_2_to_2_3 ( appFiles ) ; }
void test1 ( ) throws Throwable { Application application0 = new Application ( ) ; WindowManager windowManager0 = application0 . getWindowManager ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" WindowManager getWindowManager ( ) ; ActionCollection getActionCollection ( ) ; SQLDriverManager getSQLDriverManager ( ) ; DataCache getDataCache ( ) ; SquirrelPreferences getSquirrelPreferences ( ) ; DesktopStyle getDesktopStyle ( ) ; SquirrelResources getResources ( ) ; / * * * Retrieves the message handler for the application . * * @return Application level message handler . * / IMessageHandler getMessageHandler ( ) ; / * * * Return an array of all the sessions currently active . * * @return array of all active sessions . * / / / ISession [ ] getActiveSessions ( ) ; / * * * Retrieve the object that manages sessions . * * @return < TT > SessionManager < / TT > . * / SessionManager getSessionManager ( ) ; / * * * Display an error message dialog . * * @param msg The error msg . * / void showErrorDialog ( String msg ) ; / * * * Display an error message dialog . * * @param th The Throwable that caused the error * / void showErrorDialog ( Throwable th ) ; / * * * Display an error message dialog . * * @param msg The error msg . * @param th The Throwable that caused the error * / void showErrorDialog ( String msg , Throwable th ) ; / * * * Return the main frame . * * @return The main frame for the app . * / MainFrame getMainFrame ( ) ; / * * * Return the thread pool for this app . * * @return the thread pool for this app . * / TaskThreadPool getThreadPool ( ) ; / * * * Return the collection of < TT > FontInfo < / TT > objects for this app . * * @return the collection of < TT > FontInfo < / TT > objects for this app . * / FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test2 ( ) throws Throwable { Application application0 = new Application ( ) ; SQLDriverManager sQLDriverManager0 = application0 . getSQLDriverManager ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLDriverManager getSQLDriverManager ( ) ; DataCache getDataCache ( ) ; SquirrelPreferences getSquirrelPreferences ( ) ; DesktopStyle getDesktopStyle ( ) ; SquirrelResources getResources ( ) ; / * * * Retrieves the message handler for the application . * * @return Application level message handler . * / IMessageHandler getMessageHandler ( ) ; / * * * Return an array of all the sessions currently active . * * @return array of all active sessions . * / / / ISession [ ] getActiveSessions ( ) ; / * * * Retrieve the object that manages sessions . * * @return < TT > SessionManager < / TT > . * / SessionManager getSessionManager ( ) ; / * * * Display an error message dialog . * * @param msg The error msg . * / void showErrorDialog ( String msg ) ; / * * * Display an error message dialog . * * @param th The Throwable that caused the error * / void showErrorDialog ( Throwable th ) ; / * * * Display an error message dialog . * * @param msg The error msg . * @param th The Throwable that caused the error * / void showErrorDialog ( String msg , Throwable th ) ; / * * * Return the main frame . * * @return The main frame for the app . * / MainFrame getMainFrame ( ) ; / * * * Return the thread pool for this app . * * @return the thread pool for this app . * / TaskThreadPool getThreadPool ( ) ; / * * * Return the collection of < TT > FontInfo < / TT > objects for this app . * * @return the collection of < TT > FontInfo < / TT > objects for this app . * / FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test3 ( ) throws Throwable { Application application0 = new Application ( ) ; ActionCollection actionCollection0 = application0 . getActionCollection ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ActionCollection getActionCollection ( ) ; SQLDriverManager getSQLDriverManager ( ) ; DataCache getDataCache ( ) ; SquirrelPreferences getSquirrelPreferences ( ) ; DesktopStyle getDesktopStyle ( ) ; SquirrelResources getResources ( ) ; / * * * Retrieves the message handler for the application . * * @return Application level message handler . * / IMessageHandler getMessageHandler ( ) ; / * * * Return an array of all the sessions currently active . * * @return array of all active sessions . * / / / ISession [ ] getActiveSessions ( ) ; / * * * Retrieve the object that manages sessions . * * @return < TT > SessionManager < / TT > . * / SessionManager getSessionManager ( ) ; / * * * Display an error message dialog . * * @param msg The error msg . * / void showErrorDialog ( String msg ) ; / * * * Display an error message dialog . * * @param th The Throwable that caused the error * / void showErrorDialog ( Throwable th ) ; / * * * Display an error message dialog . * * @param msg The error msg . * @param th The Throwable that caused the error * / void showErrorDialog ( String msg , Throwable th ) ; / * * * Return the main frame . * * @return The main frame for the app . * / MainFrame getMainFrame ( ) ; / * * * Return the thread pool for this app . * * @return the thread pool for this app . * / TaskThreadPool getThreadPool ( ) ; / * * * Return the collection of < TT > FontInfo < / TT > objects for this app . * * @return the collection of < TT > FontInfo < / TT > objects for this app . * / FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test6 ( ) throws Throwable { Application application0 = new Application ( ) ; DummyAppPlugin dummyAppPlugin0 = ( DummyAppPlugin ) application0 . getDummyAppPlugin ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLicenceFileName ( ) ; / * * * Create panels for the Global Preferences dialog . * * @return Array of < TT > IGlobalPreferencesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the Global Preferences Dialog . * / IGlobalPreferencesPanel [ ] getGlobalPreferencePanels ( ) ; / * * * Creates Alias Prefs Controllers for this Plugin . * / IAliasPropertiesPanelController [ ] getAliasPropertiesPanelControllers ( SQLAlias alias ) ; / * * * Called when an Alias is copied . Should be overridden by Plugins * that work with Alias properties . * / void aliasCopied ( SQLAlias source , SQLAlias target ) ; / * * * Called when an Alias is removed . Should be overridden by Plugins * that work with Alias properties . * / void aliasRemoved ( SQLAlias alias ) ; / * * * Create panels for the New Session Properties dialog . * * @return Array of < TT > INewSessionPropertiesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the New Session Properties Dialog . * / INewSessionPropertiesPanel [ ] getNewSessionPropertiesPanels ( ) ; / * * * Return the folder with the Squirrel application folder * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; squirrel_app & gt ; / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins application folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginAppSettingsFolder ( ) throws IOException , IllegalStateException ; / * * * Return the folder with the users home directory * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; user_home & gt ; / . squirrel - sql / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins user folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginUserSettingsFolder ( ) throws IllegalStateException , IOException ; / * * * Allows a plugin to provide services to other plugins . * @see PluginManager . bindExternalPluginService ( ) ; * / Object getExternalService ( ) ; / * * * Returns the absolute path to the plugin jar file . * * @return the absolute path to the plugin jar file . * * @throws IllegalStateException if this plugin doesn't have a valid internal name . * / String getPluginJarFilePath ( ) throws IllegalStateException ; / * * * @param applicationFiles the applicationFiles to set * / void setApplicationFiles ( ApplicationFileWrappers applicationFiles ) ; / * * * @param fileWrapperFactory the fileWrapperFactory to set * / void setFileWrapperFactory ( FileWrapperFactory fileWrapperFactory ) ; }
void test8 ( ) throws Throwable { Application application0 = new Application ( ) ; SessionManager sessionManager0 = application0 . getSessionManager ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SessionManager getSessionManager ( ) ; / * * * Display an error message dialog . * * @param msg The error msg . * / void showErrorDialog ( String msg ) ; / * * * Display an error message dialog . * * @param th The Throwable that caused the error * / void showErrorDialog ( Throwable th ) ; / * * * Display an error message dialog . * * @param msg The error msg . * @param th The Throwable that caused the error * / void showErrorDialog ( String msg , Throwable th ) ; / * * * Return the main frame . * * @return The main frame for the app . * / MainFrame getMainFrame ( ) ; / * * * Return the thread pool for this app . * * @return the thread pool for this app . * / TaskThreadPool getThreadPool ( ) ; / * * * Return the collection of < TT > FontInfo < / TT > objects for this app . * * @return the collection of < TT > FontInfo < / TT > objects for this app . * / FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test9 ( ) throws Throwable { Application application0 = new Application ( ) ; SQLHistory sQLHistory0 = application0 . getSQLHistory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test13 ( ) throws Throwable { Application application0 = new Application ( ) ; DesktopStyle desktopStyle0 = application0 . getDesktopStyle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DesktopStyle getDesktopStyle ( ) ; SquirrelResources getResources ( ) ; / * * * Retrieves the message handler for the application . * * @return Application level message handler . * / IMessageHandler getMessageHandler ( ) ; / * * * Return an array of all the sessions currently active . * * @return array of all active sessions . * / / / ISession [ ] getActiveSessions ( ) ; / * * * Retrieve the object that manages sessions . * * @return < TT > SessionManager < / TT > . * / SessionManager getSessionManager ( ) ; / * * * Display an error message dialog . * * @param msg The error msg . * / void showErrorDialog ( String msg ) ; / * * * Display an error message dialog . * * @param th The Throwable that caused the error * / void showErrorDialog ( Throwable th ) ; / * * * Display an error message dialog . * * @param msg The error msg . * @param th The Throwable that caused the error * / void showErrorDialog ( String msg , Throwable th ) ; / * * * Return the main frame . * * @return The main frame for the app . * / MainFrame getMainFrame ( ) ; / * * * Return the thread pool for this app . * * @return the thread pool for this app . * / TaskThreadPool getThreadPool ( ) ; / * * * Return the collection of < TT > FontInfo < / TT > objects for this app . * * @return the collection of < TT > FontInfo < / TT > objects for this app . * / FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test14 ( ) throws Throwable { Application application0 = new Application ( ) ; MultipleWindowsHandler multipleWindowsHandler0 = application0 . getMultipleWindowsHandler ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test15 ( ) throws Throwable { Application application0 = new Application ( ) ; DataCache dataCache0 = application0 . getDataCache ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataCache getDataCache ( ) ; SquirrelPreferences getSquirrelPreferences ( ) ; DesktopStyle getDesktopStyle ( ) ; SquirrelResources getResources ( ) ; / * * * Retrieves the message handler for the application . * * @return Application level message handler . * / IMessageHandler getMessageHandler ( ) ; / * * * Return an array of all the sessions currently active . * * @return array of all active sessions . * / / / ISession [ ] getActiveSessions ( ) ; / * * * Retrieve the object that manages sessions . * * @return < TT > SessionManager < / TT > . * / SessionManager getSessionManager ( ) ; / * * * Display an error message dialog . * * @param msg The error msg . * / void showErrorDialog ( String msg ) ; / * * * Display an error message dialog . * * @param th The Throwable that caused the error * / void showErrorDialog ( Throwable th ) ; / * * * Display an error message dialog . * * @param msg The error msg . * @param th The Throwable that caused the error * / void showErrorDialog ( String msg , Throwable th ) ; / * * * Return the main frame . * * @return The main frame for the app . * / MainFrame getMainFrame ( ) ; / * * * Return the thread pool for this app . * * @return the thread pool for this app . * / TaskThreadPool getThreadPool ( ) ; / * * * Return the collection of < TT > FontInfo < / TT > objects for this app . * * @return the collection of < TT > FontInfo < / TT > objects for this app . * / FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test18 ( ) throws Throwable { Application application0 = new Application ( ) ; LoggerController loggerController0 = application0 . getLoggerFactory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" LoggerController getLoggerFactory ( ) { return _loggerFactory ; }
void test19 ( ) throws Throwable { Application application0 = new Application ( ) ; SquirrelResources squirrelResources0 = application0 . getResources ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SquirrelResources getResources ( ) ; / * * * Retrieves the message handler for the application . * * @return Application level message handler . * / IMessageHandler getMessageHandler ( ) ; / * * * Return an array of all the sessions currently active . * * @return array of all active sessions . * / / / ISession [ ] getActiveSessions ( ) ; / * * * Retrieve the object that manages sessions . * * @return < TT > SessionManager < / TT > . * / SessionManager getSessionManager ( ) ; / * * * Display an error message dialog . * * @param msg The error msg . * / void showErrorDialog ( String msg ) ; / * * * Display an error message dialog . * * @param th The Throwable that caused the error * / void showErrorDialog ( Throwable th ) ; / * * * Display an error message dialog . * * @param msg The error msg . * @param th The Throwable that caused the error * / void showErrorDialog ( String msg , Throwable th ) ; / * * * Return the main frame . * * @return The main frame for the app . * / MainFrame getMainFrame ( ) ; / * * * Return the thread pool for this app . * * @return the thread pool for this app . * / TaskThreadPool getThreadPool ( ) ; / * * * Return the collection of < TT > FontInfo < / TT > objects for this app . * * @return the collection of < TT > FontInfo < / TT > objects for this app . * / FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test23 ( ) throws Throwable { Application application0 = new Application ( ) ; FontInfoStore fontInfoStore0 = application0 . getFontInfoStore ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test26 ( ) throws Throwable { Application application0 = new Application ( ) ; IPluginManager iPluginManager0 = application0 . getPluginManager ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginManager getPluginManager ( ) ; / * * * Return the manager responsible for windows . * * @return the manager responsible for windows . * / WindowManager getWindowManager ( ) ; ActionCollection getActionCollection ( ) ; SQLDriverManager getSQLDriverManager ( ) ; DataCache getDataCache ( ) ; SquirrelPreferences getSquirrelPreferences ( ) ; DesktopStyle getDesktopStyle ( ) ; SquirrelResources getResources ( ) ; / * * * Retrieves the message handler for the application . * * @return Application level message handler . * / IMessageHandler getMessageHandler ( ) ; / * * * Return an array of all the sessions currently active . * * @return array of all active sessions . * / / / ISession [ ] getActiveSessions ( ) ; / * * * Retrieve the object that manages sessions . * * @return < TT > SessionManager < / TT > . * / SessionManager getSessionManager ( ) ; / * * * Display an error message dialog . * * @param msg The error msg . * / void showErrorDialog ( String msg ) ; / * * * Display an error message dialog . * * @param th The Throwable that caused the error * / void showErrorDialog ( Throwable th ) ; / * * * Display an error message dialog . * * @param msg The error msg . * @param th The Throwable that caused the error * / void showErrorDialog ( String msg , Throwable th ) ; / * * * Return the main frame . * * @return The main frame for the app . * / MainFrame getMainFrame ( ) ; / * * * Return the thread pool for this app . * * @return the thread pool for this app . * / TaskThreadPool getThreadPool ( ) ; / * * * Return the collection of < TT > FontInfo < / TT > objects for this app . * * @return the collection of < TT > FontInfo < / TT > objects for this app . * / FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test27 ( ) throws Throwable { Application application0 = new Application ( ) ; TaskThreadPool taskThreadPool0 = application0 . getThreadPool ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TaskThreadPool getThreadPool ( ) ; / * * * Return the collection of < TT > FontInfo < / TT > objects for this app . * * @return the collection of < TT > FontInfo < / TT > objects for this app . * / FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test0 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { DailyRollingFileAppender dailyRollingFileAppender0 = new DailyRollingFileAppender ( ) ; SquirrelLoggerFactory squirrelLoggerFactory0 = new SquirrelLoggerFactory ( ( FileAppender ) dailyRollingFileAppender0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test1 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { SquirrelLoggerFactory squirrelLoggerFactory0 = new SquirrelLoggerFactory ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test2 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { DailyRollingFileAppender dailyRollingFileAppender0 = new DailyRollingFileAppender ( ) ; SquirrelLoggerFactory squirrelLoggerFactory0 = new SquirrelLoggerFactory ( ( FileAppender ) dailyRollingFileAppender0 , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test0 ( ) throws Throwable { ActionKeys actionKeys0 = new ActionKeys ( "" , "" , ( - 836 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMnemonic ( ) { return _mnemonic ; }
void test1 ( ) throws Throwable { ActionKeys actionKeys0 = new ActionKeys ( "" , "" , ( - 836 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMnemonic ( ) { return _mnemonic ; }
void test2 ( ) throws Throwable { ActionKeys actionKeys0 = new ActionKeys ( "" , "" , ( - 836 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMnemonic ( ) { return _mnemonic ; }
void test3 ( ) throws Throwable { ActionKeys actionKeys0 = new ActionKeys ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMnemonic ( ) { return _mnemonic ; }
void test4 ( ) throws Throwable { ActionKeys actionKeys0 = new ActionKeys ( "" , "" , ( - 836 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setActionClassName ( String value ) { if ( value = = null ) { throw new IllegalArgumentException ( "ActionClassName = = null" ) ; } _actionClassName = value ; }
void test5 ( ) throws Throwable { ActionKeys actionKeys0 = new ActionKeys ( "" , "" , ( - 836 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMnemonic ( ) { return _mnemonic ; }
void test0 ( ) throws Throwable { PluginInfo [ ] pluginInfoArray0 = new PluginInfo [ 1 ] ; DummyAppPlugin dummyAppPlugin0 = new DummyAppPlugin ( ) ; PluginInfo pluginInfo0 = new PluginInfo ( ) ; pluginInfoArray0 [ 0 ] = pluginInfo0 ; pluginInfoArray0 [ 0 ] . setPlugin ( dummyAppPlugin0 ) ; PluginStatus [ ] pluginStatusArray0 = new PluginStatus [ 2 ] ; PluginStatus pluginStatus0 = new PluginStatus ( ) ; pluginStatusArray0 [ 0 ] = pluginStatus0 ; pluginStatusArray0 [ 1 ] = pluginStatusArray0 [ 0 ] ; PluginSummaryTable pluginSummaryTable0 = new PluginSummaryTable ( pluginInfoArray0 , pluginStatusArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { PluginInfo [ ] pluginInfoArray0 = new PluginInfo [ 1 ] ; PluginInfo pluginInfo0 = new PluginInfo ( ) ; pluginInfoArray0 [ 0 ] = pluginInfo0 ; DummyAppPlugin dummyAppPlugin0 = new DummyAppPlugin ( ) ; pluginInfo0 . setPlugin ( dummyAppPlugin0 ) ; PluginSummaryTable pluginSummaryTable0 = new PluginSummaryTable ( pluginInfoArray0 , ( PluginStatus [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { PluginSummaryTable pluginSummaryTable0 = new PluginSummaryTable ( ( PluginInfo [ ] ) null , ( PluginStatus [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test3 ( ) throws Throwable { PluginInfo [ ] pluginInfoArray0 = new PluginInfo [ 1 ] ; PluginInfo pluginInfo0 = new PluginInfo ( ) ; pluginInfoArray0 [ 0 ] = pluginInfo0 ; DummyAppPlugin dummyAppPlugin0 = new DummyAppPlugin ( ) ; pluginInfo0 . setPlugin ( dummyAppPlugin0 ) ; PluginSummaryTable pluginSummaryTable0 = new PluginSummaryTable ( pluginInfoArray0 , ( PluginStatus [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test4 ( ) throws Throwable { PluginInfo [ ] pluginInfoArray0 = new PluginInfo [ 1 ] ; PluginInfo pluginInfo0 = new PluginInfo ( ) ; pluginInfoArray0 [ 0 ] = pluginInfo0 ; DummyAppPlugin dummyAppPlugin0 = new DummyAppPlugin ( ) ; pluginInfo0 . setPlugin ( dummyAppPlugin0 ) ; PluginSummaryTable pluginSummaryTable0 = new PluginSummaryTable ( pluginInfoArray0 , ( PluginStatus [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test5 ( ) throws Throwable { PluginInfo [ ] pluginInfoArray0 = new PluginInfo [ 1 ] ; PluginInfo pluginInfo0 = new PluginInfo ( ) ; pluginInfoArray0 [ 0 ] = pluginInfo0 ; DummyAppPlugin dummyAppPlugin0 = new DummyAppPlugin ( ) ; pluginInfo0 . setPlugin ( dummyAppPlugin0 ) ; PluginSummaryTable pluginSummaryTable0 = new PluginSummaryTable ( pluginInfoArray0 , ( PluginStatus [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test6 ( ) throws Throwable { PluginInfo [ ] pluginInfoArray0 = new PluginInfo [ 1 ] ; DummyAppPlugin dummyAppPlugin0 = new DummyAppPlugin ( ) ; PluginInfo pluginInfo0 = new PluginInfo ( ) ; pluginInfoArray0 [ 0 ] = pluginInfo0 ; pluginInfoArray0 [ 0 ] . setPlugin ( dummyAppPlugin0 ) ; PluginStatus [ ] pluginStatusArray0 = new PluginStatus [ 2 ] ; PluginStatus pluginStatus0 = new PluginStatus ( ) ; pluginStatusArray0 [ 0 ] = pluginStatus0 ; pluginStatusArray0 [ 1 ] = pluginStatusArray0 [ 0 ] ; PluginSummaryTable pluginSummaryTable0 = new PluginSummaryTable ( pluginInfoArray0 , pluginStatusArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test7 ( ) throws Throwable { PluginInfo [ ] pluginInfoArray0 = new PluginInfo [ 1 ] ; PluginInfo pluginInfo0 = new PluginInfo ( ) ; pluginInfoArray0 [ 0 ] = pluginInfo0 ; DummyAppPlugin dummyAppPlugin0 = new DummyAppPlugin ( ) ; pluginInfo0 . setPlugin ( dummyAppPlugin0 ) ; PluginSummaryTable pluginSummaryTable0 = new PluginSummaryTable ( pluginInfoArray0 , ( PluginStatus [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { PreferenceUtil preferenceUtil0 = new PreferenceUtil ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { PluginInfo pluginInfo0 = new PluginInfo ( "cmS < . " ) ; DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; pluginInfo0 . setPlugin ( dBCopyPlugin0 ) ; SessionPluginInfo sessionPluginInfo0 = new SessionPluginInfo ( pluginInfo0 ) ; DBCopyPlugin dBCopyPlugin1 = ( DBCopyPlugin ) sessionPluginInfo0 . getSessionPlugin ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ISessionPlugin getSessionPlugin ( ) { return ( ISessionPlugin ) getPlugin ( ) ; }
void test0 ( ) throws Throwable { PluginStatus pluginStatus0 = new PluginStatus ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLoadAtStartup ( ) { return _loadAtStartup ; }
void test1 ( ) throws Throwable { PluginStatus pluginStatus0 = new PluginStatus ( ) ; pluginStatus0 . setInternalName ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLoadAtStartup ( ) { return _loadAtStartup ; }
void test2 ( ) throws Throwable { PluginStatus pluginStatus0 = new PluginStatus ( ) ; pluginStatus0 . getInternalName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLoadAtStartup ( ) { return _loadAtStartup ; }
void test3 ( ) throws Throwable { PluginStatus pluginStatus0 = new PluginStatus ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLoadAtStartup ( ) { return _loadAtStartup ; }
void test4 ( ) throws Throwable { PluginStatus pluginStatus0 = new PluginStatus ( ) ; boolean boolean0 = pluginStatus0 . isLoadAtStartup ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLoadAtStartup ( ) { return _loadAtStartup ; }
void test0 ( ) throws Throwable { PluginGlobalPreferencesTab pluginGlobalPreferencesTab0 = new PluginGlobalPreferencesTab ( ( PluginQueryTokenizerPreferencesPanel ) null ) ; String string0 = pluginGlobalPreferencesTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { PluginGlobalPreferencesTab pluginGlobalPreferencesTab0 = new PluginGlobalPreferencesTab ( ( PluginQueryTokenizerPreferencesPanel ) null ) ; pluginGlobalPreferencesTab0 . initialize ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { PluginGlobalPreferencesTab pluginGlobalPreferencesTab0 = new PluginGlobalPreferencesTab ( ( PluginQueryTokenizerPreferencesPanel ) null ) ; String string0 = pluginGlobalPreferencesTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test3 ( ) throws Throwable { PluginGlobalPreferencesTab pluginGlobalPreferencesTab0 = new PluginGlobalPreferencesTab ( ( PluginQueryTokenizerPreferencesPanel ) null ) ; JScrollPane jScrollPane0 = ( JScrollPane ) pluginGlobalPreferencesTab0 . getPanelComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getPanelComponent ( ) { return this ; }
void test4 ( ) throws Throwable { PluginGlobalPreferencesTab pluginGlobalPreferencesTab0 = new PluginGlobalPreferencesTab ( ( PluginQueryTokenizerPreferencesPanel ) null ) ; pluginGlobalPreferencesTab0 . setHint ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test5 ( ) throws Throwable { PluginGlobalPreferencesTab pluginGlobalPreferencesTab0 = new PluginGlobalPreferencesTab ( ( PluginQueryTokenizerPreferencesPanel ) null ) ; pluginGlobalPreferencesTab0 . uninitialize ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test6 ( ) throws Throwable { PluginGlobalPreferencesTab pluginGlobalPreferencesTab0 = new PluginGlobalPreferencesTab ( ( PluginQueryTokenizerPreferencesPanel ) null ) ; pluginGlobalPreferencesTab0 . setTitle ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test7 ( ) throws Throwable { PluginGlobalPreferencesTab pluginGlobalPreferencesTab0 = new PluginGlobalPreferencesTab ( ( PluginQueryTokenizerPreferencesPanel ) null ) ; pluginGlobalPreferencesTab0 . applyChanges ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { SQLPreferencesPanel sQLPreferencesPanel0 = new SQLPreferencesPanel ( ( MainFrame ) null ) ; sQLPreferencesPanel0 . uninitialize ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { SQLPreferencesPanel sQLPreferencesPanel0 = new SQLPreferencesPanel ( ( MainFrame ) null ) ; String string0 = sQLPreferencesPanel0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test2 ( ) throws Throwable { SQLPreferencesPanel sQLPreferencesPanel0 = new SQLPreferencesPanel ( ( MainFrame ) null ) ; String string0 = sQLPreferencesPanel0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test4 ( ) throws Throwable { SQLPreferencesPanel sQLPreferencesPanel0 = new SQLPreferencesPanel ( ( MainFrame ) null ) ; sQLPreferencesPanel0 . getPanelComponent ( ) ; JScrollPane jScrollPane0 = ( JScrollPane ) sQLPreferencesPanel0 . getPanelComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getPanelComponent ( ) { return this ; }
void test0 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpdateServer ( ) { return updateServer ; }
void test1 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; UpdateSettings updateSettings1 = new UpdateSettings ( ( IUpdateSettings ) updateSettings0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFileSystemUpdatePath ( ) { return fileSystemUpdatePath ; }
void test2 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpdateServerPort ( ) { return updateServerPort ; }
void test3 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; updateSettings0 . setUpdateServerPort ( "80" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpdateServerChannel ( ) { return updateServerChannel ; }
void test4 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpdateServerPath ( ) { return updateServerPath ; }
void test5 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; updateSettings0 . setEnableAutomaticUpdates ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpdateServerChannel ( ) { return updateServerChannel ; }
void test6 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; updateSettings0 . setUpdateServerChannel ( "80" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpdateServerChannel ( ) { return updateServerChannel ; }
void test7 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; UpdateSettings updateSettings1 = ( UpdateSettings ) updateSettings0 . clone ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLastUpdateCheckTimeMillis ( ) { return lastUpdateCheckTimeMillis ; }
void test8 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpdateCheckFrequency ( ) { return updateCheckFrequency ; }
void test9 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; updateSettings0 . setFileSystemUpdatePath ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLastUpdateCheckTimeMillis ( ) { return lastUpdateCheckTimeMillis ; }
void test10 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; updateSettings0 . setRemoteUpdateSite ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpdateServer ( ) { return updateServer ; }
void test11 ( ) throws Throwable { UpdateSettings updateSettings0 = new UpdateSettings ( ) ; updateSettings0 . setUpdateServer ( "www . squirrel - sql . net" ) ; UpdateSettings updateSettings1 = new UpdateSettings ( ( IUpdateSettings ) updateSettings0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpdateServer ( ) { return updateServer ; }
void test0 ( ) throws Throwable { UpdateCheckFrequency updateCheckFrequency0 = UpdateCheckFrequency . STARTUP ; UpdateCheckFrequencyComboBoxEntry updateCheckFrequencyComboBoxEntry0 = new UpdateCheckFrequencyComboBoxEntry ( updateCheckFrequency0 , "" ) ; String string0 = updateCheckFrequencyComboBoxEntry0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { UpdateCheckFrequency updateCheckFrequency0 = UpdateCheckFrequency . STARTUP ; UpdateCheckFrequencyComboBoxEntry updateCheckFrequencyComboBoxEntry0 = new UpdateCheckFrequencyComboBoxEntry ( updateCheckFrequency0 , "" ) ; UpdateCheckFrequency updateCheckFrequency1 = updateCheckFrequencyComboBoxEntry0 . getUpdateCheckFrequencyEnum ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" UpdateCheckFrequency getUpdateCheckFrequencyEnum ( ) { return _frequency ; }
void test0 ( ) throws Throwable { GeneralPreferencesPanel generalPreferencesPanel0 = new GeneralPreferencesPanel ( ) ; generalPreferencesPanel0 . uninitialize ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { GeneralPreferencesPanel generalPreferencesPanel0 = new GeneralPreferencesPanel ( ) ; String string0 = generalPreferencesPanel0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test3 ( ) throws Throwable { GeneralPreferencesPanel generalPreferencesPanel0 = new GeneralPreferencesPanel ( ) ; String string0 = generalPreferencesPanel0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test5 ( ) throws Throwable { GeneralPreferencesPanel generalPreferencesPanel0 = new GeneralPreferencesPanel ( ) ; JScrollPane jScrollPane0 = ( JScrollPane ) generalPreferencesPanel0 . getPanelComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getPanelComponent ( ) { return this ; }
void test0 ( ) throws Throwable { DataTypePreferencesPanel dataTypePreferencesPanel0 = new DataTypePreferencesPanel ( ) ; dataTypePreferencesPanel0 . uninitialize ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { DataTypePreferencesPanel dataTypePreferencesPanel0 = new DataTypePreferencesPanel ( ) ; String string0 = dataTypePreferencesPanel0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { DataTypePreferencesPanel dataTypePreferencesPanel0 = new DataTypePreferencesPanel ( ) ; JScrollPane jScrollPane0 = ( JScrollPane ) dataTypePreferencesPanel0 . getPanelComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getPanelComponent ( ) { return this ; }
void test3 ( ) throws Throwable { DataTypePreferencesPanel dataTypePreferencesPanel0 = new DataTypePreferencesPanel ( ) ; String string0 = dataTypePreferencesPanel0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test4 ( ) throws Throwable { DataTypePreferencesPanel dataTypePreferencesPanel0 = new DataTypePreferencesPanel ( ) ; dataTypePreferencesPanel0 . applyChanges ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test5 ( ) throws Throwable { DataTypePreferencesPanel dataTypePreferencesPanel0 = new DataTypePreferencesPanel ( ) ; dataTypePreferencesPanel0 . initialize ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test6 ( ) throws Throwable { DataTypePreferencesPanel dataTypePreferencesPanel0 = new DataTypePreferencesPanel ( ) ; dataTypePreferencesPanel0 . initialize ( ( IApplication ) null , ( ISession ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { WikiTablePreferencesPanel wikiTablePreferencesPanel0 = new WikiTablePreferencesPanel ( ) ; IApplication iApplication0 = wikiTablePreferencesPanel0 . getApplication ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IApplication getApplication ( ) { return application ; }
void test1 ( ) throws Throwable { WikiTablePreferencesPanel wikiTablePreferencesPanel0 = new WikiTablePreferencesPanel ( ) ; wikiTablePreferencesPanel0 . setApplication ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setApplication ( IApplication app ) ; }
void test2 ( ) throws Throwable { WikiTablePreferencesPanel wikiTablePreferencesPanel0 = new WikiTablePreferencesPanel ( ) ; WikiTableConfigurationFactory wikiTableConfigurationFactory0 = ( WikiTableConfigurationFactory ) WikiTableConfigurationFactory . getInstance ( ) ; wikiTablePreferencesPanel0 . setWikiTableConfigFactory ( ( IWikiTableConfigurationFactory ) wikiTableConfigurationFactory0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setWikiTableConfigFactory ( IWikiTableConfigurationFactory wikiTableConfigFactory ) { this . wikiTableConfigFactory = wikiTableConfigFactory ; }
void test3 ( ) throws Throwable { WikiTablePreferencesPanel wikiTablePreferencesPanel0 = new WikiTablePreferencesPanel ( ) ; WikiTableConfigurationFactory wikiTableConfigurationFactory0 = ( WikiTableConfigurationFactory ) wikiTablePreferencesPanel0 . getWikiTableConfigFactory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test4 ( ) throws Throwable { WikiTablePreferencesPanel wikiTablePreferencesPanel0 = new WikiTablePreferencesPanel ( ) ; SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; wikiTablePreferencesPanel0 . loadData ( squirrelPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEnabled ( ) { return enabled ; }
void test5 ( ) throws Throwable { WikiTablePreferencesPanel wikiTablePreferencesPanel0 = new WikiTablePreferencesPanel ( ) ; wikiTablePreferencesPanel0 . applyChanges ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void applyChanges ( ) { save ( ) ; }
void test0 ( ) throws Throwable { SquirrelPreferencesBeanInfo squirrelPreferencesBeanInfo0 = new SquirrelPreferencesBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = squirrelPreferencesBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { UpdateChannelComboBoxEntry . ChannelType updateChannelComboBoxEntry_ChannelType0 = UpdateChannelComboBoxEntry . ChannelType . SNAPSHOT ; UpdateChannelComboBoxEntry updateChannelComboBoxEntry0 = new UpdateChannelComboBoxEntry ( updateChannelComboBoxEntry_ChannelType0 , "cG { ^3 R2CveB#3 > " ) ; String string0 = updateChannelComboBoxEntry0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { UpdateChannelComboBoxEntry . ChannelType updateChannelComboBoxEntry_ChannelType0 = UpdateChannelComboBoxEntry . ChannelType . SNAPSHOT ; UpdateChannelComboBoxEntry updateChannelComboBoxEntry0 = new UpdateChannelComboBoxEntry ( updateChannelComboBoxEntry_ChannelType0 , "cG { ^3 R2CveB#3 > " ) ; boolean boolean0 = updateChannelComboBoxEntry0 . isStable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStable ( ) { return _channel = = ChannelType . STABLE ; }
void test2 ( ) throws Throwable { UpdateChannelComboBoxEntry . ChannelType updateChannelComboBoxEntry_ChannelType0 = UpdateChannelComboBoxEntry . ChannelType . STABLE ; UpdateChannelComboBoxEntry updateChannelComboBoxEntry0 = new UpdateChannelComboBoxEntry ( updateChannelComboBoxEntry_ChannelType0 , "" ) ; boolean boolean0 = updateChannelComboBoxEntry0 . isStable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStable ( ) { return _channel = = ChannelType . STABLE ; }
void test3 ( ) throws Throwable { UpdateChannelComboBoxEntry . ChannelType updateChannelComboBoxEntry_ChannelType0 = UpdateChannelComboBoxEntry . ChannelType . STABLE ; UpdateChannelComboBoxEntry updateChannelComboBoxEntry0 = new UpdateChannelComboBoxEntry ( updateChannelComboBoxEntry_ChannelType0 , "" ) ; boolean boolean0 = updateChannelComboBoxEntry0 . isSnapshot ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSnapshot ( ) { return _channel = = ChannelType . SNAPSHOT ; }
void test4 ( ) throws Throwable { UpdateChannelComboBoxEntry . ChannelType updateChannelComboBoxEntry_ChannelType0 = UpdateChannelComboBoxEntry . ChannelType . SNAPSHOT ; UpdateChannelComboBoxEntry updateChannelComboBoxEntry0 = new UpdateChannelComboBoxEntry ( updateChannelComboBoxEntry_ChannelType0 , "cG { ^3 R2CveB#3 > " ) ; boolean boolean0 = updateChannelComboBoxEntry0 . isSnapshot ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSnapshot ( ) { return _channel = = ChannelType . SNAPSHOT ; }
void test0 ( ) throws Throwable { WikiTablePreferencesTab wikiTablePreferencesTab0 = new WikiTablePreferencesTab ( ) ; String string0 = wikiTablePreferencesTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test2 ( ) throws Throwable { WikiTablePreferencesTab wikiTablePreferencesTab0 = new WikiTablePreferencesTab ( ) ; wikiTablePreferencesTab0 . uninitialize ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test3 ( ) throws Throwable { WikiTablePreferencesTab wikiTablePreferencesTab0 = new WikiTablePreferencesTab ( ) ; String string0 = wikiTablePreferencesTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test4 ( ) throws Throwable { WikiTablePreferencesTab wikiTablePreferencesTab0 = new WikiTablePreferencesTab ( ) ; WikiTablePreferencesPanel wikiTablePreferencesPanel0 = ( WikiTablePreferencesPanel ) wikiTablePreferencesTab0 . getPanelComponent ( ) ; WikiTablePreferencesPanel wikiTablePreferencesPanel1 = ( WikiTablePreferencesPanel ) wikiTablePreferencesTab0 . getPanelComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getPanelComponent ( ) { return this ; }
void test0 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJdbcDebugToStream ( ) { return _jdbcDebugType = = IJdbcDebugTypes . TO_STREAM ; }
void test1 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test2 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setPluginStatus ( int idx , PluginStatus value ) { _pluginStatusInfoColl . ensureCapacity ( idx + 1 ) ; PluginStatus oldValue = _pluginStatusInfoColl . get ( idx ) ; ; _pluginStatusInfoColl . set ( idx , value ) ; getPropertyChangeReporter ( ) . firePropertyChange ( IPropertyNames . PLUGIN_STATUSES , oldValue , value ) ; }
void test3 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PluginStatus [ ] getPluginStatus ( ) { SortableTableModel stm = getSortableTableModel ( ) ; SortableTableModel stm2 = ( SortableTableModel ) stm . getActualModel ( ) ; MyTableModel tm = ( MyTableModel ) ( stm2 . getActualModel ( ) ) ; return tm . getPluginStatus ( ) ; }
void test4 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInPreviousDir ( ) { return _fileOpenInPreviousDir ; }
void test5 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowMainToolBar ( ) { return _showMainToolBar ; }
void test6 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getTabbedStyle ( ) { return _tabbedStyle ; }
void test7 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowToolTips ( ) { return _showToolTips ; }
void test8 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLoginTimeout ( ) { return _loginTimeout ; }
void test9 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getTabbedStyle ( ) { return _tabbedStyle ; }
void test10 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLargeScriptStmtCount ( ) { return _largeScriptStmtCount ; }
void test11 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setActionKeys ( ActionKeys [ ] data ) { ActionKeys [ ] oldValue = _actionsKeys ; _actionsKeys = data ! = null ? data : new ActionKeys [ 0 ] ; getPropertyChangeReporter ( ) . firePropertyChange ( IPropertyNames . ACTION_KEYS , oldValue , _actionsKeys ) ; }
void test12 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowTabbedStyleHint ( ) { return _showTabbedStyleHint ; }
void test13 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ActionKeys [ ] getActionKeys ( ) { return _actionsKeys ; }
void test14 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowMainStatusBar ( ) { return _showMainStatusBar ; }
void test15 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJdbcDebugDontDebug ( ) { return ! ( isJdbcDebugToStream ( ) | | isJdbcDebugToWriter ( ) ) ; }
void test16 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLoginTimeout ( ) { return _loginTimeout ; }
void test17 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJdbcDebugDontDebug ( ) { return ! ( isJdbcDebugToStream ( ) | | isJdbcDebugToWriter ( ) ) ; }
void test18 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getTabbedStyle ( ) { return _tabbedStyle ; }
void test19 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLargeScriptStmtCount ( ) { return _largeScriptStmtCount ; }
void test20 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLargeScriptStmtCount ( ) { return _largeScriptStmtCount ; }
void test21 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLargeScriptStmtCount ( ) { return _largeScriptStmtCount ; }
void test22 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getTabbedStyle ( ) { return _tabbedStyle ; }
void test23 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowContentsWhenDragging ( ) { return _showContentsWhenDragging ; }
void test24 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJdbcDebugDontDebug ( ) { return ! ( isJdbcDebugToStream ( ) | | isJdbcDebugToWriter ( ) ) ; }
void test25 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLargeScriptStmtCount ( ) { return _largeScriptStmtCount ; }
void test26 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJdbcDebugDontDebug ( ) { return ! ( isJdbcDebugToStream ( ) | | isJdbcDebugToWriter ( ) ) ; }
void test27 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLoginTimeout ( ) { return _loginTimeout ; }
void test28 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInPreviousDir ( ) { return _fileOpenInPreviousDir ; }
void test29 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getUseScrollableTabbedPanes ( ) { return _useScrollableTabbedPanes ; }
void test30 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowMainToolBar ( ) { return _showMainToolBar ; }
void test31 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLargeScriptStmtCount ( ) { return _largeScriptStmtCount ; }
void test32 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInSpecifiedDir ( ) { return _fileOpenInSpecifiedDir ; }
void test33 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowColoriconsInToolbar ( ) { return _showColorIconsInToolbars ; }
void test34 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getTabbedStyle ( ) { return _tabbedStyle ; }
void test35 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowPluginFilesInSplashScreen ( ) { return _showPluginFilesInSplashScreen ; }
void test36 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLoginTimeout ( ) { return _loginTimeout ; }
void test37 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLoginTimeout ( ) { return _loginTimeout ; }
void test38 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setJdbcDebugType ( int data ) { if ( data < IJdbcDebugTypes . NONE | | data > IJdbcDebugTypes . TO_WRITER ) { throw new IllegalArgumentException ( "Invalid setDebugJdbcToStream of : " + data ) ; } if ( data ! = _jdbcDebugType ) { int oldValue = _jdbcDebugType ; _jdbcDebugType = data ; getPropertyChangeReporter ( ) . firePropertyChange ( IPropertyNames . JDBC_DEBUG_TYPE , oldValue , _jdbcDebugType ) ; } }
void test39 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInSpecifiedDir ( ) { return _fileOpenInSpecifiedDir ; }
void test40 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInSpecifiedDir ( ) { return _fileOpenInSpecifiedDir ; }
void test41 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getUseScrollableTabbedPanes ( ) { return _useScrollableTabbedPanes ; }
void test42 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowContentsWhenDragging ( ) { return _showContentsWhenDragging ; }
void test43 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getMaximizeSessionSheetOnOpen ( ) { return _maxSessionSheetOnOpen ; }
void test44 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getTabbedStyle ( ) { return _tabbedStyle ; }
void test45 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInPreviousDir ( ) { return _fileOpenInPreviousDir ; }
void test46 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowMainStatusBar ( ) { return _showMainStatusBar ; }
void test47 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInPreviousDir ( ) { return _fileOpenInPreviousDir ; }
void test48 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getJdbcDebugType ( ) { return _jdbcDebugType ; }
void test49 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInPreviousDir ( ) { return _fileOpenInPreviousDir ; }
void test50 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowContentsWhenDragging ( ) { return _showContentsWhenDragging ; }
void test51 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowTabbedStyleHint ( ) { return _showTabbedStyleHint ; }
void test52 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFirstRun ( ) { return _firstRun ; }
void test53 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInSpecifiedDir ( ) { return _fileOpenInSpecifiedDir ; }
void test54 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLoginTimeout ( ) { return _loginTimeout ; }
void test55 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getJdbcDebugType ( ) { return _jdbcDebugType ; }
void test56 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInPreviousDir ( ) { return _fileOpenInPreviousDir ; }
void test57 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowContentsWhenDragging ( ) { return _showContentsWhenDragging ; }
void test58 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getJdbcDebugType ( ) { return _jdbcDebugType ; }
void test59 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getJdbcDebugType ( ) { return _jdbcDebugType ; }
void test60 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowContentsWhenDragging ( ) { return _showContentsWhenDragging ; }
void test61 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowMainStatusBar ( ) { return _showMainStatusBar ; }
void test62 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowToolTips ( ) { return _showToolTips ; }
void test63 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLoginTimeout ( ) { return _loginTimeout ; }
void test64 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowTabbedStyleHint ( ) { return _showTabbedStyleHint ; }
void test65 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLoginTimeout ( ) { return _loginTimeout ; }
void test66 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInSpecifiedDir ( ) { return _fileOpenInSpecifiedDir ; }
void test67 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLargeScriptStmtCount ( ) { return _largeScriptStmtCount ; }
void test68 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFileOpenInSpecifiedDir ( ) { return _fileOpenInSpecifiedDir ; }
void test69 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowSessionStartupTimeHint ( ) { return _showSessionStartupTimeHint ; }
void test70 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJdbcDebugToStream ( ) { return _jdbcDebugType = = IJdbcDebugTypes . TO_STREAM ; }
void test71 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLargeScriptStmtCount ( ) { return _largeScriptStmtCount ; }
void test72 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowInfoLogMessages ( ) { return _showInfoLogMessages ; }
void test73 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowInfoLogMessages ( ) { return _showInfoLogMessages ; }
void test74 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowContentsWhenDragging ( ) { return _showContentsWhenDragging ; }
void test75 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = new SquirrelPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowContentsWhenDragging ( ) { return _showContentsWhenDragging ; }
void test76 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJdbcDebugDontDebug ( ) { return ! ( isJdbcDebugToStream ( ) | | isJdbcDebugToWriter ( ) ) ; }
void test77 ( ) throws Throwable { SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSavePreferencesImmediately ( ) { return _savePreferencesImmediately ; }
void test0 ( ) throws Throwable { UpdatePreferencesPanel updatePreferencesPanel0 = new UpdatePreferencesPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void loadData ( ) { IQueryTokenizerPreferenceBean _prefs = _prefsManager . getPreferences ( ) ; removeMultiLineCommentCheckBox . setSelected ( _prefs . isRemoveMultiLineComments ( ) ) ; lineCommentTextField . setText ( _prefs . getLineComment ( ) ) ; statementSeparatorTextField . setText ( _prefs . getStatementSeparator ( ) ) ; if ( _showProcSep ) { procedureSeparatorTextField . setText ( _prefs . getProcedureSeparator ( ) ) ; } useCustomQTCheckBox . setSelected ( _prefs . isInstallCustomQueryTokenizer ( ) ) ; updatePreferenceState ( ) ; }
void test1 ( ) throws Throwable { UpdatePreferencesPanel updatePreferencesPanel0 = new UpdatePreferencesPanel ( ) ; updatePreferencesPanel0 . setApplication ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setApplication ( IApplication app ) ; }
void test2 ( ) throws Throwable { UpdatePreferencesPanel updatePreferencesPanel0 = new UpdatePreferencesPanel ( ) ; SquirrelPreferences squirrelPreferences0 = SquirrelPreferences . load ( ) ; updatePreferencesPanel0 . applyChanges ( squirrelPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isValid ( ) { return _name ! = null & & _name . length ( ) > 0 & & _driverId ! = null & & _url ! = null & & _url . length ( ) > 0 ; }
void test0 ( ) throws Throwable { UpdatePreferencesTab updatePreferencesTab0 = new UpdatePreferencesTab ( ) ; String string0 = updatePreferencesTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test2 ( ) throws Throwable { UpdatePreferencesTab updatePreferencesTab0 = new UpdatePreferencesTab ( ) ; String string0 = updatePreferencesTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test3 ( ) throws Throwable { UpdatePreferencesTab updatePreferencesTab0 = new UpdatePreferencesTab ( ) ; updatePreferencesTab0 . uninitialize ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test5 ( ) throws Throwable { UpdatePreferencesTab updatePreferencesTab0 = new UpdatePreferencesTab ( ) ; UpdatePreferencesPanel updatePreferencesPanel0 = ( UpdatePreferencesPanel ) updatePreferencesTab0 . getPanelComponent ( ) ; UpdatePreferencesPanel updatePreferencesPanel1 = ( UpdatePreferencesPanel ) updatePreferencesTab0 . getPanelComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getPanelComponent ( ) { return this ; }
void test0 ( ) throws Throwable { ProxyPreferencesPanel proxyPreferencesPanel0 = new ProxyPreferencesPanel ( ) ; String string0 = proxyPreferencesPanel0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { ProxyPreferencesPanel proxyPreferencesPanel0 = new ProxyPreferencesPanel ( ) ; proxyPreferencesPanel0 . uninitialize ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { ProxyPreferencesPanel proxyPreferencesPanel0 = new ProxyPreferencesPanel ( ) ; String string0 = proxyPreferencesPanel0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test4 ( ) throws Throwable { ProxyPreferencesPanel proxyPreferencesPanel0 = new ProxyPreferencesPanel ( ) ; proxyPreferencesPanel0 . getPanelComponent ( ) ; Component component0 = proxyPreferencesPanel0 . getPanelComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getPanelComponent ( ) { return this ; }
void test0 ( ) throws Throwable { Vector < String > vector0 = new Vector < String > ( ) ; JComboBox jComboBox0 = new JComboBox ( vector0 ) ; KeywordBehaviourPref keywordBehaviourPref0 = new KeywordBehaviourPref ( ( String ) null , 1 ) ; KeywordBehaviourPrefCtrl keywordBehaviourPrefCtrl0 = new KeywordBehaviourPrefCtrl ( jComboBox0 , keywordBehaviourPref0 ) ; keywordBehaviourPrefCtrl0 . addKeyWordBehaviourChangedListener ( ( ActionListener ) jComboBox0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { Vector < String > vector0 = new Vector < String > ( ) ; JComboBox jComboBox0 = new JComboBox ( vector0 ) ; KeywordBehaviourPref keywordBehaviourPref0 = new KeywordBehaviourPref ( ( String ) null , 1 ) ; KeywordBehaviourPrefCtrl keywordBehaviourPrefCtrl0 = new KeywordBehaviourPrefCtrl ( jComboBox0 , keywordBehaviourPref0 ) ; keywordBehaviourPrefCtrl0 . getKeywordBehaviourPref ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test2 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 5 ] ; JComboBox jComboBox0 = new JComboBox ( objectArray0 ) ; KeywordBehaviourPref keywordBehaviourPref0 = new KeywordBehaviourPref ( "j~E" , 1 ) ; KeywordBehaviourPrefCtrl keywordBehaviourPrefCtrl0 = new KeywordBehaviourPrefCtrl ( jComboBox0 , keywordBehaviourPref0 ) ; keywordBehaviourPrefCtrl0 . setEnabled ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 5 ] ; JComboBox jComboBox0 = new JComboBox ( objectArray0 ) ; KeywordBehaviourPref keywordBehaviourPref0 = new KeywordBehaviourPref ( "j~E" , 1 ) ; KeywordBehaviourPrefCtrl keywordBehaviourPrefCtrl0 = new KeywordBehaviourPrefCtrl ( jComboBox0 , keywordBehaviourPref0 ) ; keywordBehaviourPrefCtrl0 . applyChanges ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test4 ( ) throws Throwable { Vector < String > vector0 = new Vector < String > ( ) ; JComboBox jComboBox0 = new JComboBox ( vector0 ) ; KeywordBehaviourPref keywordBehaviourPref0 = new KeywordBehaviourPref ( ( String ) null , 1 ) ; KeywordBehaviourPrefCtrl keywordBehaviourPrefCtrl0 = new KeywordBehaviourPrefCtrl ( jComboBox0 , keywordBehaviourPref0 ) ; FormatSqlPanel . KeywordBehaviour formatSqlPanel_KeywordBehaviour0 = FormatSqlPanel . KeywordBehaviour . NO_INFLUENCE_ON_NEW_LINE ; keywordBehaviourPrefCtrl0 . setBehaviour ( formatSqlPanel_KeywordBehaviour0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test0 ( ) throws Throwable { FormatSqlPref formatSqlPref0 = new FormatSqlPref ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDoInsertValuesAlign ( ) { return _doInsertValuesAlign ; }
void test1 ( ) throws Throwable { FormatSqlPref formatSqlPref0 = new FormatSqlPref ( ) ; KeywordBehaviourPref [ ] keywordBehaviourPrefArray0 = formatSqlPref0 . getKeywordBehaviourPrefs ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" KeywordBehaviourPref [ ] getKeywordBehaviourPrefs ( ) { return _keywordBehaviourPrefs ; }
void test2 ( ) throws Throwable { FormatSqlPref formatSqlPref0 = new FormatSqlPref ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getIndent ( ) { return _indent ; }
void test3 ( ) throws Throwable { FormatSqlPref formatSqlPref0 = new FormatSqlPref ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDoInsertValuesAlign ( ) { return _doInsertValuesAlign ; }
void test4 ( ) throws Throwable { FormatSqlPref formatSqlPref0 = new FormatSqlPref ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getIndent ( ) { return _indent ; }
void test5 ( ) throws Throwable { FormatSqlPref formatSqlPref0 = new FormatSqlPref ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getPreferedLineLength ( ) { return _preferedLineLength ; }
void test6 ( ) throws Throwable { FormatSqlPref formatSqlPref0 = new FormatSqlPref ( ) ; KeywordBehaviourPref [ ] keywordBehaviourPrefArray0 = new KeywordBehaviourPref [ 8 ] ; formatSqlPref0 . setKeywordBehaviourPrefs ( keywordBehaviourPrefArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getPreferedLineLength ( ) { return _preferedLineLength ; }
void test7 ( ) throws Throwable { FormatSqlPref formatSqlPref0 = new FormatSqlPref ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getPreferedLineLength ( ) { return _preferedLineLength ; }
void test0 ( ) throws Throwable { FormatSqlPrefReader formatSqlPrefReader0 = new FormatSqlPrefReader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { FormatSqlPref formatSqlPref0 = FormatSqlPrefReader . loadPref ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getPreferedLineLength ( ) { return _preferedLineLength ; }
void test2 ( ) throws Throwable { KeywordBehaviourPref [ ] keywordBehaviourPrefArray0 = new KeywordBehaviourPref [ 2 ] ; KeywordBehaviourPref keywordBehaviourPref0 = new KeywordBehaviourPref ( "0dC , kT\"" , ( - 465 ) ) ; keywordBehaviourPrefArray0 [ 1 ] = keywordBehaviourPref0 ; keywordBehaviourPrefArray0 [ 0 ] = keywordBehaviourPref0 ; keywordBehaviourPref0 . setKeywordBehaviourId ( 1 ) ; FormatSqlPanel formatSqlPanel0 = new FormatSqlPanel ( keywordBehaviourPrefArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FormatSqlPanel ( KeywordBehaviourPref [ ] keywordBehaviourPrefs ) { setLayout ( new BorderLayout ( ) ) ; add ( createControlsPanel ( keywordBehaviourPrefs ) , BorderLayout . WEST ) ; add ( new JScrollPane ( txtExampleSqls ) , BorderLayout . CENTER ) ; }
void test0 ( ) throws Throwable { KeywordBehaviourPref keywordBehaviourPref0 = new KeywordBehaviourPref ( "" , 0 ) ; keywordBehaviourPref0 . setKeyWord ( "en ? Hxti } Zw~EiRF | A2A" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getKeywordBehaviourId ( ) { return _keywordBehaviourId ; }
void test1 ( ) throws Throwable { KeywordBehaviourPref keywordBehaviourPref0 = new KeywordBehaviourPref ( "" , 0 ) ; int int0 = keywordBehaviourPref0 . getKeywordBehaviourId ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getKeywordBehaviourId ( ) { return _keywordBehaviourId ; }
void test2 ( ) throws Throwable { KeywordBehaviourPref keywordBehaviourPref0 = new KeywordBehaviourPref ( "IyPJB9L > Yc | ? 2Y" , 1772 ) ; String string0 = keywordBehaviourPref0 . getKeyWord ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getKeywordBehaviourId ( ) { return _keywordBehaviourId ; }
void test3 ( ) throws Throwable { KeywordBehaviourPref keywordBehaviourPref0 = new KeywordBehaviourPref ( "IyPJB9L > Yc | ? 2Y" , 1772 ) ; keywordBehaviourPref0 . setKeywordBehaviourId ( ( - 1259 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getKeywordBehaviourId ( ) { return _keywordBehaviourId ; }
void test4 ( ) throws Throwable { KeywordBehaviourPref keywordBehaviourPref0 = new KeywordBehaviourPref ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getKeyWord ( ) { return _keyWord ; }
void test0 ( ) throws Throwable { JdbcConnectionData jdbcConnectionData0 = new JdbcConnectionData ( "" , "" , "" , "" ) ; String string0 = jdbcConnectionData0 . getUser ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUser ( ) { return _user ; }
void test1 ( ) throws Throwable { JdbcConnectionData jdbcConnectionData0 = new JdbcConnectionData ( "" , "" , "" , "" ) ; String string0 = jdbcConnectionData0 . getPassword ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPassword ( ) { return _password ; }
void test2 ( ) throws Throwable { JdbcConnectionData jdbcConnectionData0 = new JdbcConnectionData ( "" , "" , "" , "" ) ; String string0 = jdbcConnectionData0 . getUrl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUrl ( ) { return _url ; }
void test3 ( ) throws Throwable { JdbcConnectionData jdbcConnectionData0 = new JdbcConnectionData ( "" , "" , "" , "" ) ; String string0 = jdbcConnectionData0 . getDriverClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDriverClassName ( ) { return _driverClassName ; }
void test0 ( ) throws Throwable { SQLEntryPanelUtil sQLEntryPanelUtil0 = new SQLEntryPanelUtil ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { JEditorPane jEditorPane0 = new JEditorPane ( "6 - * tU7 / P } 9$D - . A2" , "6 - * tU7 / P } 9$D - . A2" ) ; int [ ] intArray0 = SQLEntryPanelUtil . getWordBoundsAtCursor ( ( JTextComponent ) jEditorPane0 , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] getWordBoundsAtCursor ( JTextComponent textComponent , boolean qualified ) { String text = textComponent . getText ( ) ; int caretPos = textComponent . getCaretPosition ( ) ; int [ ] beginAndEndPos = new int [ 2 ] ; int lastIndexOfText = Math . max ( 0 , text . length ( ) - 1 ) ; beginAndEndPos [ 0 ] = Math . min ( caretPos , lastIndexOfText ) ; / / The Math . min is for the Caret at the end of the text while ( 0 < beginAndEndPos [ 0 ] ) { if ( isParseStop ( text . charAt ( beginAndEndPos [ 0 ] - 1 ) , false = = qualified ) ) { break ; } - - beginAndEndPos [ 0 ] ; } beginAndEndPos [ 1 ] = caretPos ; while ( beginAndEndPos [ 1 ] < text . length ( ) & & false = = isParseStop ( text . charAt ( beginAndEndPos [ 1 ] ) , true ) ) { + + beginAndEndPos [ 1 ] ; } return beginAndEndPos ; }
void test2 ( ) throws Throwable { MaskFormatter maskFormatter0 = new MaskFormatter ( "The 'data' array must have length = = 6 . " ) ; JFormattedTextField jFormattedTextField0 = new JFormattedTextField ( ( JFormattedTextField . AbstractFormatter ) maskFormatter0 ) ; int [ ] intArray0 = SQLEntryPanelUtil . getWordBoundsAtCursor ( ( JTextComponent ) jFormattedTextField0 , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] getWordBoundsAtCursor ( JTextComponent textComponent , boolean qualified ) { String text = textComponent . getText ( ) ; int caretPos = textComponent . getCaretPosition ( ) ; int [ ] beginAndEndPos = new int [ 2 ] ; int lastIndexOfText = Math . max ( 0 , text . length ( ) - 1 ) ; beginAndEndPos [ 0 ] = Math . min ( caretPos , lastIndexOfText ) ; / / The Math . min is for the Caret at the end of the text while ( 0 < beginAndEndPos [ 0 ] ) { if ( isParseStop ( text . charAt ( beginAndEndPos [ 0 ] - 1 ) , false = = qualified ) ) { break ; } - - beginAndEndPos [ 0 ] ; } beginAndEndPos [ 1 ] = caretPos ; while ( beginAndEndPos [ 1 ] < text . length ( ) & & false = = isParseStop ( text . charAt ( beginAndEndPos [ 1 ] ) , true ) ) { + + beginAndEndPos [ 1 ] ; } return beginAndEndPos ; }
void test3 ( ) throws Throwable { JTextArea jTextArea0 = new JTextArea ( "^ek * ) l" , ( int ) '2' , ( int ) '2' ) ; jTextArea0 . select ( 335 , 335 ) ; int [ ] intArray0 = SQLEntryPanelUtil . getWordBoundsAtCursor ( ( JTextComponent ) jTextArea0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] getWordBoundsAtCursor ( JTextComponent textComponent , boolean qualified ) { String text = textComponent . getText ( ) ; int caretPos = textComponent . getCaretPosition ( ) ; int [ ] beginAndEndPos = new int [ 2 ] ; int lastIndexOfText = Math . max ( 0 , text . length ( ) - 1 ) ; beginAndEndPos [ 0 ] = Math . min ( caretPos , lastIndexOfText ) ; / / The Math . min is for the Caret at the end of the text while ( 0 < beginAndEndPos [ 0 ] ) { if ( isParseStop ( text . charAt ( beginAndEndPos [ 0 ] - 1 ) , false = = qualified ) ) { break ; } - - beginAndEndPos [ 0 ] ; } beginAndEndPos [ 1 ] = caretPos ; while ( beginAndEndPos [ 1 ] < text . length ( ) & & false = = isParseStop ( text . charAt ( beginAndEndPos [ 1 ] ) , true ) ) { + + beginAndEndPos [ 1 ] ; } return beginAndEndPos ; }
void test4 ( ) throws Throwable { boolean boolean0 = SQLEntryPanelUtil . isParseStop ( ' ( ' , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isParseStop ( char c , boolean treatDotAsStop ) { return ' ( ' = = c | | ' ) ' = = c | | ' , ' = = c | | ' ; ' = = c | | '\'' = = c | | Character . isWhitespace ( c ) | | ( treatDotAsStop & & ' . ' = = c ) ; }
void test5 ( ) throws Throwable { boolean boolean0 = SQLEntryPanelUtil . isParseStop ( ' , ' , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isParseStop ( char c , boolean treatDotAsStop ) { return ' ( ' = = c | | ' ) ' = = c | | ' , ' = = c | | ' ; ' = = c | | '\'' = = c | | Character . isWhitespace ( c ) | | ( treatDotAsStop & & ' . ' = = c ) ; }
void test6 ( ) throws Throwable { JTextField jTextField0 = new JTextField ( "A = BgpB ; 0" ) ; int [ ] intArray0 = SQLEntryPanelUtil . getWordBoundsAtCursor ( ( JTextComponent ) jTextField0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] getWordBoundsAtCursor ( JTextComponent textComponent , boolean qualified ) { String text = textComponent . getText ( ) ; int caretPos = textComponent . getCaretPosition ( ) ; int [ ] beginAndEndPos = new int [ 2 ] ; int lastIndexOfText = Math . max ( 0 , text . length ( ) - 1 ) ; beginAndEndPos [ 0 ] = Math . min ( caretPos , lastIndexOfText ) ; / / The Math . min is for the Caret at the end of the text while ( 0 < beginAndEndPos [ 0 ] ) { if ( isParseStop ( text . charAt ( beginAndEndPos [ 0 ] - 1 ) , false = = qualified ) ) { break ; } - - beginAndEndPos [ 0 ] ; } beginAndEndPos [ 1 ] = caretPos ; while ( beginAndEndPos [ 1 ] < text . length ( ) & & false = = isParseStop ( text . charAt ( beginAndEndPos [ 1 ] ) , true ) ) { + + beginAndEndPos [ 1 ] ; } return beginAndEndPos ; }
void test7 ( ) throws Throwable { boolean boolean0 = SQLEntryPanelUtil . isParseStop ( '\'' , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isParseStop ( char c , boolean treatDotAsStop ) { return ' ( ' = = c | | ' ) ' = = c | | ' , ' = = c | | ' ; ' = = c | | '\'' = = c | | Character . isWhitespace ( c ) | | ( treatDotAsStop & & ' . ' = = c ) ; }
void test8 ( ) throws Throwable { boolean boolean0 = SQLEntryPanelUtil . isParseStop ( 'i' , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isParseStop ( char c , boolean treatDotAsStop ) { return ' ( ' = = c | | ' ) ' = = c | | ' , ' = = c | | ' ; ' = = c | | '\'' = = c | | Character . isWhitespace ( c ) | | ( treatDotAsStop & & ' . ' = = c ) ; }
void test4 ( ) throws Throwable { FileManager fileManager0 = new FileManager ( ( ISQLPanelAPI ) null ) ; File file0 = fileManager0 . getFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" File getFile ( ) { return _toSaveTo ; }
void test0 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "7H | XQG0" , "7H | XQG0" , "7H | XQG0" , "7H | XQG0" , 11 , "7H | XQG0" , 11 , 11 , 11 , 11 , "7H | XQG0" , "7H | XQG0" , 11 , 11 , "7H | XQG0" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "7H | XQG0" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnTypeID ( ) { return _columnTypeID ; }
void test1 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "7H | XQG0" , "7H | XQG0" , "7H | XQG0" , "7H | XQG0" , 11 , "7H | XQG0" , 11 , 11 , 11 , 11 , "7H | XQG0" , "7H | XQG0" , 11 , 11 , "7H | XQG0" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "7H | XQG0" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNullable ( ) { return _nullable ; }
void test2 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , 473 , "" , 473 , 473 , 473 , 473 , "" , "" , 473 , 473 , "" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnSize ( ) { return _columnSize ; }
void test3 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "7H | XQG0" , "7H | XQG0" , "7H | XQG0" , "7H | XQG0" , 11 , "7H | XQG0" , 11 , 11 , 11 , 11 , "7H | XQG0" , "7H | XQG0" , 11 , 11 , "7H | XQG0" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "7H | XQG0" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnTypeID ( ) { return _columnTypeID ; }
void test4 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , ( - 1 ) , "i` * YIF & i# ? pP ? X : . e' ] ^" , ( - 1 ) , ( - 1 ) , ( - 1 ) , ( - 1 ) , "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , ( - 1 ) , ( - 1 ) , "i` * YIF & i# ? pP ? X : . e' ] ^" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "i` * YIF & i# ? pP ? X : . e' ] ^" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCharacterType ( ) { return Types . VARCHAR = = _columnTypeID | | Types . LONGVARCHAR = = _columnTypeID | | Types . CHAR = = _columnTypeID | | Types . NVARCHAR = = _columnTypeID ; }
void test5 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , 473 , "" , 473 , 473 , 473 , 473 , "" , "" , 473 , 473 , "" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnSize ( ) { return _columnSize ; }
void test6 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , ( - 1 ) , "i` * YIF & i# ? pP ? X : . e' ] ^" , ( - 1 ) , ( - 1 ) , ( - 1 ) , ( - 1 ) , "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , ( - 1 ) , ( - 1 ) , "i` * YIF & i# ? pP ? X : . e' ] ^" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "i` * YIF & i# ? pP ? X : . e' ] ^" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnTypeID ( ) { return _columnTypeID ; }
void test7 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , 473 , "" , 473 , 473 , 473 , 473 , "" , "" , 473 , 473 , "" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnSize ( ) { return _columnSize ; }
void test8 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , 473 , "" , 473 , 473 , 473 , 473 , "" , "" , 473 , 473 , "" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDecimalDigits ( ) { return _decimalDigits ; }
void test9 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "~9Gki" , "~9Gki" , "~9Gki" , "~9Gki" , 1212 , "YES" , 1212 , 1212 , 1212 , 1212 , "~9Gki" , "~9Gki" , 1212 , 1212 , "YES" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "YES" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNullable ( ) { return _nullable ; }
void test10 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "7H | XQG0" , "7H | XQG0" , "7H | XQG0" , "7H | XQG0" , 11 , "7H | XQG0" , 11 , 11 , 11 , 11 , "7H | XQG0" , "7H | XQG0" , 11 , 11 , "7H | XQG0" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "7H | XQG0" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNullable ( ) { return _nullable ; }
void test11 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , ( - 1 ) , "i` * YIF & i# ? pP ? X : . e' ] ^" , ( - 1 ) , ( - 1 ) , ( - 1 ) , ( - 1 ) , "i` * YIF & i# ? pP ? X : . e' ] ^" , "i` * YIF & i# ? pP ? X : . e' ] ^" , ( - 1 ) , ( - 1 ) , "i` * YIF & i# ? pP ? X : . e' ] ^" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "i` * YIF & i# ? pP ? X : . e' ] ^" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDecimalDigits ( ) { return _decimalDigits ; }
void test12 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( ( String ) null , ( String ) null , ( String ) null , ( String ) null , 1 , ( String ) null , 1 , 1 , 1 , 1 , ( String ) null , ( String ) null , 1 , 1 , ( String ) null ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDecimalDigits ( ) { return _decimalDigits ; }
void test13 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( ( String ) null , ( String ) null , ( String ) null , ( String ) null , ( - 9 ) , ( String ) null , ( - 9 ) , ( - 9 ) , ( - 9 ) , ( - 9 ) , ( String ) null , ( String ) null , ( - 9 ) , ( - 9 ) , ( String ) null ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDecimalDigits ( ) { return _decimalDigits ; }
void test14 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , 473 , "" , 473 , 473 , 473 , 473 , "" , "" , 473 , 473 , "" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnTypeID ( ) { return _columnTypeID ; }
void test15 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , 473 , "" , 473 , 473 , 473 , 473 , "" , "" , 473 , 473 , "" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnSize ( ) { return _columnSize ; }
void test16 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "7H | XQG0" , "7H | XQG0" , "7H | XQG0" , "7H | XQG0" , 11 , "7H | XQG0" , 11 , 11 , 11 , 11 , "7H | XQG0" , "7H | XQG0" , 11 , 11 , "7H | XQG0" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "7H | XQG0" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDecimalDigits ( ) { return _decimalDigits ; }
void test17 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "~9Gki" , "~9Gki" , "~9Gki" , "~9Gki" , 1212 , "YES" , 1212 , 1212 , 1212 , 1212 , "~9Gki" , "~9Gki" , 1212 , 1212 , "YES" ) ; ExtendedColumnInfo extendedColumnInfo0 = new ExtendedColumnInfo ( tableColumnInfo0 , "YES" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNullable ( ) { return _nullable ; }
void test0 ( ) throws Throwable { SQLExecutionInfo sQLExecutionInfo0 = new SQLExecutionInfo ( 18 , "X2Yp ? 1`ArRo9 > #" , 18 ) ; EditableSqlCheck editableSqlCheck0 = new EditableSqlCheck ( sQLExecutionInfo0 ) ; String string0 = editableSqlCheck0 . getTableNameFromSQL ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTableNameFromSQL ( ) { return _tableNameFromSQL ; }
void test1 ( ) throws Throwable { EditableSqlCheck editableSqlCheck0 = new EditableSqlCheck ( ( SQLExecutionInfo ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean allowsEditing ( ) { return null ! = _tableNameFromSQL ; }
void test0 ( ) throws Throwable { DefaultSQLExecuterHandler defaultSQLExecuterHandler0 = new DefaultSQLExecuterHandler ( ( ISession ) null ) ; SQLExecutionInfo sQLExecutionInfo0 = new SQLExecutionInfo ( 2024 , "" , 2024 ) ; defaultSQLExecuterHandler0 . sqlExecutionComplete ( sQLExecutionInfo0 , 2024 , 2024 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getSQLExecutionElapsedMillis ( ) { long results = 0 ; if ( _resultsProcessingStart ! = null ) { results = _resultsProcessingStart . getTime ( ) - _sqlExecutionStart . getTime ( ) ; } return results ; }
void test2 ( ) throws Throwable { DefaultSQLExecuterHandler defaultSQLExecuterHandler0 = new DefaultSQLExecuterHandler ( ( ISession ) null ) ; SQLExecutionInfo sQLExecutionInfo0 = new SQLExecutionInfo ( 1065 , "0s : $" , 1065 ) ; DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; defaultSQLExecuterHandler0 . sqlResultSetAvailable ( ( ResultSet ) null , sQLExecutionInfo0 , ( IDataSetUpdateableTableModel ) dataSetUpdateableTableModelImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSQL ( ) { return _sql ; }
void test4 ( ) throws Throwable { DefaultSQLExecuterHandler defaultSQLExecuterHandler0 = new DefaultSQLExecuterHandler ( ( ISession ) null ) ; ArrayList < String > arrayList0 = new ArrayList < String > ( ) ; defaultSQLExecuterHandler0 . sqlCloseExecutionHandler ( arrayList0 , "`" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test0 ( ) throws Throwable { MessagePanel messagePanel0 = new MessagePanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test1 ( ) throws Throwable { MessagePanel messagePanel0 = new MessagePanel ( ) ; StyledEditorKit . FontSizeAction styledEditorKit_FontSizeAction0 = new StyledEditorKit . FontSizeAction ( ( String ) null , 19 ) ; messagePanel0 . addToMessagePanelPopup ( ( Action ) styledEditorKit_FontSizeAction0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addToMessagePanelPopup ( Action action ) { if ( action = = null ) { throw new IllegalArgumentException ( "action cannot be null" ) ; } _popupMenu . add ( action ) ; }
void test5 ( ) throws Throwable { MessagePanel messagePanel0 = new MessagePanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCaretPosition ( ) { return _comp . getCaretPosition ( ) ; }
void test7 ( ) throws Throwable { MessagePanel messagePanel0 = new MessagePanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectionEnd ( ) { return _comp . getSelectionEnd ( ) ; }
void test0 ( ) throws Throwable { SQLExecutionInfo sQLExecutionInfo0 = new SQLExecutionInfo ( 1646 , "" , 1646 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxRows ( Statement stmt ) { int result = 0 ; try { result = stmt . getMaxRows ( ) ; } catch ( SQLException e ) { if ( s_log . isDebugEnabled ( ) ) { s_log . debug ( "Unexpected exception : " + e . getMessage ( ) , e ) ; } } return result ; }
void test1 ( ) throws Throwable { SQLExecutionInfo sQLExecutionInfo0 = new SQLExecutionInfo ( ( - 1 ) , "" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Time getTime ( int columnIdx ) throws SQLException { Time results = _rs . getTime ( columnIdx ) ; _wasNull = results = = null ; return results ; }
void test2 ( ) throws Throwable { SQLExecutionInfo sQLExecutionInfo0 = new SQLExecutionInfo ( ( - 1 ) , "" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxRows ( Statement stmt ) { int result = 0 ; try { result = stmt . getMaxRows ( ) ; } catch ( SQLException e ) { if ( s_log . isDebugEnabled ( ) ) { s_log . debug ( "Unexpected exception : " + e . getMessage ( ) , e ) ; } } return result ; }
void test3 ( ) throws Throwable { SQLExecutionInfo sQLExecutionInfo0 = new SQLExecutionInfo ( 1960 , "" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxRows ( Statement stmt ) { int result = 0 ; try { result = stmt . getMaxRows ( ) ; } catch ( SQLException e ) { if ( s_log . isDebugEnabled ( ) ) { s_log . debug ( "Unexpected exception : " + e . getMessage ( ) , e ) ; } } return result ; }
void test4 ( ) throws Throwable { SQLExecutionInfo sQLExecutionInfo0 = new SQLExecutionInfo ( ( - 1 ) , "" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxRows ( Statement stmt ) { int result = 0 ; try { result = stmt . getMaxRows ( ) ; } catch ( SQLException e ) { if ( s_log . isDebugEnabled ( ) ) { s_log . debug ( "Unexpected exception : " + e . getMessage ( ) , e ) ; } } return result ; }
void test6 ( ) throws Throwable { SQLExecutionInfo sQLExecutionInfo0 = new SQLExecutionInfo ( ( - 1 ) , "" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxRows ( Statement stmt ) { int result = 0 ; try { result = stmt . getMaxRows ( ) ; } catch ( SQLException e ) { if ( s_log . isDebugEnabled ( ) ) { s_log . debug ( "Unexpected exception : " + e . getMessage ( ) , e ) ; } } return result ; }
void test7 ( ) throws Throwable { SQLExecutionInfo sQLExecutionInfo0 = new SQLExecutionInfo ( ( - 1 ) , "" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTotalElapsedMillis ( ) { return getSQLExecutionElapsedMillis ( ) + getResultsProcessingElapsedMillis ( ) ; }
void test3 ( ) throws Throwable { EntryPanelManager entryPanelManager0 = new EntryPanelManager ( ( ISession ) null ) ; ISession iSession0 = entryPanelManager0 . getSession ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ISession getSession ( ) { return _session ; }
void test1 ( ) throws Throwable { NullMessageHandler nullMessageHandler0 = NullMessageHandler . getInstance ( ) ; CancelStatementThread cancelStatementThread0 = new CancelStatementThread ( ( Statement ) null , ( IMessageHandler ) nullMessageHandler0 ) ; cancelStatementThread0 . tryCancel ( ) ; cancelStatementThread0 . run ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void run ( ) { try { Thread . sleep ( _shutdownSeconds * 1000 ) ; } catch ( InterruptedException e ) { s_log . error ( "Shutdown timer thread was interrupted unexpectedly : " + e . getMessage ( ) , e ) ; } if ( s_log . isInfoEnabled ( ) ) { s_log . info ( "ShutdownTimer is shutting down the application" ) ; } System . exit ( _app . shutdown ( false ) ? 0 : 1 ) ; }
void test2 ( ) throws Throwable { ListMessageHandler listMessageHandler0 = new ListMessageHandler ( ) ; CancelStatementThread cancelStatementThread0 = new CancelStatementThread ( ( Statement ) null , ( IMessageHandler ) listMessageHandler0 ) ; cancelStatementThread0 . run ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test0 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowidCol ( ) { return _dataSetUpdateableTableModel . getRowidCol ( ) ; }
void test2 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editModeIsForced ( ) { return _dataSetUpdateableTableModel . editModeIsForced ( ) ; }
void test3 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowidCol ( ) { return _dataSetUpdateableTableModel . getRowidCol ( ) ; }
void test4 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowidCol ( ) { return _dataSetUpdateableTableModel . getRowidCol ( ) ; }
void test5 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDestinationClassName ( ) { if ( editModeForced ) { if ( _session . getProperties ( ) . getTableContentsOutputClassName ( ) . equals ( sqlOutputClassNameAtTimeOfForcedEdit ) ) { return _session . getProperties ( ) . getEditableTableOutputClassName ( ) ; } / / forced edit mode ended because user changed the Session Properties editModeForced = false ; } / / if the user selected Editable Table in the Session Properties , / / then the display will be an editable table ; otherwise the display is read - only return _session . getProperties ( ) . getTableContentsOutputClassName ( ) ; }
void test6 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editModeIsForced ( ) { return _dataSetUpdateableTableModel . editModeIsForced ( ) ; }
void test7 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowidCol ( ) { return _dataSetUpdateableTableModel . getRowidCol ( ) ; }
void test8 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowidCol ( ) { return _dataSetUpdateableTableModel . getRowidCol ( ) ; }
void test9 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editModeIsForced ( ) { return _dataSetUpdateableTableModel . editModeIsForced ( ) ; }
void test10 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowidCol ( ) { return _dataSetUpdateableTableModel . getRowidCol ( ) ; }
void test11 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDestinationClassName ( ) { if ( editModeForced ) { if ( _session . getProperties ( ) . getTableContentsOutputClassName ( ) . equals ( sqlOutputClassNameAtTimeOfForcedEdit ) ) { return _session . getProperties ( ) . getEditableTableOutputClassName ( ) ; } / / forced edit mode ended because user changed the Session Properties editModeForced = false ; } / / if the user selected Editable Table in the Session Properties , / / then the display will be an editable table ; otherwise the display is read - only return _session . getProperties ( ) . getTableContentsOutputClassName ( ) ; }
void test12 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editModeIsForced ( ) { return _dataSetUpdateableTableModel . editModeIsForced ( ) ; }
void test13 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editModeIsForced ( ) { return _dataSetUpdateableTableModel . editModeIsForced ( ) ; }
void test14 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editModeIsForced ( ) { return _dataSetUpdateableTableModel . editModeIsForced ( ) ; }
void test15 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editModeIsForced ( ) { return _dataSetUpdateableTableModel . editModeIsForced ( ) ; }
void test16 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editModeIsForced ( ) { return _dataSetUpdateableTableModel . editModeIsForced ( ) ; }
void test17 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowidCol ( ) { return _dataSetUpdateableTableModel . getRowidCol ( ) ; }
void test18 ( ) throws Throwable { DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editModeIsForced ( ) { return _dataSetUpdateableTableModel . editModeIsForced ( ) ; }
void test0 ( ) throws Throwable { DefaultDataModelImplementationDetails defaultDataModelImplementationDetails0 = new DefaultDataModelImplementationDetails ( ( ISession ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStatementSeparator ( ) { if ( null = = _session ) { return " ; " ; } else { return _session . getProperties ( ) . getSQLStatementSeparator ( ) ; } }
void test1 ( ) throws Throwable { DefaultDataModelImplementationDetails defaultDataModelImplementationDetails0 = new DefaultDataModelImplementationDetails ( ) ; String string0 = defaultDataModelImplementationDetails0 . getStatementSeparator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStatementSeparator ( ) { if ( null = = _session ) { return " ; " ; } else { return _session . getProperties ( ) . getSQLStatementSeparator ( ) ; } }
void test1 ( ) throws Throwable { File file0 = new File ( "" , "" ) ; DumpSessionCommand dumpSessionCommand0 = new DumpSessionCommand ( file0 ) ; dumpSessionCommand0 . setDumpFile ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isHidden ( ) { return _wrappedFile . isHidden ( ) ; }
void test0 ( ) throws Throwable { FormatSQLCommand formatSQLCommand0 = new FormatSQLCommand ( ( ISession ) null , ( ISQLPanelAPI ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FormatSQLCommand ( ISession session , ISQLPanelAPI panel ) { super ( ) ; _session = session ; _panel = panel ; }
void test0 ( ) throws Throwable { SQLFilterClauses sQLFilterClauses0 = new SQLFilterClauses ( ) ; sQLFilterClauses0 . put ( "" , "" , "" ) ; String string0 = sQLFilterClauses0 . get ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test1 ( ) throws Throwable { SQLFilterClauses sQLFilterClauses0 = new SQLFilterClauses ( ) ; String string0 = sQLFilterClauses0 . get ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test0 ( ) throws Throwable { TreeSet < String > treeSet0 = new TreeSet < String > ( ) ; HashMap < String , Boolean > hashMap0 = new HashMap < String , Boolean > ( ) ; WhereClausePanel whereClausePanel0 = new WhereClausePanel ( ( SortedSet < String > ) treeSet0 , ( Map < String , Boolean > ) hashMap0 , "" ) ; String string0 = whereClausePanel0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { TreeSet < String > treeSet0 = new TreeSet < String > ( ) ; HashMap < String , Boolean > hashMap0 = new HashMap < String , Boolean > ( ) ; WhereClausePanel whereClausePanel0 = new WhereClausePanel ( ( SortedSet < String > ) treeSet0 , ( Map < String , Boolean > ) hashMap0 , "" ) ; SQLFilterClauses sQLFilterClauses0 = new SQLFilterClauses ( ) ; whereClausePanel0 . initialize ( sQLFilterClauses0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClauseIdentifier ( ) { return WhereClauseSubPanel . WhereClauseSubPanelI18n . WHERE_CLAUSE ; }
void test2 ( ) throws Throwable { TreeSet < String > treeSet0 = new TreeSet < String > ( ) ; HashMap < String , Boolean > hashMap0 = new HashMap < String , Boolean > ( ) ; WhereClausePanel whereClausePanel0 = new WhereClausePanel ( ( SortedSet < String > ) treeSet0 , ( Map < String , Boolean > ) hashMap0 , "" ) ; whereClausePanel0 . applyChanges ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClauseIdentifier ( ) { return WhereClauseSubPanel . WhereClauseSubPanelI18n . WHERE_CLAUSE ; }
void test3 ( ) throws Throwable { TreeSet < String > treeSet0 = new TreeSet < String > ( ) ; HashMap < String , Boolean > hashMap0 = new HashMap < String , Boolean > ( ) ; WhereClausePanel whereClausePanel0 = new WhereClausePanel ( ( SortedSet < String > ) treeSet0 , ( Map < String , Boolean > ) hashMap0 , "" ) ; Component component0 = whereClausePanel0 . getPanelComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getX ( ) { return _x ; }
void test4 ( ) throws Throwable { TreeSet < String > treeSet0 = new TreeSet < String > ( ) ; HashMap < String , Boolean > hashMap0 = new HashMap < String , Boolean > ( ) ; WhereClausePanel whereClausePanel0 = new WhereClausePanel ( ( SortedSet < String > ) treeSet0 , ( Map < String , Boolean > ) hashMap0 , "" ) ; whereClausePanel0 . clearFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClauseIdentifier ( ) { return WhereClauseSubPanel . WhereClauseSubPanelI18n . WHERE_CLAUSE ; }
void test5 ( ) throws Throwable { TreeSet < String > treeSet0 = new TreeSet < String > ( ) ; HashMap < String , Boolean > hashMap0 = new HashMap < String , Boolean > ( ) ; WhereClausePanel whereClausePanel0 = new WhereClausePanel ( ( SortedSet < String > ) treeSet0 , ( Map < String , Boolean > ) hashMap0 , "" ) ; String string0 = whereClausePanel0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { TreeSet < String > treeSet0 = new TreeSet < String > ( ) ; OrderByClausePanel orderByClausePanel0 = new OrderByClausePanel ( ( SortedSet < String > ) treeSet0 , "gp_2bPVU" ) ; String string0 = orderByClausePanel0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { TreeSet < String > treeSet0 = new TreeSet < String > ( ) ; OrderByClausePanel orderByClausePanel0 = new OrderByClausePanel ( ( SortedSet < String > ) treeSet0 , "gp_2bPVU" ) ; Component component0 = orderByClausePanel0 . getPanelComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getPanelComponent ( ) { return this ; }
void test3 ( ) throws Throwable { TreeSet < String > treeSet0 = new TreeSet < String > ( ) ; OrderByClausePanel orderByClausePanel0 = new OrderByClausePanel ( ( SortedSet < String > ) treeSet0 , "gp_2bPVU" ) ; orderByClausePanel0 . clearFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClauseIdentifier ( ) { return WhereClauseSubPanel . WhereClauseSubPanelI18n . WHERE_CLAUSE ; }
void test4 ( ) throws Throwable { TreeSet < String > treeSet0 = new TreeSet < String > ( ) ; OrderByClausePanel orderByClausePanel0 = new OrderByClausePanel ( ( SortedSet < String > ) treeSet0 , "gp_2bPVU" ) ; String string0 = orderByClausePanel0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test5 ( ) throws Throwable { TreeSet < String > treeSet0 = new TreeSet < String > ( ) ; OrderByClausePanel orderByClausePanel0 = new OrderByClausePanel ( ( SortedSet < String > ) treeSet0 , "gp_2bPVU" ) ; SQLFilterClauses sQLFilterClauses0 = new SQLFilterClauses ( ) ; orderByClausePanel0 . initialize ( sQLFilterClauses0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "" , "" , "" ) ; SQLFilterSheet sQLFilterSheet0 = SQLFilterSheet . createSheet ( ( IObjectTreeAPI ) null , ( IDatabaseObjectInfo ) databaseObjectInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLFilterSheet createSheet ( IObjectTreeAPI objectTree , IDatabaseObjectInfo objectInfo ) { return null ; / / To change body of created methods use File | Settings | File Templates . }
void test0 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; int int0 = sessionProperties0 . getSqlPanelOrientation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test1 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setKeepTableLayoutOnRerun ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test2 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getAutoCommit ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test3 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getShowToolBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSQLLimitRows ( ) { return _sqlLimitRows ; }
void test4 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getSchemaFilterExclude ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test5 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getLimitSQLEntryHistorySize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test6 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; int int0 = sessionProperties0 . getObjectTabPlacement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test7 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; int int0 = sessionProperties0 . getSqlResultTabLimit ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test8 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getCommitOnClosingConnection ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getAutoCommit ( ) { return _autoCommit ; }
void test9 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getCatalogFilterInclude ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test10 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getSQLStatementSeparator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test11 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getEditableTableOutputClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test12 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setCatalogFilterInclude ( "net . sourceforge . squirrel_sql . fw . datasetviewer . DataSetViewerTablePanel" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test13 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getObjectFilterExclude ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test14 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . getLoadColumnsInBackground ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test15 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getReadOnlyTableOutputClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test16 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setShowRowCount ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test17 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; int int0 = sessionProperties0 . getSQLEntryHistorySize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getCommitOnClosingConnection ( ) { return _commitOnClosingConnection ; }
void test18 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLEntryHistorySize ( 100 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test19 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; int int0 = sessionProperties0 . getSQLExecutionTabPlacement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test20 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; PropertyChangeListenerProxy propertyChangeListenerProxy0 = new PropertyChangeListenerProxy ( "dOgate" , ( PropertyChangeListener ) null ) ; sessionProperties0 . addPropertyChangeListener ( ( PropertyChangeListener ) propertyChangeListenerProxy0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getAutoCommit ( ) { return _autoCommit ; }
void test21 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; int int0 = sessionProperties0 . getSQLNbrRowsToShow ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test22 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getShowSQLErrorsInTab ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getCommitOnClosingConnection ( ) { return _commitOnClosingConnection ; }
void test23 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getShowResultsMetaData ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test24 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setObjectFilterExclude ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test25 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setLimitSQLEntryHistorySize ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test26 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getSQLLimitRows ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test27 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getLoadSchemasCatalogs ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test28 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getContentsLimitRows ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test29 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; SpinnerNumberModel spinnerNumberModel0 = new SpinnerNumberModel ( ) ; JSpinner jSpinner0 = new JSpinner ( ( SpinnerModel ) spinnerNumberModel0 ) ; JSpinner . DefaultEditor jSpinner_DefaultEditor0 = new JSpinner . DefaultEditor ( jSpinner0 ) ; sessionProperties0 . removePropertyChangeListener ( ( PropertyChangeListener ) jSpinner_DefaultEditor0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test30 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getTableContentsOutputClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test31 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; int int0 = sessionProperties0 . getMainTabPlacement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test32 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getRemoveMultiLineComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSQLLimitRows ( ) { return _sqlLimitRows ; }
void test33 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSchemaFilterInclude ( "#_fBU ; U" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test34 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getObjectFilterInclude ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test35 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getAbortOnError ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test36 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; int int0 = sessionProperties0 . getContentsNbrRowsToShow ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getCommitOnClosingConnection ( ) { return _commitOnClosingConnection ; }
void test37 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLShareHistory ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test38 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getSchemaFilterInclude ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test39 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . getKeepTableLayoutOnRerun ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test40 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test41 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; int int0 = sessionProperties0 . getSQLResultsTabPlacement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test42 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setCatalogFilterExclude ( "net . sourceforge . squirrel_sql . fw . datasetviewer . DataSetViewerTablePanel" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test43 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSchemaFilterExclude ( " ; " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test44 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; int int0 = sessionProperties0 . getSQLFetchSize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSQLLimitRows ( ) { return _sqlLimitRows ; }
void test45 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setLoadSchemasCatalogs ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test46 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . getSQLUseFetchSize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test47 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setShowResultsMetaData ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test48 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getMetaDataOutputClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test49 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . getWriteSQLErrorsToLog ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test50 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getStartOfLineComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getAutoCommit ( ) { return _autoCommit ; }
void test51 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getLimitSQLResultTabs ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test52 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getSQLResultsOutputClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test53 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setRemoveMultiLineComment ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getCommitOnClosingConnection ( ) { return _commitOnClosingConnection ; }
void test54 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . getShowRowCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getCommitOnClosingConnection ( ) { return _commitOnClosingConnection ; }
void test55 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getCatalogFilterExclude ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test56 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setStartOfLineComment ( "#_fBU ; U" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test57 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; boolean boolean0 = sessionProperties0 . getSQLShareHistory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test58 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setLimitSQLResultTabs ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getCommitOnClosingConnection ( ) { return _commitOnClosingConnection ; }
void test59 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setObjectFilterInclude ( " / ( [ + C . ? * rl@ | " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getCommitOnClosingConnection ( ) { return _commitOnClosingConnection ; }
void test60 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; FontInfo fontInfo0 = sessionProperties0 . getFontInfo ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test61 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; SessionProperties sessionProperties1 = ( SessionProperties ) sessionProperties0 . clone ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test62 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; String string0 = sessionProperties0 . getReadOnlySQLResultsOutputClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test63 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setMetaDataOutputClassName ( "net . sourceforge . squirrel_sql . fw . datasetviewer . DataSetViewerTablePanel" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test64 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setMetaDataOutputClassName ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMetaDataOutputClassName ( ) { return _metaDataOutputClassName ; }
void test65 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setTableContentsOutputClassName ( "net . sourceforge . squirrel_sql . fw . datasetviewer . DataSetViewerTablePanel" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test66 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setTableContentsOutputClassName ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test67 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLResultsOutputClassName ( "net . sourceforge . squirrel_sql . fw . datasetviewer . DataSetViewerTablePanel" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test68 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLResultsOutputClassName ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getCommitOnClosingConnection ( ) { return _commitOnClosingConnection ; }
void test69 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test70 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setAutoCommit ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test71 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setAbortOnError ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getAutoCommit ( ) { return _autoCommit ; }
void test72 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setAbortOnError ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test73 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setShowSQLErrorsInTab ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getAutoCommit ( ) { return _autoCommit ; }
void test74 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setShowSQLErrorsInTab ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test75 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setWriteSQLErrorsToLog ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test76 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setWriteSQLErrorsToLog ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSQLLimitRows ( ) { return _sqlLimitRows ; }
void test77 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setLoadColumnsInBackground ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test78 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setLoadColumnsInBackground ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test79 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSqlResultTabLimit ( 15 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSqlResultTabLimit ( ) { return _sqlResultTabLimit ; }
void test80 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSqlResultTabLimit ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSQLLimitRows ( ) { return _sqlLimitRows ; }
void test81 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setShowToolBar ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test82 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setShowToolBar ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test83 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setContentsNbrRowsToShow ( 100 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test84 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setContentsNbrRowsToShow ( ( - 158 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test85 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLNbrRowsToShow ( 100 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test86 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLNbrRowsToShow ( 27 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test87 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test88 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test89 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getContentsLimitRows ( ) { return _contentsLimitRows ; }
void test90 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test91 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLFetchSize ( 0 ) ; sessionProperties0 . setSQLFetchSize ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLFetchSize ( ) { return _sqlFetchSize ; }
void test93 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLUseFetchSize ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowResultsMetaData ( ) { return _showResultsMetaData ; }
void test94 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLUseFetchSize ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSQLUseFetchSize ( ) { return _sqlUseFetchSize ; }
void test95 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLStatementSeparator ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSQLLimitRows ( ) { return _sqlLimitRows ; }
void test96 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLStatementSeparator ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test97 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLStatementSeparator ( "dOgate" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLNbrRowsToShow ( ) { return _sqlNbrRowsToShow ; }
void test98 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; JRadioButton jRadioButton0 = new JRadioButton ( ) ; FontUIResource fontUIResource0 = ( FontUIResource ) jRadioButton0 . getFont ( ) ; FontInfo fontInfo0 = new FontInfo ( ( Font ) fontUIResource0 ) ; sessionProperties0 . setFontInfo ( fontInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test99 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setFontInfo ( ( FontInfo ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test100 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSqlPanelOrientation ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test101 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSqlPanelOrientation ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test102 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setMainTabPlacement ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getCommitOnClosingConnection ( ) { return _commitOnClosingConnection ; }
void test103 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setMainTabPlacement ( 27 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMainTabPlacement ( ) { return _mainTabPlacement ; }
void test104 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setObjectTabPlacement ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSQLLimitRows ( ) { return _sqlLimitRows ; }
void test105 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setObjectTabPlacement ( 100 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test106 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLExecutionTabPlacement ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getAutoCommit ( ) { return _autoCommit ; }
void test107 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLExecutionTabPlacement ( 598 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getLoadSchemasCatalogs ( ) { return _loadSchemasCatalogs ; }
void test108 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLResultsTabPlacement ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLResultsTabPlacement ( ) { return _sqlResultsTabPlacement ; }
void test109 ( ) throws Throwable { SessionProperties sessionProperties0 = new SessionProperties ( ) ; sessionProperties0 . setSQLResultsTabPlacement ( 100 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getContentsNbrRowsToShow ( ) { return _contentsNbrRowsToShow ; }
void test0 ( ) throws Throwable { SessionPropertiesBeanInfo sessionPropertiesBeanInfo0 = new SessionPropertiesBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = sessionPropertiesBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test1 ( ) throws Throwable { HashMap < String , String > hashMap0 = EditWhereCols . get ( "'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test1 ( ) throws Throwable { GeneralSessionPropertiesPanel generalSessionPropertiesPanel0 = new GeneralSessionPropertiesPanel ( ) ; JScrollPane jScrollPane0 = ( JScrollPane ) generalSessionPropertiesPanel0 . getPanelComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getPanelComponent ( ) { return this ; }
void test2 ( ) throws Throwable { GeneralSessionPropertiesPanel generalSessionPropertiesPanel0 = new GeneralSessionPropertiesPanel ( ) ; String string0 = generalSessionPropertiesPanel0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test3 ( ) throws Throwable { GeneralSessionPropertiesPanel generalSessionPropertiesPanel0 = new GeneralSessionPropertiesPanel ( ) ; String string0 = generalSessionPropertiesPanel0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; TreeMap < CaseInsensitiveString , String > treeMap0 = schemaInfoCache0 . getDataTypesForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test2 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; TreeMap < CaseInsensitiveString , String > treeMap0 = schemaInfoCache0 . getKeywordsForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test3 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; List < ITableInfo > list0 = schemaInfoCache0 . getITableInfosForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test5 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; List < String > list0 = schemaInfoCache0 . getSchemasForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test6 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( ) ; List < ExtendedColumnInfo > list0 = schemaInfoCache0 . getExtendedColumnInfosForReadOnly ( caseInsensitiveString0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < ExtendedColumnInfo > getExtendedColumnInfosForReadOnly ( CaseInsensitiveString cissTableName ) { return _extendedColumnInfosByTableName . get ( cissTableName ) ; }
void test7 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( "Te#U . " ) ; schemaInfoCache0 . writeColumsNotAccessible ( ( Throwable ) null , caseInsensitiveString0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test10 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( ) ; boolean boolean0 = schemaInfoCache0 . didTryLoadingColumns ( caseInsensitiveString0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean didTryLoadingColumns ( CaseInsensitiveString tableName ) { return _extendedColumnInfosByTableName . containsKey ( tableName ) | | _tablesWithInaccessibleColumns . contains ( tableName ) ; }
void test11 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; Hashtable < CaseInsensitiveString , String > hashtable0 = new Hashtable < CaseInsensitiveString , String > ( ) ; schemaInfoCache0 . writeKeywords ( hashtable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test12 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; Hashtable < CaseInsensitiveString , String > hashtable0 = new Hashtable < CaseInsensitiveString , String > ( ) ; schemaInfoCache0 . writeDataTypes ( hashtable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test13 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; Map < CaseInsensitiveString , String > map0 = schemaInfoCache0 . getProcedureNamesForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test16 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; Hashtable < CaseInsensitiveString , String > hashtable0 = new Hashtable < CaseInsensitiveString , String > ( ) ; schemaInfoCache0 . writeFunctions ( hashtable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test17 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; List < String > list0 = schemaInfoCache0 . getCatalogsForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test18 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; Map < CaseInsensitiveString , List < ExtendedColumnInfo > > map0 = schemaInfoCache0 . getExtColumnInfosByColumnNameForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test20 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; Map < CaseInsensitiveString , String > map0 = schemaInfoCache0 . getFunctionsForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test23 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; Map < IProcedureInfo , IProcedureInfo > map0 = schemaInfoCache0 . getIProcedureInfosForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test25 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; Hashtable < CaseInsensitiveString , List < ITableInfo > > hashtable0 = schemaInfoCache0 . getTableInfosBySimpleNameForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test26 ( ) throws Throwable { SchemaInfoCache schemaInfoCache0 = new SchemaInfoCache ( ) ; Map < CaseInsensitiveString , String > map0 = schemaInfoCache0 . getTableNamesForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test28 ( ) throws Throwable { String [ ] stringArray0 = new String [ 5 ] ; stringArray0 [ 0 ] = "Null 'type' argument" ; stringArray0 [ 1 ] = "Null 'type' argument" ; stringArray0 [ 2 ] = "Null 'type' argument" ; stringArray0 [ 3 ] = "Null 'type' argument" ; stringArray0 [ 4 ] = "Null 'type' argument" ; boolean boolean0 = SchemaInfoCache . containsType ( stringArray0 , "b" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean containsType ( String [ ] types , String type ) { if ( null = = types ) { return true ; } for ( int i = 0 ; i < types . length ; i + + ) { if ( type . trim ( ) . equalsIgnoreCase ( types [ i ] ) ) { return true ; } } return false ; }
void test29 ( ) throws Throwable { String [ ] stringArray0 = new String [ 1 ] ; stringArray0 [ 0 ] = "D" ; boolean boolean0 = SchemaInfoCache . containsType ( stringArray0 , "D" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean containsType ( String [ ] types , String type ) { if ( null = = types ) { return true ; } for ( int i = 0 ; i < types . length ; i + + ) { if ( type . trim ( ) . equalsIgnoreCase ( types [ i ] ) ) { return true ; } } return false ; }
void test0 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( ) ; String string0 = caseInsensitiveString0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( "Invalid index = " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( "V" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setCharBuffer ( char [ ] buffer , int beginIndex , int len ) { if ( false = = _isMutable ) { throw new UnsupportedOperationException ( "This CaseInsensitiveString is immutable" ) ; } value = buffer ; offset = beginIndex ; count = len ; hash = 0 ; }
void test3 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( "iPj4G * U7 * 7LU" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test4 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( "Invalid index = " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test5 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( "yMSWh" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test6 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( "yMSWh" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test7 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( ) ; char [ ] charArray0 = new char [ 16 ] ; caseInsensitiveString0 . setCharBuffer ( charArray0 , 0 , 1 ) ; boolean boolean0 = caseInsensitiveString0 . equals ( ( Object ) "0" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test8 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( ) ; Object object0 = new Object ( ) ; boolean boolean0 = caseInsensitiveString0 . equals ( object0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test9 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( "Invalid index = " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test10 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( ) ; char [ ] charArray0 = new char [ 16 ] ; caseInsensitiveString0 . setCharBuffer ( charArray0 , 0 , 1 ) ; CaseInsensitiveString caseInsensitiveString1 = new CaseInsensitiveString ( "0" ) ; boolean boolean0 = caseInsensitiveString0 . equals ( ( Object ) caseInsensitiveString1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test11 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( "yMSWh" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test12 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( "yMSWh" ) ; CaseInsensitiveString caseInsensitiveString1 = new CaseInsensitiveString ( "20" ) ; int int0 = caseInsensitiveString0 . compareTo ( caseInsensitiveString1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compareTo ( CaseInsensitiveString anotherString ) { int len1 = count ; int len2 = anotherString . count ; int n = Math . min ( len1 , len2 ) ; char v1 [ ] = value ; char v2 [ ] = anotherString . value ; int i = offset ; int j = anotherString . offset ; if ( i = = j ) { int k = i ; int lim = n + i ; while ( k < lim ) { char c1 = v1 [ k ] ; char c2 = v2 [ k ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } k + + ; } } else { while ( n - - ! = 0 ) { char c1 = v1 [ i + + ] ; char c2 = v2 [ j + + ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } } } return len1 - len2 ; }
void test13 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( ) ; char [ ] charArray0 = new char [ 8 ] ; caseInsensitiveString0 . setCharBuffer ( charArray0 , ( int ) 'q' , ( int ) 'q' ) ; CaseInsensitiveString caseInsensitiveString1 = new CaseInsensitiveString ( ) ; int int0 = caseInsensitiveString0 . compareTo ( caseInsensitiveString1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compareTo ( CaseInsensitiveString anotherString ) { int len1 = count ; int len2 = anotherString . count ; int n = Math . min ( len1 , len2 ) ; char v1 [ ] = value ; char v2 [ ] = anotherString . value ; int i = offset ; int j = anotherString . offset ; if ( i = = j ) { int k = i ; int lim = n + i ; while ( k < lim ) { char c1 = v1 [ k ] ; char c2 = v2 [ k ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } k + + ; } } else { while ( n - - ! = 0 ) { char c1 = v1 [ i + + ] ; char c2 = v2 [ j + + ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } } } return len1 - len2 ; }
void test14 ( ) throws Throwable { CaseInsensitiveString caseInsensitiveString0 = new CaseInsensitiveString ( ) ; CaseInsensitiveString caseInsensitiveString1 = new CaseInsensitiveString ( "ex3xi / s6C ( BmJ" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compareTo ( CaseInsensitiveString anotherString ) { int len1 = count ; int len2 = anotherString . count ; int n = Math . min ( len1 , len2 ) ; char v1 [ ] = value ; char v2 [ ] = anotherString . value ; int i = offset ; int j = anotherString . offset ; if ( i = = j ) { int k = i ; int lim = n + i ; while ( k < lim ) { char c1 = v1 [ k ] ; char c2 = v2 [ k ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } k + + ; } } else { while ( n - - ! = 0 ) { char c1 = v1 [ i + + ] ; char c2 = v2 [ j + + ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } } } return len1 - len2 ; }
void test0 ( ) throws Throwable { FilterMatcher filterMatcher0 = new FilterMatcher ( " & ' ; YgSX & Lo" , " & ' ; YgSX & Lo" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSqlLikeMatchString ( ) { if ( null ! = _sqlOrMetaDataMatchString ) { return _sqlOrMetaDataMatchString ; } else { return "%" ; } }
void test1 ( ) throws Throwable { FilterMatcher filterMatcher0 = new FilterMatcher ( ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matches ( String simpleObjectName ) { return matchesPatterns ( simpleObjectName , _includeFilterPatterns , false ) & & ! matchesPatterns ( simpleObjectName , _excludeFilterPatterns , true ) ; }
void test2 ( ) throws Throwable { FilterMatcher filterMatcher0 = new FilterMatcher ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSqlLikeMatchString ( ) { if ( null ! = _sqlOrMetaDataMatchString ) { return _sqlOrMetaDataMatchString ; } else { return "%" ; } }
void test3 ( ) throws Throwable { FilterMatcher filterMatcher0 = new FilterMatcher ( "wd_y , K" , "wd_y , K" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSqlLikeMatchString ( ) { if ( null ! = _sqlOrMetaDataMatchString ) { return _sqlOrMetaDataMatchString ; } else { return "%" ; } }
void test4 ( ) throws Throwable { FilterMatcher filterMatcher0 = new FilterMatcher ( "_" , "_" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSqlLikeMatchString ( ) { if ( null ! = _sqlOrMetaDataMatchString ) { return _sqlOrMetaDataMatchString ; } else { return "%" ; } }
void test5 ( ) throws Throwable { FilterMatcher filterMatcher0 = new FilterMatcher ( " dstBegin = " , " dstBegin = " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSqlLikeMatchString ( ) { if ( null ! = _sqlOrMetaDataMatchString ) { return _sqlOrMetaDataMatchString ; } else { return "%" ; } }
void test6 ( ) throws Throwable { FilterMatcher filterMatcher0 = new FilterMatcher ( " / NZy } " , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSqlLikeMatchString ( ) { if ( null ! = _sqlOrMetaDataMatchString ) { return _sqlOrMetaDataMatchString ; } else { return "%" ; } }
void test2 ( ) throws Throwable { SchemaInfoCacheSerializer schemaInfoCacheSerializer0 = new SchemaInfoCacheSerializer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLoaded ( ) { return _loaded ; }
void test1 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ITableInfo [ ] getITableInfos ( ) { return getITableInfos ( null , null ) ; }
void test2 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getKeywords ( ) { return _schemaInfoCache . getKeywordsForReadOnly ( ) . values ( ) . toArray ( new String [ _schemaInfoCache . getKeywordsForReadOnly ( ) . size ( ) ] ) ; }
void test3 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLoaded ( ) { return _loaded ; }
void test4 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isColumn ( char [ ] buffer , int offset , int len ) ; boolean isKeyword ( char [ ] buffer , int offset , int len ) ; }
void test5 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLoaded ( ) { return _loaded ; }
void test6 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ExtendedColumnInfo [ ] getExtendedColumnInfos ( String tableName ) { return getExtendedColumnInfos ( null , null , tableName ) ; }
void test7 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void reload ( IDatabaseObjectInfo doi ) { reload ( doi , true ) ; }
void test8 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void reloadAllTables ( ) { GUIUtils . processOnSwingEventThread ( new Runnable ( ) { void run ( ) { _session . getSessionSheet ( ) . setStatusBarProgress ( i18n . LOADING_TABLES_MSG , 0 , MAX_PROGRESS , 50 ) ; } } ) ; breathing ( ) ; _schemaInfoCache . clearAllTableData ( ) ; loadTables ( null , null , null , null , 0 ) ; notifyTablesLoaded ( ) ; GUIUtils . processOnSwingEventThread ( new Runnable ( ) { void run ( ) { fireSchemaInfoUpdate ( ) ; _session . getSessionSheet ( ) . setStatusBarProgressFinished ( ) ; } } ) ; }
void test9 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFunction ( char [ ] buffer , int offset , int len ) ; boolean isDataType ( char [ ] buffer , int offset , int len ) ; boolean isStatementSeparator ( char [ ] buffer , int offset , int len ) ; boolean isColumn ( char [ ] buffer , int offset , int len ) ; boolean isKeyword ( char [ ] buffer , int offset , int len ) ; }
void test10 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getTables ( ) { return _schemaInfoCache . getTableNamesForReadOnly ( ) . values ( ) . toArray ( new String [ _schemaInfoCache . getTableNamesForReadOnly ( ) . size ( ) ] ) ; }
void test11 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTable ( char [ ] buffer , int offset , int len ) ; void removeSQLTokenListener ( SQLTokenListener tl ) ; void addSQLTokenListener ( SQLTokenListener tl ) ; boolean isFunction ( char [ ] buffer , int offset , int len ) ; boolean isDataType ( char [ ] buffer , int offset , int len ) ; boolean isStatementSeparator ( char [ ] buffer , int offset , int len ) ; boolean isColumn ( char [ ] buffer , int offset , int len ) ; boolean isKeyword ( char [ ] buffer , int offset , int len ) ; }
void test12 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void refreshCacheForSimpleProcedureName ( String simpleProcName ) { refreshCacheForSimpleProcedureName ( simpleProcName , true ) ; }
void test13 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isKeyword ( char [ ] buffer , int offset , int len ) ; }
void test14 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLoaded ( ) { return _loaded ; }
void test15 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLoaded ( ) { return _loaded ; }
void test16 ( ) throws Throwable { SchemaInfo schemaInfo0 = new SchemaInfo ( ( IApplication ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCaseSensitiveProcedureName ( String data ) { if ( ! _loading & & data ! = null ) { return _schemaInfoCache . getProcedureNamesForReadOnly ( ) . get ( new CaseInsensitiveString ( data ) ) ; } return null ; }
void test0 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Time getTime ( int columnIdx ) throws SQLException { Time results = _rs . getTime ( columnIdx ) ; _wasNull = results = = null ; return results ; }
void test1 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( "" , "" ) ; sQLHistoryItem0 . setAliasName ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAliasName ( ) { return _aliasName ; }
void test2 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( "" , "" ) ; Date date0 = sQLHistoryItem0 . getLastUsageTime ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Date getLastUsageTime ( ) { return _lastUsageTime ; }
void test3 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( ) ; String string0 = sQLHistoryItem0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test4 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( "" , "" ) ; SQLHistoryItem sQLHistoryItem1 = ( SQLHistoryItem ) sQLHistoryItem0 . clone ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; }
void test5 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( "" , "" ) ; int int0 = sQLHistoryItem0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test6 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( ) ; String string0 = sQLHistoryItem0 . getAliasName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAliasName ( ) { return _aliasName ; }
void test8 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( "sU * t ) " , "sU * t ) " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test9 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test10 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test11 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test0 ( ) throws Throwable { String [ ] stringArray0 = SQLHistoryItemWrapper . getColumns ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getColumns ( ) { return COLUMNS ; }
void test1 ( ) throws Throwable { int int0 = SQLHistoryItemWrapper . getSQLColIx ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSQLColIx ( ) { return 2 ; }
void test2 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( " * " , " * " ) ; SQLHistoryItemWrapper sQLHistoryItemWrapper0 = new SQLHistoryItemWrapper ( sQLHistoryItem0 , 602 ) ; String string0 = sQLHistoryItemWrapper0 . getUpperCaseSQL ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpperCaseSQL ( ) { return _upperCaseSQL ; }
void test3 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( ) ; ArrayList < SQLHistoryItem > arrayList0 = new ArrayList < SQLHistoryItem > ( ) ; arrayList0 . add ( sQLHistoryItem0 ) ; ArrayList < SQLHistoryItemWrapper > arrayList1 = SQLHistoryItemWrapper . wrap ( arrayList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test4 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( "" , "" ) ; SQLHistoryItemWrapper sQLHistoryItemWrapper0 = new SQLHistoryItemWrapper ( sQLHistoryItem0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getColum ( int column ) { / / corresponding to COLUMNS switch ( column ) { case 0 : return _index ; case 1 : return _lastUsageTimeString ; case 2 : return _item . getSQL ( ) ; default : throw new IllegalArgumentException ( "Unknown colum index " + column ) ; } }
void test5 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( "" , "" ) ; SQLHistoryItemWrapper sQLHistoryItemWrapper0 = new SQLHistoryItemWrapper ( sQLHistoryItem0 , ( - 759 ) ) ; Integer integer0 = ( Integer ) sQLHistoryItemWrapper0 . getColum ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getColum ( int column ) { / / corresponding to COLUMNS switch ( column ) { case 0 : return _index ; case 1 : return _lastUsageTimeString ; case 2 : return _item . getSQL ( ) ; default : throw new IllegalArgumentException ( "Unknown colum index " + column ) ; } }
void test6 ( ) throws Throwable { SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( "false" , "false" ) ; SQLHistoryItemWrapper sQLHistoryItemWrapper0 = new SQLHistoryItemWrapper ( sQLHistoryItem0 , 2000 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getColum ( int column ) { / / corresponding to COLUMNS switch ( column ) { case 0 : return _index ; case 1 : return _lastUsageTimeString ; case 2 : return _item . getSQL ( ) ; default : throw new IllegalArgumentException ( "Unknown colum index " + column ) ; } }
void test0 ( ) throws Throwable { ObjectTreeTab objectTreeTab0 = new ObjectTreeTab ( ) ; objectTreeTab0 . select ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { ObjectTreeTab objectTreeTab0 = new ObjectTreeTab ( ) ; String string0 = objectTreeTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test0 ( ) throws Throwable { ObjectTreeTab objectTreeTab0 = new ObjectTreeTab ( ) ; Component component0 = objectTreeTab0 . getTabComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getTabComponent ( ) ; / * * * Return the hint for the tab . * * @return The hint for the tab . * / String getHint ( ) ; / * * * Return the component to be displayed in the panel . * * @return The component to be displayed in the panel . * / Component getComponent ( ) ; / * * * Set the current session . * * @param session Current session . * / void setSession ( ISession session ) ; / * * * The current session is closing . * * @param session Current session . * / void sessionClosing ( ISession session ) ; / * * * This tab has been selected . * / void select ( ) ; }
void test1 ( ) throws Throwable { ObjectTreeTab objectTreeTab0 = new ObjectTreeTab ( ) ; objectTreeTab0 . sessionClosing ( ( ISession ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test2 ( ) throws Throwable { ObjectTreeTab objectTreeTab0 = new ObjectTreeTab ( ) ; ISession iSession0 = objectTreeTab0 . getSession ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ISession getSession ( ) { return _session ; }
void test4 ( ) throws Throwable { ObjectTreeTab objectTreeTab0 = new ObjectTreeTab ( ) ; objectTreeTab0 . select ( ) ; objectTreeTab0 . select ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test5 ( ) throws Throwable { ObjectTreeTab objectTreeTab0 = new ObjectTreeTab ( ) ; objectTreeTab0 . sessionEnding ( ( ISession ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { SQLHistory sQLHistory0 = new SQLHistory ( ) ; SQLHistoryItem [ ] sQLHistoryItemArray0 = sQLHistory0 . getData ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test2 ( ) throws Throwable { SQLHistory sQLHistory0 = new SQLHistory ( ) ; SQLHistoryItem sQLHistoryItem0 = new SQLHistoryItem ( ) ; sQLHistory0 . add ( sQLHistoryItem0 ) ; sQLHistory0 . add ( sQLHistoryItem0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { SquirrelDefaultUndoManager squirrelDefaultUndoManager0 = new SquirrelDefaultUndoManager ( ) ; AbstractUndoableEdit abstractUndoableEdit0 = new AbstractUndoableEdit ( ) ; squirrelDefaultUndoManager0 . addEdit ( ( UndoableEdit ) abstractUndoableEdit0 ) ; squirrelDefaultUndoManager0 . undoOrRedo ( ) ; squirrelDefaultUndoManager0 . getUndoOrRedoPresentationName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SquirrelDefaultUndoManager ( ) { super ( ) ; / / Prepare to have a lot of DocumentEvent . EventType . CHANGE setLimit ( 200000 ) ; }
void test2 ( ) throws Throwable { SquirrelDefaultUndoManager squirrelDefaultUndoManager0 = new SquirrelDefaultUndoManager ( ) ; StringContent stringContent0 = new StringContent ( ( - 15 ) ) ; PlainDocument plainDocument0 = new PlainDocument ( ( AbstractDocument . Content ) stringContent0 ) ; DocumentEvent . EventType documentEvent_EventType0 = DocumentEvent . EventType . CHANGE ; AbstractDocument . DefaultDocumentEvent abstractDocument_DefaultDocumentEvent0 = plainDocument0 . new DefaultDocumentEvent ( ( - 15 ) , ( - 15 ) , documentEvent_EventType0 ) ; squirrelDefaultUndoManager0 . addEdit ( ( UndoableEdit ) abstractDocument_DefaultDocumentEvent0 ) ; squirrelDefaultUndoManager0 . getUndoOrRedoPresentationName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SquirrelDefaultUndoManager ( ) { super ( ) ; / / Prepare to have a lot of DocumentEvent . EventType . CHANGE setLimit ( 200000 ) ; }
void test3 ( ) throws Throwable { SquirrelDefaultUndoManager squirrelDefaultUndoManager0 = new SquirrelDefaultUndoManager ( ) ; StyleContext styleContext0 = StyleContext . getDefaultStyleContext ( ) ; DefaultStyledDocument defaultStyledDocument0 = new DefaultStyledDocument ( styleContext0 ) ; DocumentEvent . EventType documentEvent_EventType0 = DocumentEvent . EventType . REMOVE ; AbstractDocument . DefaultDocumentEvent abstractDocument_DefaultDocumentEvent0 = defaultStyledDocument0 . new DefaultDocumentEvent ( 164 , 164 , documentEvent_EventType0 ) ; squirrelDefaultUndoManager0 . addEdit ( ( UndoableEdit ) abstractDocument_DefaultDocumentEvent0 ) ; squirrelDefaultUndoManager0 . canUndo ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SquirrelDefaultUndoManager ( ) { super ( ) ; / / Prepare to have a lot of DocumentEvent . EventType . CHANGE setLimit ( 200000 ) ; }
void test4 ( ) throws Throwable { SquirrelDefaultUndoManager squirrelDefaultUndoManager0 = new SquirrelDefaultUndoManager ( ) ; String string0 = squirrelDefaultUndoManager0 . getRedoPresentationName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SquirrelDefaultUndoManager ( ) { super ( ) ; / / Prepare to have a lot of DocumentEvent . EventType . CHANGE setLimit ( 200000 ) ; }
void test0 ( ) throws Throwable { SQLHistoryComboBoxModel sQLHistoryComboBoxModel0 = new SQLHistoryComboBoxModel ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void insertElementAt ( Object object , int index ) { _dataModel . insertElementAt ( object , index ) ; }
void test2 ( ) throws Throwable { SQLHistoryComboBoxModel sQLHistoryComboBoxModel0 = new SQLHistoryComboBoxModel ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUsingSharedDataModel ( ) { return _dataModel = = s_sharedDataModel ; }
void test3 ( ) throws Throwable { SQLHistoryComboBoxModel sQLHistoryComboBoxModel0 = new SQLHistoryComboBoxModel ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUsingSharedDataModel ( ) { return _dataModel = = s_sharedDataModel ; }
void test6 ( ) throws Throwable { SQLHistoryComboBoxModel sQLHistoryComboBoxModel0 = new SQLHistoryComboBoxModel ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUsingSharedDataModel ( ) { return _dataModel = = s_sharedDataModel ; }
void test10 ( ) throws Throwable { SQLHistoryComboBoxModel sQLHistoryComboBoxModel0 = new SQLHistoryComboBoxModel ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test11 ( ) throws Throwable { SQLHistoryComboBoxModel sQLHistoryComboBoxModel0 = new SQLHistoryComboBoxModel ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUsingSharedDataModel ( ) { return _dataModel = = s_sharedDataModel ; }
void test12 ( ) throws Throwable { SQLHistoryComboBoxModel sQLHistoryComboBoxModel0 = new SQLHistoryComboBoxModel ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setUseSharedModel ( boolean use ) { if ( isUsingSharedDataModel ( ) ! = use ) { _dataModel = use ? s_sharedDataModel : duplicateSharedDataModel ( ) ; } }
void test13 ( ) throws Throwable { SQLHistoryComboBoxModel sQLHistoryComboBoxModel0 = new SQLHistoryComboBoxModel ( false ) ; ArrayList < SQLHistoryItem > arrayList0 = sQLHistoryComboBoxModel0 . getItems ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test0 ( ) throws Throwable { SQLHistoryDlg . FilterCboItems sQLHistoryDlg_FilterCboItems0 = SQLHistoryDlg . FilterCboItems . REG_EX ; String string0 = sQLHistoryDlg_FilterCboItems0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { SQLHistoryComboBox sQLHistoryComboBox0 = new SQLHistoryComboBox ( false ) ; sQLHistoryComboBox0 . contentsChanged ( ( ListDataEvent ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryComboBox ( boolean useSharedModel ) { super ( ) ; setModel ( new SQLHistoryComboBoxModel ( useSharedModel ) ) ; setRenderer ( new Renderer ( ) ) ; addActionListener ( new ActionListener ( ) { void actionPerformed ( ActionEvent e ) { updateToolTip ( ) ; } } ) ; }
void test1 ( ) throws Throwable { SQLHistoryComboBox sQLHistoryComboBox0 = new SQLHistoryComboBox ( false ) ; boolean boolean0 = sQLHistoryComboBox0 . isUsingSharedDataModel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUsingSharedDataModel ( ) { return _dataModel = = s_sharedDataModel ; }
void test2 ( ) throws Throwable { SQLHistoryComboBox sQLHistoryComboBox0 = new SQLHistoryComboBox ( false ) ; sQLHistoryComboBox0 . dispose ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void dispose ( ) { Dimension size = getSize ( ) ; Preferences . userRoot ( ) . putInt ( PREF_KEY_NEW_SESSION_PROPS_SHEET_WIDTH , size . width ) ; Preferences . userRoot ( ) . putInt ( PREF_KEY_NEW_SESSION_PROPS_SHEET_HEIGHT , size . height ) ; ( getClass ( ) ) { s_instance = null ; } super . dispose ( ) ; }
void test3 ( ) throws Throwable { SQLHistoryComboBox sQLHistoryComboBox0 = new SQLHistoryComboBox ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUsingSharedDataModel ( ) { return _dataModel = = s_sharedDataModel ; }
void test4 ( ) throws Throwable { SQLHistoryComboBox sQLHistoryComboBox0 = new SQLHistoryComboBox ( false ) ; int int0 = sQLHistoryComboBox0 . getBaseline ( 18 , 18 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryComboBox ( boolean useSharedModel ) { super ( ) ; setModel ( new SQLHistoryComboBoxModel ( useSharedModel ) ) ; setRenderer ( new Renderer ( ) ) ; addActionListener ( new ActionListener ( ) { void actionPerformed ( ActionEvent e ) { updateToolTip ( ) ; } } ) ; }
void test0 ( ) throws Throwable { ChartConfigPanelTabMode chartConfigPanelTabMode0 = ChartConfigPanelTabMode . XY_CHART ; ChartConfigPanelTab chartConfigPanelTab0 = new ChartConfigPanelTab ( chartConfigPanelTabMode0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTabTitle ( ) { return s_stringMgr . getString ( _chartConfigPanelTabMode . getTabTitleKey ( ) ) ; }
void test1 ( ) throws Throwable { ChartConfigPanelTabMode chartConfigPanelTabMode0 = ChartConfigPanelTabMode . SINGLE_COLUMN ; ChartConfigPanelTab chartConfigPanelTab0 = new ChartConfigPanelTab ( chartConfigPanelTabMode0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ChartConfigPanelTab ( ChartConfigPanelTabMode chartConfigPanelTabMode ) { super ( new GridBagLayout ( ) ) ; _chartConfigPanelTabMode = chartConfigPanelTabMode ; GridBagConstraints gbc ; gbc = new GridBagConstraints ( 0 , 0 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 5 , 5 , 5 ) , 0 , 0 ) ; add ( new JLabel ( s_stringMgr . getString ( "OverviewPanel . XAxis" ) ) , gbc ) ; gbc = new GridBagConstraints ( 1 , 0 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 15 , 10 , 5 , 5 ) , 0 , 0 ) ; cboXColumns = new JComboBox ( ) ; add ( cboXColumns , gbc ) ; if ( chartConfigPanelTabMode = = ChartConfigPanelTabMode . SINGLE_COLUMN ) { gbc = new GridBagConstraints ( 0 , 1 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; add ( new JLabel ( s_stringMgr . getString ( "OverviewPanel . YAxis" ) ) , gbc ) ; gbc = new GridBagConstraints ( 1 , 1 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; cboYAxisKind = new JComboBox ( ) ; add ( cboYAxisKind , gbc ) ; } else if ( chartConfigPanelTabMode = = ChartConfigPanelTabMode . XY_CHART ) { gbc = new GridBagConstraints ( 0 , 1 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; add ( new JLabel ( s_stringMgr . getString ( "OverviewPanel . YAxis" ) ) , gbc ) ; gbc = new GridBagConstraints ( 1 , 1 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; cboYColumns = new JComboBox ( ) ; add ( cboYColumns , gbc ) ; gbc = new GridBagConstraints ( 2 , 1 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 0 , 0 , 5 , 5 ) , 0 , 0 ) ; add ( createAsKindPanel ( ) , gbc ) ; } gbc = new GridBagConstraints ( 0 , 2 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; add ( new JLabel ( s_stringMgr . getString ( "OverviewPanel . maxBarCount" ) ) , gbc ) ; gbc = new GridBagConstraints ( 1 , 2 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; cboCallDepth = new JComboBox ( ) ; add ( cboCallDepth , gbc ) ; gbc = new GridBagConstraints ( 0 , 3 , 2 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 15 , 10 , 5 , 0 ) , 0 , 0 ) ; btnChart = new JButton ( s_stringMgr . getString ( "OverviewPanel . showChartEndButton" ) ) ; add ( btnChart , gbc ) ; int gbcCol = chartConfigPanelTabMode = = ChartConfigPanelTabMode . SINGLE_COLUMN ? 4 : 5 ; gbc = new GridBagConstraints ( 0 , gbcCol , 3 , 1 , 0 , 1 , GridBagConstraints . EAST , GridBagConstraints . BOTH , new Insets ( 0 , 0 , 0 , 0 ) , 0 , 0 ) ; add ( new JPanel ( ) , gbc ) ; gbc = new GridBagConstraints ( 3 , 0 , 1 , 4 , 1 , 0 , GridBagConstraints . EAST , GridBagConstraints . BOTH , new Insets ( 0 , 0 , 0 , 0 ) , 0 , 0 ) ; add ( new JPanel ( ) , gbc ) ; }
void test2 ( ) throws Throwable { ChartConfigPanelTabMode chartConfigPanelTabMode0 = ChartConfigPanelTabMode . XYZ_CHART ; ChartConfigPanelTab chartConfigPanelTab0 = new ChartConfigPanelTab ( chartConfigPanelTabMode0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ChartConfigPanelTab ( ChartConfigPanelTabMode chartConfigPanelTabMode ) { super ( new GridBagLayout ( ) ) ; _chartConfigPanelTabMode = chartConfigPanelTabMode ; GridBagConstraints gbc ; gbc = new GridBagConstraints ( 0 , 0 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 15 , 5 , 5 , 5 ) , 0 , 0 ) ; add ( new JLabel ( s_stringMgr . getString ( "OverviewPanel . XAxis" ) ) , gbc ) ; gbc = new GridBagConstraints ( 1 , 0 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 15 , 10 , 5 , 5 ) , 0 , 0 ) ; cboXColumns = new JComboBox ( ) ; add ( cboXColumns , gbc ) ; if ( chartConfigPanelTabMode = = ChartConfigPanelTabMode . SINGLE_COLUMN ) { gbc = new GridBagConstraints ( 0 , 1 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; add ( new JLabel ( s_stringMgr . getString ( "OverviewPanel . YAxis" ) ) , gbc ) ; gbc = new GridBagConstraints ( 1 , 1 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; cboYAxisKind = new JComboBox ( ) ; add ( cboYAxisKind , gbc ) ; } else if ( chartConfigPanelTabMode = = ChartConfigPanelTabMode . XY_CHART ) { gbc = new GridBagConstraints ( 0 , 1 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; add ( new JLabel ( s_stringMgr . getString ( "OverviewPanel . YAxis" ) ) , gbc ) ; gbc = new GridBagConstraints ( 1 , 1 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; cboYColumns = new JComboBox ( ) ; add ( cboYColumns , gbc ) ; gbc = new GridBagConstraints ( 2 , 1 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 0 , 0 , 5 , 5 ) , 0 , 0 ) ; add ( createAsKindPanel ( ) , gbc ) ; } gbc = new GridBagConstraints ( 0 , 2 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . NONE , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; add ( new JLabel ( s_stringMgr . getString ( "OverviewPanel . maxBarCount" ) ) , gbc ) ; gbc = new GridBagConstraints ( 1 , 2 , 1 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 0 , 10 , 5 , 5 ) , 0 , 0 ) ; cboCallDepth = new JComboBox ( ) ; add ( cboCallDepth , gbc ) ; gbc = new GridBagConstraints ( 0 , 3 , 2 , 1 , 0 , 0 , GridBagConstraints . EAST , GridBagConstraints . HORIZONTAL , new Insets ( 15 , 10 , 5 , 0 ) , 0 , 0 ) ; btnChart = new JButton ( s_stringMgr . getString ( "OverviewPanel . showChartEndButton" ) ) ; add ( btnChart , gbc ) ; int gbcCol = chartConfigPanelTabMode = = ChartConfigPanelTabMode . SINGLE_COLUMN ? 4 : 5 ; gbc = new GridBagConstraints ( 0 , gbcCol , 3 , 1 , 0 , 1 , GridBagConstraints . EAST , GridBagConstraints . BOTH , new Insets ( 0 , 0 , 0 , 0 ) , 0 , 0 ) ; add ( new JPanel ( ) , gbc ) ; gbc = new GridBagConstraints ( 3 , 0 , 1 , 4 , 1 , 0 , GridBagConstraints . EAST , GridBagConstraints . BOTH , new Insets ( 0 , 0 , 0 , 0 ) , 0 , 0 ) ; add ( new JPanel ( ) , gbc ) ; }
void test0 ( ) throws Throwable { CallDepthComboModel callDepthComboModel0 = new CallDepthComboModel ( 88 ) ; int int0 = callDepthComboModel0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test1 ( ) throws Throwable { CallDepthComboModel callDepthComboModel0 = new CallDepthComboModel ( 0 ) ; String string0 = callDepthComboModel0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCallDepth ( ) { return _callDepth ; }
void test2 ( ) throws Throwable { CallDepthComboModel callDepthComboModel0 = new CallDepthComboModel ( 0 ) ; int int0 = callDepthComboModel0 . getCallDepth ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCallDepth ( ) { return _callDepth ; }
void test4 ( ) throws Throwable { CallDepthComboModel [ ] callDepthComboModelArray0 = CallDepthComboModel . createModels ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" CallDepthComboModel [ ] createModels ( ) { return new CallDepthComboModel [ ] { new CallDepthComboModel ( ScaleFactory . DEFAULT_CALL_DEPTH ) , new CallDepthComboModel ( ScaleFactory . DEFAULT_CALL_DEPTH + 1 ) , new CallDepthComboModel ( ScaleFactory . DEFAULT_CALL_DEPTH + 2 ) , new CallDepthComboModel ( ScaleFactory . DEFAULT_CALL_DEPTH + 3 ) , new CallDepthComboModel ( ScaleFactory . DEFAULT_CALL_DEPTH + 4 ) , new CallDepthComboModel ( ScaleFactory . DEFAULT_CALL_DEPTH + 5 ) , new CallDepthComboModel ( ScaleFactory . DEFAULT_CALL_DEPTH + 6 ) , } ; }
void test5 ( ) throws Throwable { CallDepthComboModel callDepthComboModel0 = new CallDepthComboModel ( 0 ) ; boolean boolean0 = callDepthComboModel0 . equals ( ( Object ) "1" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCallDepth ( ) { return _callDepth ; }
void test6 ( ) throws Throwable { CallDepthComboModel callDepthComboModel0 = new CallDepthComboModel ( 88 ) ; boolean boolean0 = callDepthComboModel0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCallDepth ( ) { return _callDepth ; }
void test7 ( ) throws Throwable { CallDepthComboModel callDepthComboModel0 = new CallDepthComboModel ( 0 ) ; CallDepthComboModel callDepthComboModel1 = new CallDepthComboModel ( 0 ) ; boolean boolean0 = callDepthComboModel0 . equals ( ( Object ) callDepthComboModel1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCallDepth ( ) { return _callDepth ; }
void test8 ( ) throws Throwable { CallDepthComboModel callDepthComboModel0 = new CallDepthComboModel ( 88 ) ; CallDepthComboModel callDepthComboModel1 = new CallDepthComboModel ( ( - 1673 ) ) ; boolean boolean0 = callDepthComboModel0 . equals ( ( Object ) callDepthComboModel1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test0 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1 ) , "COUNT" ) ; ChartConfigPanelTabMode chartConfigPanelTabMode0 = ChartConfigPanelTabMode . XY_CHART ; ChartConfigMode [ ] chartConfigModeArray0 = ChartConfigMode . getAvailableValues ( columnDisplayDefinition0 , chartConfigPanelTabMode0 , ( StringManager ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ChartConfigMode [ ] getAvailableValues ( ColumnDisplayDefinition columnDisplayDefinition , ChartConfigPanelTabMode chartConfigPanelTabMode , StringManager s_stringMgr ) { ArrayList < ChartConfigMode > ret = new ArrayList < ChartConfigMode > ( ) ; for ( ChartConfigMode chartConfigMode : values ( ) ) { chartConfigMode . setStringManager ( s_stringMgr ) ; } if ( ChartConfigPanelTabMode . SINGLE_COLUMN = = chartConfigPanelTabMode ) { ret . add ( COUNT ) ; if ( IndexedColumnFactory . isSumable ( columnDisplayDefinition ) ) { ret . add ( SUM ) ; } } else if ( ChartConfigPanelTabMode . XY_CHART = = chartConfigPanelTabMode ) { ret . add ( XY_COUNT_DISTINCT ) ; if ( IndexedColumnFactory . isSumable ( columnDisplayDefinition ) ) { ret . add ( XY_SUM_COL ) ; } / / if ( IndexedColumnFactory . isOrderable ( columnDisplayDefinition ) ) / / { / / ret . add ( XY_MIN ) ; / / ret . add ( XY_MAX ) ; / / } } return ret . toArray ( new ChartConfigMode [ ret . size ( ) ] ) ; }
void test2 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1 ) , "COUNT" ) ; ChartConfigPanelTabMode chartConfigPanelTabMode0 = ChartConfigPanelTabMode . SINGLE_COLUMN ; ChartConfigMode [ ] chartConfigModeArray0 = ChartConfigMode . getAvailableValues ( columnDisplayDefinition0 , chartConfigPanelTabMode0 , ( StringManager ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ChartConfigMode [ ] getAvailableValues ( ColumnDisplayDefinition columnDisplayDefinition , ChartConfigPanelTabMode chartConfigPanelTabMode , StringManager s_stringMgr ) { ArrayList < ChartConfigMode > ret = new ArrayList < ChartConfigMode > ( ) ; for ( ChartConfigMode chartConfigMode : values ( ) ) { chartConfigMode . setStringManager ( s_stringMgr ) ; } if ( ChartConfigPanelTabMode . SINGLE_COLUMN = = chartConfigPanelTabMode ) { ret . add ( COUNT ) ; if ( IndexedColumnFactory . isSumable ( columnDisplayDefinition ) ) { ret . add ( SUM ) ; } } else if ( ChartConfigPanelTabMode . XY_CHART = = chartConfigPanelTabMode ) { ret . add ( XY_COUNT_DISTINCT ) ; if ( IndexedColumnFactory . isSumable ( columnDisplayDefinition ) ) { ret . add ( XY_SUM_COL ) ; } / / if ( IndexedColumnFactory . isOrderable ( columnDisplayDefinition ) ) / / { / / ret . add ( XY_MIN ) ; / / ret . add ( XY_MAX ) ; / / } } return ret . toArray ( new ChartConfigMode [ ret . size ( ) ] ) ; }
void test3 ( ) throws Throwable { ChartConfigPanelTabMode chartConfigPanelTabMode0 = ChartConfigPanelTabMode . XYZ_CHART ; ChartConfigMode [ ] chartConfigModeArray0 = ChartConfigMode . getAvailableValues ( ( ColumnDisplayDefinition ) null , chartConfigPanelTabMode0 , ( StringManager ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ChartConfigMode [ ] getAvailableValues ( ColumnDisplayDefinition columnDisplayDefinition , ChartConfigPanelTabMode chartConfigPanelTabMode , StringManager s_stringMgr ) { ArrayList < ChartConfigMode > ret = new ArrayList < ChartConfigMode > ( ) ; for ( ChartConfigMode chartConfigMode : values ( ) ) { chartConfigMode . setStringManager ( s_stringMgr ) ; } if ( ChartConfigPanelTabMode . SINGLE_COLUMN = = chartConfigPanelTabMode ) { ret . add ( COUNT ) ; if ( IndexedColumnFactory . isSumable ( columnDisplayDefinition ) ) { ret . add ( SUM ) ; } } else if ( ChartConfigPanelTabMode . XY_CHART = = chartConfigPanelTabMode ) { ret . add ( XY_COUNT_DISTINCT ) ; if ( IndexedColumnFactory . isSumable ( columnDisplayDefinition ) ) { ret . add ( XY_SUM_COL ) ; } / / if ( IndexedColumnFactory . isOrderable ( columnDisplayDefinition ) ) / / { / / ret . add ( XY_MIN ) ; / / ret . add ( XY_MAX ) ; / / } } return ret . toArray ( new ChartConfigMode [ ret . size ( ) ] ) ; }
void test0 ( ) throws Throwable { ObjectTreeDndTransfer objectTreeDndTransfer0 = new ObjectTreeDndTransfer ( ( List < ITableInfo > ) null , ( IIdentifier ) null ) ; List < ITableInfo > list0 = objectTreeDndTransfer0 . getSelectedTables ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < ITableInfo > getSelectedTables ( ) ; / * * * Refresh the object tree . * / void refreshTree ( ) ; / * * * Refresh the object tree . * / void refreshTree ( boolean reloadSchemaInfo ) ; / * * * Refresh the nodes currently selected in the object tree . * / void refreshSelectedNodes ( ) ; / * * * Remove one or more nodes from the tree . * * @param nodes Array of nodes to be removed . * * @throws IllegalArgumentException * Thrown if a < TT > null < / TT > < TT > ObjectTreeNode [ ] < / TT > thrown . * / void removeNodes ( ObjectTreeNode [ ] nodes ) ; / * * * Retrieve details about all object types that can be in this * tree . * * @return DatabaseObjectType [ ] Array of object type info objects . * / DatabaseObjectType [ ] getDatabaseObjectTypes ( ) ; / * * * Add a known database object type to the object tree . * * @param dboType The new database object type . * / void addKnownDatabaseObjectType ( DatabaseObjectType dboType ) ; IObjectTab getTabbedPaneIfSelected ( DatabaseObjectType dbObjectType , String title ) ; / * * * Tries to locate the object given by the paramteres in the Object tree . * The first matching object found is selected . * * @param catalog null means any catalog * @param schema null means any schema * @return true if the Object was found and selected . * / boolean selectInObjectTree ( String catalog , String schema , FilterMatcher objectMatcher ) ; / * * * Selects the root node of the tree . * / void selectRoot ( ) ; / * * * Expands the specified tree node . * * @param node the tree node to expand * / void expandNode ( ObjectTreeNode node ) ; / * * * Calls refreshComponent on the selected tab in the current * ObjectTreeTabbedPane , if the selected tab happens to be a BaseDataSetTab * type . * * @throws DataSetException if there was a problem refreshing the component . * / void refreshSelectedTab ( ) throws DataSetException ; FindInObjectTreeController getFindController ( ) ; Component getDetailTabComp ( ) ; }
void test1 ( ) throws Throwable { ObjectTreeDndTransfer objectTreeDndTransfer0 = new ObjectTreeDndTransfer ( ( List < ITableInfo > ) null , ( IIdentifier ) null ) ; IIdentifier iIdentifier0 = objectTreeDndTransfer0 . getSessionIdentifier ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IIdentifier getSessionIdentifier ( ) { return _sessionIdentifier ; }
void test0 ( ) throws Throwable { TableTypeExpander tableTypeExpander0 = new TableTypeExpander ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { UDTTypeExpander uDTTypeExpander0 = new UDTTypeExpander ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { DatabaseObjectInfoTab databaseObjectInfoTab0 = new DatabaseObjectInfoTab ( ) ; JavabeanDataSet javabeanDataSet0 = ( JavabeanDataSet ) databaseObjectInfoTab0 . createDataSet ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test1 ( ) throws Throwable { DatabaseObjectInfoTab databaseObjectInfoTab0 = new DatabaseObjectInfoTab ( ) ; String string0 = databaseObjectInfoTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { DatabaseObjectInfoTab databaseObjectInfoTab0 = new DatabaseObjectInfoTab ( ) ; String string0 = databaseObjectInfoTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { DatabaseObjectInfoTab databaseObjectInfoTab0 = new DatabaseObjectInfoTab ( ) ; IDatabaseObjectInfo iDatabaseObjectInfo0 = databaseObjectInfoTab0 . getDatabaseObjectInfo ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IDatabaseObjectInfo getDatabaseObjectInfo ( ) { return _objectInfo ; }
void test2 ( ) throws Throwable { DatabaseObjectInfoTab databaseObjectInfoTab0 = new DatabaseObjectInfoTab ( ) ; databaseObjectInfoTab0 . setDatabaseObjectInfo ( ( IDatabaseObjectInfo ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test3 ( ) throws Throwable { DatabaseObjectInfoTab databaseObjectInfoTab0 = new DatabaseObjectInfoTab ( ) ; databaseObjectInfoTab0 . rebuild ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test0 ( ) throws Throwable { LineNumber lineNumber0 = new LineNumber ( ( JComponent ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void paintComponent ( Graphics g ) { int lineHeight = getLineHeight ( ) ; int startOffset = getStartOffset ( ) ; Rectangle drawHere = g . getClipBounds ( ) ; / / Paint the background g . setColor ( getBackground ( ) ) ; g . fillRect ( drawHere . x , drawHere . y , drawHere . width , drawHere . height ) ; / / Determine the number of lines to draw in the foreground . g . setColor ( getForeground ( ) ) ; int startLineNumber = ( drawHere . y / lineHeight ) + 1 ; int endLineNumber = startLineNumber + ( drawHere . height / lineHeight ) ; int start = ( drawHere . y / lineHeight ) * lineHeight + startOffset ; for ( int i = startLineNumber ; i < = endLineNumber ; i + + ) { String lineNumber = String . valueOf ( i ) ; int stringWidth = fontMetrics . stringWidth ( lineNumber ) ; int rowWidth = getSize ( ) . width ; g . drawString ( lineNumber , rowWidth - stringWidth - MARGIN , start ) ; start + = lineHeight ; } int rows = component . getSize ( ) . height / componentFontHeight ; setPreferredWidth ( rows ) ; }
void test1 ( ) throws Throwable { JViewport jViewport0 = new JViewport ( ) ; JToolTip jToolTip0 = jViewport0 . createToolTip ( ) ; LineNumber lineNumber0 = new LineNumber ( ( JComponent ) jToolTip0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { LineNumber lineNumber0 = new LineNumber ( ( JComponent ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWidth ( ) { return _indexedColumn . calculateDist ( _beginData , _endData ) ; }
void test3 ( ) throws Throwable { LineNumber lineNumber0 = new LineNumber ( ( JComponent ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void paintComponent ( Graphics g ) { int lineHeight = getLineHeight ( ) ; int startOffset = getStartOffset ( ) ; Rectangle drawHere = g . getClipBounds ( ) ; / / Paint the background g . setColor ( getBackground ( ) ) ; g . fillRect ( drawHere . x , drawHere . y , drawHere . width , drawHere . height ) ; / / Determine the number of lines to draw in the foreground . g . setColor ( getForeground ( ) ) ; int startLineNumber = ( drawHere . y / lineHeight ) + 1 ; int endLineNumber = startLineNumber + ( drawHere . height / lineHeight ) ; int start = ( drawHere . y / lineHeight ) * lineHeight + startOffset ; for ( int i = startLineNumber ; i < = endLineNumber ; i + + ) { String lineNumber = String . valueOf ( i ) ; int stringWidth = fontMetrics . stringWidth ( lineNumber ) ; int rowWidth = getSize ( ) . width ; g . drawString ( lineNumber , rowWidth - stringWidth - MARGIN , start ) ; start + = lineHeight ; } int rows = component . getSize ( ) . height / componentFontHeight ; setPreferredWidth ( rows ) ; }
void test4 ( ) throws Throwable { LineNumber lineNumber0 = new LineNumber ( ( JComponent ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { DatabaseObjectInfoTab databaseObjectInfoTab0 = new DatabaseObjectInfoTab ( ) ; databaseObjectInfoTab0 . rebuild ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test0 ( ) throws Throwable { RowCountTab rowCountTab0 = new RowCountTab ( ) ; String string0 = rowCountTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test2 ( ) throws Throwable { RowCountTab rowCountTab0 = new RowCountTab ( ) ; String string0 = rowCountTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test0 ( ) throws Throwable { ImportedKeysTab importedKeysTab0 = new ImportedKeysTab ( ) ; String string0 = importedKeysTab0 . getHintKey ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHintKey ( ) ; / * * * Retrieve the < TT > IDataSet < / TT > to be displayed in this tab . * * @return the < TT > IDataSet < / TT > to be displayed in this tab . * / IDataSet createDataSet ( ) throws DataSetException { / / Provide the actual integer value , as well as it's meaning Map < Integer , Map < String , String > > replacements = new HashMap < Integer , Map < String , String > > ( 20 ) ; HashMap < String , String > replacementMap = new HashMap < String , String > ( ) ; replacementMap . put ( "" + importedKeyCascade , importedKeyCascade + " ( CASCADE ) " ) ; replacementMap . put ( "" + importedKeyRestrict , importedKeyRestrict + " ( RESTRICT ) " ) ; replacementMap . put ( "" + importedKeySetNull , importedKeySetNull + " ( SET NULL ) " ) ; replacementMap . put ( "" + importedKeyNoAction , importedKeyNoAction + " ( NO ACTION ) " ) ; replacementMap . put ( "" + importedKeySetDefault , importedKeySetDefault + " ( SET DEFAULT ) " ) ; replacements . put ( 9 , replacementMap ) ; replacements . put ( 10 , replacementMap ) ; ISQLConnection conn = getSession ( ) . getSQLConnection ( ) ; IDataSet orig = getUnfilteredDataSet ( conn . getSQLMetaData ( ) , getTableInfo ( ) ) ; return new FilterDataSet ( orig , replacements ) ; }
void test1 ( ) throws Throwable { ImportedKeysTab importedKeysTab0 = new ImportedKeysTab ( ) ; String string0 = importedKeysTab0 . getTitleKey ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitleKey ( ) ; / * * * Return the hint for the tab . * * @return The hint for the tab . * / String getHint ( ) { return s_stringMgr . getString ( getHintKey ( ) ) ; }
void test0 ( ) throws Throwable { ExportedKeysTab exportedKeysTab0 = new ExportedKeysTab ( ) ; String string0 = exportedKeysTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { ImportedKeysTab importedKeysTab0 = new ImportedKeysTab ( ) ; String string0 = importedKeysTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { String string0 = ContentsTab . getContentsTabTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getContentsTabTitle ( ) { / / i18n [ ContentsTab . title = Content ] return s_stringMgr . getString ( "ContentsTab . title" ) ; }
void test0 ( ) throws Throwable { ExportedKeysTab exportedKeysTab0 = new ExportedKeysTab ( ) ; String string0 = exportedKeysTab0 . getTitleKey ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitleKey ( ) ; / * * * Return the hint for the tab . * * @return The hint for the tab . * / String getHint ( ) { return s_stringMgr . getString ( getHintKey ( ) ) ; }
void test2 ( ) throws Throwable { ExportedKeysTab exportedKeysTab0 = new ExportedKeysTab ( ) ; String string0 = exportedKeysTab0 . getHintKey ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHintKey ( ) ; / * * * Retrieve the < TT > IDataSet < / TT > to be displayed in this tab . * * @return the < TT > IDataSet < / TT > to be displayed in this tab . * / IDataSet createDataSet ( ) throws DataSetException { / / Provide the actual integer value , as well as it's meaning Map < Integer , Map < String , String > > replacements = new HashMap < Integer , Map < String , String > > ( 20 ) ; HashMap < String , String > replacementMap = new HashMap < String , String > ( ) ; replacementMap . put ( "" + importedKeyCascade , importedKeyCascade + " ( CASCADE ) " ) ; replacementMap . put ( "" + importedKeyRestrict , importedKeyRestrict + " ( RESTRICT ) " ) ; replacementMap . put ( "" + importedKeySetNull , importedKeySetNull + " ( SET NULL ) " ) ; replacementMap . put ( "" + importedKeyNoAction , importedKeyNoAction + " ( NO ACTION ) " ) ; replacementMap . put ( "" + importedKeySetDefault , importedKeySetDefault + " ( SET DEFAULT ) " ) ; replacements . put ( 9 , replacementMap ) ; replacements . put ( 10 , replacementMap ) ; ISQLConnection conn = getSession ( ) . getSQLConnection ( ) ; IDataSet orig = getUnfilteredDataSet ( conn . getSQLMetaData ( ) , getTableInfo ( ) ) ; return new FilterDataSet ( orig , replacements ) ; }
void test1 ( ) throws Throwable { TablePriviligesTab tablePriviligesTab0 = new TablePriviligesTab ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { TablePriviligesTab tablePriviligesTab0 = new TablePriviligesTab ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { PrimaryKeyTab primaryKeyTab0 = new PrimaryKeyTab ( ) ; String string0 = primaryKeyTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { PrimaryKeyTab primaryKeyTab0 = new PrimaryKeyTab ( ) ; String string0 = primaryKeyTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { ColumnPriviligesTab columnPriviligesTab0 = new ColumnPriviligesTab ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test2 ( ) throws Throwable { ColumnPriviligesTab columnPriviligesTab0 = new ColumnPriviligesTab ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test0 ( ) throws Throwable { VersionColumnsTab versionColumnsTab0 = new VersionColumnsTab ( ) ; String string0 = versionColumnsTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { VersionColumnsTab versionColumnsTab0 = new VersionColumnsTab ( ) ; String string0 = versionColumnsTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { VersionColumnsTab versionColumnsTab0 = new VersionColumnsTab ( ) ; versionColumnsTab0 . setTableInfo ( ( ITableInfo ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { ColumnsTab columnsTab0 = new ColumnsTab ( ) ; ITableInfo iTableInfo0 = columnsTab0 . getTableInfo ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IDatabaseObjectInfo getTableInfo ( ) { return _tableInfo ; }
void test1 ( ) throws Throwable { RowIDTab rowIDTab0 = new RowIDTab ( ) ; String string0 = rowIDTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test2 ( ) throws Throwable { RowIDTab rowIDTab0 = new RowIDTab ( ) ; String string0 = rowIDTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test0 ( ) throws Throwable { ColumnsTab columnsTab0 = new ColumnsTab ( ) ; String string0 = columnsTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { ColumnsTab columnsTab0 = new ColumnsTab ( ) ; String string0 = columnsTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { IndexesTab indexesTab0 = new IndexesTab ( ) ; String string0 = indexesTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { IndexesTab indexesTab0 = new IndexesTab ( ) ; String string0 = indexesTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test0 ( ) throws Throwable { ProcedureColumnsTab procedureColumnsTab0 = new ProcedureColumnsTab ( ) ; procedureColumnsTab0 . setProcedureInfo ( ( IProcedureInfo ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { ProcedureColumnsTab procedureColumnsTab0 = new ProcedureColumnsTab ( ) ; IProcedureInfo iProcedureInfo0 = procedureColumnsTab0 . getProcedureInfo ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IProcedureInfo getProcedureInfo ( ) { return ( IProcedureInfo ) getDatabaseObjectInfo ( ) ; }
void test1 ( ) throws Throwable { ProcedureColumnsTab procedureColumnsTab0 = new ProcedureColumnsTab ( ) ; String string0 = procedureColumnsTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { DataTypesTab dataTypesTab0 = new DataTypesTab ( ) ; String string0 = dataTypesTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { DataTypesTab dataTypesTab0 = new DataTypesTab ( ) ; String string0 = dataTypesTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { TimeDateFunctionsTab timeDateFunctionsTab0 = new TimeDateFunctionsTab ( ) ; String string0 = timeDateFunctionsTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { TimeDateFunctionsTab timeDateFunctionsTab0 = new TimeDateFunctionsTab ( ) ; String string0 = timeDateFunctionsTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { NumericFunctionsTab numericFunctionsTab0 = new NumericFunctionsTab ( ) ; String string0 = numericFunctionsTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { NumericFunctionsTab numericFunctionsTab0 = new NumericFunctionsTab ( ) ; String string0 = numericFunctionsTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { KeywordsTab keywordsTab0 = new KeywordsTab ( ) ; String string0 = keywordsTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test2 ( ) throws Throwable { KeywordsTab keywordsTab0 = new KeywordsTab ( ) ; String string0 = keywordsTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { TableTypesTab tableTypesTab0 = new TableTypesTab ( ) ; String string0 = tableTypesTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { TableTypesTab tableTypesTab0 = new TableTypesTab ( ) ; String string0 = tableTypesTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { ConnectionStatusTab connectionStatusTab0 = new ConnectionStatusTab ( ) ; String string0 = connectionStatusTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test2 ( ) throws Throwable { ConnectionStatusTab connectionStatusTab0 = new ConnectionStatusTab ( ) ; String string0 = connectionStatusTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test0 ( ) throws Throwable { MetaDataTab metaDataTab0 = new MetaDataTab ( ) ; String string0 = metaDataTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { MetaDataTab metaDataTab0 = new MetaDataTab ( ) ; String string0 = metaDataTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { SystemFunctionsTab systemFunctionsTab0 = new SystemFunctionsTab ( ) ; String string0 = systemFunctionsTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { SystemFunctionsTab systemFunctionsTab0 = new SystemFunctionsTab ( ) ; String string0 = systemFunctionsTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { StringFunctionsTab stringFunctionsTab0 = new StringFunctionsTab ( ) ; String string0 = stringFunctionsTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { StringFunctionsTab stringFunctionsTab0 = new StringFunctionsTab ( ) ; String string0 = stringFunctionsTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { CatalogsTab catalogsTab0 = new CatalogsTab ( ) ; String string0 = catalogsTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test2 ( ) throws Throwable { CatalogsTab catalogsTab0 = new CatalogsTab ( ) ; String string0 = catalogsTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test0 ( ) throws Throwable { SchemasTab schemasTab0 = new SchemasTab ( ) ; String string0 = schemasTab0 . getTitle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTitle ( ) { return _title ; }
void test1 ( ) throws Throwable { SchemasTab schemasTab0 = new SchemasTab ( ) ; String string0 = schemasTab0 . getHint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHint ( ) { return _hint ; }
void test1 ( ) throws Throwable { Parser parser0 = new Parser ( ( Scanner ) null , ( SQLSchema ) null ) ; String string0 = parser0 . LookAheadName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String LookAheadName ( ) { return t . val ; }
void test4 ( ) throws Throwable { Parser parser0 = new Parser ( ( Scanner ) null , ( SQLSchema ) null ) ; SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 0 ) ; parser0 . addRootStatement ( ( SQLStatement ) sQLModifyingStatement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String LookAheadName ( ) { return t . val ; }
void test5 ( ) throws Throwable { Parser parser0 = new Parser ( ( Scanner ) null , ( SQLSchema ) null ) ; parser0 . removeaddParserListener ( ( ParserListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String LookAheadString ( ) { return t . str ; }
void test7 ( ) throws Throwable { SQLStatement sQLStatement0 = new SQLStatement ( 1030 ) ; Parser parser0 = new Parser ( ( Scanner ) null , ( SQLSchema ) sQLStatement0 ) ; String string0 = parser0 . LookAheadString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String LookAheadString ( ) { return t . str ; }
void test8 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; Parser parser0 = new Parser ( ( Scanner ) null , ( SQLSchema ) sQLSelectStatement0 ) ; parser0 . addSQLSelectStatementListener ( ( SQLSelectStatementListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String LookAheadString ( ) { return t . str ; }
void test9 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; Parser parser0 = new Parser ( ( Scanner ) null , ( SQLSchema ) sQLSelectStatement0 ) ; parser0 . removeSQLSelectStatementListener ( ( SQLSelectStatementListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String LookAheadName ( ) { return t . val ; }
void test13 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 97 ) ; Parser parser0 = new Parser ( ( Scanner ) null , ( SQLSchema ) sQLModifyingStatement0 ) ; boolean boolean0 = parser0 . WeakSeparator ( 97 , 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean WeakSeparator ( int n , int syFol , int repFol ) { boolean [ ] s = new boolean [ maxT + 1 ] ; if ( t . kind = = n ) { Get ( ) ; return true ; } else if ( StartOf ( repFol ) ) return false ; else { for ( int i = 0 ; i < = maxT ; i + + ) { s [ i ] = set [ syFol ] [ i ] | | set [ repFol ] [ i ] | | set [ 0 ] [ i ] ; } Error ( n ) ; while ( ! s [ t . kind ] ) Get ( ) ; return StartOf ( syFol ) ; } }
void test0 ( ) throws Throwable { TableAliasInfo tableAliasInfo0 = new TableAliasInfo ( "" , "" , 1285 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TableAliasInfo ( String aliasName , String tableName , int statBegin ) { this . aliasName = aliasName ; this . tableName = tableName ; this . statBegin = statBegin ; }
void test1 ( ) throws Throwable { Scanner . SBuffer scanner_SBuffer0 = new Scanner . SBuffer ( "Could not find class [ " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ErrorStream ( ) { count = 0 ; }
void test2 ( ) throws Throwable { Scanner . SBuffer scanner_SBuffer0 = new Scanner . SBuffer ( "Could not find class [ " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test3 ( ) throws Throwable { Scanner . SBuffer scanner_SBuffer0 = new Scanner . SBuffer ( "O > 1u%oFQ > J6 ( H . ' * " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ErrorStream ( ) { count = 0 ; }
void test4 ( ) throws Throwable { Scanner . SBuffer scanner_SBuffer0 = new Scanner . SBuffer ( "\n\n" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ErrorStream ( ) { count = 0 ; }
void test1 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1 ) ; boolean boolean0 = sQLSelectStatement0 . isRepeatable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test2 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) sQLSelectStatement0 , ( - 17 ) ) ; int int0 = sQLTable0 . getLength ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test3 ( ) throws Throwable { SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) null , 0 , ( - 487 ) ) ; SQLColumn sQLColumn1 = ( SQLColumn ) sQLColumn0 . getCompletion ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test4 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; int int0 = sQLSelectStatement0 . getStart ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test5 ( ) throws Throwable { SQLCompletion . ChildComparator sQLCompletion_ChildComparator0 = new SQLCompletion . ChildComparator ( ) ; SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 , 0 ) ; int int0 = sQLCompletion_ChildComparator0 . compare ( ( SQLCompletion ) sQLSelectStatement0 , ( SQLCompletion ) sQLColumn0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test7 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 0 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLModifyingStatement0 ) ; boolean boolean0 = sQLColumn0 . hasTextPosition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasTextPosition ( ) ; / * * * @return whether this completion can be used to generate lists of items , e . g . columns * in a SQL select clause * / boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test8 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1 ) ; boolean boolean0 = sQLSelectStatement0 . mustReplace ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test9 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) sQLSelectStatement0 , ( - 17 ) ) ; SQLTable sQLTable1 = ( SQLTable ) sQLTable0 . getCompletion ( 1291 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test10 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 0 ) ; SQLWhere sQLWhere0 = new SQLWhere ( ( SQLStatement ) sQLModifyingStatement0 , 0 ) ; boolean boolean0 = sQLWhere0 . hasTextPosition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test11 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test12 ( ) throws Throwable { SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) null , 1 , 13 ) ; SQLTable sQLTable1 = ( SQLTable ) sQLTable0 . getCompletion ( ( - 1834 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test13 ( ) throws Throwable { SQLCompletion . ChildComparator sQLCompletion_ChildComparator0 = new SQLCompletion . ChildComparator ( ) ; SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; int int0 = sQLCompletion_ChildComparator0 . compare ( ( SQLCompletion ) sQLSelectStatement0 , ( SQLCompletion ) sQLSelectStatement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConcrete ( ) { return true ; }
void test14 ( ) throws Throwable { SQLCompletion . ChildComparator sQLCompletion_ChildComparator0 = new SQLCompletion . ChildComparator ( ) ; SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) sQLSelectStatement0 , ( - 17 ) ) ; int int0 = sQLCompletion_ChildComparator0 . compare ( ( SQLCompletion ) sQLTable0 , ( SQLCompletion ) sQLSelectStatement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test0 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 1635 ) ; ParserThread parserThread0 = new ParserThread ( ( SQLSchema ) sQLModifyingStatement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ErrorInfo [ ] getErrorInfos ( ) { return _lastRunErrorInfos ; }
void test1 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( ( - 1222 ) ) ; ParserThread parserThread0 = new ParserThread ( ( SQLSchema ) sQLModifyingStatement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void notifyParser ( String sqlText ) { ( this ) { _pendingString = sqlText ; this . notify ( ) ; } }
void test2 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( ( - 1222 ) ) ; ParserThread parserThread0 = new ParserThread ( ( SQLSchema ) sQLModifyingStatement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void end ( ) { IncrementalBuffer oldBuffer = this . _workingBuffer ; this . _workingBuffer = null ; oldBuffer . eof ( ) ; }
void test3 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 1635 ) ; ParserThread parserThread0 = new ParserThread ( ( SQLSchema ) sQLModifyingStatement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TableAliasInfo [ ] getTableAliasInfos ( ) { return _lastRunTableAliasInfos ; }
void test4 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1796 ) ; ParserThread parserThread0 = new ParserThread ( ( SQLSchema ) sQLSelectStatement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void exitThread ( ) { _exitThread = true ; ( this ) { this . notify ( ) ; } }
void test5 ( ) throws Throwable { ParserThread parserThread0 = new ParserThread ( ( SQLSchema ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setParsingFinishedListener ( ParsingFinishedListener parsingFinishedListener ) { _parsingFinishedListener = parsingFinishedListener ; }
void test0 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 11 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test1 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 46 ) ; sQLSelectStatement0 . setOrderByStart ( 46 ) ; SQLColumn sQLColumn0 = ( SQLColumn ) sQLSelectStatement0 . getCompletion ( 46 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test2 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 46 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test3 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 11 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test4 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( ( - 15 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasTextPosition ( ) ; / * * * @return whether this completion can be used to generate lists of items , e . g . columns * in a SQL select clause * / boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test5 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( ( - 34 ) ) ; sQLSelectStatement0 . addListener ( ( SQLSelectStatementListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test6 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 11 ) ; sQLSelectStatement0 . removeListener ( ( SQLSelectStatementListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test7 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 113 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test8 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( ( - 15 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test9 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( ( - 34 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test10 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( ( - 15 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test11 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 113 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test14 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( ( - 34 ) ) ; SQLTable sQLTable0 = ( SQLTable ) sQLSelectStatement0 . getCompletion ( ( - 34 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Completion getCompletion ( int position ) ; / * * * return completion text if the completion is fully defined * @param position the caret position at which the text should be inserted * @return return the completion text to be inserted into the underlying document * / String getText ( int position ) ; / * * * return completion text which is defined from this object and the derived option * @param position the caret position at which the text should be inserted * @param option an option string , which was earlier derived from this object * @return return the completion text to be inserted into the underlying document * / String getText ( int position , String option ) ; / * * * @return whether this completion is assigned to a specific position within the * underlying document * / boolean hasTextPosition ( ) ; / * * * @return whether this completion can be used to generate lists of items , e . g . columns * in a SQL select clause * / boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test15 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 11 ) ; SQLSelectStatement sQLSelectStatement1 = new SQLSelectStatement ( ( - 1647 ) ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 , ( - 1647 ) , 11 ) ; sQLSelectStatement1 . addColumn ( sQLColumn0 ) ; SQLColumn sQLColumn1 = ( SQLColumn ) sQLSelectStatement1 . getCompletion ( ( - 1647 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Completion getCompletion ( int position ) ; / * * * return completion text if the completion is fully defined * @param position the caret position at which the text should be inserted * @return return the completion text to be inserted into the underlying document * / String getText ( int position ) ; / * * * return completion text which is defined from this object and the derived option * @param position the caret position at which the text should be inserted * @param option an option string , which was earlier derived from this object * @return return the completion text to be inserted into the underlying document * / String getText ( int position , String option ) ; / * * * @return whether this completion is assigned to a specific position within the * underlying document * / boolean hasTextPosition ( ) ; / * * * @return whether this completion can be used to generate lists of items , e . g . columns * in a SQL select clause * / boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test16 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 113 ) ; SQLColumn sQLColumn0 = ( SQLColumn ) sQLSelectStatement0 . getCompletion ( 113 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Completion getCompletion ( int position ) ; / * * * return completion text if the completion is fully defined * @param position the caret position at which the text should be inserted * @return return the completion text to be inserted into the underlying document * / String getText ( int position ) ; / * * * return completion text which is defined from this object and the derived option * @param position the caret position at which the text should be inserted * @param option an option string , which was earlier derived from this object * @return return the completion text to be inserted into the underlying document * / String getText ( int position , String option ) ; / * * * @return whether this completion is assigned to a specific position within the * underlying document * / boolean hasTextPosition ( ) ; / * * * @return whether this completion can be used to generate lists of items , e . g . columns * in a SQL select clause * / boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test0 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1850 ) ; SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) sQLSelectStatement0 , 1850 , 1850 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getCompletions ( int position ) { SQLSchema . Table table = null ; if ( qualifier ! = null ) { / / try as an alias table = getStatement ( ) . getTableForAlias ( qualifier ) ; / / could also be a table name if ( table = = null ) table = getStatement ( ) . getTable ( null , null , qualifier ) ; } else / / see if its a one - table statement table = getStatement ( ) . getTable ( ) ; / / now match the columns if ( table ! = null ) { String col = null ; if ( name ! = null & & position > namePos ) { col = position < = endPosition ? name . substring ( 0 , position - namePos ) : name ; } String [ ] result = table . getColumns ( col ) ; return ( col ! = null & & result . length = = 1 & & result [ 0 ] . length ( ) = = col . length ( ) ) ? EMPTY_RESULT : result ; / / no need to return if completion is identical } else return EMPTY_RESULT ; }
void test1 ( ) throws Throwable { SQLStatement sQLStatement0 = new SQLStatement ( 0 ) ; SQLTable sQLTable0 = new SQLTable ( sQLStatement0 , 0 ) ; String string0 = sQLTable0 . getText ( 0 , "GQ" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test2 ( ) throws Throwable { SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) null , ( - 944 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test3 ( ) throws Throwable { SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) null , ( - 944 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test4 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1850 ) ; SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) sQLSelectStatement0 , 1850 , 1850 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getCompletions ( int position ) { SQLSchema . Table table = null ; if ( qualifier ! = null ) { / / try as an alias table = getStatement ( ) . getTableForAlias ( qualifier ) ; / / could also be a table name if ( table = = null ) table = getStatement ( ) . getTable ( null , null , qualifier ) ; } else / / see if its a one - table statement table = getStatement ( ) . getTable ( ) ; / / now match the columns if ( table ! = null ) { String col = null ; if ( name ! = null & & position > namePos ) { col = position < = endPosition ? name . substring ( 0 , position - namePos ) : name ; } String [ ] result = table . getColumns ( col ) ; return ( col ! = null & & result . length = = 1 & & result [ 0 ] . length ( ) = = col . length ( ) ) ? EMPTY_RESULT : result ; / / no need to return if completion is identical } else return EMPTY_RESULT ; }
void test5 ( ) throws Throwable { SQLStatement sQLStatement0 = new SQLStatement ( 0 ) ; SQLTable sQLTable0 = new SQLTable ( sQLStatement0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test6 ( ) throws Throwable { SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) null , ( - 944 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test7 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1850 ) ; SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) sQLSelectStatement0 , 1850 , 1850 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getCompletions ( int position ) { SQLSchema . Table table = null ; if ( qualifier ! = null ) { / / try as an alias table = getStatement ( ) . getTableForAlias ( qualifier ) ; / / could also be a table name if ( table = = null ) table = getStatement ( ) . getTable ( null , null , qualifier ) ; } else / / see if its a one - table statement table = getStatement ( ) . getTable ( ) ; / / now match the columns if ( table ! = null ) { String col = null ; if ( name ! = null & & position > namePos ) { col = position < = endPosition ? name . substring ( 0 , position - namePos ) : name ; } String [ ] result = table . getColumns ( col ) ; return ( col ! = null & & result . length = = 1 & & result [ 0 ] . length ( ) = = col . length ( ) ) ? EMPTY_RESULT : result ; / / no need to return if completion is identical } else return EMPTY_RESULT ; }
void test8 ( ) throws Throwable { SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) null , ( - 944 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConcrete ( ) { return true ; }
void test9 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1850 ) ; SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) sQLSelectStatement0 , 1850 , 1850 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConcrete ( ) { return true ; }
void test10 ( ) throws Throwable { SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) null , ( - 944 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean mustReplace ( int position ) ; }
void test11 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1850 ) ; SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) sQLSelectStatement0 , 1850 , 1850 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConcrete ( ) { return true ; }
void test12 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1850 ) ; SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) sQLSelectStatement0 , 1850 , 1850 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConcrete ( ) { return true ; }
void test13 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1850 ) ; SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) sQLSelectStatement0 , 1850 , 1850 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConcrete ( ) { return true ; }
void test0 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 14 ) ; SQLWhere sQLWhere0 = new SQLWhere ( ( SQLStatement ) sQLModifyingStatement0 , 14 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test1 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( ( - 166 ) ) ; SQLWhere sQLWhere0 = new SQLWhere ( ( SQLStatement ) sQLModifyingStatement0 , ( - 166 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addContext ( SQLStatementContext context ) { context . setSqlSchema ( this ) ; addChild ( context ) ; }
void test2 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 1 ) ; SQLWhere sQLWhere0 = new SQLWhere ( ( SQLStatement ) sQLModifyingStatement0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test3 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 14 ) ; SQLWhere sQLWhere0 = new SQLWhere ( ( SQLStatement ) sQLModifyingStatement0 , 14 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test4 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( ( - 1378 ) ) ; SQLWhere sQLWhere0 = new SQLWhere ( ( SQLStatement ) sQLSelectStatement0 , ( - 1378 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test5 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( ( - 1378 ) ) ; SQLWhere sQLWhere0 = new SQLWhere ( ( SQLStatement ) sQLSelectStatement0 , ( - 1378 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test0 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 681 ) ; SQLSchema . Table sQLSchema_Table0 = sQLSelectStatement0 . getTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLSchema . Table getTable ( String catalog , String schema , String name ) { if ( _session . getSchemaInfo ( ) . isTable ( name ) ) { String key = getKey ( catalog , schema , name ) ; SQLSchema . Table ret = _tableCache . get ( key ) ; if ( null = = ret ) { ret = new SQLSchema . Table ( catalog , schema , name , _dmd ) ; _tableCache . put ( key , ret ) ; } return ret ; } return null ; }
void test1 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 365 ) ; SQLSelectStatement sQLSelectStatement1 = ( SQLSelectStatement ) sQLSelectStatement0 . getStatement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test3 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 1766 ) ; SQLTable sQLTable0 = new SQLTable ( ( SQLStatement ) sQLSelectStatement0 , 1766 ) ; sQLSelectStatement0 . addTable ( sQLTable0 ) ; SQLTable sQLTable1 = ( SQLTable ) sQLSelectStatement0 . getCompletion ( 1766 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test5 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( ( - 14 ) ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLModifyingStatement0 ) ; sQLModifyingStatement0 . addColumn ( sQLColumn0 ) ; SQLColumn sQLColumn1 = ( SQLColumn ) sQLModifyingStatement0 . getCompletion ( ( - 14 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Completion getCompletion ( int position ) ; / * * * return completion text if the completion is fully defined * @param position the caret position at which the text should be inserted * @return return the completion text to be inserted into the underlying document * / String getText ( int position ) ; / * * * return completion text which is defined from this object and the derived option * @param position the caret position at which the text should be inserted * @param option an option string , which was earlier derived from this object * @return return the completion text to be inserted into the underlying document * / String getText ( int position , String option ) ; / * * * @return whether this completion is assigned to a specific position within the * underlying document * / boolean hasTextPosition ( ) ; / * * * @return whether this completion can be used to generate lists of items , e . g . columns * in a SQL select clause * / boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test8 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 681 ) ; Completion completion0 = sQLSelectStatement0 . getCompletion ( ( - 9 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Completion getCompletion ( int position ) ; / * * * return completion text if the completion is fully defined * @param position the caret position at which the text should be inserted * @return return the completion text to be inserted into the underlying document * / String getText ( int position ) ; / * * * return completion text which is defined from this object and the derived option * @param position the caret position at which the text should be inserted * @param option an option string , which was earlier derived from this object * @return return the completion text to be inserted into the underlying document * / String getText ( int position , String option ) ; / * * * @return whether this completion is assigned to a specific position within the * underlying document * / boolean hasTextPosition ( ) ; / * * * @return whether this completion can be used to generate lists of items , e . g . columns * in a SQL select clause * / boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test9 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( ( - 14 ) ) ; Completion completion0 = sQLModifyingStatement0 . getCompletion ( ( - 14 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Completion getCompletion ( int position ) ; / * * * return completion text if the completion is fully defined * @param position the caret position at which the text should be inserted * @return return the completion text to be inserted into the underlying document * / String getText ( int position ) ; / * * * return completion text which is defined from this object and the derived option * @param position the caret position at which the text should be inserted * @param option an option string , which was earlier derived from this object * @return return the completion text to be inserted into the underlying document * / String getText ( int position , String option ) ; / * * * @return whether this completion is assigned to a specific position within the * underlying document * / boolean hasTextPosition ( ) ; / * * * @return whether this completion can be used to generate lists of items , e . g . columns * in a SQL select clause * / boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test11 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( ( - 14 ) ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLModifyingStatement0 ) ; sQLModifyingStatement0 . addColumn ( sQLColumn0 ) ; sQLModifyingStatement0 . addColumn ( sQLColumn0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test12 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 365 ) ; SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 365 ) ; sQLSelectStatement0 . setSqlSchema ( ( SQLSchema ) sQLModifyingStatement0 ) ; sQLSelectStatement0 . setFromEnd ( 365 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test0 ( ) throws Throwable { SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) null ) ; String string0 = sQLColumn0 . getText ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test1 ( ) throws Throwable { SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) null ) ; sQLColumn0 . setColumn ( " ? & 3G%m ; " , 0 ) ; boolean boolean0 = sQLColumn0 . isConcrete ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConcrete ( ) { return true ; }
void test2 ( ) throws Throwable { SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) null ) ; sQLColumn0 . setName ( " ? & 3G%m ; " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test3 ( ) throws Throwable { SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) null , ( - 1238 ) ) ; boolean boolean0 = sQLColumn0 . isRepeatable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test5 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 ) ; sQLColumn0 . getQualifier ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test6 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 758 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test7 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 758 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 ) ; sQLColumn0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test8 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( ( - 1504 ) ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 , ( - 1504 ) , ( - 1504 ) ) ; sQLColumn0 . setQualifier ( " : " ) ; String string0 = sQLColumn0 . getText ( 854 , " : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test9 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( ( - 1504 ) ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 , ( - 1504 ) , ( - 1504 ) ) ; String [ ] stringArray0 = sQLColumn0 . getCompletions ( ( - 1504 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test10 ( ) throws Throwable { SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) null , ( - 1238 ) ) ; sQLColumn0 . setQualifier ( "" , 621 ) ; boolean boolean0 = sQLColumn0 . hasTable ( 917 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test11 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 133 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 , 133 , 133 ) ; boolean boolean0 = sQLColumn0 . hasTable ( 133 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test12 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 ) ; sQLColumn0 . setQualifier ( "o < 0C@Ut47" , 0 ) ; boolean boolean0 = sQLColumn0 . hasTable ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test15 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 ) ; sQLColumn0 . setQualifier ( "o < 0C@Ut47" , 0 ) ; String string0 = sQLColumn0 . getText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test16 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 ) ; boolean boolean0 = sQLColumn0 . isConcrete ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test17 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 133 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 , 133 , 133 ) ; String string0 = sQLColumn0 . getText ( 133 , "S ; - WAUSx ; ! ^T" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test18 ( ) throws Throwable { SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) null ) ; sQLColumn0 . setColumn ( " ? & 3G%m ; " , 0 ) ; String string0 = sQLColumn0 . getText ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test20 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 133 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 , 133 , 133 ) ; String string0 = sQLColumn0 . getText ( ( - 2027 ) , "S ; - WAUSx ; ! ^T" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test22 ( ) throws Throwable { SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) null ) ; sQLColumn0 . setColumn ( " ? & 3G%m ; " , 0 ) ; boolean boolean0 = sQLColumn0 . mustReplace ( ( - 26 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test23 ( ) throws Throwable { SQLSelectStatement sQLSelectStatement0 = new SQLSelectStatement ( 0 ) ; SQLColumn sQLColumn0 = new SQLColumn ( ( SQLStatementContext ) sQLSelectStatement0 ) ; sQLColumn0 . setColumn ( "" , 0 ) ; boolean boolean0 = sQLColumn0 . mustReplace ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test0 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 473 ) ; sQLModifyingStatement0 . setUpdateListEnd ( 473 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test4 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 473 ) ; sQLModifyingStatement0 . setUpdateListStart ( 473 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test7 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( ( - 1 ) ) ; SQLModifyingStatement sQLModifyingStatement1 = new SQLModifyingStatement ( ( - 1 ) ) ; sQLModifyingStatement0 . addContext ( ( SQLStatementContext ) sQLModifyingStatement1 ) ; SQLColumn sQLColumn0 = ( SQLColumn ) sQLModifyingStatement0 . getCompletion ( ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test8 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( ( - 1080 ) ) ; SQLColumn sQLColumn0 = ( SQLColumn ) sQLModifyingStatement0 . getCompletion ( ( - 1080 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Completion getCompletion ( int position ) ; / * * * return completion text if the completion is fully defined * @param position the caret position at which the text should be inserted * @return return the completion text to be inserted into the underlying document * / String getText ( int position ) ; / * * * return completion text which is defined from this object and the derived option * @param position the caret position at which the text should be inserted * @param option an option string , which was earlier derived from this object * @return return the completion text to be inserted into the underlying document * / String getText ( int position , String option ) ; / * * * @return whether this completion is assigned to a specific position within the * underlying document * / boolean hasTextPosition ( ) ; / * * * @return whether this completion can be used to generate lists of items , e . g . columns * in a SQL select clause * / boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test9 ( ) throws Throwable { SQLModifyingStatement sQLModifyingStatement0 = new SQLModifyingStatement ( 473 ) ; SQLColumn sQLColumn0 = ( SQLColumn ) sQLModifyingStatement0 . getCompletion ( 473 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Completion getCompletion ( int position ) ; / * * * return completion text if the completion is fully defined * @param position the caret position at which the text should be inserted * @return return the completion text to be inserted into the underlying document * / String getText ( int position ) ; / * * * return completion text which is defined from this object and the derived option * @param position the caret position at which the text should be inserted * @param option an option string , which was earlier derived from this object * @return return the completion text to be inserted into the underlying document * / String getText ( int position , String option ) ; / * * * @return whether this completion is assigned to a specific position within the * underlying document * / boolean hasTextPosition ( ) ; / * * * @return whether this completion can be used to generate lists of items , e . g . columns * in a SQL select clause * / boolean isRepeatable ( ) ; / * * * @return the length of the text currently occupied by this completion * / int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test0 ( ) throws Throwable { File file0 = new File ( "" , "iK# > . ~26" ) ; LogFile logFile0 = new LogFile ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { LogFile logFile0 = new LogFile ( ( File ) null , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { HtmlViewerPanel htmlViewerPanel0 = new HtmlViewerPanel ( ( URL ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { HtmlViewerPanel htmlViewerPanel0 = new HtmlViewerPanel ( ( URL ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { HtmlViewerPanel htmlViewerPanel0 = new HtmlViewerPanel ( ( URL ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { HtmlViewerPanel htmlViewerPanel0 = new HtmlViewerPanel ( ( URL ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test4 ( ) throws Throwable { HtmlViewerPanel htmlViewerPanel0 = new HtmlViewerPanel ( ( URL ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test5 ( ) throws Throwable { HtmlViewerPanel htmlViewerPanel0 = new HtmlViewerPanel ( ( URL ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void gotoURL ( URL url ) throws IOException { if ( url = = null ) { throw new IllegalArgumentException ( "URL = = null" ) ; } if ( ! url . equals ( _currentURL ) ) { ListIterator < URL > it = _history . listIterator ( _historyIndex + 1 ) ; while ( it . hasNext ( ) ) { it . next ( ) ; it . remove ( ) ; } _history . add ( url ) ; _historyIndex = _history . size ( ) - 1 ; _contentsTxt . setPage ( url ) ; _currentURL = url ; fireURLChanged ( ) ; } }
void test6 ( ) throws Throwable { HtmlViewerPanel htmlViewerPanel0 = new HtmlViewerPanel ( ( URL ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test7 ( ) throws Throwable { HtmlViewerPanel htmlViewerPanel0 = new HtmlViewerPanel ( ( URL ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test8 ( ) throws Throwable { Handler handler0 = new Handler ( ) ; URL uRL0 = new URL ( "U^wupb`" , "U^wupb`" , 0 , "U^wupb`" , ( URLStreamHandler ) handler0 ) ; HtmlViewerPanel htmlViewerPanel0 = new HtmlViewerPanel ( uRL0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { HtmlViewerPanel htmlViewerPanel0 = new HtmlViewerPanel ( ( URL ) null ) ; HtmlViewerPanelListenerEvent htmlViewerPanelListenerEvent0 = new HtmlViewerPanelListenerEvent ( htmlViewerPanel0 ) ; HtmlViewerPanel htmlViewerPanel1 = htmlViewerPanelListenerEvent0 . getHtmlViewerPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" HtmlViewerPanel getHtmlViewerPanel ( ) { return _pnl ; }
void test0 ( ) throws Throwable { AliasGroup aliasGroup0 = new AliasGroup ( ) ; MetalLabelUI metalLabelUI0 = new MetalLabelUI ( ) ; aliasGroup0 . addPropertyChangeListener ( ( PropertyChangeListener ) metalLabelUI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test2 ( ) throws Throwable { AliasGroup aliasGroup0 = new AliasGroup ( ) ; BasicRootPaneUI basicRootPaneUI0 = new BasicRootPaneUI ( ) ; aliasGroup0 . removePropertyChangeListener ( ( PropertyChangeListener ) basicRootPaneUI0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test3 ( ) throws Throwable { AliasGroup aliasGroup0 = new AliasGroup ( ) ; int int0 = aliasGroup0 . compareTo ( aliasGroup0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compareTo ( CaseInsensitiveString anotherString ) { int len1 = count ; int len2 = anotherString . count ; int n = Math . min ( len1 , len2 ) ; char v1 [ ] = value ; char v2 [ ] = anotherString . value ; int i = offset ; int j = anotherString . offset ; if ( i = = j ) { int k = i ; int lim = n + i ; while ( k < lim ) { char c1 = v1 [ k ] ; char c2 = v2 [ k ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } k + + ; } } else { while ( n - - ! = 0 ) { char c1 = v1 [ i + + ] ; char c2 = v2 [ j + + ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } } } return len1 - len2 ; }
void test5 ( ) throws Throwable { AliasGroup aliasGroup0 = new AliasGroup ( ) ; IntegerIdentifier integerIdentifier0 = new IntegerIdentifier ( 40 ) ; aliasGroup0 . setIdentifier ( ( IIdentifier ) integerIdentifier0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test6 ( ) throws Throwable { AliasGroup aliasGroup0 = new AliasGroup ( ) ; boolean boolean0 = aliasGroup0 . isValid ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isValid ( ) { return _name ! = null & & _name . length ( ) > 0 & & _driverId ! = null & & _url ! = null & & _url . length ( ) > 0 ; }
void test7 ( ) throws Throwable { AliasGroup aliasGroup0 = new AliasGroup ( ) ; aliasGroup0 . setName ( "HtmlViewerPanel . error . processhyperlink" ) ; boolean boolean0 = aliasGroup0 . isValid ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test8 ( ) throws Throwable { AliasGroup aliasGroup0 = new AliasGroup ( ) ; boolean boolean0 = aliasGroup0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test9 ( ) throws Throwable { AliasGroup aliasGroup0 = new AliasGroup ( ) ; boolean boolean0 = aliasGroup0 . equals ( ( Object ) "Default" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test10 ( ) throws Throwable { AliasGroup aliasGroup0 = new AliasGroup ( ) ; aliasGroup0 . setName ( "HtmlViewerPanel . error . processhyperlink" ) ; aliasGroup0 . setName ( "HtmlViewerPanel . error . processhyperlink" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isValid ( ) { return _name ! = null & & _name . length ( ) > 0 & & _driverId ! = null & & _url ! = null & & _url . length ( ) > 0 ; }
void test11 ( ) throws Throwable { AliasGroup aliasGroup0 = new AliasGroup ( ) ; aliasGroup0 . setName ( "% [ 6YG0 . Zukz" ) ; aliasGroup0 . setName ( "g } ExZ5w8" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test0 ( ) throws Throwable { AliasGroupBeanInfo aliasGroupBeanInfo0 = new AliasGroupBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = aliasGroupBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { DownloadStatusEventHandler downloadStatusEventHandler0 = new DownloadStatusEventHandler ( ( UpdateController ) null ) ; downloadStatusEventHandler0 . setDownloader ( ( ArtifactDownloader ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setDownloader ( ArtifactDownloader downloader ) { this . downloader = downloader ; }
void test1 ( ) throws Throwable { DownloadStatusEventHandler downloadStatusEventHandler0 = new DownloadStatusEventHandler ( ( UpdateController ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleDownloadStatusEvent ( DownloadStatusEvent evt ) { logDebug ( "handleDownloadStatusEvent : processing event : " + evt ) ; if ( progressMonitor ! = null & & progressMonitor . isCanceled ( ) ) { downloader . stopDownload ( ) ; return ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_STARTED ) { totalFiles = evt . getFileCountTotal ( ) ; currentFile = 0 ; handleDownloadStarted ( ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FILE_STARTED ) { setNote ( i18n . FILE_LABEL + " : " + evt . getFilename ( ) ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FILE_COMPLETED ) { setProgress ( + + currentFile ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_STOPPED ) { setProgress ( totalFiles ) ; } / / When all updates are retrieved , tell the user that the updates will be installed upon the / / next startup . if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_COMPLETED ) { controller . showMessage ( i18n . CHANGES_RECORDED_TITLE , i18n . CHANGES_RECORDED_MSG ) ; setProgress ( totalFiles ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FAILED ) { controller . showErrorMessage ( i18n . UPDATE_DOWNLOAD_FAILED_TITLE , i18n . UPDATE_DOWNLOAD_FAILED_MSG ) ; setProgress ( totalFiles ) ; } }
void test2 ( ) throws Throwable { DownloadEventType downloadEventType0 = DownloadEventType . DOWNLOAD_FILE_STARTED ; DownloadStatusEventHandler downloadStatusEventHandler0 = new DownloadStatusEventHandler ( ( UpdateController ) null ) ; DownloadStatusEvent downloadStatusEvent0 = new DownloadStatusEvent ( downloadEventType0 ) ; downloadStatusEventHandler0 . handleDownloadStatusEvent ( downloadStatusEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleDownloadStatusEvent ( DownloadStatusEvent evt ) { logDebug ( "handleDownloadStatusEvent : processing event : " + evt ) ; if ( progressMonitor ! = null & & progressMonitor . isCanceled ( ) ) { downloader . stopDownload ( ) ; return ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_STARTED ) { totalFiles = evt . getFileCountTotal ( ) ; currentFile = 0 ; handleDownloadStarted ( ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FILE_STARTED ) { setNote ( i18n . FILE_LABEL + " : " + evt . getFilename ( ) ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FILE_COMPLETED ) { setProgress ( + + currentFile ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_STOPPED ) { setProgress ( totalFiles ) ; } / / When all updates are retrieved , tell the user that the updates will be installed upon the / / next startup . if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_COMPLETED ) { controller . showMessage ( i18n . CHANGES_RECORDED_TITLE , i18n . CHANGES_RECORDED_MSG ) ; setProgress ( totalFiles ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FAILED ) { controller . showErrorMessage ( i18n . UPDATE_DOWNLOAD_FAILED_TITLE , i18n . UPDATE_DOWNLOAD_FAILED_MSG ) ; setProgress ( totalFiles ) ; } }
void test3 ( ) throws Throwable { DownloadStatusEventHandler downloadStatusEventHandler0 = new DownloadStatusEventHandler ( ( UpdateController ) null ) ; DownloadEventType downloadEventType0 = DownloadEventType . DOWNLOAD_FILE_COMPLETED ; DownloadStatusEvent downloadStatusEvent0 = new DownloadStatusEvent ( downloadEventType0 ) ; downloadStatusEventHandler0 . handleDownloadStatusEvent ( downloadStatusEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleDownloadStatusEvent ( DownloadStatusEvent evt ) { logDebug ( "handleDownloadStatusEvent : processing event : " + evt ) ; if ( progressMonitor ! = null & & progressMonitor . isCanceled ( ) ) { downloader . stopDownload ( ) ; return ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_STARTED ) { totalFiles = evt . getFileCountTotal ( ) ; currentFile = 0 ; handleDownloadStarted ( ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FILE_STARTED ) { setNote ( i18n . FILE_LABEL + " : " + evt . getFilename ( ) ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FILE_COMPLETED ) { setProgress ( + + currentFile ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_STOPPED ) { setProgress ( totalFiles ) ; } / / When all updates are retrieved , tell the user that the updates will be installed upon the / / next startup . if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_COMPLETED ) { controller . showMessage ( i18n . CHANGES_RECORDED_TITLE , i18n . CHANGES_RECORDED_MSG ) ; setProgress ( totalFiles ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FAILED ) { controller . showErrorMessage ( i18n . UPDATE_DOWNLOAD_FAILED_TITLE , i18n . UPDATE_DOWNLOAD_FAILED_MSG ) ; setProgress ( totalFiles ) ; } }
void test5 ( ) throws Throwable { DownloadStatusEventHandler downloadStatusEventHandler0 = new DownloadStatusEventHandler ( ( UpdateController ) null ) ; DownloadEventType downloadEventType0 = DownloadEventType . DOWNLOAD_STOPPED ; DownloadStatusEvent downloadStatusEvent0 = new DownloadStatusEvent ( downloadEventType0 ) ; downloadStatusEventHandler0 . handleDownloadStatusEvent ( downloadStatusEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleDownloadStatusEvent ( DownloadStatusEvent evt ) { logDebug ( "handleDownloadStatusEvent : processing event : " + evt ) ; if ( progressMonitor ! = null & & progressMonitor . isCanceled ( ) ) { downloader . stopDownload ( ) ; return ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_STARTED ) { totalFiles = evt . getFileCountTotal ( ) ; currentFile = 0 ; handleDownloadStarted ( ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FILE_STARTED ) { setNote ( i18n . FILE_LABEL + " : " + evt . getFilename ( ) ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FILE_COMPLETED ) { setProgress ( + + currentFile ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_STOPPED ) { setProgress ( totalFiles ) ; } / / When all updates are retrieved , tell the user that the updates will be installed upon the / / next startup . if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_COMPLETED ) { controller . showMessage ( i18n . CHANGES_RECORDED_TITLE , i18n . CHANGES_RECORDED_MSG ) ; setProgress ( totalFiles ) ; } if ( evt . getType ( ) = = DownloadEventType . DOWNLOAD_FAILED ) { controller . showErrorMessage ( i18n . UPDATE_DOWNLOAD_FAILED_TITLE , i18n . UPDATE_DOWNLOAD_FAILED_MSG ) ; setProgress ( totalFiles ) ; } }
void test2 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; IPluginManager iPluginManager0 = updateUtilImpl0 . getPluginManager ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginManager getPluginManager ( ) ; / * * * Return the manager responsible for windows . * * @return the manager responsible for windows . * / WindowManager getWindowManager ( ) ; ActionCollection getActionCollection ( ) ; SQLDriverManager getSQLDriverManager ( ) ; DataCache getDataCache ( ) ; SquirrelPreferences getSquirrelPreferences ( ) ; DesktopStyle getDesktopStyle ( ) ; SquirrelResources getResources ( ) ; / * * * Retrieves the message handler for the application . * * @return Application level message handler . * / IMessageHandler getMessageHandler ( ) ; / * * * Return an array of all the sessions currently active . * * @return array of all active sessions . * / / / ISession [ ] getActiveSessions ( ) ; / * * * Retrieve the object that manages sessions . * * @return < TT > SessionManager < / TT > . * / SessionManager getSessionManager ( ) ; / * * * Display an error message dialog . * * @param msg The error msg . * / void showErrorDialog ( String msg ) ; / * * * Display an error message dialog . * * @param th The Throwable that caused the error * / void showErrorDialog ( Throwable th ) ; / * * * Display an error message dialog . * * @param msg The error msg . * @param th The Throwable that caused the error * / void showErrorDialog ( String msg , Throwable th ) ; / * * * Return the main frame . * * @return The main frame for the app . * / MainFrame getMainFrame ( ) ; / * * * Return the thread pool for this app . * * @return the thread pool for this app . * / TaskThreadPool getThreadPool ( ) ; / * * * Return the collection of < TT > FontInfo < / TT > objects for this app . * * @return the collection of < TT > FontInfo < / TT > objects for this app . * / FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test6 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) updateUtilImpl0 . getInstalledSquirrelMainJarLocation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void copyDir ( FileWrapper fromDir , FileWrapper toDir ) throws FileNotFoundException , IOException ; / * * * Lists the specified fromDir and copies all of the files found in that directory to the specified toDir * directory . * * @param fromDir * the directory to copy files from * @param filePattern * the pattern against which to compare the name of the file * @param matchPattern * a boolean value indicating whether or not to match the specified file pattern . If true , then * only filenames that match the pattern are copied . If false , the only filenames that do not * match the pattern are copied . * @param toDir * the directory to copy files to * @throws FileNotFoundException * @throws IOException * / void copyDir ( FileWrapper fromDir , String filePattern , boolean matchPattern , FileWrapper toDir ) throws FileNotFoundException , IOException ; / * * * Returns an ChannelXmlBean that describes the locally installed release . * * @param localReleaseFile * the xml file to decode into an xmlbean . * @return a ChannelXmlBean * / ChannelXmlBean getLocalReleaseInfo ( String localReleaseFile ) ; / * * * Returns the top - level directory in which all installed components of SQuirreL live under . * * @return a File representing the home directory of SQuirreL * / FileWrapper getSquirrelHomeDir ( ) ; / * * * Returns the top - level directory in which all installed plugins of SQuirreL live under . * * @return a File representing the plugins directory of SQuirreL * / FileWrapper getSquirrelPluginsDir ( ) ; / * * * Returns the top - level directory in which all core libraries ( and possibly translations ) of SQuirreL live * under . * * @return a File representing the core library directory of SQuirreL * / FileWrapper getSquirrelLibraryDir ( ) ; / * * * Returns the file that represents the list of changes to make when running the prelaunch update * application * * @return a File representing the change list . * / FileWrapper getChangeListFile ( ) ; FileWrapper checkDir ( FileWrapper parent , String child ) ; void createZipFile ( FileWrapper zipFile , FileWrapper . . . sourceFiles ) throws FileNotFoundException , IOException ; / * * * Returns the update directory in which all information about available updates and the user's desired * actions are located . * * @return a File representing the update directory . * / FileWrapper getSquirrelUpdateDir ( ) ; / * * * Create and save a ChangeListXmlBean to the update directory . * * @param changes * the list of changes to be persisted * @throws FileNotFoundException * if the file to be written couldn't be found . * / void saveChangeList ( List < ArtifactStatus > changes ) throws FileNotFoundException ; / * * * Retrieves the change list ( if one exists ) from the update directory . * * @return a change list bean . * @throws FileNotFoundException * if the file couldn't be found . * / ChangeListXmlBean getChangeList ( ) throws FileNotFoundException ; / * * * Returns the absolute path to the release xml file that describes what release the user currently has . * * @return the absolute path to the release xml file * @throws FileNotFoundException * if the release xml file couldn't be found . * / FileWrapper getLocalReleaseFile ( ) throws FileNotFoundException ; / * * * Builds a list of ArtifactStatus objects from the specified ChannelXmlBean * * @param channelXmlBean * the bean that represents the channel that the user is pulling updates from . * @return a list of ArtifactStatus objects that describe all of the available artifacts from the specified * channel . * / List < ArtifactStatus > getArtifactStatus ( ChannelXmlBean channelXmlBean ) ; List < ArtifactStatus > getArtifactStatus ( ReleaseXmlBean releaseXmlBean ) ; / * * * Returns a set of plugin archive filenames - one for each installed plugin . * / Set < String > getInstalledPlugins ( ) ; / * * * Returns a set of translation filenames - one jar for each translation . * * @return * / Set < String > getInstalledTranslations ( ) ; / * * * @return the _pluginManager * / IPluginManager getPluginManager ( ) ; / * * * @param manager * the _pluginManager to set * / void setPluginManager ( IPluginManager manager ) ; / * * * Returns the top - level directory that contains artifact type sub - folders into which downloaded files are * copied . * * @return a File representing the root directory of the download tree . * / FileWrapper getDownloadsDir ( ) ; FileWrapper getCoreDownloadsDir ( ) ; FileWrapper getPluginDownloadsDir ( ) ; FileWrapper getI18nDownloadsDir ( ) ; FileWrapper getBackupDir ( ) ; FileWrapper getCoreBackupDir ( ) ; FileWrapper getPluginBackupDir ( ) ; FileWrapper getI18nBackupDir ( ) ; / * * * Returns the absolute path to the location of the squirrel - sql . jar file . * * @return a File representing the current installed squirrel - sql . jar file . * / FileWrapper getInstalledSquirrelMainJarLocation ( ) ; ChangeListXmlBean getChangeList ( FileWrapper changeListFile ) throws FileNotFoundException ; FileWrapper getFile ( FileWrapper installDir , String artifactName ) ; / * * * This function will recursivly delete directories and files . * * @param path * File or Directory to be deleted * @return true indicates success . * / boolean deleteFile ( FileWrapper path ) ; / * * * Extracts the specified zip file to the specified output directory . * * @param zipFile * the compressed archive file to extract * @param outputDirectory * the directory into which to extract * @throws IOException * if an error occurs * / void extractZipFile ( FileWrapper zipFile , FileWrapper outputDirectory ) throws IOException ; / * * * Returns the absolute path to the file in the downloads section for the specified ArtifactStatus * * @param status * the ArtifactStatus that describes the type and name of this artifact . * @return a File object representing the location of the artifact in the downloads directory . * / FileWrapper getDownloadFileLocation ( ArtifactStatus status ) ; boolean isPresentInDownloadsDirectory ( ArtifactStatus status ) ; / * * * Get the checksum for the specified file . This has a side effect in that it caches the checksum for * speedier lookup on subsequent calls . * * @param f * the file to get the checksum for * @return the checksum as a long . If an error occurs , this method will return - 1 * / long getCheckSum ( FileWrapper f ) ; / * * * Returns an Enum value representing the users preference for how often to automatically check for * updates . * * @param settings * the settings to look in . * @return the Enum value * / UpdateCheckFrequency getUpdateCheckFrequency ( IUpdateSettings settings ) ; }
void test11 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) updateUtilImpl0 . getSquirrelHomeDir ( ) ; updateUtilImpl0 . copyDir ( ( FileWrapper ) fileWrapperImpl0 , ( FileWrapper ) fileWrapperImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCanonicalPath ( ) throws IOException { return _wrappedFile . getCanonicalPath ( ) ; }
void test22 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; ChannelXmlBean channelXmlBean0 = updateUtilImpl0 . loadUpdateFromFileSystem ( "lib" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ChannelXmlBean loadUpdateFromFileSystem ( String path ) ; / * * * Downloads the specified file from the specified server and stores it by the same name in the specified * destination directory . * * @param host * the name of the server * @param port * the port on the server * @param fileToGet * the name of the file to download * @param fileSize * the size of the file in bytes * @param checksum * the checksum of the file * @param proxySettings * information about the web - proxy to use if any * @return a string representing the full local path to where the file was downloaded to * @throws Exception * / String downloadHttpUpdateFile ( String host , int port , String fileToGet , String destDir , long fileSize , long checksum , IProxySettings proxySettings ) throws Exception ; / * * * Downloads the a file from a local directory into our update downloads directory . * * @param fileToGet * the file to retreive . * @param destDir * the destination directory into which to place the file . * @return true if the download succeeded ; false otherwise . * / boolean downloadLocalUpdateFile ( String fileToGet , String destDir ) throws FileNotFoundException , IOException ; / * * * Copies the specified from file to the specified to file . If "to" is a directory , then this will copy * "from" into that directory and the resulting file will have the same name . * * @param from * the file to copy from * @param to * the file to copy to * / void copyFile ( FileWrapper from , FileWrapper to ) throws FileNotFoundException , IOException ; / * * * Lists the specified fromDir and moves all of the files found in that directory that match the specified * filePattern to the specified toDir * directory . * * @param fromDir * the directory to copy files from * @param toDir * the directory to copy files to * @throws FileNotFoundException * @throws IOException * / void moveFiles ( FileWrapper fromDir , String filePattern , boolean matchPattern , FileWrapper toDir ) throws FileNotFoundException , IOException ; / * * * Lists the specified fromDir and copies all of the files found in that directory to the specified toDir * directory . * * @param fromDir * the directory to copy files from * @param toDir * the directory to copy files to * @throws FileNotFoundException * @throws IOException * / void copyDir ( FileWrapper fromDir , FileWrapper toDir ) throws FileNotFoundException , IOException ; / * * * Lists the specified fromDir and copies all of the files found in that directory to the specified toDir * directory . * * @param fromDir * the directory to copy files from * @param filePattern * the pattern against which to compare the name of the file * @param matchPattern * a boolean value indicating whether or not to match the specified file pattern . If true , then * only filenames that match the pattern are copied . If false , the only filenames that do not * match the pattern are copied . * @param toDir * the directory to copy files to * @throws FileNotFoundException * @throws IOException * / void copyDir ( FileWrapper fromDir , String filePattern , boolean matchPattern , FileWrapper toDir ) throws FileNotFoundException , IOException ; / * * * Returns an ChannelXmlBean that describes the locally installed release . * * @param localReleaseFile * the xml file to decode into an xmlbean . * @return a ChannelXmlBean * / ChannelXmlBean getLocalReleaseInfo ( String localReleaseFile ) ; / * * * Returns the top - level directory in which all installed components of SQuirreL live under . * * @return a File representing the home directory of SQuirreL * / FileWrapper getSquirrelHomeDir ( ) ; / * * * Returns the top - level directory in which all installed plugins of SQuirreL live under . * * @return a File representing the plugins directory of SQuirreL * / FileWrapper getSquirrelPluginsDir ( ) ; / * * * Returns the top - level directory in which all core libraries ( and possibly translations ) of SQuirreL live * under . * * @return a File representing the core library directory of SQuirreL * / FileWrapper getSquirrelLibraryDir ( ) ; / * * * Returns the file that represents the list of changes to make when running the prelaunch update * application * * @return a File representing the change list . * / FileWrapper getChangeListFile ( ) ; FileWrapper checkDir ( FileWrapper parent , String child ) ; void createZipFile ( FileWrapper zipFile , FileWrapper . . . sourceFiles ) throws FileNotFoundException , IOException ; / * * * Returns the update directory in which all information about available updates and the user's desired * actions are located . * * @return a File representing the update directory . * / FileWrapper getSquirrelUpdateDir ( ) ; / * * * Create and save a ChangeListXmlBean to the update directory . * * @param changes * the list of changes to be persisted * @throws FileNotFoundException * if the file to be written couldn't be found . * / void saveChangeList ( List < ArtifactStatus > changes ) throws FileNotFoundException ; / * * * Retrieves the change list ( if one exists ) from the update directory . * * @return a change list bean . * @throws FileNotFoundException * if the file couldn't be found . * / ChangeListXmlBean getChangeList ( ) throws FileNotFoundException ; / * * * Returns the absolute path to the release xml file that describes what release the user currently has . * * @return the absolute path to the release xml file * @throws FileNotFoundException * if the release xml file couldn't be found . * / FileWrapper getLocalReleaseFile ( ) throws FileNotFoundException ; / * * * Builds a list of ArtifactStatus objects from the specified ChannelXmlBean * * @param channelXmlBean * the bean that represents the channel that the user is pulling updates from . * @return a list of ArtifactStatus objects that describe all of the available artifacts from the specified * channel . * / List < ArtifactStatus > getArtifactStatus ( ChannelXmlBean channelXmlBean ) ; List < ArtifactStatus > getArtifactStatus ( ReleaseXmlBean releaseXmlBean ) ; / * * * Returns a set of plugin archive filenames - one for each installed plugin . * / Set < String > getInstalledPlugins ( ) ; / * * * Returns a set of translation filenames - one jar for each translation . * * @return * / Set < String > getInstalledTranslations ( ) ; / * * * @return the _pluginManager * / IPluginManager getPluginManager ( ) ; / * * * @param manager * the _pluginManager to set * / void setPluginManager ( IPluginManager manager ) ; / * * * Returns the top - level directory that contains artifact type sub - folders into which downloaded files are * copied . * * @return a File representing the root directory of the download tree . * / FileWrapper getDownloadsDir ( ) ; FileWrapper getCoreDownloadsDir ( ) ; FileWrapper getPluginDownloadsDir ( ) ; FileWrapper getI18nDownloadsDir ( ) ; FileWrapper getBackupDir ( ) ; FileWrapper getCoreBackupDir ( ) ; FileWrapper getPluginBackupDir ( ) ; FileWrapper getI18nBackupDir ( ) ; / * * * Returns the absolute path to the location of the squirrel - sql . jar file . * * @return a File representing the current installed squirrel - sql . jar file . * / FileWrapper getInstalledSquirrelMainJarLocation ( ) ; ChangeListXmlBean getChangeList ( FileWrapper changeListFile ) throws FileNotFoundException ; FileWrapper getFile ( FileWrapper installDir , String artifactName ) ; / * * * This function will recursivly delete directories and files . * * @param path * File or Directory to be deleted * @return true indicates success . * / boolean deleteFile ( FileWrapper path ) ; / * * * Extracts the specified zip file to the specified output directory . * * @param zipFile * the compressed archive file to extract * @param outputDirectory * the directory into which to extract * @throws IOException * if an error occurs * / void extractZipFile ( FileWrapper zipFile , FileWrapper outputDirectory ) throws IOException ; / * * * Returns the absolute path to the file in the downloads section for the specified ArtifactStatus * * @param status * the ArtifactStatus that describes the type and name of this artifact . * @return a File object representing the location of the artifact in the downloads directory . * / FileWrapper getDownloadFileLocation ( ArtifactStatus status ) ; boolean isPresentInDownloadsDirectory ( ArtifactStatus status ) ; / * * * Get the checksum for the specified file . This has a side effect in that it caches the checksum for * speedier lookup on subsequent calls . * * @param f * the file to get the checksum for * @return the checksum as a long . If an error occurs , this method will return - 1 * / long getCheckSum ( FileWrapper f ) ; / * * * Returns an Enum value representing the users preference for how often to automatically check for * updates . * * @param settings * the settings to look in . * @return the Enum value * / UpdateCheckFrequency getUpdateCheckFrequency ( IUpdateSettings settings ) ; }
void test23 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; ChannelXmlBean channelXmlBean0 = updateUtilImpl0 . loadUpdateFromFileSystem ( "v~K6 / Bo" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ChannelXmlBean loadUpdateFromFileSystem ( String path ) ; / * * * Downloads the specified file from the specified server and stores it by the same name in the specified * destination directory . * * @param host * the name of the server * @param port * the port on the server * @param fileToGet * the name of the file to download * @param fileSize * the size of the file in bytes * @param checksum * the checksum of the file * @param proxySettings * information about the web - proxy to use if any * @return a string representing the full local path to where the file was downloaded to * @throws Exception * / String downloadHttpUpdateFile ( String host , int port , String fileToGet , String destDir , long fileSize , long checksum , IProxySettings proxySettings ) throws Exception ; / * * * Downloads the a file from a local directory into our update downloads directory . * * @param fileToGet * the file to retreive . * @param destDir * the destination directory into which to place the file . * @return true if the download succeeded ; false otherwise . * / boolean downloadLocalUpdateFile ( String fileToGet , String destDir ) throws FileNotFoundException , IOException ; / * * * Copies the specified from file to the specified to file . If "to" is a directory , then this will copy * "from" into that directory and the resulting file will have the same name . * * @param from * the file to copy from * @param to * the file to copy to * / void copyFile ( FileWrapper from , FileWrapper to ) throws FileNotFoundException , IOException ; / * * * Lists the specified fromDir and moves all of the files found in that directory that match the specified * filePattern to the specified toDir * directory . * * @param fromDir * the directory to copy files from * @param toDir * the directory to copy files to * @throws FileNotFoundException * @throws IOException * / void moveFiles ( FileWrapper fromDir , String filePattern , boolean matchPattern , FileWrapper toDir ) throws FileNotFoundException , IOException ; / * * * Lists the specified fromDir and copies all of the files found in that directory to the specified toDir * directory . * * @param fromDir * the directory to copy files from * @param toDir * the directory to copy files to * @throws FileNotFoundException * @throws IOException * / void copyDir ( FileWrapper fromDir , FileWrapper toDir ) throws FileNotFoundException , IOException ; / * * * Lists the specified fromDir and copies all of the files found in that directory to the specified toDir * directory . * * @param fromDir * the directory to copy files from * @param filePattern * the pattern against which to compare the name of the file * @param matchPattern * a boolean value indicating whether or not to match the specified file pattern . If true , then * only filenames that match the pattern are copied . If false , the only filenames that do not * match the pattern are copied . * @param toDir * the directory to copy files to * @throws FileNotFoundException * @throws IOException * / void copyDir ( FileWrapper fromDir , String filePattern , boolean matchPattern , FileWrapper toDir ) throws FileNotFoundException , IOException ; / * * * Returns an ChannelXmlBean that describes the locally installed release . * * @param localReleaseFile * the xml file to decode into an xmlbean . * @return a ChannelXmlBean * / ChannelXmlBean getLocalReleaseInfo ( String localReleaseFile ) ; / * * * Returns the top - level directory in which all installed components of SQuirreL live under . * * @return a File representing the home directory of SQuirreL * / FileWrapper getSquirrelHomeDir ( ) ; / * * * Returns the top - level directory in which all installed plugins of SQuirreL live under . * * @return a File representing the plugins directory of SQuirreL * / FileWrapper getSquirrelPluginsDir ( ) ; / * * * Returns the top - level directory in which all core libraries ( and possibly translations ) of SQuirreL live * under . * * @return a File representing the core library directory of SQuirreL * / FileWrapper getSquirrelLibraryDir ( ) ; / * * * Returns the file that represents the list of changes to make when running the prelaunch update * application * * @return a File representing the change list . * / FileWrapper getChangeListFile ( ) ; FileWrapper checkDir ( FileWrapper parent , String child ) ; void createZipFile ( FileWrapper zipFile , FileWrapper . . . sourceFiles ) throws FileNotFoundException , IOException ; / * * * Returns the update directory in which all information about available updates and the user's desired * actions are located . * * @return a File representing the update directory . * / FileWrapper getSquirrelUpdateDir ( ) ; / * * * Create and save a ChangeListXmlBean to the update directory . * * @param changes * the list of changes to be persisted * @throws FileNotFoundException * if the file to be written couldn't be found . * / void saveChangeList ( List < ArtifactStatus > changes ) throws FileNotFoundException ; / * * * Retrieves the change list ( if one exists ) from the update directory . * * @return a change list bean . * @throws FileNotFoundException * if the file couldn't be found . * / ChangeListXmlBean getChangeList ( ) throws FileNotFoundException ; / * * * Returns the absolute path to the release xml file that describes what release the user currently has . * * @return the absolute path to the release xml file * @throws FileNotFoundException * if the release xml file couldn't be found . * / FileWrapper getLocalReleaseFile ( ) throws FileNotFoundException ; / * * * Builds a list of ArtifactStatus objects from the specified ChannelXmlBean * * @param channelXmlBean * the bean that represents the channel that the user is pulling updates from . * @return a list of ArtifactStatus objects that describe all of the available artifacts from the specified * channel . * / List < ArtifactStatus > getArtifactStatus ( ChannelXmlBean channelXmlBean ) ; List < ArtifactStatus > getArtifactStatus ( ReleaseXmlBean releaseXmlBean ) ; / * * * Returns a set of plugin archive filenames - one for each installed plugin . * / Set < String > getInstalledPlugins ( ) ; / * * * Returns a set of translation filenames - one jar for each translation . * * @return * / Set < String > getInstalledTranslations ( ) ; / * * * @return the _pluginManager * / IPluginManager getPluginManager ( ) ; / * * * @param manager * the _pluginManager to set * / void setPluginManager ( IPluginManager manager ) ; / * * * Returns the top - level directory that contains artifact type sub - folders into which downloaded files are * copied . * * @return a File representing the root directory of the download tree . * / FileWrapper getDownloadsDir ( ) ; FileWrapper getCoreDownloadsDir ( ) ; FileWrapper getPluginDownloadsDir ( ) ; FileWrapper getI18nDownloadsDir ( ) ; FileWrapper getBackupDir ( ) ; FileWrapper getCoreBackupDir ( ) ; FileWrapper getPluginBackupDir ( ) ; FileWrapper getI18nBackupDir ( ) ; / * * * Returns the absolute path to the location of the squirrel - sql . jar file . * * @return a File representing the current installed squirrel - sql . jar file . * / FileWrapper getInstalledSquirrelMainJarLocation ( ) ; ChangeListXmlBean getChangeList ( FileWrapper changeListFile ) throws FileNotFoundException ; FileWrapper getFile ( FileWrapper installDir , String artifactName ) ; / * * * This function will recursivly delete directories and files . * * @param path * File or Directory to be deleted * @return true indicates success . * / boolean deleteFile ( FileWrapper path ) ; / * * * Extracts the specified zip file to the specified output directory . * * @param zipFile * the compressed archive file to extract * @param outputDirectory * the directory into which to extract * @throws IOException * if an error occurs * / void extractZipFile ( FileWrapper zipFile , FileWrapper outputDirectory ) throws IOException ; / * * * Returns the absolute path to the file in the downloads section for the specified ArtifactStatus * * @param status * the ArtifactStatus that describes the type and name of this artifact . * @return a File object representing the location of the artifact in the downloads directory . * / FileWrapper getDownloadFileLocation ( ArtifactStatus status ) ; boolean isPresentInDownloadsDirectory ( ArtifactStatus status ) ; / * * * Get the checksum for the specified file . This has a side effect in that it caches the checksum for * speedier lookup on subsequent calls . * * @param f * the file to get the checksum for * @return the checksum as a long . If an error occurs , this method will return - 1 * / long getCheckSum ( FileWrapper f ) ; / * * * Returns an Enum value representing the users preference for how often to automatically check for * updates . * * @param settings * the settings to look in . * @return the Enum value * / UpdateCheckFrequency getUpdateCheckFrequency ( IUpdateSettings settings ) ; }
void test24 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; boolean boolean0 = updateUtilImpl0 . downloadLocalUpdateFile ( "O6ZxwIsqWXMZ" , "O6ZxwIsqWXMZ" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean downloadLocalUpdateFile ( String fileToGet , String destDir ) throws FileNotFoundException , IOException ; / * * * Copies the specified from file to the specified to file . If "to" is a directory , then this will copy * "from" into that directory and the resulting file will have the same name . * * @param from * the file to copy from * @param to * the file to copy to * / void copyFile ( FileWrapper from , FileWrapper to ) throws FileNotFoundException , IOException ; / * * * Lists the specified fromDir and moves all of the files found in that directory that match the specified * filePattern to the specified toDir * directory . * * @param fromDir * the directory to copy files from * @param toDir * the directory to copy files to * @throws FileNotFoundException * @throws IOException * / void moveFiles ( FileWrapper fromDir , String filePattern , boolean matchPattern , FileWrapper toDir ) throws FileNotFoundException , IOException ; / * * * Lists the specified fromDir and copies all of the files found in that directory to the specified toDir * directory . * * @param fromDir * the directory to copy files from * @param toDir * the directory to copy files to * @throws FileNotFoundException * @throws IOException * / void copyDir ( FileWrapper fromDir , FileWrapper toDir ) throws FileNotFoundException , IOException ; / * * * Lists the specified fromDir and copies all of the files found in that directory to the specified toDir * directory . * * @param fromDir * the directory to copy files from * @param filePattern * the pattern against which to compare the name of the file * @param matchPattern * a boolean value indicating whether or not to match the specified file pattern . If true , then * only filenames that match the pattern are copied . If false , the only filenames that do not * match the pattern are copied . * @param toDir * the directory to copy files to * @throws FileNotFoundException * @throws IOException * / void copyDir ( FileWrapper fromDir , String filePattern , boolean matchPattern , FileWrapper toDir ) throws FileNotFoundException , IOException ; / * * * Returns an ChannelXmlBean that describes the locally installed release . * * @param localReleaseFile * the xml file to decode into an xmlbean . * @return a ChannelXmlBean * / ChannelXmlBean getLocalReleaseInfo ( String localReleaseFile ) ; / * * * Returns the top - level directory in which all installed components of SQuirreL live under . * * @return a File representing the home directory of SQuirreL * / FileWrapper getSquirrelHomeDir ( ) ; / * * * Returns the top - level directory in which all installed plugins of SQuirreL live under . * * @return a File representing the plugins directory of SQuirreL * / FileWrapper getSquirrelPluginsDir ( ) ; / * * * Returns the top - level directory in which all core libraries ( and possibly translations ) of SQuirreL live * under . * * @return a File representing the core library directory of SQuirreL * / FileWrapper getSquirrelLibraryDir ( ) ; / * * * Returns the file that represents the list of changes to make when running the prelaunch update * application * * @return a File representing the change list . * / FileWrapper getChangeListFile ( ) ; FileWrapper checkDir ( FileWrapper parent , String child ) ; void createZipFile ( FileWrapper zipFile , FileWrapper . . . sourceFiles ) throws FileNotFoundException , IOException ; / * * * Returns the update directory in which all information about available updates and the user's desired * actions are located . * * @return a File representing the update directory . * / FileWrapper getSquirrelUpdateDir ( ) ; / * * * Create and save a ChangeListXmlBean to the update directory . * * @param changes * the list of changes to be persisted * @throws FileNotFoundException * if the file to be written couldn't be found . * / void saveChangeList ( List < ArtifactStatus > changes ) throws FileNotFoundException ; / * * * Retrieves the change list ( if one exists ) from the update directory . * * @return a change list bean . * @throws FileNotFoundException * if the file couldn't be found . * / ChangeListXmlBean getChangeList ( ) throws FileNotFoundException ; / * * * Returns the absolute path to the release xml file that describes what release the user currently has . * * @return the absolute path to the release xml file * @throws FileNotFoundException * if the release xml file couldn't be found . * / FileWrapper getLocalReleaseFile ( ) throws FileNotFoundException ; / * * * Builds a list of ArtifactStatus objects from the specified ChannelXmlBean * * @param channelXmlBean * the bean that represents the channel that the user is pulling updates from . * @return a list of ArtifactStatus objects that describe all of the available artifacts from the specified * channel . * / List < ArtifactStatus > getArtifactStatus ( ChannelXmlBean channelXmlBean ) ; List < ArtifactStatus > getArtifactStatus ( ReleaseXmlBean releaseXmlBean ) ; / * * * Returns a set of plugin archive filenames - one for each installed plugin . * / Set < String > getInstalledPlugins ( ) ; / * * * Returns a set of translation filenames - one jar for each translation . * * @return * / Set < String > getInstalledTranslations ( ) ; / * * * @return the _pluginManager * / IPluginManager getPluginManager ( ) ; / * * * @param manager * the _pluginManager to set * / void setPluginManager ( IPluginManager manager ) ; / * * * Returns the top - level directory that contains artifact type sub - folders into which downloaded files are * copied . * * @return a File representing the root directory of the download tree . * / FileWrapper getDownloadsDir ( ) ; FileWrapper getCoreDownloadsDir ( ) ; FileWrapper getPluginDownloadsDir ( ) ; FileWrapper getI18nDownloadsDir ( ) ; FileWrapper getBackupDir ( ) ; FileWrapper getCoreBackupDir ( ) ; FileWrapper getPluginBackupDir ( ) ; FileWrapper getI18nBackupDir ( ) ; / * * * Returns the absolute path to the location of the squirrel - sql . jar file . * * @return a File representing the current installed squirrel - sql . jar file . * / FileWrapper getInstalledSquirrelMainJarLocation ( ) ; ChangeListXmlBean getChangeList ( FileWrapper changeListFile ) throws FileNotFoundException ; FileWrapper getFile ( FileWrapper installDir , String artifactName ) ; / * * * This function will recursivly delete directories and files . * * @param path * File or Directory to be deleted * @return true indicates success . * / boolean deleteFile ( FileWrapper path ) ; / * * * Extracts the specified zip file to the specified output directory . * * @param zipFile * the compressed archive file to extract * @param outputDirectory * the directory into which to extract * @throws IOException * if an error occurs * / void extractZipFile ( FileWrapper zipFile , FileWrapper outputDirectory ) throws IOException ; / * * * Returns the absolute path to the file in the downloads section for the specified ArtifactStatus * * @param status * the ArtifactStatus that describes the type and name of this artifact . * @return a File object representing the location of the artifact in the downloads directory . * / FileWrapper getDownloadFileLocation ( ArtifactStatus status ) ; boolean isPresentInDownloadsDirectory ( ArtifactStatus status ) ; / * * * Get the checksum for the specified file . This has a side effect in that it caches the checksum for * speedier lookup on subsequent calls . * * @param f * the file to get the checksum for * @return the checksum as a long . If an error occurs , this method will return - 1 * / long getCheckSum ( FileWrapper f ) ; / * * * Returns an Enum value representing the users preference for how often to automatically check for * updates . * * @param settings * the settings to look in . * @return the Enum value * / UpdateCheckFrequency getUpdateCheckFrequency ( IUpdateSettings settings ) ; }
void test26 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "pR@kXf@#n$w2X" ) ; updateUtilImpl0 . copyFile ( ( FileWrapper ) fileWrapperImpl0 , ( FileWrapper ) fileWrapperImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long length ( ) { return _wrappedFile . length ( ) ; }
void test28 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getLibraryDirectory ( ) ; updateUtilImpl0 . moveFiles ( ( FileWrapper ) fileWrapperImpl0 , "joss - commo - " , true , ( FileWrapper ) fileWrapperImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAbsolutePath ( ) { return _wrappedFile . getAbsolutePath ( ) ; }
void test31 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; ChannelXmlBean channelXmlBean0 = updateUtilImpl0 . getLocalReleaseInfo ( "O6ZxwIsqWXMZ" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ChannelXmlBean getLocalReleaseInfo ( String localReleaseFile ) ; / * * * Returns the top - level directory in which all installed components of SQuirreL live under . * * @return a File representing the home directory of SQuirreL * / FileWrapper getSquirrelHomeDir ( ) ; / * * * Returns the top - level directory in which all installed plugins of SQuirreL live under . * * @return a File representing the plugins directory of SQuirreL * / FileWrapper getSquirrelPluginsDir ( ) ; / * * * Returns the top - level directory in which all core libraries ( and possibly translations ) of SQuirreL live * under . * * @return a File representing the core library directory of SQuirreL * / FileWrapper getSquirrelLibraryDir ( ) ; / * * * Returns the file that represents the list of changes to make when running the prelaunch update * application * * @return a File representing the change list . * / FileWrapper getChangeListFile ( ) ; FileWrapper checkDir ( FileWrapper parent , String child ) ; void createZipFile ( FileWrapper zipFile , FileWrapper . . . sourceFiles ) throws FileNotFoundException , IOException ; / * * * Returns the update directory in which all information about available updates and the user's desired * actions are located . * * @return a File representing the update directory . * / FileWrapper getSquirrelUpdateDir ( ) ; / * * * Create and save a ChangeListXmlBean to the update directory . * * @param changes * the list of changes to be persisted * @throws FileNotFoundException * if the file to be written couldn't be found . * / void saveChangeList ( List < ArtifactStatus > changes ) throws FileNotFoundException ; / * * * Retrieves the change list ( if one exists ) from the update directory . * * @return a change list bean . * @throws FileNotFoundException * if the file couldn't be found . * / ChangeListXmlBean getChangeList ( ) throws FileNotFoundException ; / * * * Returns the absolute path to the release xml file that describes what release the user currently has . * * @return the absolute path to the release xml file * @throws FileNotFoundException * if the release xml file couldn't be found . * / FileWrapper getLocalReleaseFile ( ) throws FileNotFoundException ; / * * * Builds a list of ArtifactStatus objects from the specified ChannelXmlBean * * @param channelXmlBean * the bean that represents the channel that the user is pulling updates from . * @return a list of ArtifactStatus objects that describe all of the available artifacts from the specified * channel . * / List < ArtifactStatus > getArtifactStatus ( ChannelXmlBean channelXmlBean ) ; List < ArtifactStatus > getArtifactStatus ( ReleaseXmlBean releaseXmlBean ) ; / * * * Returns a set of plugin archive filenames - one for each installed plugin . * / Set < String > getInstalledPlugins ( ) ; / * * * Returns a set of translation filenames - one jar for each translation . * * @return * / Set < String > getInstalledTranslations ( ) ; / * * * @return the _pluginManager * / IPluginManager getPluginManager ( ) ; / * * * @param manager * the _pluginManager to set * / void setPluginManager ( IPluginManager manager ) ; / * * * Returns the top - level directory that contains artifact type sub - folders into which downloaded files are * copied . * * @return a File representing the root directory of the download tree . * / FileWrapper getDownloadsDir ( ) ; FileWrapper getCoreDownloadsDir ( ) ; FileWrapper getPluginDownloadsDir ( ) ; FileWrapper getI18nDownloadsDir ( ) ; FileWrapper getBackupDir ( ) ; FileWrapper getCoreBackupDir ( ) ; FileWrapper getPluginBackupDir ( ) ; FileWrapper getI18nBackupDir ( ) ; / * * * Returns the absolute path to the location of the squirrel - sql . jar file . * * @return a File representing the current installed squirrel - sql . jar file . * / FileWrapper getInstalledSquirrelMainJarLocation ( ) ; ChangeListXmlBean getChangeList ( FileWrapper changeListFile ) throws FileNotFoundException ; FileWrapper getFile ( FileWrapper installDir , String artifactName ) ; / * * * This function will recursivly delete directories and files . * * @param path * File or Directory to be deleted * @return true indicates success . * / boolean deleteFile ( FileWrapper path ) ; / * * * Extracts the specified zip file to the specified output directory . * * @param zipFile * the compressed archive file to extract * @param outputDirectory * the directory into which to extract * @throws IOException * if an error occurs * / void extractZipFile ( FileWrapper zipFile , FileWrapper outputDirectory ) throws IOException ; / * * * Returns the absolute path to the file in the downloads section for the specified ArtifactStatus * * @param status * the ArtifactStatus that describes the type and name of this artifact . * @return a File object representing the location of the artifact in the downloads directory . * / FileWrapper getDownloadFileLocation ( ArtifactStatus status ) ; boolean isPresentInDownloadsDirectory ( ArtifactStatus status ) ; / * * * Get the checksum for the specified file . This has a side effect in that it caches the checksum for * speedier lookup on subsequent calls . * * @param f * the file to get the checksum for * @return the checksum as a long . If an error occurs , this method will return - 1 * / long getCheckSum ( FileWrapper f ) ; / * * * Returns an Enum value representing the users preference for how often to automatically check for * updates . * * @param settings * the settings to look in . * @return the Enum value * / UpdateCheckFrequency getUpdateCheckFrequency ( IUpdateSettings settings ) ; }
void test32 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; Set < String > set0 = updateUtilImpl0 . getInstalledTranslations ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test34 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) updateUtilImpl0 . checkDir ( ( FileWrapper ) null , "hs_err_pid4545 . log" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long lastModified ( ) { return _wrappedFile . lastModified ( ) ; }
void test36 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) updateUtilImpl0 . getSquirrelPluginsDir ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean deleteFile ( FileWrapper path ) ; / * * * Extracts the specified zip file to the specified output directory . * * @param zipFile * the compressed archive file to extract * @param outputDirectory * the directory into which to extract * @throws IOException * if an error occurs * / void extractZipFile ( FileWrapper zipFile , FileWrapper outputDirectory ) throws IOException ; / * * * Returns the absolute path to the file in the downloads section for the specified ArtifactStatus * * @param status * the ArtifactStatus that describes the type and name of this artifact . * @return a File object representing the location of the artifact in the downloads directory . * / FileWrapper getDownloadFileLocation ( ArtifactStatus status ) ; boolean isPresentInDownloadsDirectory ( ArtifactStatus status ) ; / * * * Get the checksum for the specified file . This has a side effect in that it caches the checksum for * speedier lookup on subsequent calls . * * @param f * the file to get the checksum for * @return the checksum as a long . If an error occurs , this method will return - 1 * / long getCheckSum ( FileWrapper f ) ; / * * * Returns an Enum value representing the users preference for how often to automatically check for * updates . * * @param settings * the settings to look in . * @return the Enum value * / UpdateCheckFrequency getUpdateCheckFrequency ( IUpdateSettings settings ) ; }
void test40 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getPluginsDirectory ( ) ; updateUtilImpl0 . extractZipFile ( ( FileWrapper ) fileWrapperImpl0 , ( FileWrapper ) fileWrapperImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDirectory ( ) { return _wrappedFile . isDirectory ( ) ; }
void test42 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; FileWrapper fileWrapper0 = updateUtilImpl0 . getDownloadFileLocation ( artifactStatus0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FileWrapper getDownloadFileLocation ( ArtifactStatus status ) ; boolean isPresentInDownloadsDirectory ( ArtifactStatus status ) ; / * * * Get the checksum for the specified file . This has a side effect in that it caches the checksum for * speedier lookup on subsequent calls . * * @param f * the file to get the checksum for * @return the checksum as a long . If an error occurs , this method will return - 1 * / long getCheckSum ( FileWrapper f ) ; / * * * Returns an Enum value representing the users preference for how often to automatically check for * updates . * * @param settings * the settings to look in . * @return the Enum value * / UpdateCheckFrequency getUpdateCheckFrequency ( IUpdateSettings settings ) ; }
void test43 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; UpdateSettings updateSettings0 = new UpdateSettings ( ) ; updateSettings0 . setUpdateCheckFrequency ( "HTTP / " ) ; UpdateCheckFrequency updateCheckFrequency0 = updateUtilImpl0 . getUpdateCheckFrequency ( ( IUpdateSettings ) updateSettings0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpdateCheckFrequency ( ) { return updateCheckFrequency ; }
void test44 ( ) throws Throwable { UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; UpdateSettings updateSettings0 = new UpdateSettings ( ) ; UpdateCheckFrequency updateCheckFrequency0 = updateUtilImpl0 . getUpdateCheckFrequency ( ( IUpdateSettings ) updateSettings0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUpdateCheckFrequency ( ) { return updateCheckFrequency ; }
void test0 ( ) throws Throwable { UpdateCheckFrequency updateCheckFrequency0 = UpdateCheckFrequency . WEEKLY ; boolean boolean0 = updateCheckFrequency0 . isTimeForUpdateCheck ( 0L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTimeForUpdateCheck ( long delta ) { if ( this = = DAILY & & delta > DAY_DURATION ) { return true ; } if ( this = = WEEKLY & & delta > WEEK_DURATION ) { return true ; } return false ; }
void test1 ( ) throws Throwable { UpdateCheckFrequency updateCheckFrequency0 = UpdateCheckFrequency . DAILY ; boolean boolean0 = updateCheckFrequency0 . isTimeForUpdateCheck ( ( - 328L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTimeForUpdateCheck ( long delta ) { if ( this = = DAILY & & delta > DAY_DURATION ) { return true ; } if ( this = = WEEKLY & & delta > WEEK_DURATION ) { return true ; } return false ; }
void test2 ( ) throws Throwable { UpdateCheckFrequency updateCheckFrequency0 = UpdateCheckFrequency . DAILY ; boolean boolean0 = updateCheckFrequency0 . isTimeForUpdateCheck ( 86400000L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTimeForUpdateCheck ( long delta ) { if ( this = = DAILY & & delta > DAY_DURATION ) { return true ; } if ( this = = WEEKLY & & delta > WEEK_DURATION ) { return true ; } return false ; }
void test4 ( ) throws Throwable { UpdateCheckFrequency updateCheckFrequency0 = UpdateCheckFrequency . getEnumForString ( "DAILY" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" UpdateCheckFrequency getEnumForString ( String value ) { if ( "daily" . equalsIgnoreCase ( value ) ) { return UpdateCheckFrequency . DAILY ; } if ( "startup" . equalsIgnoreCase ( value ) ) { return UpdateCheckFrequency . STARTUP ; } if ( "weekly" . equalsIgnoreCase ( value ) ) { return UpdateCheckFrequency . WEEKLY ; } throw new IllegalArgumentException ( "Uknown update check frequency : " + value ) ; }
void test5 ( ) throws Throwable { UpdateCheckFrequency updateCheckFrequency0 = UpdateCheckFrequency . getEnumForString ( "STARTUP" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" UpdateCheckFrequency getEnumForString ( String value ) { if ( "daily" . equalsIgnoreCase ( value ) ) { return UpdateCheckFrequency . DAILY ; } if ( "startup" . equalsIgnoreCase ( value ) ) { return UpdateCheckFrequency . STARTUP ; } if ( "weekly" . equalsIgnoreCase ( value ) ) { return UpdateCheckFrequency . WEEKLY ; } throw new IllegalArgumentException ( "Uknown update check frequency : " + value ) ; }
void test6 ( ) throws Throwable { UpdateCheckFrequency updateCheckFrequency0 = UpdateCheckFrequency . getEnumForString ( "weekly" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" UpdateCheckFrequency getEnumForString ( String value ) { if ( "daily" . equalsIgnoreCase ( value ) ) { return UpdateCheckFrequency . DAILY ; } if ( "startup" . equalsIgnoreCase ( value ) ) { return UpdateCheckFrequency . STARTUP ; } if ( "weekly" . equalsIgnoreCase ( value ) ) { return UpdateCheckFrequency . WEEKLY ; } throw new IllegalArgumentException ( "Uknown update check frequency : " + value ) ; }
void test0 ( ) throws Throwable { ArtifactDownloaderFactoryImpl artifactDownloaderFactoryImpl0 = new ArtifactDownloaderFactoryImpl ( ) ; LinkedList < ArtifactStatus > linkedList0 = new LinkedList < ArtifactStatus > ( ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; linkedList0 . offerFirst ( artifactStatus0 ) ; ArtifactDownloaderImpl artifactDownloaderImpl0 = ( ArtifactDownloaderImpl ) artifactDownloaderFactoryImpl0 . create ( ( List < ArtifactStatus > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isReleaseVersionWillChange ( ) { return releaseVersionWillChange ; }
void test0 ( ) throws Throwable { DefaultRetryStrategyImpl defaultRetryStrategyImpl0 = new DefaultRetryStrategyImpl ( ) ; long long0 = defaultRetryStrategyImpl0 . getTimeToWaitBeforeRetrying ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getTimeToWaitBeforeRetrying ( int failureCount ) ; }
void test1 ( ) throws Throwable { DefaultRetryStrategyImpl defaultRetryStrategyImpl0 = new DefaultRetryStrategyImpl ( ) ; boolean boolean0 = defaultRetryStrategyImpl0 . shouldTryAgain ( 1274 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean shouldTryAgain ( int failureCount ) ; / * * * How long to wait before trying again . The specified failure count can be used to implement an * exponential backoff so that with each successive retry , more time is given to allow the circumstances * that yielded failure to correct themselves . For example , file transfer can fail for many reasons , most * of which are failures that will correct themselves if given enough time . * * @param failureCount * the number of times that the operation has failed so far . * @return the number of milliseconds to wait before retrying . * / long getTimeToWaitBeforeRetrying ( int failureCount ) ; }
void test2 ( ) throws Throwable { DefaultRetryStrategyImpl defaultRetryStrategyImpl0 = new DefaultRetryStrategyImpl ( ) ; boolean boolean0 = defaultRetryStrategyImpl0 . shouldTryAgain ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean shouldTryAgain ( int failureCount ) ; / * * * How long to wait before trying again . The specified failure count can be used to implement an * exponential backoff so that with each successive retry , more time is given to allow the circumstances * that yielded failure to correct themselves . For example , file transfer can fail for many reasons , most * of which are failures that will correct themselves if given enough time . * * @param failureCount * the number of times that the operation has failed so far . * @return the number of milliseconds to wait before retrying . * / long getTimeToWaitBeforeRetrying ( int failureCount ) ; }
void test0 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; boolean boolean0 = artifactDownloaderImpl0 . isRemoteUpdateSite ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isReleaseVersionWillChange ( ) { return releaseVersionWillChange ; }
void test1 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; String string0 = artifactDownloaderImpl0 . getFileSystemUpdatePath ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isReleaseVersionWillChange ( ) { return releaseVersionWillChange ; }
void test2 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . setHost ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test3 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; ProxySettings proxySettings0 = new ProxySettings ( ) ; artifactDownloaderImpl0 . setProxySettings ( ( IProxySettings ) proxySettings0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test4 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . setChannelName ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test5 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; String string0 = artifactDownloaderImpl0 . getHost ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test6 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; artifactDownloaderImpl0 . setUtil ( ( UpdateUtil ) updateUtilImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test7 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void run ( ) { try { Thread . sleep ( _shutdownSeconds * 1000 ) ; } catch ( InterruptedException e ) { s_log . error ( "Shutdown timer thread was interrupted unexpectedly : " + e . getMessage ( ) , e ) ; } if ( s_log . isInfoEnabled ( ) ) { s_log . info ( "ShutdownTimer is shutting down the application" ) ; } System . exit ( _app . shutdown ( false ) ? 0 : 1 ) ; }
void test8 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . setPath ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test9 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . removeDownloadListener ( ( DownloadStatusListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test10 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; String string0 = artifactDownloaderImpl0 . getPath ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test11 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . setIsRemoteUpdateSite ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test12 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . getArtifactStatus ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test13 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . addDownloadStatusListener ( ( DownloadStatusListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test14 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; DefaultRetryStrategyImpl defaultRetryStrategyImpl0 = new DefaultRetryStrategyImpl ( ) ; artifactDownloaderImpl0 . setRetryStrategy ( ( RetryStrategy ) defaultRetryStrategyImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test15 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . setPort ( 1636 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test16 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . setArtifactStatus ( ( List < ArtifactStatus > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isReleaseVersionWillChange ( ) { return releaseVersionWillChange ; }
void test17 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . setFileSystemUpdatePath ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test18 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . stopDownload ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test19 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . getUtil ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isReleaseVersionWillChange ( ) { return releaseVersionWillChange ; }
void test20 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; boolean boolean0 = artifactDownloaderImpl0 . isReleaseVersionWillChange ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test21 ( ) throws Throwable { ArtifactDownloaderImpl artifactDownloaderImpl0 = new ArtifactDownloaderImpl ( ( List < ArtifactStatus > ) null ) ; artifactDownloaderImpl0 . start ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoteUpdateSite ( ) { return this . isRemoteUpdateSite ; }
void test0 ( ) throws Throwable { DownloadEventType downloadEventType0 = DownloadEventType . DOWNLOAD_FILE_COMPLETED ; DownloadStatusEvent downloadStatusEvent0 = new DownloadStatusEvent ( downloadEventType0 ) ; downloadStatusEvent0 . setFilename ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFileCountTotal ( ) { return _fileCountTotal ; }
void test1 ( ) throws Throwable { DownloadEventType downloadEventType0 = DownloadEventType . DOWNLOAD_FILE_COMPLETED ; DownloadStatusEvent downloadStatusEvent0 = new DownloadStatusEvent ( downloadEventType0 ) ; int int0 = downloadStatusEvent0 . getFileCountTotal ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFileCountTotal ( ) { return _fileCountTotal ; }
void test2 ( ) throws Throwable { DownloadEventType downloadEventType0 = DownloadEventType . DOWNLOAD_FILE_COMPLETED ; DownloadStatusEvent downloadStatusEvent0 = new DownloadStatusEvent ( downloadEventType0 ) ; String string0 = downloadStatusEvent0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFileCountTotal ( ) { return _fileCountTotal ; }
void test3 ( ) throws Throwable { DownloadEventType downloadEventType0 = DownloadEventType . DOWNLOAD_FILE_COMPLETED ; DownloadStatusEvent downloadStatusEvent0 = new DownloadStatusEvent ( downloadEventType0 ) ; downloadStatusEvent0 . setFileCountTotal ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFileCountTotal ( ) { return _fileCountTotal ; }
void test4 ( ) throws Throwable { DownloadEventType downloadEventType0 = DownloadEventType . DOWNLOAD_FILE_COMPLETED ; DownloadStatusEvent downloadStatusEvent0 = new DownloadStatusEvent ( downloadEventType0 ) ; downloadStatusEvent0 . setException ( ( Exception ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFileCountTotal ( ) { return _fileCountTotal ; }
void test5 ( ) throws Throwable { DownloadEventType downloadEventType0 = DownloadEventType . DOWNLOAD_FILE_COMPLETED ; DownloadStatusEvent downloadStatusEvent0 = new DownloadStatusEvent ( downloadEventType0 ) ; downloadStatusEvent0 . getType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFileCountTotal ( ) { return _fileCountTotal ; }
void test6 ( ) throws Throwable { DownloadEventType downloadEventType0 = DownloadEventType . DOWNLOAD_FILE_COMPLETED ; DownloadStatusEvent downloadStatusEvent0 = new DownloadStatusEvent ( downloadEventType0 ) ; downloadStatusEvent0 . getFilename ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFileCountTotal ( ) { return _fileCountTotal ; }
void test0 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "" , "" ) ; releaseXmlBean0 . getVersion ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test1 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( ) ; releaseXmlBean0 . setName ( " ) 03NHIRG2 [ Se4" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test2 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( " , f / n6tJ#2" , " , f / n6tJ#2" ) ; String string0 = releaseXmlBean0 . getCreateTime ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLastModifiedTime ( ) { return dateFormat . format ( lastModifiedTime ) ; }
void test3 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( " , f / n6tJ#2" , " , f / n6tJ#2" ) ; releaseXmlBean0 . getModules ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLastModifiedTime ( ) { return dateFormat . format ( lastModifiedTime ) ; }
void test4 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "" , "" ) ; releaseXmlBean0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test5 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "" , "" ) ; String string0 = releaseXmlBean0 . getLastModifiedTime ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test6 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "" , "" ) ; releaseXmlBean0 . setVersion ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLastModifiedTime ( ) { return dateFormat . format ( lastModifiedTime ) ; }
void test7 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( ) ; releaseXmlBean0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLastModifiedTime ( ) { return dateFormat . format ( lastModifiedTime ) ; }
void test9 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "" , "" ) ; ModuleXmlBean moduleXmlBean0 = new ModuleXmlBean ( ) ; releaseXmlBean0 . addmodule ( moduleXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLastModifiedTime ( ) { return dateFormat . format ( lastModifiedTime ) ; }
void test10 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( ) ; releaseXmlBean0 . addmodule ( ( ModuleXmlBean ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test11 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( ) ; releaseXmlBean0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLastModifiedTime ( ) { return dateFormat . format ( lastModifiedTime ) ; }
void test12 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "" , "" ) ; ReleaseXmlBean releaseXmlBean1 = new ReleaseXmlBean ( "ZATD - xrH . Be" , "ZATD - xrH . Be" ) ; boolean boolean0 = releaseXmlBean1 . equals ( ( Object ) releaseXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test13 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "sJ$ * B }  / | < & j" , "sJ$ * B }  / | < & j" ) ; boolean boolean0 = releaseXmlBean0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test14 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "sJ$ * B }  / | < & j" , "sJ$ * B }  / | < & j" ) ; boolean boolean0 = releaseXmlBean0 . equals ( ( Object ) "2013 - 07 - 02_08 : 08 : 15 . 493 + 0100" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test15 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( ) ; ReleaseXmlBean releaseXmlBean1 = new ReleaseXmlBean ( "" , "" ) ; boolean boolean0 = releaseXmlBean0 . equals ( ( Object ) releaseXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test16 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( ) ; ReleaseXmlBean releaseXmlBean1 = new ReleaseXmlBean ( ) ; boolean boolean0 = releaseXmlBean0 . equals ( ( Object ) releaseXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test17 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "ZATD - xrH . Be" , "ZATD - xrH . Be" ) ; ReleaseXmlBean releaseXmlBean1 = new ReleaseXmlBean ( "ZATD - xrH . Be" , "" ) ; boolean boolean0 = releaseXmlBean0 . equals ( ( Object ) releaseXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test18 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( ) ; ReleaseXmlBean releaseXmlBean1 = new ReleaseXmlBean ( ( String ) null , "bzu7D" ) ; boolean boolean0 = releaseXmlBean0 . equals ( ( Object ) releaseXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test19 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "sJ$ * B }  / | < & j" , "sJ$ * B }  / | < & j" ) ; ReleaseXmlBean releaseXmlBean1 = new ReleaseXmlBean ( "sJ$ * B }  / | < & j" , "sJ$ * B }  / | < & j" ) ; boolean boolean0 = releaseXmlBean0 . equals ( ( Object ) releaseXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test20 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( ) ; Date date0 = new Date ( 1928L ) ; releaseXmlBean0 . setCreateTime ( date0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test21 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "sJ$ * B }  / | < & j" , "sJ$ * B }  / | < & j" ) ; releaseXmlBean0 . setCreateTime ( ( Date ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test22 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "sJ$ * B }  / | < & j" , "sJ$ * B }  / | < & j" ) ; Date date0 = new Date ( ) ; releaseXmlBean0 . setLastModifiedTime ( date0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Time getTime ( int columnIdx ) throws SQLException { Time results = _rs . getTime ( columnIdx ) ; _wasNull = results = = null ; return results ; }
void test23 ( ) throws Throwable { ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( ) ; releaseXmlBean0 . setLastModifiedTime ( ( Date ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateTime ( ) { return dateFormat . format ( createTime ) ; }
void test0 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "ChannelXmlBean ( net . sourceforge . squirrel_sql . client . update . xmlbeans . ChannelXmlBean@3c1 name = currentRelease = null ) " , "ChannelXmlBean ( net . sourceforge . squirrel_sql . client . update . xmlbeans . ChannelXmlBean@3c1 name = currentRelease = null ) " ) ; channelXmlBean0 . setCurrentRelease ( releaseXmlBean0 ) ; ChannelXmlBean channelXmlBean1 = new ChannelXmlBean ( ) ; channelXmlBean1 . setCurrentRelease ( releaseXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test1 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; ReleaseXmlBean releaseXmlBean0 = channelXmlBean0 . getCurrentRelease ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ReleaseXmlBean getCurrentRelease ( ) { return currentRelease ; }
void test2 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; String string0 = channelXmlBean0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; String string0 = channelXmlBean0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test4 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( ) ; channelXmlBean0 . setCurrentRelease ( releaseXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test5 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; channelXmlBean0 . setName ( "ChannelXmlBean ( net . sourceforge . squirrel_sql . client . update . xmlbeans . ChannelXmlBean@3c1 name = null currentRelease = null ) " ) ; int int0 = channelXmlBean0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test6 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( ) ; channelXmlBean0 . setCurrentRelease ( releaseXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test7 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; boolean boolean0 = channelXmlBean0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test8 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; boolean boolean0 = channelXmlBean0 . equals ( ( Object ) "ChannelXmlBean ( net . sourceforge . squirrel_sql . client . update . xmlbeans . ChannelXmlBean@3c1 name = null currentRelease = null ) " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test9 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; ChannelXmlBean channelXmlBean1 = new ChannelXmlBean ( ) ; boolean boolean0 = channelXmlBean1 . equals ( ( Object ) channelXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test10 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; ChannelXmlBean channelXmlBean1 = new ChannelXmlBean ( ) ; ReleaseXmlBean releaseXmlBean0 = new ReleaseXmlBean ( "WLwKz4 : x - - " , "m | , \"4no = d9%% ? " ) ; channelXmlBean0 . setCurrentRelease ( releaseXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test11 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; ChannelXmlBean channelXmlBean1 = new ChannelXmlBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test12 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; ChannelXmlBean channelXmlBean1 = new ChannelXmlBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test13 ( ) throws Throwable { ChannelXmlBean channelXmlBean0 = new ChannelXmlBean ( ) ; ChannelXmlBean channelXmlBean1 = new ChannelXmlBean ( ) ; channelXmlBean0 . setName ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test0 ( ) throws Throwable { ModuleXmlBean moduleXmlBean0 = new ModuleXmlBean ( ) ; TreeSet < ArtifactXmlBean > treeSet0 = new TreeSet < ArtifactXmlBean > ( ) ; moduleXmlBean0 . setArtifacts ( ( Set < ArtifactXmlBean > ) treeSet0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test1 ( ) throws Throwable { ModuleXmlBean moduleXmlBean0 = new ModuleXmlBean ( ) ; moduleXmlBean0 . setName ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test2 ( ) throws Throwable { ModuleXmlBean moduleXmlBean0 = new ModuleXmlBean ( ) ; Set < ArtifactXmlBean > set0 = moduleXmlBean0 . getArtifacts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test3 ( ) throws Throwable { ModuleXmlBean moduleXmlBean0 = new ModuleXmlBean ( ) ; String string0 = moduleXmlBean0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test4 ( ) throws Throwable { ModuleXmlBean moduleXmlBean0 = new ModuleXmlBean ( ) ; moduleXmlBean0 . addArtifact ( ( ArtifactXmlBean ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test0 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( "$'t } [ oHC1~" , "$'t } [ oHC1~" , "$'t } [ oHC1~" , ( - 1574L ) , ( - 1574L ) ) ; artifactXmlBean0 . setSize ( ( - 1L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getChecksum ( ) { return checksum ; }
void test1 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; artifactXmlBean0 . getSize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test2 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( "$'t } [ oHC1~" , "$'t } [ oHC1~" , "$'t } [ oHC1~" , ( - 1574L ) , ( - 1574L ) ) ; long long0 = artifactXmlBean0 . getChecksum ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test3 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( "$'t } [ oHC1~" , "$'t } [ oHC1~" , "$'t } [ oHC1~" , ( - 1574L ) , ( - 1574L ) ) ; boolean boolean0 = artifactXmlBean0 . isInstalled ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getChecksum ( ) { return checksum ; }
void test4 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; artifactXmlBean0 . setChecksum ( 0L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test5 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; artifactXmlBean0 . setInstalled ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test6 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; String string0 = artifactXmlBean0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test7 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( "$'t } [ oHC1~" , "$'t } [ oHC1~" , "$'t } [ oHC1~" , ( - 1574L ) , ( - 1574L ) ) ; String string0 = artifactXmlBean0 . getType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getChecksum ( ) { return checksum ; }
void test8 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( " < S2" , " < S2" , " < S2" , ( - 900L ) , ( - 900L ) ) ; String string0 = artifactXmlBean0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test9 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( "$'t } [ oHC1~" , "$'t } [ oHC1~" , "$'t } [ oHC1~" , ( - 1574L ) , ( - 1574L ) ) ; String string0 = artifactXmlBean0 . getVersion ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test10 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( " < S2" , " < S2" , " < S2" , ( - 900L ) , ( - 900L ) ) ; int int0 = artifactXmlBean0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test11 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( "$'t } [ oHC1~" , "$'t } [ oHC1~" , "$'t } [ oHC1~" , ( - 1574L ) , ( - 1574L ) ) ; boolean boolean0 = artifactXmlBean0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test12 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( "$'t } [ oHC1~" , "$'t } [ oHC1~" , "$'t } [ oHC1~" , ( - 1574L ) , ( - 1574L ) ) ; ArtifactXmlBean artifactXmlBean1 = new ArtifactXmlBean ( "$'t } [ oHC1~" , "$'t } [ oHC1~" , "$'t } [ oHC1~" , ( - 1574L ) , ( - 1574L ) ) ; boolean boolean0 = artifactXmlBean0 . equals ( ( Object ) artifactXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getChecksum ( ) { return checksum ; }
void test13 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; boolean boolean0 = artifactXmlBean0 . equals ( ( Object ) "ArtifactXmlBean ( net . sourceforge . squirrel_sql . client . update . xmlbeans . ArtifactXmlBean@1b4d89f name = null type = null version = null size = 0 checksum = 0 installed = false ) " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test14 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; ArtifactXmlBean artifactXmlBean1 = new ArtifactXmlBean ( "Uyc'" , "Uyc'" , "Uyc'" , 7L , 1932L ) ; boolean boolean0 = artifactXmlBean0 . equals ( ( Object ) artifactXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getChecksum ( ) { return checksum ; }
void test15 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; ArtifactXmlBean artifactXmlBean1 = new ArtifactXmlBean ( ) ; boolean boolean0 = artifactXmlBean1 . equals ( ( Object ) artifactXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test16 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; artifactXmlBean0 . setName ( "dlwpEM - HQL > n . xGrlb" ) ; ArtifactXmlBean artifactXmlBean1 = new ArtifactXmlBean ( ) ; boolean boolean0 = artifactXmlBean1 . equals ( ( Object ) artifactXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test17 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; artifactXmlBean0 . setName ( "dlwpEM - HQL > n . xGrlb" ) ; ArtifactXmlBean artifactXmlBean1 = new ArtifactXmlBean ( ) ; boolean boolean0 = artifactXmlBean0 . equals ( ( Object ) artifactXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test18 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( " < S2" , " < S2" , " < S2" , ( - 900L ) , ( - 900L ) ) ; ArtifactXmlBean artifactXmlBean1 = new ArtifactXmlBean ( " < S2" , " < S2" , " < S2" , 1L , ( - 900L ) ) ; boolean boolean0 = artifactXmlBean0 . equals ( ( Object ) artifactXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test19 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; artifactXmlBean0 . setName ( "dlwpEM - HQL > n . xGrlb" ) ; ArtifactXmlBean artifactXmlBean1 = new ArtifactXmlBean ( "dlwpEM - HQL > n . xGrlb" , "dlwpEM - HQL > n . xGrlb" , "dlwpEM - HQL > n . xGrlb" , 0L , 0L ) ; boolean boolean0 = artifactXmlBean0 . equals ( ( Object ) artifactXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test20 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; artifactXmlBean0 . setType ( "NQ , | FbvFXsG@x9bVKo" ) ; ArtifactXmlBean artifactXmlBean1 = new ArtifactXmlBean ( ) ; boolean boolean0 = artifactXmlBean0 . equals ( ( Object ) artifactXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test21 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; artifactXmlBean0 . setVersion ( "Za1 , B0 ; I ] zHmaH ? " ) ; ArtifactXmlBean artifactXmlBean1 = new ArtifactXmlBean ( ) ; boolean boolean0 = artifactXmlBean1 . equals ( ( Object ) artifactXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test22 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; artifactXmlBean0 . setVersion ( "NQ , | FbvFXsG@x9bVKo" ) ; ArtifactXmlBean artifactXmlBean1 = new ArtifactXmlBean ( ) ; boolean boolean0 = artifactXmlBean0 . equals ( ( Object ) artifactXmlBean1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test0 ( ) throws Throwable { ChangeListXmlBean changeListXmlBean0 = new ChangeListXmlBean ( ) ; List < ArtifactStatus > list0 = changeListXmlBean0 . getChanges ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < ArtifactStatus > getChanges ( ) { return changes ; }
void test1 ( ) throws Throwable { ChangeListXmlBean changeListXmlBean0 = new ChangeListXmlBean ( ) ; LinkedList < ArtifactStatus > linkedList0 = new LinkedList < ArtifactStatus > ( ) ; changeListXmlBean0 . setChanges ( ( List < ArtifactStatus > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test0 ( ) throws Throwable { UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( ( List < ArtifactStatus > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setValueAt ( Object value , int row , int col ) { if ( col = = IColumnIndexes . IDX_VALUE ) { SQLDriverProperty sdp = _props . getDriverProperty ( row ) ; sdp . setValue ( value . toString ( ) ) ; } else if ( col = = IColumnIndexes . IDX_SPECIFY ) { SQLDriverProperty sdp = _props . getDriverProperty ( row ) ; Boolean bool = Boolean . valueOf ( value . toString ( ) ) ; sdp . setIsSpecified ( bool . booleanValue ( ) ) ; } else { throw new IllegalStateException ( "Can only edit value / specify column . Trying to edit " + col ) ; } }
void test1 ( ) throws Throwable { UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( ( List < ArtifactStatus > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test2 ( ) throws Throwable { LinkedList < ArtifactStatus > linkedList0 = new LinkedList < ArtifactStatus > ( ) ; UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( ( List < ArtifactStatus > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test3 ( ) throws Throwable { UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( ( List < ArtifactStatus > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test4 ( ) throws Throwable { UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( ( List < ArtifactStatus > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test5 ( ) throws Throwable { LinkedList < ArtifactStatus > linkedList0 = new LinkedList < ArtifactStatus > ( ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; linkedList0 . add ( artifactStatus0 ) ; UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( ( List < ArtifactStatus > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test6 ( ) throws Throwable { LinkedList < ArtifactStatus > linkedList0 = new LinkedList < ArtifactStatus > ( ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; linkedList0 . add ( artifactStatus0 ) ; UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( ( List < ArtifactStatus > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test7 ( ) throws Throwable { UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( ( List < ArtifactStatus > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test8 ( ) throws Throwable { UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( ( List < ArtifactStatus > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test0 ( ) throws Throwable { LinkedList < ArtifactStatus > linkedList0 = new LinkedList < ArtifactStatus > ( ) ; ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( artifactXmlBean0 ) ; linkedList0 . add ( artifactStatus0 ) ; UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( linkedList0 ) ; UpdateSummaryTable updateSummaryTable0 = new UpdateSummaryTable ( ( List < ArtifactStatus > ) linkedList0 , updateSummaryTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test1 ( ) throws Throwable { LinkedList < ArtifactStatus > linkedList0 = new LinkedList < ArtifactStatus > ( ) ; ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( artifactXmlBean0 ) ; linkedList0 . add ( artifactStatus0 ) ; UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( linkedList0 ) ; UpdateSummaryTable updateSummaryTable0 = new UpdateSummaryTable ( ( List < ArtifactStatus > ) linkedList0 , updateSummaryTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { LinkedList < ArtifactStatus > linkedList0 = new LinkedList < ArtifactStatus > ( ) ; ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( artifactXmlBean0 ) ; linkedList0 . add ( artifactStatus0 ) ; UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( linkedList0 ) ; UpdateSummaryTable updateSummaryTable0 = new UpdateSummaryTable ( ( List < ArtifactStatus > ) linkedList0 , updateSummaryTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test3 ( ) throws Throwable { LinkedList < ArtifactStatus > linkedList0 = new LinkedList < ArtifactStatus > ( ) ; ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( artifactXmlBean0 ) ; linkedList0 . add ( artifactStatus0 ) ; UpdateSummaryTableModel updateSummaryTableModel0 = new UpdateSummaryTableModel ( linkedList0 ) ; UpdateSummaryTable updateSummaryTable0 = new UpdateSummaryTable ( ( List < ArtifactStatus > ) linkedList0 , updateSummaryTableModel0 ) ; updateSummaryTable0 . setReleaseVersionWillChange ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test0 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; ArtifactAction artifactAction0 = artifactStatus0 . getArtifactAction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; boolean boolean0 = artifactStatus0 . isTranslationArtifact ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTranslationArtifact ( ) { return UpdateUtil . TRANSLATION_ARTIFACT_ID . equals ( this . type ) ; }
void test2 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; artifactStatus0 . setName ( " MB" ) ; int int0 = artifactStatus0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test3 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; String string0 = artifactStatus0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test4 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; String string0 = artifactStatus0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test5 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; String string0 = artifactStatus0 . getType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test6 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( artifactXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test7 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; String string0 = artifactStatus0 . getDisplayType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDisplayType ( ) { return displayType ; }
void test8 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; long long0 = artifactStatus0 . getChecksum ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getChecksum ( ) { return checksum ; }
void test9 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; long long0 = artifactStatus0 . getSize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test10 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; artifactStatus0 . setSize ( 0L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test11 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( artifactXmlBean0 ) ; ArtifactAction artifactAction0 = ArtifactAction . INSTALL ; artifactStatus0 . setArtifactAction ( artifactAction0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test12 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; artifactStatus0 . setDisplayType ( "8 > 9W^%3" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCoreArtifact ( ) { return UpdateUtil . CORE_ARTIFACT_ID . equals ( this . type ) ; }
void test13 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; artifactStatus0 . setChecksum ( ( - 941L ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getChecksum ( ) { return checksum ; }
void test14 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; boolean boolean0 = artifactStatus0 . isPluginArtifact ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPluginArtifact ( ) { return UpdateUtil . PLUGIN_ARTIFACT_ID . equals ( this . type ) ; }
void test15 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; boolean boolean0 = artifactStatus0 . isInstalled ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstalled ( ) { return installed ; }
void test16 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; boolean boolean0 = artifactStatus0 . isCoreArtifact ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCoreArtifact ( ) { return UpdateUtil . CORE_ARTIFACT_ID . equals ( this . type ) ; }
void test17 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; artifactStatus0 . setType ( "log4j . debug" ) ; ArtifactStatus artifactStatus1 = new ArtifactStatus ( ) ; boolean boolean0 = artifactStatus0 . equals ( ( Object ) artifactStatus1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test18 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; artifactStatus0 . setType ( "core" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDisplayType ( ) { return displayType ; }
void test19 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( "plugin" , "plugin" , "plugin" , ( - 1347L ) , ( - 1347L ) ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( artifactXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getChecksum ( ) { return checksum ; }
void test20 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; artifactStatus0 . setType ( " MB" ) ; int int0 = artifactStatus0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test21 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( "i18n" , "i18n" , "i18n" , ( - 1L ) , ( - 1L ) ) ; ArtifactStatus artifactStatus1 = new ArtifactStatus ( artifactXmlBean0 ) ; boolean boolean0 = artifactStatus0 . equals ( ( Object ) artifactStatus1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDisplayType ( ) { return displayType ; }
void test22 ( ) throws Throwable { ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( ) ; ArtifactStatus artifactStatus0 = new ArtifactStatus ( artifactXmlBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test23 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; boolean boolean0 = artifactStatus0 . equals ( ( Object ) "ArtifactStatus ( net . sourceforge . squirrel_sql . client . update . gui . ArtifactStatus@3c1 name = null type = null installed = false displayType = null artifactAction = NONE ) " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test24 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; artifactStatus0 . setName ( " MB" ) ; ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( " MB" , " MB" , " MB" , 0L , 0L ) ; ArtifactStatus artifactStatus1 = new ArtifactStatus ( artifactXmlBean0 ) ; boolean boolean0 = artifactStatus0 . equals ( ( Object ) artifactStatus1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test25 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; ArtifactStatus artifactStatus1 = new ArtifactStatus ( ) ; boolean boolean0 = artifactStatus1 . equals ( ( Object ) artifactStatus0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test26 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; artifactStatus0 . setName ( " MB" ) ; ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( " + y1x2_Dz% | [ f" , " + y1x2_Dz% | [ f" , " + y1x2_Dz% | [ f" , ( - 1352L ) , ( - 1352L ) ) ; ArtifactStatus artifactStatus1 = new ArtifactStatus ( artifactXmlBean0 ) ; boolean boolean0 = artifactStatus0 . equals ( ( Object ) artifactStatus1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test27 ( ) throws Throwable { ArtifactStatus artifactStatus0 = new ArtifactStatus ( ) ; artifactStatus0 . setName ( " MB" ) ; artifactStatus0 . setType ( " MB" ) ; ArtifactXmlBean artifactXmlBean0 = new ArtifactXmlBean ( " MB" , " MB" , " MB" , ( - 1342L ) , ( - 1342L ) ) ; ArtifactStatus artifactStatus1 = new ArtifactStatus ( artifactXmlBean0 ) ; boolean boolean0 = artifactStatus0 . equals ( ( Object ) artifactStatus1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test0 ( ) throws Throwable { SplashScreenFixer splashScreenFixer0 = new SplashScreenFixer ( ) ; String string0 = splashScreenFixer0 . fixLine ( "main" , "main" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String fixLine ( String scriptFileName , String line ) { if ( scriptWasAlreadyFixed ) { return line ; } if ( ! scriptFileName . toLowerCase ( ) . endsWith ( " . sh" ) ) { return line ; } if ( line . contains ( "buildCPFromDir ( ) " ) ) { inFunctionDeclaration = true ; return line ; } if ( inFunctionDeclaration ) { if ( line . contains ( " { " ) ) { sawOpenCurlyBrace = true ; return line ; } / / Perhaps the line has already been added . If so , skip future checks . if ( line . contains ( "CP = \"\"" ) ) { scriptWasAlreadyFixed = true ; return line ; } / / At this point we are still in the function declaration , and the current line is neither the / / opening curly brace , nor the 'CP = ""' line , so it must be the first actual line of the function . / / So , add in the if ( sawOpenCurlyBrace ) { inFunctionDeclaration = false ; scriptWasAlreadyFixed = true ; StringBuilder alteredLine = new StringBuilder ( ) ; alteredLine . append ( "\tCP = \"\"" ) ; alteredLine . append ( IOUtilities . NEW_LINE ) ; alteredLine . append ( line ) ; return alteredLine . toString ( ) ; } } return line ; }
void test0 ( ) throws Throwable { ClasspathFunctionFixer classpathFunctionFixer0 = new ClasspathFunctionFixer ( ) ; String string0 = classpathFunctionFixer0 . fixLine ( " : `s# ; | ; d . sh" , " : `s# ; | ; d . sh" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String fixLine ( String scriptFileName , String line ) { if ( scriptWasAlreadyFixed ) { return line ; } if ( ! scriptFileName . toLowerCase ( ) . endsWith ( " . sh" ) ) { return line ; } if ( line . contains ( "buildCPFromDir ( ) " ) ) { inFunctionDeclaration = true ; return line ; } if ( inFunctionDeclaration ) { if ( line . contains ( " { " ) ) { sawOpenCurlyBrace = true ; return line ; } / / Perhaps the line has already been added . If so , skip future checks . if ( line . contains ( "CP = \"\"" ) ) { scriptWasAlreadyFixed = true ; return line ; } / / At this point we are still in the function declaration , and the current line is neither the / / opening curly brace , nor the 'CP = ""' line , so it must be the first actual line of the function . / / So , add in the if ( sawOpenCurlyBrace ) { inFunctionDeclaration = false ; scriptWasAlreadyFixed = true ; StringBuilder alteredLine = new StringBuilder ( ) ; alteredLine . append ( "\tCP = \"\"" ) ; alteredLine . append ( IOUtilities . NEW_LINE ) ; alteredLine . append ( line ) ; return alteredLine . toString ( ) ; } } return line ; }
void test1 ( ) throws Throwable { ClasspathFunctionFixer classpathFunctionFixer0 = new ClasspathFunctionFixer ( ) ; String string0 = classpathFunctionFixer0 . fixLine ( " : `s# ; | ; d . sh" , " ) buildCPFromDir ( ) " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test2 ( ) throws Throwable { ClasspathFunctionFixer classpathFunctionFixer0 = new ClasspathFunctionFixer ( ) ; String string0 = classpathFunctionFixer0 . fixLine ( " ) buildCPFromDir ( ) " , " ) buildCPFromDir ( ) " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String fixLine ( String scriptFileName , String line ) { if ( scriptWasAlreadyFixed ) { return line ; } if ( ! scriptFileName . toLowerCase ( ) . endsWith ( " . sh" ) ) { return line ; } if ( line . contains ( "buildCPFromDir ( ) " ) ) { inFunctionDeclaration = true ; return line ; } if ( inFunctionDeclaration ) { if ( line . contains ( " { " ) ) { sawOpenCurlyBrace = true ; return line ; } / / Perhaps the line has already been added . If so , skip future checks . if ( line . contains ( "CP = \"\"" ) ) { scriptWasAlreadyFixed = true ; return line ; } / / At this point we are still in the function declaration , and the current line is neither the / / opening curly brace , nor the 'CP = ""' line , so it must be the first actual line of the function . / / So , add in the if ( sawOpenCurlyBrace ) { inFunctionDeclaration = false ; scriptWasAlreadyFixed = true ; StringBuilder alteredLine = new StringBuilder ( ) ; alteredLine . append ( "\tCP = \"\"" ) ; alteredLine . append ( IOUtilities . NEW_LINE ) ; alteredLine . append ( line ) ; return alteredLine . toString ( ) ; } } return line ; }
void test3 ( ) throws Throwable { ClasspathFunctionFixer classpathFunctionFixer0 = new ClasspathFunctionFixer ( ) ; String string0 = classpathFunctionFixer0 . fixLine ( " : `s# ; | ; d . sh" , " ) buildCPFromDir ( ) " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String fixLine ( String scriptFileName , String line ) { if ( scriptWasAlreadyFixed ) { return line ; } if ( ! scriptFileName . toLowerCase ( ) . endsWith ( " . sh" ) ) { return line ; } if ( line . contains ( "buildCPFromDir ( ) " ) ) { inFunctionDeclaration = true ; return line ; } if ( inFunctionDeclaration ) { if ( line . contains ( " { " ) ) { sawOpenCurlyBrace = true ; return line ; } / / Perhaps the line has already been added . If so , skip future checks . if ( line . contains ( "CP = \"\"" ) ) { scriptWasAlreadyFixed = true ; return line ; } / / At this point we are still in the function declaration , and the current line is neither the / / opening curly brace , nor the 'CP = ""' line , so it must be the first actual line of the function . / / So , add in the if ( sawOpenCurlyBrace ) { inFunctionDeclaration = false ; scriptWasAlreadyFixed = true ; StringBuilder alteredLine = new StringBuilder ( ) ; alteredLine . append ( "\tCP = \"\"" ) ; alteredLine . append ( IOUtilities . NEW_LINE ) ; alteredLine . append ( line ) ; return alteredLine . toString ( ) ; } } return line ; }
void test1 ( ) throws Throwable { PreLaunchHelperImpl preLaunchHelperImpl0 = new PreLaunchHelperImpl ( ) ; Vector < ScriptLineFixer > vector0 = new Vector < ScriptLineFixer > ( 521 ) ; preLaunchHelperImpl0 . setScriptLineFixers ( ( List < ScriptLineFixer > ) vector0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test2 ( ) throws Throwable { PreLaunchHelperImpl preLaunchHelperImpl0 = new PreLaunchHelperImpl ( ) ; IOUtilitiesImpl iOUtilitiesImpl0 = new IOUtilitiesImpl ( ) ; preLaunchHelperImpl0 . setIoutils ( ( IOUtilities ) iOUtilitiesImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getScriptLocation ( ) { return scriptLocation ; }
void test3 ( ) throws Throwable { PreLaunchHelperImpl preLaunchHelperImpl0 = new PreLaunchHelperImpl ( ) ; ArtifactInstallerFactoryImpl artifactInstallerFactoryImpl0 = new ArtifactInstallerFactoryImpl ( ) ; preLaunchHelperImpl0 . setArtifactInstallerFactory ( ( ArtifactInstallerFactory ) artifactInstallerFactoryImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getScriptLocation ( ) { return scriptLocation ; }
void test4 ( ) throws Throwable { PreLaunchHelperImpl preLaunchHelperImpl0 = new PreLaunchHelperImpl ( ) ; UpdateUtilImpl updateUtilImpl0 = new UpdateUtilImpl ( ) ; preLaunchHelperImpl0 . setUpdateUtil ( ( UpdateUtil ) updateUtilImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getScriptLocation ( ) { return scriptLocation ; }
void test5 ( ) throws Throwable { PreLaunchHelperImpl preLaunchHelperImpl0 = new PreLaunchHelperImpl ( ) ; String string0 = preLaunchHelperImpl0 . getScriptLocation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getScriptLocation ( ) { return scriptLocation ; }
void test2 ( ) throws Throwable { ArtifactInstallerFactoryImpl artifactInstallerFactoryImpl0 = new ArtifactInstallerFactoryImpl ( ) ; FileSystemXmlApplicationContext fileSystemXmlApplicationContext0 = new FileSystemXmlApplicationContext ( ) ; artifactInstallerFactoryImpl0 . setApplicationContext ( ( ApplicationContext ) fileSystemXmlApplicationContext0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = applicationContext ; }
void test0 ( ) throws Throwable { PreLaunchUpdateApplication preLaunchUpdateApplication0 = new PreLaunchUpdateApplication ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test2 ( ) throws Throwable { ArtifactInstallerImpl artifactInstallerImpl0 = new ArtifactInstallerImpl ( ) ; FileWrapper fileWrapper0 = artifactInstallerImpl0 . getChangeListFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FileWrapper getChangeListFile ( ) ; FileWrapper checkDir ( FileWrapper parent , String child ) ; void createZipFile ( FileWrapper zipFile , FileWrapper . . . sourceFiles ) throws FileNotFoundException , IOException ; / * * * Returns the update directory in which all information about available updates and the user's desired * actions are located . * * @return a File representing the update directory . * / FileWrapper getSquirrelUpdateDir ( ) ; / * * * Create and save a ChangeListXmlBean to the update directory . * * @param changes * the list of changes to be persisted * @throws FileNotFoundException * if the file to be written couldn't be found . * / void saveChangeList ( List < ArtifactStatus > changes ) throws FileNotFoundException ; / * * * Retrieves the change list ( if one exists ) from the update directory . * * @return a change list bean . * @throws FileNotFoundException * if the file couldn't be found . * / ChangeListXmlBean getChangeList ( ) throws FileNotFoundException ; / * * * Returns the absolute path to the release xml file that describes what release the user currently has . * * @return the absolute path to the release xml file * @throws FileNotFoundException * if the release xml file couldn't be found . * / FileWrapper getLocalReleaseFile ( ) throws FileNotFoundException ; / * * * Builds a list of ArtifactStatus objects from the specified ChannelXmlBean * * @param channelXmlBean * the bean that represents the channel that the user is pulling updates from . * @return a list of ArtifactStatus objects that describe all of the available artifacts from the specified * channel . * / List < ArtifactStatus > getArtifactStatus ( ChannelXmlBean channelXmlBean ) ; List < ArtifactStatus > getArtifactStatus ( ReleaseXmlBean releaseXmlBean ) ; / * * * Returns a set of plugin archive filenames - one for each installed plugin . * / Set < String > getInstalledPlugins ( ) ; / * * * Returns a set of translation filenames - one jar for each translation . * * @return * / Set < String > getInstalledTranslations ( ) ; / * * * @return the _pluginManager * / IPluginManager getPluginManager ( ) ; / * * * @param manager * the _pluginManager to set * / void setPluginManager ( IPluginManager manager ) ; / * * * Returns the top - level directory that contains artifact type sub - folders into which downloaded files are * copied . * * @return a File representing the root directory of the download tree . * / FileWrapper getDownloadsDir ( ) ; FileWrapper getCoreDownloadsDir ( ) ; FileWrapper getPluginDownloadsDir ( ) ; FileWrapper getI18nDownloadsDir ( ) ; FileWrapper getBackupDir ( ) ; FileWrapper getCoreBackupDir ( ) ; FileWrapper getPluginBackupDir ( ) ; FileWrapper getI18nBackupDir ( ) ; / * * * Returns the absolute path to the location of the squirrel - sql . jar file . * * @return a File representing the current installed squirrel - sql . jar file . * / FileWrapper getInstalledSquirrelMainJarLocation ( ) ; ChangeListXmlBean getChangeList ( FileWrapper changeListFile ) throws FileNotFoundException ; FileWrapper getFile ( FileWrapper installDir , String artifactName ) ; / * * * This function will recursivly delete directories and files . * * @param path * File or Directory to be deleted * @return true indicates success . * / boolean deleteFile ( FileWrapper path ) ; / * * * Extracts the specified zip file to the specified output directory . * * @param zipFile * the compressed archive file to extract * @param outputDirectory * the directory into which to extract * @throws IOException * if an error occurs * / void extractZipFile ( FileWrapper zipFile , FileWrapper outputDirectory ) throws IOException ; / * * * Returns the absolute path to the file in the downloads section for the specified ArtifactStatus * * @param status * the ArtifactStatus that describes the type and name of this artifact . * @return a File object representing the location of the artifact in the downloads directory . * / FileWrapper getDownloadFileLocation ( ArtifactStatus status ) ; boolean isPresentInDownloadsDirectory ( ArtifactStatus status ) ; / * * * Get the checksum for the specified file . This has a side effect in that it caches the checksum for * speedier lookup on subsequent calls . * * @param f * the file to get the checksum for * @return the checksum as a long . If an error occurs , this method will return - 1 * / long getCheckSum ( FileWrapper f ) ; / * * * Returns an Enum value representing the users preference for how often to automatically check for * updates . * * @param settings * the settings to look in . * @return the Enum value * / UpdateCheckFrequency getUpdateCheckFrequency ( IUpdateSettings settings ) ; }
void test0 ( ) throws Throwable { InstallEventType installEventType0 = InstallEventType . FILE_REMOVE_COMPLETE ; InstallStatusEvent installStatusEvent0 = new InstallStatusEvent ( installEventType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getNumFilesToUpdate ( ) { return numFilesToUpdate ; }
void test1 ( ) throws Throwable { InstallEventType installEventType0 = InstallEventType . FILE_REMOVE_COMPLETE ; InstallStatusEvent installStatusEvent0 = new InstallStatusEvent ( installEventType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getNumFilesToUpdate ( ) { return numFilesToUpdate ; }
void test2 ( ) throws Throwable { InstallEventType installEventType0 = InstallEventType . FILE_REMOVE_COMPLETE ; InstallStatusEvent installStatusEvent0 = new InstallStatusEvent ( installEventType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getNumFilesToUpdate ( ) { return numFilesToUpdate ; }
void test3 ( ) throws Throwable { InstallEventType installEventType0 = InstallEventType . FILE_REMOVE_COMPLETE ; InstallStatusEvent installStatusEvent0 = new InstallStatusEvent ( installEventType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getNumFilesToUpdate ( ) { return numFilesToUpdate ; }
void test4 ( ) throws Throwable { InstallEventType installEventType0 = InstallEventType . FILE_REMOVE_COMPLETE ; InstallStatusEvent installStatusEvent0 = new InstallStatusEvent ( installEventType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getNumFilesToUpdate ( ) { return numFilesToUpdate ; }
void test5 ( ) throws Throwable { InstallEventType installEventType0 = InstallEventType . FILE_REMOVE_COMPLETE ; InstallStatusEvent installStatusEvent0 = new InstallStatusEvent ( installEventType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getNumFilesToUpdate ( ) { return numFilesToUpdate ; }
void test3 ( ) throws Throwable { ProgressDialogControllerImpl progressDialogControllerImpl0 = new ProgressDialogControllerImpl ( ) ; InstallStatusListenerImpl installStatusListenerImpl0 = new InstallStatusListenerImpl ( ( ProgressDialogController ) progressDialogControllerImpl0 ) ; InstallEventType installEventType0 = InstallEventType . BACKUP_STARTED ; InstallStatusEvent installStatusEvent0 = new InstallStatusEvent ( installEventType0 ) ; installStatusListenerImpl0 . handleInstallStatusEvent ( installStatusEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test6 ( ) throws Throwable { ProgressDialogControllerImpl progressDialogControllerImpl0 = new ProgressDialogControllerImpl ( ) ; InstallStatusListenerImpl installStatusListenerImpl0 = new InstallStatusListenerImpl ( ( ProgressDialogController ) progressDialogControllerImpl0 ) ; InstallEventType installEventType0 = InstallEventType . REMOVE_STARTED ; InstallStatusEvent installStatusEvent0 = new InstallStatusEvent ( installEventType0 ) ; installStatusListenerImpl0 . handleInstallStatusEvent ( installStatusEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test9 ( ) throws Throwable { ProgressDialogControllerImpl progressDialogControllerImpl0 = new ProgressDialogControllerImpl ( ) ; InstallStatusListenerImpl installStatusListenerImpl0 = new InstallStatusListenerImpl ( ( ProgressDialogController ) progressDialogControllerImpl0 ) ; InstallEventType installEventType0 = InstallEventType . INSTALL_STARTED ; InstallStatusEvent installStatusEvent0 = new InstallStatusEvent ( installEventType0 ) ; installStatusListenerImpl0 . handleInstallStatusEvent ( installStatusEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getArtifactName ( ) { return _artifactName ; }
void test0 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "" , "" ) ; InstallFileOperationInfoImpl installFileOperationInfoImpl0 = new InstallFileOperationInfoImpl ( ( FileWrapper ) fileWrapperImpl0 , ( FileWrapper ) fileWrapperImpl0 ) ; boolean boolean0 = installFileOperationInfoImpl0 . isPlugin ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPlugin ( ) ; / * * * @param isPlugin the isPlugin to set * / void setPlugin ( boolean isPlugin ) ; / * * * @param artifactName the artifactName to set * / void setArtifactName ( String artifactName ) ; / * * * @return the artifactName * / String getArtifactName ( ) ; }
void test1 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "" , "" ) ; InstallFileOperationInfoImpl installFileOperationInfoImpl0 = new InstallFileOperationInfoImpl ( ( FileWrapper ) fileWrapperImpl0 , ( FileWrapper ) fileWrapperImpl0 ) ; FileWrapperImpl fileWrapperImpl1 = ( FileWrapperImpl ) installFileOperationInfoImpl0 . getFileToInstall ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canRead ( ) { return _wrappedFile . canRead ( ) ; }
void test2 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "" , "" ) ; InstallFileOperationInfoImpl installFileOperationInfoImpl0 = new InstallFileOperationInfoImpl ( ( FileWrapper ) fileWrapperImpl0 , ( FileWrapper ) fileWrapperImpl0 ) ; installFileOperationInfoImpl0 . setPlugin ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPlugin ( ) ; / * * * @param isPlugin the isPlugin to set * / void setPlugin ( boolean isPlugin ) ; / * * * @param artifactName the artifactName to set * / void setArtifactName ( String artifactName ) ; / * * * @return the artifactName * / String getArtifactName ( ) ; }
void test3 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "" , "" ) ; InstallFileOperationInfoImpl installFileOperationInfoImpl0 = new InstallFileOperationInfoImpl ( ( FileWrapper ) fileWrapperImpl0 , ( FileWrapper ) fileWrapperImpl0 ) ; installFileOperationInfoImpl0 . setFileToInstall ( ( FileWrapper ) fileWrapperImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canRead ( ) { return _wrappedFile . canRead ( ) ; }
void test4 ( ) throws Throwable { InstallFileOperationInfoImpl installFileOperationInfoImpl0 = new InstallFileOperationInfoImpl ( ( FileWrapper ) null , ( FileWrapper ) null ) ; installFileOperationInfoImpl0 . setInstallDir ( ( FileWrapper ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPlugin ( ) ; / * * * @param isPlugin the isPlugin to set * / void setPlugin ( boolean isPlugin ) ; / * * * @param artifactName the artifactName to set * / void setArtifactName ( String artifactName ) ; / * * * @return the artifactName * / String getArtifactName ( ) ; }
void test5 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "" , "" ) ; InstallFileOperationInfoImpl installFileOperationInfoImpl0 = new InstallFileOperationInfoImpl ( ( FileWrapper ) fileWrapperImpl0 , ( FileWrapper ) fileWrapperImpl0 ) ; String string0 = installFileOperationInfoImpl0 . getArtifactName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getArtifactName ( ) { return _artifactName ; }
void test6 ( ) throws Throwable { InstallFileOperationInfoImpl installFileOperationInfoImpl0 = new InstallFileOperationInfoImpl ( ( FileWrapper ) null , ( FileWrapper ) null ) ; installFileOperationInfoImpl0 . setArtifactName ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPlugin ( ) ; / * * * @param isPlugin the isPlugin to set * / void setPlugin ( boolean isPlugin ) ; / * * * @param artifactName the artifactName to set * / void setArtifactName ( String artifactName ) ; / * * * @return the artifactName * / String getArtifactName ( ) ; }
void test7 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "" , "" ) ; InstallFileOperationInfoImpl installFileOperationInfoImpl0 = new InstallFileOperationInfoImpl ( ( FileWrapper ) fileWrapperImpl0 , ( FileWrapper ) fileWrapperImpl0 ) ; FileWrapperImpl fileWrapperImpl1 = ( FileWrapperImpl ) installFileOperationInfoImpl0 . getInstallDir ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isHidden ( ) { return _wrappedFile . isHidden ( ) ; }
void test0 ( ) throws Throwable { InstallFileOperationInfoFactoryImpl installFileOperationInfoFactoryImpl0 = new InstallFileOperationInfoFactoryImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "lrw8WD / ( ] | D | n / " , "lrw8WD / ( ] | D | n / " ) ; InstallFileOperationInfoImpl installFileOperationInfoImpl0 = ( InstallFileOperationInfoImpl ) installFileOperationInfoFactoryImpl0 . create ( ( FileWrapper ) fileWrapperImpl0 , ( FileWrapper ) fileWrapperImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPlugin ( ) ; / * * * @param isPlugin the isPlugin to set * / void setPlugin ( boolean isPlugin ) ; / * * * @param artifactName the artifactName to set * / void setArtifactName ( String artifactName ) ; / * * * @return the artifactName * / String getArtifactName ( ) ; }
void test0 ( ) throws Throwable { PathUtilsImpl pathUtilsImpl0 = new PathUtilsImpl ( ) ; String [ ] stringArray0 = new String [ 4 ] ; String string0 = pathUtilsImpl0 . buildPath ( false , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String buildPath ( boolean prependSlash , String . . . pathElements ) ; / * * * Returns the file part of the specified path . * * @param path * the path * @return the file part of the path * / String getFileFromPath ( String path ) ; }
void test1 ( ) throws Throwable { PathUtilsImpl pathUtilsImpl0 = new PathUtilsImpl ( ) ; String string0 = pathUtilsImpl0 . getFileFromPath ( " / / & usT : qdvP#q\"p ? MNHl3 / null / null / null / null / null / null / null / K = #sZ~zMa`3 / K = #sZ~zMa`3 / K = #sZ~zMa`3 / K = #sZ~zMa`3 / / / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFileFromPath ( String path ) ; }
void test2 ( ) throws Throwable { PathUtilsImpl pathUtilsImpl0 = new PathUtilsImpl ( ) ; String string0 = pathUtilsImpl0 . getFileFromPath ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFileFromPath ( String path ) ; }
void test0 ( ) throws Throwable { IdentifierFactory identifierFactory0 = new IdentifierFactory ( ) ; UidIdentifier uidIdentifier0 = ( UidIdentifier ) identifierFactory0 . createIdentifier ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { UidIdentifierFactory uidIdentifierFactory0 = ( UidIdentifierFactory ) IdentifierFactory . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ApplicationArguments getInstance ( ) { if ( s_instance = = null ) { try { s_instance = new ApplicationArguments ( new String [ ] { } ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } } return s_instance ; }
void test0 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getFAQFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean exists ( ) { return _wrappedFile . exists ( ) ; }
void test1 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getDTPropertiesFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean exists ( ) { return _wrappedFile . exists ( ) ; }
void test2 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getUpdateDirectory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean exists ( ) { return _wrappedFile . exists ( ) ; }
void test3 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getQuickStartGuideFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isHidden ( ) { return _wrappedFile . isHidden ( ) ; }
void test4 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getExecutionLogFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return _path ; }
void test6 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getFwJarFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canRead ( ) { return _wrappedFile . canRead ( ) ; }
void test7 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getDatabaseAliasesFile_before_version_2_3 ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean exists ( ) { return _wrappedFile . exists ( ) ; }
void test8 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getChangeLogFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test9 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getSQuirrelJarFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canRead ( ) { return _wrappedFile . canRead ( ) ; }
void test10 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getDatabaseAliasesTreeStructureFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDirectory ( ) { return _wrappedFile . isDirectory ( ) ; }
void test11 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getPluginsUserSettingsDirectory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getParent ( ) { return _wrappedFile . getParent ( ) ; }
void test12 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getDatabaseAliasesFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDirectory ( ) { return _wrappedFile . isDirectory ( ) ; }
void test13 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getLibraryDirectory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long length ( ) { return _wrappedFile . length ( ) ; }
void test14 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getJDBCDebugLogFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFile ( ) { return _wrappedFile . isFile ( ) ; }
void test15 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getWelcomeFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return _path ; }
void test16 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getUserSettingsDirectory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return _path ; }
void test17 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getEditWhereColsFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return _path ; }
void test18 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getUserSQLHistoryFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAbsolute ( ) { return _wrappedFile . isAbsolute ( ) ; }
void test19 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getPluginsDirectory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getParent ( ) { return _wrappedFile . getParent ( ) ; }
void test21 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getCellImportExportSelectionsFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test22 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getUserPreferencesFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return _path ; }
void test23 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getLicenceFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test24 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getDatabaseDriversFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return _path ; }
void test25 ( ) throws Throwable { ApplicationFileWrappersImpl applicationFileWrappersImpl0 = new ApplicationFileWrappersImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) applicationFileWrappersImpl0 . getSquirrelHomeDir ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAbsolutePath ( ) { return _wrappedFile . getAbsolutePath ( ) ; }
void test0 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCanonicalPath ( ) throws IOException { return _wrappedFile . getCanonicalPath ( ) ; }
void test1 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCanonicalPath ( ) throws IOException { return _wrappedFile . getCanonicalPath ( ) ; }
void test2 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAbsolutePath ( ) { return _wrappedFile . getAbsolutePath ( ) ; }
void test3 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAbsolutePath ( ) { return _wrappedFile . getAbsolutePath ( ) ; }
void test4 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCanonicalPath ( ) throws IOException { return _wrappedFile . getCanonicalPath ( ) ; }
void test5 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return _path ; }
void test6 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAbsolutePath ( ) { return _wrappedFile . getAbsolutePath ( ) ; }
void test7 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCanonicalPath ( ) throws IOException { return _wrappedFile . getCanonicalPath ( ) ; }
void test8 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test9 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getParent ( ) { return _wrappedFile . getParent ( ) ; }
void test10 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAbsolutePath ( ) { return _wrappedFile . getAbsolutePath ( ) ; }
void test11 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCanonicalPath ( ) throws IOException { return _wrappedFile . getCanonicalPath ( ) ; }
void test12 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCanonicalPath ( ) throws IOException { return _wrappedFile . getCanonicalPath ( ) ; }
void test13 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; File file0 = applicationFiles0 . getSquirrelHomeDir ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean mkdirs ( ) { return _wrappedFile . mkdirs ( ) ; }
void test14 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; File file0 = applicationFiles0 . getUserSettingsDirectory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAbsolute ( ) { return _wrappedFile . isAbsolute ( ) ; }
void test15 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return _path ; }
void test16 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAbsolutePath ( ) { return _wrappedFile . getAbsolutePath ( ) ; }
void test17 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAbsolutePath ( ) { return _wrappedFile . getAbsolutePath ( ) ; }
void test18 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return _path ; }
void test19 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test20 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test21 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return _path ; }
void test22 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test23 ( ) throws Throwable { ApplicationFiles applicationFiles0 = new ApplicationFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCanonicalPath ( ) throws IOException { return _wrappedFile . getCanonicalPath ( ) ; }
void test0 ( ) throws Throwable { Box box0 = Box . createHorizontalBox ( ) ; PrintUtilities . enableDoubleBuffering ( ( Component ) box0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getHeight ( ) ; }
void test1 ( ) throws Throwable { Box box0 = Box . createHorizontalBox ( ) ; PrintUtilities . disableDoubleBuffering ( ( Component ) box0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void disableDoubleBuffering ( Component c ) { RepaintManager currentManager = RepaintManager . currentManager ( c ) ; currentManager . setDoubleBufferingEnabled ( false ) ; }
void test4 ( ) throws Throwable { Box box0 = Box . createHorizontalBox ( ) ; PrintUtilities printUtilities0 = new PrintUtilities ( ( Component ) box0 ) ; PageFormat pageFormat0 = new PageFormat ( ) ; int int0 = printUtilities0 . print ( ( Graphics ) null , pageFormat0 , 6 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { PrinterJob printJob = PrinterJob . getPrinterJob ( ) ; printJob . setPrintable ( this ) ; if ( printJob . printDialog ( ) ) { try { printJob . print ( ) ; } catch ( PrinterException pe ) { s_log . error ( "Error printing" , pe ) ; } } }
void test0 ( ) throws Throwable { PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( "" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test1 ( ) throws Throwable { PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( "" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test3 ( ) throws Throwable { PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( " ] % ; " , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test4 ( ) throws Throwable { PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( "Y . 8" , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test5 ( ) throws Throwable { PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( " ] % ; " , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test6 ( ) throws Throwable { PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( " " , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test7 ( ) throws Throwable { PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( " ] % ; " , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test8 ( ) throws Throwable { PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( " " , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test9 ( ) throws Throwable { PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( " ] % ; " , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test10 ( ) throws Throwable { PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( " " , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test0 ( ) throws Throwable { StateOfPosition stateOfPosition0 = new StateOfPosition ( ) ; StateOfPosition stateOfPosition1 = ( StateOfPosition ) stateOfPosition0 . clone ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; }
void test0 ( ) throws Throwable { CommentSpec commentSpec0 = new CommentSpec ( ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" CommentSpec ( String commentBegin , String commentEnd ) { this . commentBegin = commentBegin ; this . commentEnd = commentEnd ; }
void test0 ( ) throws Throwable { PieceMarkerSpec [ ] pieceMarkerSpecArray0 = new PieceMarkerSpec [ 12 ] ; PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( "C" , 2 ) ; pieceMarkerSpecArray0 [ 0 ] = pieceMarkerSpec0 ; CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 1 ] ; CommentSpec commentSpec0 = new CommentSpec ( "C" , "C" ) ; commentSpecArray0 [ 0 ] = commentSpec0 ; CodeReformatorKernel codeReformatorKernel0 = new CodeReformatorKernel ( "C" , pieceMarkerSpecArray0 , commentSpecArray0 ) ; pieceMarkerSpecArray0 [ 1 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 2 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 3 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 4 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 5 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 6 ] = pieceMarkerSpecArray0 [ 0 ] ; pieceMarkerSpecArray0 [ 7 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 8 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 9 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 10 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 11 ] = pieceMarkerSpec0 ; String [ ] stringArray0 = codeReformatorKernel0 . toPieces ( "C" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] toPieces ( String in ) { _statesOfPosition = getStatesOfPosition ( in ) ; Vector < String > ret = new Vector < String > ( ) ; / / toUpperCase replaces the German ß by ss . / / This will kill reformating later . / / Since upperIn is just for building pieces / / it is OK to place ß here . String upperIn = in . replaceAll ( "ß" , "s" ) ; upperIn = upperIn . toUpperCase ( ) ; int begin = 0 ; while ( begin < in . length ( ) ) { Piece p = getNextToplevelPiece ( begin , upperIn ) ; if ( null = = p . spec ) { ret . add ( in . substring ( begin ) . trim ( ) ) ; begin = in . length ( ) ; } else { int type = p . spec . getType ( ) ; switch ( type ) { case PieceMarkerSpec . TYPE_PIECE_MARKER_AT_BEGIN : if ( begin < p . beginsAt & & 0 < in . substring ( begin , p . beginsAt ) . trim ( ) . length ( ) ) { ret . add ( in . substring ( begin , p . beginsAt ) . trim ( ) ) ; } int afterPieceMarker = p . beginsAt + p . spec . getLengthRightSpaced ( ) ; Piece nextP = getNextToplevelPiece ( afterPieceMarker , upperIn ) ; if ( null = = nextP . spec ) { ret . add ( in . substring ( p . beginsAt ) . trim ( ) ) ; begin = in . length ( ) ; } else { if ( PieceMarkerSpec . TYPE_PIECE_MARKER_AT_END = = nextP . spec . getType ( ) ) { if ( nextP . beginsAt + nextP . spec . getLengthRightSpaced ( ) < in . length ( ) ) { ret . add ( in . substring ( p . beginsAt , nextP . beginsAt + nextP . spec . getLengthRightSpaced ( ) ) . trim ( ) ) ; } else { ret . add ( in . substring ( p . beginsAt ) . trim ( ) ) ; } begin = nextP . beginsAt + nextP . spec . getLengthRightSpaced ( ) ; } else { ret . add ( in . substring ( p . beginsAt , nextP . beginsAt ) . trim ( ) ) ; begin = nextP . beginsAt ; } } break ; case PieceMarkerSpec . TYPE_PIECE_MARKER_AT_END : if ( p . beginsAt + p . spec . getLengthRightSpaced ( ) < in . length ( ) ) { ret . add ( in . substring ( begin , p . beginsAt + p . spec . getLengthRightSpaced ( ) ) . trim ( ) ) ; } else { ret . add ( in . substring ( begin ) . trim ( ) ) ; } begin = p . beginsAt + p . spec . getLengthRightSpaced ( ) ; break ; case PieceMarkerSpec . TYPE_PIECE_MARKER_IN_OWN_PIECE : if ( begin < p . beginsAt & & 0 < in . substring ( begin , p . beginsAt ) . trim ( ) . length ( ) ) { ret . add ( in . substring ( begin , p . beginsAt ) . trim ( ) ) ; } if ( p . beginsAt + p . spec . getLengthRightSpaced ( ) < in . length ( ) ) { ret . add ( in . substring ( p . beginsAt , p . beginsAt + p . spec . getLengthRightSpaced ( ) ) . trim ( ) ) ; } else { ret . add ( in . substring ( p . beginsAt ) . trim ( ) ) ; } begin = p . beginsAt + p . spec . getLengthRightSpaced ( ) ; break ; } } } return ret . toArray ( new String [ ret . size ( ) ] ) ; }
void test1 ( ) throws Throwable { PieceMarkerSpec [ ] pieceMarkerSpecArray0 = new PieceMarkerSpec [ 12 ] ; PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( "C" , 2 ) ; pieceMarkerSpecArray0 [ 0 ] = pieceMarkerSpec0 ; CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 1 ] ; CommentSpec commentSpec0 = new CommentSpec ( "C" , "C" ) ; commentSpecArray0 [ 0 ] = commentSpec0 ; CodeReformatorKernel codeReformatorKernel0 = new CodeReformatorKernel ( "C" , pieceMarkerSpecArray0 , commentSpecArray0 ) ; pieceMarkerSpecArray0 [ 1 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 2 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 3 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 4 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 5 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 6 ] = pieceMarkerSpecArray0 [ 0 ] ; pieceMarkerSpecArray0 [ 7 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 8 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 9 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 10 ] = pieceMarkerSpec0 ; pieceMarkerSpecArray0 [ 11 ] = pieceMarkerSpec0 ; String [ ] stringArray0 = codeReformatorKernel0 . toPieces ( "%Ob$ ? 3 / #MW ] cV" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] toPieces ( String in ) { _statesOfPosition = getStatesOfPosition ( in ) ; Vector < String > ret = new Vector < String > ( ) ; / / toUpperCase replaces the German ß by ss . / / This will kill reformating later . / / Since upperIn is just for building pieces / / it is OK to place ß here . String upperIn = in . replaceAll ( "ß" , "s" ) ; upperIn = upperIn . toUpperCase ( ) ; int begin = 0 ; while ( begin < in . length ( ) ) { Piece p = getNextToplevelPiece ( begin , upperIn ) ; if ( null = = p . spec ) { ret . add ( in . substring ( begin ) . trim ( ) ) ; begin = in . length ( ) ; } else { int type = p . spec . getType ( ) ; switch ( type ) { case PieceMarkerSpec . TYPE_PIECE_MARKER_AT_BEGIN : if ( begin < p . beginsAt & & 0 < in . substring ( begin , p . beginsAt ) . trim ( ) . length ( ) ) { ret . add ( in . substring ( begin , p . beginsAt ) . trim ( ) ) ; } int afterPieceMarker = p . beginsAt + p . spec . getLengthRightSpaced ( ) ; Piece nextP = getNextToplevelPiece ( afterPieceMarker , upperIn ) ; if ( null = = nextP . spec ) { ret . add ( in . substring ( p . beginsAt ) . trim ( ) ) ; begin = in . length ( ) ; } else { if ( PieceMarkerSpec . TYPE_PIECE_MARKER_AT_END = = nextP . spec . getType ( ) ) { if ( nextP . beginsAt + nextP . spec . getLengthRightSpaced ( ) < in . length ( ) ) { ret . add ( in . substring ( p . beginsAt , nextP . beginsAt + nextP . spec . getLengthRightSpaced ( ) ) . trim ( ) ) ; } else { ret . add ( in . substring ( p . beginsAt ) . trim ( ) ) ; } begin = nextP . beginsAt + nextP . spec . getLengthRightSpaced ( ) ; } else { ret . add ( in . substring ( p . beginsAt , nextP . beginsAt ) . trim ( ) ) ; begin = nextP . beginsAt ; } } break ; case PieceMarkerSpec . TYPE_PIECE_MARKER_AT_END : if ( p . beginsAt + p . spec . getLengthRightSpaced ( ) < in . length ( ) ) { ret . add ( in . substring ( begin , p . beginsAt + p . spec . getLengthRightSpaced ( ) ) . trim ( ) ) ; } else { ret . add ( in . substring ( begin ) . trim ( ) ) ; } begin = p . beginsAt + p . spec . getLengthRightSpaced ( ) ; break ; case PieceMarkerSpec . TYPE_PIECE_MARKER_IN_OWN_PIECE : if ( begin < p . beginsAt & & 0 < in . substring ( begin , p . beginsAt ) . trim ( ) . length ( ) ) { ret . add ( in . substring ( begin , p . beginsAt ) . trim ( ) ) ; } if ( p . beginsAt + p . spec . getLengthRightSpaced ( ) < in . length ( ) ) { ret . add ( in . substring ( p . beginsAt , p . beginsAt + p . spec . getLengthRightSpaced ( ) ) . trim ( ) ) ; } else { ret . add ( in . substring ( p . beginsAt ) . trim ( ) ) ; } begin = p . beginsAt + p . spec . getLengthRightSpaced ( ) ; break ; } } } return ret . toArray ( new String [ ret . size ( ) ] ) ; }
void test2 ( ) throws Throwable { PieceMarkerSpec [ ] pieceMarkerSpecArray0 = new PieceMarkerSpec [ 1 ] ; CommentSpec commentSpec0 = new CommentSpec ( "S " , "S " ) ; PieceMarkerSpec pieceMarkerSpec0 = new PieceMarkerSpec ( "S " , 0 ) ; pieceMarkerSpecArray0 [ 0 ] = pieceMarkerSpec0 ; CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 7 ] ; commentSpecArray0 [ 0 ] = commentSpec0 ; commentSpecArray0 [ 1 ] = commentSpec0 ; commentSpecArray0 [ 2 ] = commentSpecArray0 [ 0 ] ; commentSpecArray0 [ 3 ] = commentSpecArray0 [ 0 ] ; commentSpecArray0 [ 4 ] = commentSpec0 ; commentSpecArray0 [ 5 ] = commentSpecArray0 [ 2 ] ; commentSpecArray0 [ 6 ] = commentSpecArray0 [ 2 ] ; CodeReformatorKernel codeReformatorKernel0 = new CodeReformatorKernel ( "S " , pieceMarkerSpecArray0 , commentSpecArray0 ) ; String [ ] stringArray0 = codeReformatorKernel0 . toPieces ( "S " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] toPieces ( String in ) { _statesOfPosition = getStatesOfPosition ( in ) ; Vector < String > ret = new Vector < String > ( ) ; / / toUpperCase replaces the German ß by ss . / / This will kill reformating later . / / Since upperIn is just for building pieces / / it is OK to place ß here . String upperIn = in . replaceAll ( "ß" , "s" ) ; upperIn = upperIn . toUpperCase ( ) ; int begin = 0 ; while ( begin < in . length ( ) ) { Piece p = getNextToplevelPiece ( begin , upperIn ) ; if ( null = = p . spec ) { ret . add ( in . substring ( begin ) . trim ( ) ) ; begin = in . length ( ) ; } else { int type = p . spec . getType ( ) ; switch ( type ) { case PieceMarkerSpec . TYPE_PIECE_MARKER_AT_BEGIN : if ( begin < p . beginsAt & & 0 < in . substring ( begin , p . beginsAt ) . trim ( ) . length ( ) ) { ret . add ( in . substring ( begin , p . beginsAt ) . trim ( ) ) ; } int afterPieceMarker = p . beginsAt + p . spec . getLengthRightSpaced ( ) ; Piece nextP = getNextToplevelPiece ( afterPieceMarker , upperIn ) ; if ( null = = nextP . spec ) { ret . add ( in . substring ( p . beginsAt ) . trim ( ) ) ; begin = in . length ( ) ; } else { if ( PieceMarkerSpec . TYPE_PIECE_MARKER_AT_END = = nextP . spec . getType ( ) ) { if ( nextP . beginsAt + nextP . spec . getLengthRightSpaced ( ) < in . length ( ) ) { ret . add ( in . substring ( p . beginsAt , nextP . beginsAt + nextP . spec . getLengthRightSpaced ( ) ) . trim ( ) ) ; } else { ret . add ( in . substring ( p . beginsAt ) . trim ( ) ) ; } begin = nextP . beginsAt + nextP . spec . getLengthRightSpaced ( ) ; } else { ret . add ( in . substring ( p . beginsAt , nextP . beginsAt ) . trim ( ) ) ; begin = nextP . beginsAt ; } } break ; case PieceMarkerSpec . TYPE_PIECE_MARKER_AT_END : if ( p . beginsAt + p . spec . getLengthRightSpaced ( ) < in . length ( ) ) { ret . add ( in . substring ( begin , p . beginsAt + p . spec . getLengthRightSpaced ( ) ) . trim ( ) ) ; } else { ret . add ( in . substring ( begin ) . trim ( ) ) ; } begin = p . beginsAt + p . spec . getLengthRightSpaced ( ) ; break ; case PieceMarkerSpec . TYPE_PIECE_MARKER_IN_OWN_PIECE : if ( begin < p . beginsAt & & 0 < in . substring ( begin , p . beginsAt ) . trim ( ) . length ( ) ) { ret . add ( in . substring ( begin , p . beginsAt ) . trim ( ) ) ; } if ( p . beginsAt + p . spec . getLengthRightSpaced ( ) < in . length ( ) ) { ret . add ( in . substring ( p . beginsAt , p . beginsAt + p . spec . getLengthRightSpaced ( ) ) . trim ( ) ) ; } else { ret . add ( in . substring ( p . beginsAt ) . trim ( ) ) ; } begin = p . beginsAt + p . spec . getLengthRightSpaced ( ) ; break ; } } } return ret . toArray ( new String [ ret . size ( ) ] ) ; }
void test5 ( ) throws Throwable { PieceMarkerSpec [ ] pieceMarkerSpecArray0 = new PieceMarkerSpec [ 4 ] ; CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 4 ] ; CommentSpec commentSpec0 = new CommentSpec ( " } > U ( ShZwZ } xc" , " } > U ( ShZwZ } xc" ) ; commentSpecArray0 [ 0 ] = commentSpec0 ; commentSpecArray0 [ 1 ] = commentSpec0 ; commentSpecArray0 [ 2 ] = commentSpecArray0 [ 0 ] ; commentSpecArray0 [ 3 ] = commentSpec0 ; CodeReformatorKernel codeReformatorKernel0 = new CodeReformatorKernel ( " } > U ( ShZwZ } xc" , pieceMarkerSpecArray0 , commentSpecArray0 ) ; StateOfPosition [ ] stateOfPositionArray0 = codeReformatorKernel0 . getStatesOfPosition ( "tEX | W ; r ) J { 8 } y'QGcR" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" StateOfPosition [ ] getStatesOfPosition ( String in ) { StateOfPosition [ ] ret = new StateOfPosition [ in . length ( ) ] ; StateOfPosition buf = new StateOfPosition ( ) ; for ( int i = 0 ; i < in . length ( ) ; + + i ) { if ( '\'' = = in . charAt ( i ) ) { + + buf . literalSepCount ; } if ( 0 = = buf . literalSepCount % 2 ) { for ( int j = 0 ; j < _commentSpecs . length ; + + j ) { if ( in . substring ( i ) . startsWith ( _commentSpecs [ j ] . commentBegin ) ) { if ( - 1 = = buf . commentIndex ) { buf . commentIndex = j ; } } if ( in . substring ( i ) . startsWith ( _commentSpecs [ j ] . commentEnd ) ) { if ( j = = buf . commentIndex ) { buf . commentIndex = - 1 ; } } } } if ( 0 = = buf . literalSepCount % 2 & & - 1 = = buf . commentIndex ) { if ( ' ( ' = = in . charAt ( i ) ) { + + buf . braketDepth ; } if ( ' ) ' = = in . charAt ( i ) ) { - - buf . braketDepth ; } } if ( - 1 = = buf . commentIndex & & 0 = = buf . literalSepCount % 2 & & 0 = = buf . braketDepth ) { buf . isTopLevel = true ; } else { buf . isTopLevel = false ; } ret [ i ] = ( StateOfPosition ) buf . clone ( ) ; } return ret ; }
void test1 ( ) throws Throwable { CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 5 ] ; CommentSpec commentSpec0 = new CommentSpec ( " | " , " | " ) ; commentSpecArray0 [ 1 ] = commentSpec0 ; commentSpecArray0 [ 3 ] = commentSpec0 ; commentSpecArray0 [ 4 ] = commentSpecArray0 [ 3 ] ; ArrayList < PieceMarkerSpec > arrayList0 = new ArrayList < PieceMarkerSpec > ( ) ; commentSpecArray0 [ 0 ] = commentSpec0 ; commentSpecArray0 [ 2 ] = commentSpec0 ; CodeReformatorConfig codeReformatorConfig0 = new CodeReformatorConfig ( " | " , commentSpecArray0 , " | " , ( - 474 ) , false , arrayList0 ) ; CodeReformator codeReformator0 = new CodeReformator ( codeReformatorConfig0 ) ; String string0 = codeReformator0 . reformat ( "i'9" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String reformat ( String in ) { in = flatenWhiteSpaces ( in , false ) ; PieceMarkerSpec [ ] markerExcludeComma = createPieceMarkerSpecExcludeColon ( ) ; String [ ] pieces = getReformatedPieces ( in , markerExcludeComma ) . toArray ( new String [ 0 ] ) ; if ( _codeReformatorConfig . isDoInsertValuesAlign ( ) ) { pieces = doInsertSpecial ( pieces ) ; } StringBuffer ret = new StringBuffer ( ) ; int braketCount = 0 ; for ( int i = 0 ; i < pieces . length ; + + i ) { if ( " ) " . equals ( pieces [ i ] ) ) { - - braketCount ; } ret . append ( indent ( pieces [ i ] , braketCount ) ) ; ret . append ( _lineSep ) ; if ( " ( " . equals ( pieces [ i ] ) ) { + + braketCount ; } } validate ( in , ret . toString ( ) ) ; return ret . toString ( ) ; }
void test4 ( ) throws Throwable { CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 7 ] ; CommentSpec commentSpec0 = new CommentSpec ( " ] using classloader . getsystemresource ( ) . ( ) . " , " ] using classloader . getsystemresource ( ) . ( ) . " ) ; commentSpecArray0 [ 0 ] = commentSpec0 ; commentSpecArray0 [ 1 ] = commentSpec0 ; commentSpecArray0 [ 2 ] = commentSpecArray0 [ 0 ] ; commentSpecArray0 [ 3 ] = commentSpecArray0 [ 0 ] ; commentSpecArray0 [ 4 ] = commentSpecArray0 [ 1 ] ; commentSpecArray0 [ 5 ] = commentSpec0 ; commentSpecArray0 [ 6 ] = commentSpec0 ; ArrayList < PieceMarkerSpec > arrayList0 = new ArrayList < PieceMarkerSpec > ( ) ; CodeReformatorConfig codeReformatorConfig0 = new CodeReformatorConfig ( " ] using classloader . getsystemresource ( ) . ( ) . " , commentSpecArray0 , " ] using classloader . getsystemresource ( ) . ( ) . " , ( - 1407 ) , true , arrayList0 ) ; CodeReformator codeReformator0 = new CodeReformator ( codeReformatorConfig0 ) ; String string0 = codeReformator0 . reformat ( " ] using classloader . getsystemresource ( ) . ( ) . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String reformat ( String in ) { in = flatenWhiteSpaces ( in , false ) ; PieceMarkerSpec [ ] markerExcludeComma = createPieceMarkerSpecExcludeColon ( ) ; String [ ] pieces = getReformatedPieces ( in , markerExcludeComma ) . toArray ( new String [ 0 ] ) ; if ( _codeReformatorConfig . isDoInsertValuesAlign ( ) ) { pieces = doInsertSpecial ( pieces ) ; } StringBuffer ret = new StringBuffer ( ) ; int braketCount = 0 ; for ( int i = 0 ; i < pieces . length ; + + i ) { if ( " ) " . equals ( pieces [ i ] ) ) { - - braketCount ; } ret . append ( indent ( pieces [ i ] , braketCount ) ) ; ret . append ( _lineSep ) ; if ( " ( " . equals ( pieces [ i ] ) ) { + + braketCount ; } } validate ( in , ret . toString ( ) ) ; return ret . toString ( ) ; }
void test5 ( ) throws Throwable { CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 8 ] ; CommentSpec commentSpec0 = new CommentSpec ( "Tm4O7 , + & 3KFer`3" , "Tm4O7 , + & 3KFer`3" ) ; commentSpecArray0 [ 2 ] = commentSpec0 ; commentSpecArray0 [ 3 ] = commentSpec0 ; ArrayList < PieceMarkerSpec > arrayList0 = new ArrayList < PieceMarkerSpec > ( ) ; CommentSpec [ ] commentSpecArray1 = new CommentSpec [ 6 ] ; commentSpecArray1 [ 0 ] = commentSpecArray0 [ 2 ] ; commentSpecArray1 [ 1 ] = commentSpec0 ; CodeReformatorConfig codeReformatorConfig0 = new CodeReformatorConfig ( " < , " , commentSpecArray1 , "Tm4O7 , + & 3KFer`3" , ( - 2013 ) , true , arrayList0 ) ; CodeReformator codeReformator0 = new CodeReformator ( codeReformatorConfig0 ) ; commentSpecArray1 [ 2 ] = commentSpecArray1 [ 1 ] ; commentSpecArray1 [ 3 ] = commentSpecArray0 [ 3 ] ; commentSpecArray1 [ 4 ] = commentSpecArray1 [ 0 ] ; CommentSpec commentSpec1 = new CommentSpec ( " < , " , "does not have a class function tolevel ( does not have a class function tolevel ( string , level ) string , does not have a class function tolevel ( string , level ) level ) " ) ; commentSpecArray1 [ 5 ] = commentSpec1 ; String string0 = codeReformator0 . reformat ( " < , " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String reformat ( String in ) { in = flatenWhiteSpaces ( in , false ) ; PieceMarkerSpec [ ] markerExcludeComma = createPieceMarkerSpecExcludeColon ( ) ; String [ ] pieces = getReformatedPieces ( in , markerExcludeComma ) . toArray ( new String [ 0 ] ) ; if ( _codeReformatorConfig . isDoInsertValuesAlign ( ) ) { pieces = doInsertSpecial ( pieces ) ; } StringBuffer ret = new StringBuffer ( ) ; int braketCount = 0 ; for ( int i = 0 ; i < pieces . length ; + + i ) { if ( " ) " . equals ( pieces [ i ] ) ) { - - braketCount ; } ret . append ( indent ( pieces [ i ] , braketCount ) ) ; ret . append ( _lineSep ) ; if ( " ( " . equals ( pieces [ i ] ) ) { + + braketCount ; } } validate ( in , ret . toString ( ) ) ; return ret . toString ( ) ; }
void test6 ( ) throws Throwable { CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 5 ] ; CommentSpec commentSpec0 = new CommentSpec ( " | " , " | " ) ; commentSpecArray0 [ 1 ] = commentSpec0 ; commentSpecArray0 [ 3 ] = commentSpec0 ; commentSpecArray0 [ 4 ] = commentSpecArray0 [ 3 ] ; ArrayList < PieceMarkerSpec > arrayList0 = new ArrayList < PieceMarkerSpec > ( ) ; commentSpecArray0 [ 0 ] = commentSpec0 ; commentSpecArray0 [ 2 ] = commentSpec0 ; CodeReformatorConfig codeReformatorConfig0 = new CodeReformatorConfig ( " | " , commentSpecArray0 , " | " , ( - 474 ) , false , arrayList0 ) ; CodeReformator codeReformator0 = new CodeReformator ( codeReformatorConfig0 ) ; commentSpecArray0 [ 4 ] . commentEnd = "i'9\n" ; String string0 = codeReformator0 . reformat ( " | " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String reformat ( String in ) { in = flatenWhiteSpaces ( in , false ) ; PieceMarkerSpec [ ] markerExcludeComma = createPieceMarkerSpecExcludeColon ( ) ; String [ ] pieces = getReformatedPieces ( in , markerExcludeComma ) . toArray ( new String [ 0 ] ) ; if ( _codeReformatorConfig . isDoInsertValuesAlign ( ) ) { pieces = doInsertSpecial ( pieces ) ; } StringBuffer ret = new StringBuffer ( ) ; int braketCount = 0 ; for ( int i = 0 ; i < pieces . length ; + + i ) { if ( " ) " . equals ( pieces [ i ] ) ) { - - braketCount ; } ret . append ( indent ( pieces [ i ] , braketCount ) ) ; ret . append ( _lineSep ) ; if ( " ( " . equals ( pieces [ i ] ) ) { + + braketCount ; } } validate ( in , ret . toString ( ) ) ; return ret . toString ( ) ; }
void test0 ( ) throws Throwable { FormatSqlPref formatSqlPref0 = new FormatSqlPref ( ) ; CodeReformatorConfig codeReformatorConfig0 = CodeReformatorConfigFactory . createConfig ( formatSqlPref0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStatementSeparator ( ) { if ( null = = _session ) { return " ; " ; } else { return _session . getProperties ( ) . getSQLStatementSeparator ( ) ; } }
void test1 ( ) throws Throwable { CodeReformatorConfigFactory codeReformatorConfigFactory0 = new CodeReformatorConfigFactory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test2 ( ) throws Throwable { CodeReformatorConfig codeReformatorConfig0 = CodeReformatorConfigFactory . createConfig ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStatementSeparator ( ) { if ( null = = _session ) { return " ; " ; } else { return _session . getProperties ( ) . getSQLStatementSeparator ( ) ; } }
void test0 ( ) throws Throwable { CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 5 ] ; ArrayList < PieceMarkerSpec > arrayList0 = new ArrayList < PieceMarkerSpec > ( ) ; CodeReformatorConfig codeReformatorConfig0 = new CodeReformatorConfig ( "" , commentSpecArray0 , " ( On ? eP3 , SNaIf ) Tk" , 953 , false , arrayList0 ) ; boolean boolean0 = codeReformatorConfig0 . isDoInsertValuesAlign ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTrySplitLineLen ( ) { return _trySplitLineLen ; }
void test1 ( ) throws Throwable { CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 10 ] ; ArrayList < PieceMarkerSpec > arrayList0 = new ArrayList < PieceMarkerSpec > ( ) ; CodeReformatorConfig codeReformatorConfig0 = new CodeReformatorConfig ( " ) ^ ? : qj . ] Ple@ } " , commentSpecArray0 , " ) ^ ? : qj . ] Ple@ } " , 452 , false , arrayList0 ) ; int int0 = codeReformatorConfig0 . getTrySplitLineLen ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDoInsertValuesAlign ( ) { return _doInsertValuesAlign ; }
void test2 ( ) throws Throwable { CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 7 ] ; ArrayList < PieceMarkerSpec > arrayList0 = new ArrayList < PieceMarkerSpec > ( ) ; CodeReformatorConfig codeReformatorConfig0 = new CodeReformatorConfig ( " ] 1 ! #m9A ? x#E6 ? } x" , commentSpecArray0 , " ] 1 ! #m9A ? x#E6 ? } x" , ( - 1 ) , true , arrayList0 ) ; String string0 = codeReformatorConfig0 . getStatementSeparator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTrySplitLineLen ( ) { return _trySplitLineLen ; }
void test3 ( ) throws Throwable { CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 6 ] ; ArrayList < PieceMarkerSpec > arrayList0 = new ArrayList < PieceMarkerSpec > ( ) ; CodeReformatorConfig codeReformatorConfig0 = new CodeReformatorConfig ( "" , commentSpecArray0 , "" , 1 , true , arrayList0 ) ; String string0 = codeReformatorConfig0 . getIndent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTrySplitLineLen ( ) { return _trySplitLineLen ; }
void test4 ( ) throws Throwable { CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 2 ] ; ArrayList < PieceMarkerSpec > arrayList0 = new ArrayList < PieceMarkerSpec > ( 1 ) ; CodeReformatorConfig codeReformatorConfig0 = new CodeReformatorConfig ( " ( XWhx ? C / " , commentSpecArray0 , " ( XWhx ? C / " , 1873 , false , arrayList0 ) ; CommentSpec [ ] commentSpecArray1 = codeReformatorConfig0 . getCommentSpecs ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDoInsertValuesAlign ( ) { return _doInsertValuesAlign ; }
void test5 ( ) throws Throwable { CommentSpec [ ] commentSpecArray0 = new CommentSpec [ 2 ] ; ArrayList < PieceMarkerSpec > arrayList0 = new ArrayList < PieceMarkerSpec > ( 1 ) ; CodeReformatorConfig codeReformatorConfig0 = new CodeReformatorConfig ( "" , commentSpecArray0 , "" , 1 , true , arrayList0 ) ; PieceMarkerSpec [ ] pieceMarkerSpecArray0 = codeReformatorConfig0 . getKeywordPieceMarkerSpecs ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDoInsertValuesAlign ( ) { return _doInsertValuesAlign ; }
void test0 ( ) throws Throwable { UidIdentifierBeanInfo uidIdentifierBeanInfo0 = new UidIdentifierBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = uidIdentifierBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { IntegerIdentifier integerIdentifier0 = new IntegerIdentifier ( ( - 197 ) ) ; int int0 = integerIdentifier0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test2 ( ) throws Throwable { IntegerIdentifier integerIdentifier0 = new IntegerIdentifier ( 1638 ) ; boolean boolean0 = integerIdentifier0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { IntegerIdentifier integerIdentifier0 = new IntegerIdentifier ( ( - 973 ) ) ; Object object0 = new Object ( ) ; boolean boolean0 = integerIdentifier0 . equals ( object0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test4 ( ) throws Throwable { IntegerIdentifier integerIdentifier0 = new IntegerIdentifier ( 1638 ) ; boolean boolean0 = integerIdentifier0 . equals ( ( Object ) integerIdentifier0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { IntegerIdentifierFactory integerIdentifierFactory0 = new IntegerIdentifierFactory ( ) ; IntegerIdentifier integerIdentifier0 = ( IntegerIdentifier ) integerIdentifierFactory0 . createIdentifier ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { UidIdentifier uidIdentifier0 = new UidIdentifier ( ) ; uidIdentifier0 . setString ( "yCoM" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { UidIdentifier uidIdentifier0 = new UidIdentifier ( ) ; int int0 = uidIdentifier0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { UidIdentifier uidIdentifier0 = new UidIdentifier ( ) ; boolean boolean0 = uidIdentifier0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { UidIdentifier uidIdentifier0 = new UidIdentifier ( ) ; boolean boolean0 = uidIdentifier0 . equals ( ( Object ) uidIdentifier0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test4 ( ) throws Throwable { UidIdentifier uidIdentifier0 = new UidIdentifier ( ) ; Object object0 = new Object ( ) ; boolean boolean0 = uidIdentifier0 . equals ( object0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { Vector < String > vector0 = new Vector < String > ( ) ; ConstraintInfo constraintInfo0 = new ConstraintInfo ( "9 ? / ] vz ; 9" , "9 ? / ] vz ; 9" , "9 ? / ] vz ; 9" , "9 ? / ] vz ; 9" , "9 ? / ] vz ; 9" , vector0 , vector0 , ( short ) ( - 1237 ) , ( short ) ( - 1237 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ConstraintInfo ( String fkTable , String fkTableSchema , String pkTable , String pkTableSchema , String fkName , Vector < String > fkCols , Vector < String > pkCols , short deleteRule , short updateRule ) { this . fkTable = fkTable ; this . fkTableSchema = fkTableSchema ; this . pkTable = pkTable ; this . pkTableSchema = pkTableSchema ; this . fkName = fkName ; this . fkCols = fkCols ; this . pkCols = pkCols ; this . deleteRule = deleteRule ; this . updateRule = updateRule ; }
void test1 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsAccessMethods ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAccessMethods ( ) { return true ; }
void test2 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test3 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsDropIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropIndex ( ) { return true ; }
void test4 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test5 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; String string0 = daffodilDialectExt0 . getColumnDropSQL ( "Null 8x' vrgument . " , "Null 8x' vrgument . " , databaseObjectQualifier0 , ( SqlGenerationPreferences ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { StringTemplate st = new StringTemplate ( DROP_COLUMN_SQL_TEMPLATE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_COLUMN_NAME_KEY , columnName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test6 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsDropConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropConstraint ( ) { return true ; }
void test7 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test8 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " ] X^# ) " , " ] X^# ) " ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = daffodilDialectExt0 . getAlterSequenceSQL ( " ] X^# ) " , " ] X^# ) " , " ] X^# ) " , " ] X^# ) " , " ] X^# ) " , " ] X^# ) " , true , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER SEQUENCE $sequenceName$ " + / / "$restartWith$ $startValue$ " + / / "$incrementBy$ $incrementValue$ " ; StringTemplate st = new StringTemplate ( ST_ALTER_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( restart ) ) { valuesMap . put ( ST_RESTART_WITH_KEY , "RESTART WITH" ) ; valuesMap . put ( ST_START_VALUE_KEY , restart ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_BY_KEY , "INCREMENT BY" ) ; valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test9 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsMultipleRowInserts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsMultipleRowInserts ( ) { return true ; }
void test10 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsEmptyTables ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsEmptyTables ( ) { return true ; }
void test11 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; DialectType dialectType0 = daffodilDialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DialectType getDialectType ( ) { return DialectFactory . getDialectType ( getSession ( ) . getMetaData ( ) ) ; }
void test12 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test13 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test18 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test19 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsTablespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTablespace ( ) { return false ; }
void test20 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsCreateView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateView ( ) { return true ; }
void test21 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ( String ) null , "jxa" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = daffodilDialectExt0 . getDropForeignKeySQL ( "jxa" , "jxa" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test22 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "Found pr" , "Found pr" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = daffodilDialectExt0 . getCreateViewSQL ( "Found pr" , "Found pr" , "Found pr" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE [ FORCE ] VIEW [ IF NOT EXISTS ] newViewName [ ( columnName [ , . . ] ) ] / / AS select / / "CREATE VIEW $viewName$ " + / / "AS $selectStatement$ $with$ $checkOptionType$ $checkOption$" ; StringTemplate st = new StringTemplate ( ST_CREATE_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName , ST_SELECT_STATEMENT_KEY , definition ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test24 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsAddUniqueConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddUniqueConstraint ( ) { return true ; }
void test25 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test27 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; String [ ] stringArray0 = daffodilDialectExt0 . getIndexAccessMethodsTypes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexAccessMethodsTypes ( ) { return new String [ ] { "DEFAULT" , "HASH" } ; }
void test28 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsAddColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddColumn ( ) { return true ; }
void test29 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsSubSecondTimestamps ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSubSecondTimestamps ( ) { return false ; }
void test30 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsIndexes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsIndexes ( ) { return true ; }
void test32 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsDropColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropColumn ( ) { return true ; }
void test33 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; String [ ] stringArray0 = daffodilDialectExt0 . getIndexStorageOptions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexStorageOptions ( ) { return null ; }
void test35 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test36 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsCreateIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateIndex ( ) { return true ; }
void test37 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test38 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsAlterSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test39 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; String string0 = daffodilDialectExt0 . getAddColumnString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAddColumnString ( ) ; / * * * Returns the SQL used to alter the nullability of the specified column * * @param info * the column to modify * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL to execute * / String [ ] getColumnNullableAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports renaming columns . * * @return true if the database supports changing the name of columns ; false * otherwise . * / boolean supportsRenameColumn ( ) ; / * * * Returns the SQL that is used to change the column name . * * @param from * the TableColumnInfo as it is * @param to * the TableColumnInfo as it wants to be * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL to make the change * / String getColumnNameAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns a boolean value indicating whether or not this dialect supports * modifying a columns type . * * @return true if supported ; false otherwise * / boolean supportsAlterColumnType ( ) ; / * * * Returns the SQL that is used to change the column type . * * @param from * the TableColumnInfo as it is * @param to * the TableColumnInfo as it wants to be * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL to make the change * @throw UnsupportedOperationException if the database doesn't support * modifying column types . * / List < String > getColumnTypeAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException ; / * * * Returns a boolean value indicating whether or not this database dialect * supports changing a column's default value . * * @return true if the database supports modifying column defaults ; false * otherwise * / boolean supportsAlterColumnDefault ( ) ; / * * * Returns the SQL command to change the specified column's default value * * @param info * the column to modify and it's default value . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return SQL to make the change * / String getColumnDefaultAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL command to drop the specified table's primary key . * * @param pkName * the name of the primary key that should be dropped * @param tableName * the name of the table whose primary key should be dropped * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * / String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL command to drop the specified table's foreign key * constraint . * * @param fkName * the name of the foreign key that should be dropped * @param tableName * the name of the table whose foreign key should be dropped * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * / String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL command to create the specified table ( columns appear in * the same order as they are stored in the database ) . * * @param tables * the tables to get create statements for * @param md * the metadata from the ISession * @param prefs * preferences about how the resultant SQL commands should be * formed . * @param isJdbcOdbc * whether or not the connection is via JDBC - ODBC bridge . * @return the SQL that is used to create the specified table * / List < String > getCreateTableSQL ( List < ITableInfo > tables , ISQLDatabaseMetaData md , CreateScriptPreferences prefs , boolean isJdbcOdbc ) throws SQLException ; / * * * Returns the SQL command to create the specified table . Optionally , if * sortColumns is true , colums will be sorted by column name in ascending * order . * * @param tables * the tables to get create statements for * @param md * the metadata from the ISession * @param prefs * preferences about how the resultant SQL commands should be * formed . * @param isJdbcOdbc * whether or not the connection is via JDBC - ODBC bridge . * @param sortColumns * whether or not to sort columns according to their column name . * * @return the SQL that is used to create the specified table * / List < String > getCreateTableSQL ( List < ITableInfo > tables , ISQLDatabaseMetaData md , CreateScriptPreferences prefs , boolean isJdbcOdbc , boolean sortColumns ) throws SQLException ; / * * * Returns the DialectType enum value associated with this dialect . * * @return the DialectType * / DialectType getDialectType ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports sequences . * * @return true if the database supports sequence ; false otherwise . * / boolean supportsSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * suports tablespaces . Specifically , when creating an index , some databases * allow a tablespace to be specified to create the index in , recognizing * that indexes can be quite large . * * @return true if the database supports tablespaces ; false otherwise . * / boolean supportsTablespace ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports indexes . * * @return true if the database supports indexes ; false otherwise . * / boolean supportsIndexes ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports access methods . * * @return true if the database supports access methods ; false otherwise . * / boolean supportsAccessMethods ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports auto - increment on columns . * * @return true if the database supports auto - increment ; false otherwise . * / boolean supportsAutoIncrement ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports check options for views . * * @return true if the database supports check options for views ; false * otherwise . * / boolean supportsCheckOptionsForViews ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports empty tables . * * @return true if the database supports empty tables ; false otherwise . * / boolean supportsEmptyTables ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports the optional SQL feature "row value constructors" ( F641 ) that * allows to insert multiple rows in a single insert statement . * * @return true if the database supports multiple row inserts ; false * otherwise . * / boolean supportsMultipleRowInserts ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports adding columns to existing tables * * @return true if the database supports adding columns ; false otherwise . * / boolean supportsAddColumn ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports adding foreign key constraints . * * @return true if the database supports adding foreign key constraints ; * false otherwise . * / boolean supportsAddForeignKeyConstraint ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports adding unique constraints . * * @return true if the database supports adding unique constraints ; false * otherwise . * / boolean supportsAddUniqueConstraint ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports altering sequences . * * @return true if the database supports altering sequences ; false * otherwise . * / boolean supportsAlterSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating indexes . * * @return true if the database supports creating indexes ; false otherwise . * / boolean supportsCreateIndex ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating sequences . * * @return true if the database supports creating sequences ; false * otherwise . * / boolean supportsCreateSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating tables . * * @return true if the database supports creating tables ; false otherwise . * / boolean supportsCreateTable ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating views . * * @return true if the database supports creating views ; false otherwise . * / boolean supportsCreateView ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping constraints . * * @return true if the database supports dropping constraints ; false * otherwise . * / boolean supportsDropConstraint ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping indexes . * * @return true if the database supports dropping indexes ; false otherwise . * / boolean supportsDropIndex ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping sequences . * * @return true if the database supports dropping sequences ; false * otherwise . * / boolean supportsDropSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping views . * * @return true if the database supports dropping views ; false otherwise . * / boolean supportsDropView ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports inserting rows . * * @return true if the database supports inserting rows ; false otherwise . * / boolean supportsInsertInto ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports renaming tables . * * @return true if the database supports renaming tables ; false otherwise . * / boolean supportsRenameTable ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports renaming views . * * @return true if the database supports renaming views ; false otherwise . * / boolean supportsRenameView ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports gathering information about sequences . * * @return true if the database supports gathering information about * sequences ; false otherwise . * / boolean supportsSequenceInformation ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports updating rows . * * @return true if the database supports updating rows ; false otherwise . * / boolean supportsUpdate ( ) ; / * * * Gets the index access methods that this dialect supports used when * creating indexes . * * @return all the access methods supported by this dialect . * / String [ ] getIndexAccessMethodsTypes ( ) ; / * * * Gets the index storage options that this dialect supports used when * creating indexes . * * @return all the access methods supported by this dialect . * / String [ ] getIndexStorageOptions ( ) ; / * * * Gets the SQL command to create a new table . * * @param tableName * simple name of the table * @param columns * columns of the table * @param primaryKeys * primary keys of the table * @param prefs * preferences for generated sql scripts * @param qualifier * qualifier of the table * @return the sql command to create a table . * / String getCreateTableSQL ( String tableName , List < TableColumnInfo > columns , List < TableColumnInfo > primaryKeys , SqlGenerationPreferences prefs , DatabaseObjectQualifier qualifier ) ; / * * * Gets the SQL command to rename a table . * * @param oldTableName * old name of the table * @param newTableName * new name of the table * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to rename a table . * / String getRenameTableSQL ( String oldTableName , String newTableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to create a view . * * @param viewName * name of the view * @param definition * old definition of the view . * @param checkOption * CHECK OPTION . CASCADE , LOCAL or null for no check option . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to create a view . * / String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to rename a view . * * @param oldViewName * old name of the view * @param newViewName * new name of the view * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command * / String [ ] getRenameViewSQL ( String oldViewName , String newViewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop a view . * * @param viewName * name of the view * @param cascade * cascade true if automatically drop object that depend on the * view ( such as other views ) . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL command to drop a view . * / String getDropViewSQL ( String viewName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to create an index . * * @param indexName * name of the index to be created * @param tableName * name of the table * @param accessMethod * the index access method to use ( for example , b - tree , r - tree , * hash , etc . ) * @param columns * columns where the index should be stored for * @param unique * true if the index should be unique * @param tablespace * tablespace for the index ( leave empty for no tablespace ) * @param constraints * constraints for the index ( leave empty for no constraints ) * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to create an index . * / String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop an index . * * @param tableName * name of the table that the index indexes . This can be null . * @param indexName * name of the index * @param cascade * true if automatically drop object that depend on the view * ( such as other views ) . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to drop an index . * / String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to create a sequence . * * @param sequenceName * name of the sequence * @param increment * increment value * @param minimum * minimum value ( leave empty for NO MINVALUE ) * @param maximum * maximum value ( leave empty for NO MINVALUE ) * @param start * start value ( leave empty for default ) * @param cache * cache value , how many sequences should be preallocated ( leave * empty for default ) * @param cycle * true if the sequence should wrap around when the max - / minvalue * has been reached ( leave empty for NO CYCLE ) * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to create a sequence . * / String getCreateSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String start , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to alter a sequence . * * @param sequenceName * name of the sequence . * @param increment * increment value . * @param minimum * minimum value . * @param maximum * maximum value . * @param restart * start value . * @param cache * cache value , how many sequences should be preallocated . * @param cycle * true if the sequence should wrap around when the max - / minvalue * has been reached . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command statements * / String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to query the specific database to find out the * information about the sequence . The query should return the following * fields : last_value , max_value , min_value , cache_value , increment_by , * is_cycled * * @param sequenceName * the name of the sequence . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to query the database . * / String getSequenceInformationSQL ( String sequenceName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop a sequence . * * @param sequenceName * name of the sequence * @param cascade * true if automatically drop object that depend on the view * ( such as other views ) . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to drop a sequence . * / String getDropSequenceSQL ( String sequenceName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to add a foreign key constraint to a table . * * @param localTableName * name of the table where the foreign key should be stored . * @param refTableName * name of the table where the foreign key should reference to . * @param constraintName * name of the constraint . Leave it empty and it won't create a * CONSTRAINT name . * @param deferrable * true if the constraint is deferrable , false if not . * @param initiallyDeferred * true if the constraint is deferrable and initially deferred , * false if not . * @param matchFull * true if the referenced columns using MATCH FULL . * @param autoFKIndex * true to create an additional INDEX with the given fkIndexName * Name . * @param fkIndexName * name of the foreign key index name . * @param localRefColumns * local and referenced column collection . In the first Element * of the String Array should be the local column name and in the * second Element the referenced Table column name . * @param onUpdateAction * update action . For example "RESTRICT" . * @param onDeleteAction * delete action . For exampel "NO ACTION" . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add a foreign key constraint . * / String [ ] getAddForeignKeyConstraintSQL ( String localTableName , String refTableName , String constraintName , Boolean deferrable , Boolean initiallyDeferred , Boolean matchFull , boolean autoFKIndex , String fkIndexName , Collection < String [ ] > localRefColumns , String onUpdateAction , String onDeleteAction , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to add a unique constraint to a table . * * @param tableName * name of the table where the unique constraint should be added * to . * @param constraintName * name of the constraint . * @param columns * the unique columns . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add a unique constraint . * / String [ ] getAddUniqueConstraintSQL ( String tableName , String constraintName , TableColumnInfo [ ] columns , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL to add an auto - increment to a column . * * @param column * column to where the auto - increment should be added to . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add auto - increment . * / String [ ] getAddAutoIncrementSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL to add an auto - increment to a column . * * @param column * column to where the auto - increment should be added to . * @param sequenceName * if a sequence is created for the purpose of generating the * next auto - incremented value , then this is the name of the * sequence . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add auto - increment . * / String [ ] getAddAutoIncrementSQL ( TableColumnInfo column , String sequenceName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop a constraint from a table . * * @param tableName * name of the table where the constraint should be dropped from . * @param constraintName * name of the constraint . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to drop a constraint . * / String getDropConstraintSQL ( String tableName , String constraintName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to insert data into a table . * < p / > * If the list of columns is empty or null the SQL will look like : INSERT * INTO tablename valuesPart ; * < p / > * instead of : INSERT INTO tablename ( column1 , column2 , . . . ) valuesPart ; * * @param tableName * simple name of the table * @param columns * columns of the table * @param valuesPart * either a query or a VALUES ( . . . ) string that defines the data * to insert * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to insert data . * / String getInsertIntoSQL ( String tableName , List < String > columns , String valuesPart , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to update the specified columns with the specified * values . * * @param tableName * simple name of the table * @param setColumns * columns to be set * @param setValues * values the columns should be set with * @param fromTables * simple names of the tables in the FROM clause * @param whereColumns * columns in the WHERE clause * @param whereValues * values of the columns in the WHERE clause * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to update data . * / String [ ] getUpdateSQL ( String tableName , String [ ] setColumns , String [ ] setValues , String [ ] fromTables , String [ ] whereColumns , String [ ] whereValues , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to add a column to the specified table . * * @param column * information about the column * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add a column * @throws UnsupportedOperationException * if the database doesn't support adding columns after a table * has already been created . Use supportsAddColumn before * calling this to avoid that . * / String [ ] getAddColumnSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * The character specific to this dialect used to close a quoted identifier . * * @return The dialect's specific close quote character . * / char closeQuote ( ) ; / * * * The character specific to this dialect used to begin a quoted identifier . * * @return The dialect's specific open quote character . * / char openQuote ( ) ; / * * * Whether or not the definition of a view can be determined via a query * that is returned from getViewDefinitionSQL method * * @return true if getViewDefinitionSQL yields a non - null value ; false * otherwise . * / boolean supportsViewDefinition ( ) ; / * * * Returns the SQL that can be used to query the data dictionary for the * body of a view . This should exclude the "CREATE VIEW < viewname > AS" * prefix and just return the query . This can return null if the database * doesn't provide access to this definition . * * @param viewName * the name of the view to get the definition for . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * / String getViewDefinitionSQL ( String viewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the qualified identifier based on the specified qualifier and * user preferences . * * @param identifier * @param qualifier * @param prefs * @return * / String getQualifiedIdentifier ( String identifier , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns a boolean indicating whether or not this dialect supports * correlated sub - queries . * * @return true if support for correlated sub - queries and false otherwise . * / boolean supportsCorrelatedSubQuery ( ) ; / * * * Gets the sequence property mutability , which describes which properties * of a sequence can be changed , and which cannot . * * @return the SequencePropertyMutability * / SequencePropertyMutability getSequencePropertyMutability ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * timestamps with fractional second precision . For dialects that do , * Timestamp . getNanos returns the sub - second fractional value . * * @return true if support for sub - second precision , or false if timestamps * are granular only to the second . * / boolean supportsSubSecondTimestamps ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * generating SQL for adding primary keys to existing tables . * * @return true if adding primary keys is supported ; false otherwise . * / boolean supportsAddPrimaryKey ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * generating SQL for dropping primary keys from existing tables . * * @return true if dropping primary keys is supported ; false otherwise . * / boolean supportsDropPrimaryKey ( ) ; / * * * For the given columnInfo , this provides the type name that is used to * re - create this column in a new table . This method also delegates to * getJavaTypeForNativeType for type OTHER ( 1111 ) . * * @param tcInfo * the TableColumnInfo describing the column * @return the column type name * / String getTypeName ( TableColumnInfo tcInfo ) ; / * * * This will return the java . sql . Types constant that the specified * type name can be stored in . * * @param nativeColumnTypeName * the column type name * @return a java . sql . Types constant representing the java column type this * type is compatible with . * / int getJavaTypeForNativeType ( String nativeColumnTypeName ) ; int getTimestampMaximumFractionalDigits ( ) ; / * * * Returns a literal string which is acceptable for SQL that update , * insert or delete statements on a row which contains a column whose data type accepts * binary data . * * @param binaryData * the actual bytes that form the binary data value * @return a literal string that is acceptable to be used in an insert , * update or delete statement . * / String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test40 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "A0#iYY#c" , "gZ%g8 < ef" , "gZ%g8 < ef" , "A0#iYY#c" , 1274 , "gZ%g8 < ef" , 1274 , 0 , 0 , 0 , "A0#iYY#c" , "A0#iYY#c" , 0 , 1380 , "A0#iYY#c" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "A0#iYY#c" , "gZ%g8 < ef" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = daffodilDialectExt0 . getColumnDefaultAlterSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDefaultAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String defaultClause = DialectUtils . SET_DEFAULT_CLAUSE ; return DialectUtils . getColumnDefaultAlterSQL ( this , info , alterClause , false , defaultClause , qualifier , prefs ) ; }
void test41 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test42 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsAddForeignKeyConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddForeignKeyConstraint ( ) { return true ; }
void test43 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test44 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test46 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " ] X^# ) " , " ] X^# ) " ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = daffodilDialectExt0 . getDropViewSQL ( " ] X^# ) " , true , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropViewSQL ( String viewName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP VIEW $viewName$" ; StringTemplate st = new StringTemplate ( ST_DROP_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test48 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test50 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test51 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsSchemasInTableDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSchemasInTableDefinition ( ) { return false ; }
void test52 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "Assa@uGNzbq4 } czI F" , "Assa@uGNzbq4 } czI F" , "Assa@uGNzbq4 } czI F" ) ; boolean boolean0 = daffodilDialectExt0 . canPasteTo ( ( IDatabaseObjectInfo ) databaseObjectInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPasteTo ( IDatabaseObjectInfo info ) { boolean result = true ; DatabaseObjectType type = info . getDatabaseObjectType ( ) ; if ( type . getName ( ) . equalsIgnoreCase ( "database" ) ) { result = false ; } return result ; }
void test53 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; int int0 = daffodilDialectExt0 . getMaxPrecision ( ( - 1844 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxPrecision ( int dataType ) { / / float ( 54 ) produces an exception : / / / / invalid column format 'float' on column 'float_column' . , / / SQL State : 42000 , Error Code : 2014 if ( dataType = = Types . FLOAT ) { return 53 ; } else { return 31 ; } }
void test54 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; int int0 = daffodilDialectExt0 . getMaxPrecision ( 6 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxPrecision ( int dataType ) { / / float ( 54 ) produces an exception : / / / / invalid column format 'float' on column 'float_column' . , / / SQL State : 42000 , Error Code : 2014 if ( dataType = = Types . FLOAT ) { return 53 ; } else { return 31 ; } }
void test55 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; int int0 = daffodilDialectExt0 . getMaxScale ( 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxScale ( int dataType ) { return getMaxPrecision ( dataType ) ; }
void test56 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsProduct ( "ALTER TABLE \"jxa\" . \"jxa\" DROP CONSTRAINT \"jxa\"" , "ALTER TABLE \"jxa\" . \"jxa\" DROP CONSTRAINT \"jxa\"" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test57 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; boolean boolean0 = daffodilDialectExt0 . supportsProduct ( "DaffodilALTER TABLE \"jxa\" . \"jxa\" DROP CONSTRAINT \"jxa\"" , "DaffodilALTER TABLE \"jxa\" . \"jxa\" DROP CONSTRAINT \"jxa\"" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test58 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; String [ ] stringArray0 = new String [ 21 ] ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "GqOAE | V" , "GqOAE | V" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = daffodilDialectExt0 . getCreateIndexSQL ( "GqOAE | V" , "GqOAE | V" , "GqOAE | V" , stringArray0 , true , "GqOAE | V" , "GqOAE | V" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE { [ UNIQUE [ HASH ] ] INDEX [ [ IF NOT EXISTS ] newIndexName ] / / | PRIMARY KEY [ HASH ] } ON ( columnName [ , . . . ] ) StringTemplate st = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; HashMap < String , String > valuesMap = new HashMap < String , String > ( ) ; if ( unique ) { valuesMap . put ( ST_UNIQUE_KEY , "UNIQUE" ) ; if ( accessMethod ! = null & & "HASH" . equalsIgnoreCase ( accessMethod ) ) { valuesMap . put ( ST_STORAGE_OPTION_KEY , "HASH" ) ; } } valuesMap . put ( ST_INDEX_NAME_KEY , indexName ) ; valuesMap . put ( ST_TABLE_NAME_KEY , tableName ) ; return DialectUtils . getAddIndexSQL ( this , st , valuesMap , columns , qualifier , prefs ) ; }
void test59 ( ) throws Throwable { DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; String string0 = daffodilDialectExt0 . getDropPrimaryKeySQL ( " ] X^# ) " , " ] X^# ) " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test2 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test3 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; String string0 = commonHibernateDialect0 . getMaxFunction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMaxFunction ( ) { return "max" ; }
void test6 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; String string0 = commonHibernateDialect0 . getNullColumnString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNullColumnString ( ) ; / * * * Returns the name of the aggregate function that determines the max value * of an expression . * * @return the name of the function to be applied to a set to determine the * element with the highest numeric value . * / String getMaxFunction ( ) ; / * * * Returns the name of the function that measures the length of a character * string . * * @param dataType * the java . sql . Types data type . Some databases have different * length functions for different data types . * @return the name of the function to be applied to a column to determine * the length of that column in a particular record . * / String getLengthFunction ( int dataType ) ; / * * * Returns the maximum precision allowed by the database for number type * fields that specify the length of the number to the left of the decimal * point in digits . If the HibernateDialect implementation doesn't ever use * $p in any call to registerColumnType ( ) , then this maximum precsision will * not be used . * * @param dataType * the java . sql . Types data type . * @return the maximum number that can be used in a column declaration for * precision for the specified type . * / int getMaxPrecision ( int dataType ) ; / * * * Returns the maximum scale allowed by the database for number type fields * that specify the length of the number to the right of the decimal point * in digits . If the HibernateDialect implementation doesn't ever use $s in * any call to registerColumnType ( ) , then this maximum scale will not be * used . * * @param dataType * the java . sql . Types data type . * @return the maximum number that can be used in a column declaration for * scale for the specified type . * / int getMaxScale ( int dataType ) ; / * * * Returns the number of digits of precision is represented by the specifed * columnSize for the specified dataType . Some DBs represent precision as * the total number of digits on the right or left of the decimal . That is * what we want . Others ( like PostgreSQL ) give the number of bytes of * storage a column can use - less than useful , since the SQL - 92 says * "number of digits" and this is what most other DBs use . * * @param columnSize * the size of the column as reported by the driver . * @param dataType * the java . sql . Types data type . * @return a number indicating the total number of digits ( includes both * sides of the decimal point ) the column can represent . * / int getPrecisionDigits ( int columnSize , int dataType ) ; / * * * Some jdbc drivers are hopelessly broken with regard to reporting the * COLUMN_SIZE . For example , MaxDB has a "long byte" data type which can * store up to 2G of data , yet the driver reports that the column size is * "8" - real helpful . So for drivers that have this problem , return the * "proper" maximum column length for the specified dataType . If the driver * doesn't have this problem , just return the columnSize . * * @param columnSize * the size of the column as reported by the jdbc driver * @param dataType * the type of the column . * @return the specified columnSize if the jdbc driver isn't broken ; * otherwise , the maximum column size for the specified dataType if * the driver is broken . * / int getColumnLength ( int columnSize , int dataType ) ; / * * * Returns boolean value indicating whether or not this dialect supports the * specified database product / version . * * @param databaseProductName * the name of the database as reported by * DatabaseMetaData . getDatabaseProductName ( ) * @param databaseProductVersion * the version of the database as reported by * DatabaseMetaData . getDatabaseProductVersion ( ) * @return true if this dialect can be used for the specified product name * and version ; false otherwise . * / boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) ; / * * * The string which identifies this dialect in the dialect chooser . * * @return a descriptive name that tells the user what database this dialect * is design to work with . * / String getDisplayName ( ) ; / * * * Returns a boolean value indicating whether or not this dialect supports * adding comments to columns . * * @return true if column comments are supported ; false otherwise . * / boolean supportsColumnComment ( ) ; / * * * Returns the SQL statement to use to add a comment to the specified column * of the specified table . * * @param info * information about the column such as type , name , etc . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * @throws UnsupportedOperationException * if the database doesn't support annotating columns with a * comment . * / String getColumnCommentAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping columns from tables . * * @return true if the database supports dropping columns ; false otherwise . * / boolean supportsDropColumn ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports changing a column from null to not - null and vice versa . * * @return true if the database supports dropping columns ; false otherwise . * / boolean supportsAlterColumnNull ( ) ; / * * * Returns the SQL that forms the command to drop the specified colum in the * specified table . * * @param tableName * the name of the table that has the column * @param columnName * the name of the column to drop . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql for dropping the specified column * @throw UnsupportedOperationException if the database doesn't support * dropping columns . * / String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException ; / * * * Returns the SQL that forms the command to drop the specified table . If * cascade contraints is supported by the dialect and cascadeConstraints is * true , then a drop statement with cascade constraints clause will be * formed . * * @param iTableInfo * the table to drop * @param cascadeConstraints * whether or not to drop any FKs that may reference the * specified table . * @param isMaterializedView * whether or not the specified table info is actually a * materialized view * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the drop SQL command . * / List < String > getTableDropSQL ( ITableInfo iTableInfo , boolean cascadeConstraints , boolean isMaterializedView , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL that forms the command to add a primary key to the * specified table composed of the given column names . * * @param pkName * the name of the constraint * @param ti * the table to add a primary key to * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @param columnNames * the columns that form the key * @return * / String [ ] getAddPrimaryKeySQL ( String pkName , TableColumnInfo [ ] colInfos , ITableInfo ti , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL fragment for adding a column in an alter table statement . * * @return * / String getAddColumnString ( ) ; / * * * Returns the SQL used to alter the nullability of the specified column * * @param info * the column to modify * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL to execute * / String [ ] getColumnNullableAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports renaming columns . * * @return true if the database supports changing the name of columns ; false * otherwise . * / boolean supportsRenameColumn ( ) ; / * * * Returns the SQL that is used to change the column name . * * @param from * the TableColumnInfo as it is * @param to * the TableColumnInfo as it wants to be * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL to make the change * / String getColumnNameAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns a boolean value indicating whether or not this dialect supports * modifying a columns type . * * @return true if supported ; false otherwise * / boolean supportsAlterColumnType ( ) ; / * * * Returns the SQL that is used to change the column type . * * @param from * the TableColumnInfo as it is * @param to * the TableColumnInfo as it wants to be * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL to make the change * @throw UnsupportedOperationException if the database doesn't support * modifying column types . * / List < String > getColumnTypeAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException ; / * * * Returns a boolean value indicating whether or not this database dialect * supports changing a column's default value . * * @return true if the database supports modifying column defaults ; false * otherwise * / boolean supportsAlterColumnDefault ( ) ; / * * * Returns the SQL command to change the specified column's default value * * @param info * the column to modify and it's default value . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return SQL to make the change * / String getColumnDefaultAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL command to drop the specified table's primary key . * * @param pkName * the name of the primary key that should be dropped * @param tableName * the name of the table whose primary key should be dropped * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * / String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL command to drop the specified table's foreign key * constraint . * * @param fkName * the name of the foreign key that should be dropped * @param tableName * the name of the table whose foreign key should be dropped * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * / String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL command to create the specified table ( columns appear in * the same order as they are stored in the database ) . * * @param tables * the tables to get create statements for * @param md * the metadata from the ISession * @param prefs * preferences about how the resultant SQL commands should be * formed . * @param isJdbcOdbc * whether or not the connection is via JDBC - ODBC bridge . * @return the SQL that is used to create the specified table * / List < String > getCreateTableSQL ( List < ITableInfo > tables , ISQLDatabaseMetaData md , CreateScriptPreferences prefs , boolean isJdbcOdbc ) throws SQLException ; / * * * Returns the SQL command to create the specified table . Optionally , if * sortColumns is true , colums will be sorted by column name in ascending * order . * * @param tables * the tables to get create statements for * @param md * the metadata from the ISession * @param prefs * preferences about how the resultant SQL commands should be * formed . * @param isJdbcOdbc * whether or not the connection is via JDBC - ODBC bridge . * @param sortColumns * whether or not to sort columns according to their column name . * * @return the SQL that is used to create the specified table * / List < String > getCreateTableSQL ( List < ITableInfo > tables , ISQLDatabaseMetaData md , CreateScriptPreferences prefs , boolean isJdbcOdbc , boolean sortColumns ) throws SQLException ; / * * * Returns the DialectType enum value associated with this dialect . * * @return the DialectType * / DialectType getDialectType ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports sequences . * * @return true if the database supports sequence ; false otherwise . * / boolean supportsSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * suports tablespaces . Specifically , when creating an index , some databases * allow a tablespace to be specified to create the index in , recognizing * that indexes can be quite large . * * @return true if the database supports tablespaces ; false otherwise . * / boolean supportsTablespace ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports indexes . * * @return true if the database supports indexes ; false otherwise . * / boolean supportsIndexes ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports access methods . * * @return true if the database supports access methods ; false otherwise . * / boolean supportsAccessMethods ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports auto - increment on columns . * * @return true if the database supports auto - increment ; false otherwise . * / boolean supportsAutoIncrement ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports check options for views . * * @return true if the database supports check options for views ; false * otherwise . * / boolean supportsCheckOptionsForViews ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports empty tables . * * @return true if the database supports empty tables ; false otherwise . * / boolean supportsEmptyTables ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports the optional SQL feature "row value constructors" ( F641 ) that * allows to insert multiple rows in a single insert statement . * * @return true if the database supports multiple row inserts ; false * otherwise . * / boolean supportsMultipleRowInserts ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports adding columns to existing tables * * @return true if the database supports adding columns ; false otherwise . * / boolean supportsAddColumn ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports adding foreign key constraints . * * @return true if the database supports adding foreign key constraints ; * false otherwise . * / boolean supportsAddForeignKeyConstraint ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports adding unique constraints . * * @return true if the database supports adding unique constraints ; false * otherwise . * / boolean supportsAddUniqueConstraint ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports altering sequences . * * @return true if the database supports altering sequences ; false * otherwise . * / boolean supportsAlterSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating indexes . * * @return true if the database supports creating indexes ; false otherwise . * / boolean supportsCreateIndex ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating sequences . * * @return true if the database supports creating sequences ; false * otherwise . * / boolean supportsCreateSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating tables . * * @return true if the database supports creating tables ; false otherwise . * / boolean supportsCreateTable ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating views . * * @return true if the database supports creating views ; false otherwise . * / boolean supportsCreateView ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping constraints . * * @return true if the database supports dropping constraints ; false * otherwise . * / boolean supportsDropConstraint ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping indexes . * * @return true if the database supports dropping indexes ; false otherwise . * / boolean supportsDropIndex ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping sequences . * * @return true if the database supports dropping sequences ; false * otherwise . * / boolean supportsDropSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping views . * * @return true if the database supports dropping views ; false otherwise . * / boolean supportsDropView ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports inserting rows . * * @return true if the database supports inserting rows ; false otherwise . * / boolean supportsInsertInto ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports renaming tables . * * @return true if the database supports renaming tables ; false otherwise . * / boolean supportsRenameTable ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports renaming views . * * @return true if the database supports renaming views ; false otherwise . * / boolean supportsRenameView ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports gathering information about sequences . * * @return true if the database supports gathering information about * sequences ; false otherwise . * / boolean supportsSequenceInformation ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports updating rows . * * @return true if the database supports updating rows ; false otherwise . * / boolean supportsUpdate ( ) ; / * * * Gets the index access methods that this dialect supports used when * creating indexes . * * @return all the access methods supported by this dialect . * / String [ ] getIndexAccessMethodsTypes ( ) ; / * * * Gets the index storage options that this dialect supports used when * creating indexes . * * @return all the access methods supported by this dialect . * / String [ ] getIndexStorageOptions ( ) ; / * * * Gets the SQL command to create a new table . * * @param tableName * simple name of the table * @param columns * columns of the table * @param primaryKeys * primary keys of the table * @param prefs * preferences for generated sql scripts * @param qualifier * qualifier of the table * @return the sql command to create a table . * / String getCreateTableSQL ( String tableName , List < TableColumnInfo > columns , List < TableColumnInfo > primaryKeys , SqlGenerationPreferences prefs , DatabaseObjectQualifier qualifier ) ; / * * * Gets the SQL command to rename a table . * * @param oldTableName * old name of the table * @param newTableName * new name of the table * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to rename a table . * / String getRenameTableSQL ( String oldTableName , String newTableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to create a view . * * @param viewName * name of the view * @param definition * old definition of the view . * @param checkOption * CHECK OPTION . CASCADE , LOCAL or null for no check option . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to create a view . * / String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to rename a view . * * @param oldViewName * old name of the view * @param newViewName * new name of the view * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command * / String [ ] getRenameViewSQL ( String oldViewName , String newViewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop a view . * * @param viewName * name of the view * @param cascade * cascade true if automatically drop object that depend on the * view ( such as other views ) . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL command to drop a view . * / String getDropViewSQL ( String viewName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to create an index . * * @param indexName * name of the index to be created * @param tableName * name of the table * @param accessMethod * the index access method to use ( for example , b - tree , r - tree , * hash , etc . ) * @param columns * columns where the index should be stored for * @param unique * true if the index should be unique * @param tablespace * tablespace for the index ( leave empty for no tablespace ) * @param constraints * constraints for the index ( leave empty for no constraints ) * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to create an index . * / String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop an index . * * @param tableName * name of the table that the index indexes . This can be null . * @param indexName * name of the index * @param cascade * true if automatically drop object that depend on the view * ( such as other views ) . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to drop an index . * / String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to create a sequence . * * @param sequenceName * name of the sequence * @param increment * increment value * @param minimum * minimum value ( leave empty for NO MINVALUE ) * @param maximum * maximum value ( leave empty for NO MINVALUE ) * @param start * start value ( leave empty for default ) * @param cache * cache value , how many sequences should be preallocated ( leave * empty for default ) * @param cycle * true if the sequence should wrap around when the max - / minvalue * has been reached ( leave empty for NO CYCLE ) * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to create a sequence . * / String getCreateSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String start , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to alter a sequence . * * @param sequenceName * name of the sequence . * @param increment * increment value . * @param minimum * minimum value . * @param maximum * maximum value . * @param restart * start value . * @param cache * cache value , how many sequences should be preallocated . * @param cycle * true if the sequence should wrap around when the max - / minvalue * has been reached . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command statements * / String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to query the specific database to find out the * information about the sequence . The query should return the following * fields : last_value , max_value , min_value , cache_value , increment_by , * is_cycled * * @param sequenceName * the name of the sequence . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to query the database . * / String getSequenceInformationSQL ( String sequenceName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop a sequence . * * @param sequenceName * name of the sequence * @param cascade * true if automatically drop object that depend on the view * ( such as other views ) . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to drop a sequence . * / String getDropSequenceSQL ( String sequenceName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to add a foreign key constraint to a table . * * @param localTableName * name of the table where the foreign key should be stored . * @param refTableName * name of the table where the foreign key should reference to . * @param constraintName * name of the constraint . Leave it empty and it won't create a * CONSTRAINT name . * @param deferrable * true if the constraint is deferrable , false if not . * @param initiallyDeferred * true if the constraint is deferrable and initially deferred , * false if not . * @param matchFull * true if the referenced columns using MATCH FULL . * @param autoFKIndex * true to create an additional INDEX with the given fkIndexName * Name . * @param fkIndexName * name of the foreign key index name . * @param localRefColumns * local and referenced column collection . In the first Element * of the String Array should be the local column name and in the * second Element the referenced Table column name . * @param onUpdateAction * update action . For example "RESTRICT" . * @param onDeleteAction * delete action . For exampel "NO ACTION" . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add a foreign key constraint . * / String [ ] getAddForeignKeyConstraintSQL ( String localTableName , String refTableName , String constraintName , Boolean deferrable , Boolean initiallyDeferred , Boolean matchFull , boolean autoFKIndex , String fkIndexName , Collection < String [ ] > localRefColumns , String onUpdateAction , String onDeleteAction , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to add a unique constraint to a table . * * @param tableName * name of the table where the unique constraint should be added * to . * @param constraintName * name of the constraint . * @param columns * the unique columns . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add a unique constraint . * / String [ ] getAddUniqueConstraintSQL ( String tableName , String constraintName , TableColumnInfo [ ] columns , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL to add an auto - increment to a column . * * @param column * column to where the auto - increment should be added to . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add auto - increment . * / String [ ] getAddAutoIncrementSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL to add an auto - increment to a column . * * @param column * column to where the auto - increment should be added to . * @param sequenceName * if a sequence is created for the purpose of generating the * next auto - incremented value , then this is the name of the * sequence . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add auto - increment . * / String [ ] getAddAutoIncrementSQL ( TableColumnInfo column , String sequenceName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop a constraint from a table . * * @param tableName * name of the table where the constraint should be dropped from . * @param constraintName * name of the constraint . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to drop a constraint . * / String getDropConstraintSQL ( String tableName , String constraintName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to insert data into a table . * < p / > * If the list of columns is empty or null the SQL will look like : INSERT * INTO tablename valuesPart ; * < p / > * instead of : INSERT INTO tablename ( column1 , column2 , . . . ) valuesPart ; * * @param tableName * simple name of the table * @param columns * columns of the table * @param valuesPart * either a query or a VALUES ( . . . ) string that defines the data * to insert * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to insert data . * / String getInsertIntoSQL ( String tableName , List < String > columns , String valuesPart , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to update the specified columns with the specified * values . * * @param tableName * simple name of the table * @param setColumns * columns to be set * @param setValues * values the columns should be set with * @param fromTables * simple names of the tables in the FROM clause * @param whereColumns * columns in the WHERE clause * @param whereValues * values of the columns in the WHERE clause * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to update data . * / String [ ] getUpdateSQL ( String tableName , String [ ] setColumns , String [ ] setValues , String [ ] fromTables , String [ ] whereColumns , String [ ] whereValues , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to add a column to the specified table . * * @param column * information about the column * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add a column * @throws UnsupportedOperationException * if the database doesn't support adding columns after a table * has already been created . Use supportsAddColumn before * calling this to avoid that . * / String [ ] getAddColumnSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * The character specific to this dialect used to close a quoted identifier . * * @return The dialect's specific close quote character . * / char closeQuote ( ) ; / * * * The character specific to this dialect used to begin a quoted identifier . * * @return The dialect's specific open quote character . * / char openQuote ( ) ; / * * * Whether or not the definition of a view can be determined via a query * that is returned from getViewDefinitionSQL method * * @return true if getViewDefinitionSQL yields a non - null value ; false * otherwise . * / boolean supportsViewDefinition ( ) ; / * * * Returns the SQL that can be used to query the data dictionary for the * body of a view . This should exclude the "CREATE VIEW < viewname > AS" * prefix and just return the query . This can return null if the database * doesn't provide access to this definition . * * @param viewName * the name of the view to get the definition for . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * / String getViewDefinitionSQL ( String viewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the qualified identifier based on the specified qualifier and * user preferences . * * @param identifier * @param qualifier * @param prefs * @return * / String getQualifiedIdentifier ( String identifier , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns a boolean indicating whether or not this dialect supports * correlated sub - queries . * * @return true if support for correlated sub - queries and false otherwise . * / boolean supportsCorrelatedSubQuery ( ) ; / * * * Gets the sequence property mutability , which describes which properties * of a sequence can be changed , and which cannot . * * @return the SequencePropertyMutability * / SequencePropertyMutability getSequencePropertyMutability ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * timestamps with fractional second precision . For dialects that do , * Timestamp . getNanos returns the sub - second fractional value . * * @return true if support for sub - second precision , or false if timestamps * are granular only to the second . * / boolean supportsSubSecondTimestamps ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * generating SQL for adding primary keys to existing tables . * * @return true if adding primary keys is supported ; false otherwise . * / boolean supportsAddPrimaryKey ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * generating SQL for dropping primary keys from existing tables . * * @return true if dropping primary keys is supported ; false otherwise . * / boolean supportsDropPrimaryKey ( ) ; / * * * For the given columnInfo , this provides the type name that is used to * re - create this column in a new table . This method also delegates to * getJavaTypeForNativeType for type OTHER ( 1111 ) . * * @param tcInfo * the TableColumnInfo describing the column * @return the column type name * / String getTypeName ( TableColumnInfo tcInfo ) ; / * * * This will return the java . sql . Types constant that the specified * type name can be stored in . * * @param nativeColumnTypeName * the column type name * @return a java . sql . Types constant representing the java column type this * type is compatible with . * / int getJavaTypeForNativeType ( String nativeColumnTypeName ) ; int getTimestampMaximumFractionalDigits ( ) ; / * * * Returns a literal string which is acceptable for SQL that update , * insert or delete statements on a row which contains a column whose data type accepts * binary data . * * @param binaryData * the actual bytes that form the binary data value * @return a literal string that is acceptable to be used in an insert , * update or delete statement . * / String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test7 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test8 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test11 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; String [ ] stringArray0 = commonHibernateDialect0 . getIndexAccessMethodsTypes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexAccessMethodsTypes ( ) { return new String [ ] { "DEFAULT" , "HASH" } ; }
void test12 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsProduct ( "length" , "length" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test13 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test14 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsCreateIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateIndex ( ) { return true ; }
void test15 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; DialectType dialectType0 = commonHibernateDialect0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test16 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test18 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsAddPrimaryKey ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddPrimaryKey ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * generating SQL for dropping primary keys from existing tables . * * @return true if dropping primary keys is supported ; false otherwise . * / boolean supportsDropPrimaryKey ( ) ; / * * * For the given columnInfo , this provides the type name that is used to * re - create this column in a new table . This method also delegates to * getJavaTypeForNativeType for type OTHER ( 1111 ) . * * @param tcInfo * the TableColumnInfo describing the column * @return the column type name * / String getTypeName ( TableColumnInfo tcInfo ) ; / * * * This will return the java . sql . Types constant that the specified * type name can be stored in . * * @param nativeColumnTypeName * the column type name * @return a java . sql . Types constant representing the java column type this * type is compatible with . * / int getJavaTypeForNativeType ( String nativeColumnTypeName ) ; int getTimestampMaximumFractionalDigits ( ) ; / * * * Returns a literal string which is acceptable for SQL that update , * insert or delete statements on a row which contains a column whose data type accepts * binary data . * * @param binaryData * the actual bytes that form the binary data value * @return a literal string that is acceptable to be used in an insert , * update or delete statement . * / String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test20 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test21 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; byte [ ] byteArray0 = new byte [ 9 ] ; String string0 = commonHibernateDialect0 . getBinaryLiteralString ( byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test22 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test23 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test25 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; int int0 = commonHibernateDialect0 . getColumnLength ( 479 , 479 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test27 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsViewDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsViewDefinition ( ) { return true ; }
void test29 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test30 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = commonHibernateDialect0 . getDropIndexSQL ( "" , "" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP INDEX $indexName$" ; StringTemplate st = new StringTemplate ( ST_DROP_INDEX_STYLE_THREE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_INDEX_NAME_KEY , indexName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test32 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsInsertInto ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsInsertInto ( ) { return true ; }
void test33 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = commonHibernateDialect0 . getDropViewSQL ( "CREATE SEQUENCE $sequenceName$ $increment$ $minimum$ $maximum$ $startWith$ $cache$ $cycle$" , true , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropViewSQL ( String viewName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP VIEW $viewName$" ; StringTemplate st = new StringTemplate ( ST_DROP_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test34 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsTablespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTablespace ( ) { return false ; }
void test35 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsCreateTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateTable ( ) { return true ; }
void test36 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "max" , "max" , "max" ) ; boolean boolean0 = commonHibernateDialect0 . canPasteTo ( ( IDatabaseObjectInfo ) databaseObjectInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPasteTo ( IDatabaseObjectInfo info ) { boolean result = true ; DatabaseObjectType type = info . getDatabaseObjectType ( ) ; if ( type . getName ( ) . equalsIgnoreCase ( "database" ) ) { result = false ; } return result ; }
void test38 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test39 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsAddForeignKeyConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddForeignKeyConstraint ( ) { return true ; }
void test41 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test42 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsSubSecondTimestamps ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSubSecondTimestamps ( ) { return false ; }
void test44 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsRenameView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameView ( ) { return false ; }
void test45 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsSchemasInTableDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSchemasInTableDefinition ( ) { return false ; }
void test46 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test47 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsDropColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropColumn ( ) { return true ; }
void test48 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; String string0 = commonHibernateDialect0 . getLengthFunction ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLengthFunction ( int dataType ) { return "length" ; }
void test49 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsDropIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropIndex ( ) { return true ; }
void test50 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; SequencePropertyMutability sequencePropertyMutability0 = commonHibernateDialect0 . getSequencePropertyMutability ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRestart ( ) { return _restart ; }
void test51 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; String [ ] stringArray0 = commonHibernateDialect0 . getIndexStorageOptions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexStorageOptions ( ) { return null ; }
void test52 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test53 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; int int0 = commonHibernateDialect0 . getTimestampMaximumFractionalDigits ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTimestampMaximumFractionalDigits ( ) { return 9 ; }
void test54 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsAddUniqueConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddUniqueConstraint ( ) { return true ; }
void test58 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsIndexes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsIndexes ( ) { return true ; }
void test59 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " - O" , " - O" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = commonHibernateDialect0 . getDropForeignKeySQL ( " - O" , " - O" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test60 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsAddColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddColumn ( ) { return true ; }
void test61 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsMultipleRowInserts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsMultipleRowInserts ( ) { return true ; }
void test62 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; int int0 = commonHibernateDialect0 . getMaxScale ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxScale ( int dataType ) { return getMaxPrecision ( dataType ) ; }
void test65 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test66 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsAlterSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test68 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsAccessMethods ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAccessMethods ( ) { return true ; }
void test71 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsDropConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropConstraint ( ) { return true ; }
void test72 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "0" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = commonHibernateDialect0 . getInsertIntoSQL ( "" , ( List < String > ) null , "0" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getInsertIntoSQL ( String tableName , List < String > columns , String valuesPart , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getInsertIntoSQL ( tableName , columns , valuesPart , qualifier , prefs , this ) ; }
void test73 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsEmptyTables ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsEmptyTables ( ) { return true ; }
void test74 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsCheckOptionsForViews ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCheckOptionsForViews ( ) { return false ; }
void test75 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsDropPrimaryKey ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropPrimaryKey ( ) ; / * * * For the given columnInfo , this provides the type name that is used to * re - create this column in a new table . This method also delegates to * getJavaTypeForNativeType for type OTHER ( 1111 ) . * * @param tcInfo * the TableColumnInfo describing the column * @return the column type name * / String getTypeName ( TableColumnInfo tcInfo ) ; / * * * This will return the java . sql . Types constant that the specified * type name can be stored in . * * @param nativeColumnTypeName * the column type name * @return a java . sql . Types constant representing the java column type this * type is compatible with . * / int getJavaTypeForNativeType ( String nativeColumnTypeName ) ; int getTimestampMaximumFractionalDigits ( ) ; / * * * Returns a literal string which is acceptable for SQL that update , * insert or delete statements on a row which contains a column whose data type accepts * binary data . * * @param binaryData * the actual bytes that form the binary data value * @return a literal string that is acceptable to be used in an insert , * update or delete statement . * / String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test76 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "TimeSeriesDataset . addSeries ( ) : cannot add more series than specified in c'tor" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = commonHibernateDialect0 . getColumnDropSQL ( "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" char openQuote ( ) ; / * * * Whether or not the definition of a view can be determined via a query * that is returned from getViewDefinitionSQL method * * @return true if getViewDefinitionSQL yields a non - null value ; false * otherwise . * / boolean supportsViewDefinition ( ) ; / * * * Returns the SQL that can be used to query the data dictionary for the * body of a view . This should exclude the "CREATE VIEW < viewname > AS" * prefix and just return the query . This can return null if the database * doesn't provide access to this definition . * * @param viewName * the name of the view to get the definition for . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * / String getViewDefinitionSQL ( String viewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the qualified identifier based on the specified qualifier and * user preferences . * * @param identifier * @param qualifier * @param prefs * @return * / String getQualifiedIdentifier ( String identifier , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns a boolean indicating whether or not this dialect supports * correlated sub - queries . * * @return true if support for correlated sub - queries and false otherwise . * / boolean supportsCorrelatedSubQuery ( ) ; / * * * Gets the sequence property mutability , which describes which properties * of a sequence can be changed , and which cannot . * * @return the SequencePropertyMutability * / SequencePropertyMutability getSequencePropertyMutability ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * timestamps with fractional second precision . For dialects that do , * Timestamp . getNanos returns the sub - second fractional value . * * @return true if support for sub - second precision , or false if timestamps * are granular only to the second . * / boolean supportsSubSecondTimestamps ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * generating SQL for adding primary keys to existing tables . * * @return true if adding primary keys is supported ; false otherwise . * / boolean supportsAddPrimaryKey ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * generating SQL for dropping primary keys from existing tables . * * @return true if dropping primary keys is supported ; false otherwise . * / boolean supportsDropPrimaryKey ( ) ; / * * * For the given columnInfo , this provides the type name that is used to * re - create this column in a new table . This method also delegates to * getJavaTypeForNativeType for type OTHER ( 1111 ) . * * @param tcInfo * the TableColumnInfo describing the column * @return the column type name * / String getTypeName ( TableColumnInfo tcInfo ) ; / * * * This will return the java . sql . Types constant that the specified * type name can be stored in . * * @param nativeColumnTypeName * the column type name * @return a java . sql . Types constant representing the java column type this * type is compatible with . * / int getJavaTypeForNativeType ( String nativeColumnTypeName ) ; int getTimestampMaximumFractionalDigits ( ) ; / * * * Returns a literal string which is acceptable for SQL that update , * insert or delete statements on a row which contains a column whose data type accepts * binary data . * * @param binaryData * the actual bytes that form the binary data value * @return a literal string that is acceptable to be used in an insert , * update or delete statement . * / String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test77 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; boolean boolean0 = commonHibernateDialect0 . supportsCreateView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateView ( ) { return true ; }
void test79 ( ) throws Throwable { CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; String [ ] stringArray0 = new String [ 6 ] ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray1 = commonHibernateDialect0 . getUpdateSQL ( " ; = " , stringArray0 , stringArray0 , stringArray0 , stringArray0 , stringArray0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getUpdateSQL ( String tableName , String [ ] setColumns , String [ ] setValues , String [ ] fromTables , String [ ] whereColumns , String [ ] whereValues , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { StringTemplate st = new StringTemplate ( ST_UPDATE_CORRELATED_QUERY_STYLE_TWO ) ; return DialectUtils . getUpdateSQL ( st , tableName , setColumns , setValues , fromTables , whereColumns , whereValues , qualifier , prefs , this ) ; }
void test2 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsAddForeignKeyConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddForeignKeyConstraint ( ) { return true ; }
void test4 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsEmptyTables ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsEmptyTables ( ) { return true ; }
void test5 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test7 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test8 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsAlterSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test9 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test10 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test12 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsDropColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropColumn ( ) { return true ; }
void test13 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsCreateTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateTable ( ) { return true ; }
void test17 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsMultipleRowInserts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsMultipleRowInserts ( ) { return true ; }
void test18 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsCheckOptionsForViews ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCheckOptionsForViews ( ) { return false ; }
void test19 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( ( String ) null , ( String ) null , ( String ) null , ( String ) null , ( - 1 ) , ( String ) null , ( - 1 ) , 63 , ( - 1 ) , 63 , ( String ) null , ( String ) null , 63 , 63 , ( String ) null ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = timesTenDialectExt0 . getAddColumnSQL ( tableColumnInfo0 , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddColumnSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { ArrayList < String > result = new ArrayList < String > ( ) ; boolean addDefaultClause = true ; boolean supportsNullQualifier = true ; boolean addNullClause = true ; String sql = DialectUtils . getAddColumSQL ( column , this , addDefaultClause , supportsNullQualifier , addNullClause , qualifier , prefs ) ; result . add ( sql ) ; if ( column . getRemarks ( ) ! = null & & ! "" . equals ( column . getRemarks ( ) ) ) { result . add ( getColumnCommentAlterSQL ( column , qualifier , prefs ) ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; }
void test20 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsInsertInto ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsInsertInto ( ) { return true ; }
void test21 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsDropConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropConstraint ( ) { return true ; }
void test22 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test23 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test24 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test25 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( " [ , , QD | 1l" , " [ , , QD | 1l" , " [ , , QD | 1l" ) ; boolean boolean0 = timesTenDialectExt0 . canPasteTo ( ( IDatabaseObjectInfo ) databaseObjectInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPasteTo ( IDatabaseObjectInfo info ) { boolean result = true ; DatabaseObjectType type = info . getDatabaseObjectType ( ) ; if ( type . getName ( ) . equalsIgnoreCase ( "database" ) ) { result = false ; } return result ; }
void test26 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; int int0 = timesTenDialectExt0 . getPrecisionDigits ( 1218 , 1218 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getPrecisionDigits ( int columnSize , int dataType ) { return columnSize ; }
void test27 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsAddColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddColumn ( ) { return true ; }
void test29 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsRenameView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameView ( ) { return false ; }
void test30 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; int int0 = timesTenDialectExt0 . getColumnLength ( 1521 , 1521 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test31 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test33 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsCreateView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateView ( ) { return true ; }
void test34 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; DialectType dialectType0 = timesTenDialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DialectType getDialectType ( ) { return DialectFactory . getDialectType ( getSession ( ) . getMetaData ( ) ) ; }
void test35 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; int int0 = timesTenDialectExt0 . getMaxScale ( 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxScale ( int dataType ) { return getMaxPrecision ( dataType ) ; }
void test38 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test40 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsViewDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsViewDefinition ( ) { return true ; }
void test41 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsSchemasInTableDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSchemasInTableDefinition ( ) { return false ; }
void test43 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsAccessMethods ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAccessMethods ( ) { return true ; }
void test44 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = timesTenDialectExt0 . getDropForeignKeySQL ( "21H2 ; \" , | x@ ? " , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test46 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsDropIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropIndex ( ) { return true ; }
void test47 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsIndexes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsIndexes ( ) { return true ; }
void test48 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsAddUniqueConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddUniqueConstraint ( ) { return true ; }
void test49 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsCreateIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateIndex ( ) { return true ; }
void test51 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = timesTenDialectExt0 . getColumnDropSQL ( "21H2 ; \" , | x@ ? " , "21H2 ; \" , | x@ ? " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { StringTemplate st = new StringTemplate ( DROP_COLUMN_SQL_TEMPLATE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_COLUMN_NAME_KEY , columnName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test53 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = timesTenDialectExt0 . getDropPrimaryKeySQL ( " * b } , hb < p" , " * b } , hb < p" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test56 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test58 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test59 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test60 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test62 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsTablespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTablespace ( ) { return false ; }
void test63 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test65 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; int int0 = timesTenDialectExt0 . getMaxPrecision ( 6 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxPrecision ( int dataType ) { / / float ( 54 ) produces an exception : / / / / invalid column format 'float' on column 'float_column' . , / / SQL State : 42000 , Error Code : 2014 if ( dataType = = Types . FLOAT ) { return 53 ; } else { return 31 ; } }
void test66 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsProduct ( "hX1rd$" , "a20qAIvhM' H9 = c > " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test67 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsProduct ( ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test68 ( ) throws Throwable { TimesTenDialectExt timesTenDialectExt0 = new TimesTenDialectExt ( ) ; boolean boolean0 = timesTenDialectExt0 . supportsProduct ( "timestensed2" , "timestensed2" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test0 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCatalog ( ) { return _cat ; }
void test1 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; databaseObjectQualifier0 . setSchema ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSchema ( ) { return _schem ; }
void test2 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; String string0 = databaseObjectQualifier0 . getSchema ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSchema ( ) { return _schem ; }
void test3 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; String string0 = databaseObjectQualifier0 . getCatalog ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCatalog ( ) { return _cat ; }
void test4 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; databaseObjectQualifier0 . setCatalog ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCatalog ( ) { return _cat ; }
void test1 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsDropColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropColumn ( ) { return true ; }
void test2 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test3 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; DialectType dialectType0 = derbyDialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DialectType getDialectType ( ) { return DialectFactory . getDialectType ( getSession ( ) . getMetaData ( ) ) ; }
void test5 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; int int0 = derbyDialectExt0 . getColumnLength ( 1 , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test6 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = derbyDialectExt0 . getColumnDropSQL ( "lB : " , "lB : " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { StringTemplate st = new StringTemplate ( DROP_COLUMN_SQL_TEMPLATE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_COLUMN_NAME_KEY , columnName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test9 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test10 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsAlterSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test12 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; int int0 = derbyDialectExt0 . getMaxScale ( ( - 1601 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxScale ( int dataType ) { return getMaxPrecision ( dataType ) ; }
void test13 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test14 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test16 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test17 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = derbyDialectExt0 . getDropForeignKeySQL ( "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test18 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test20 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test22 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsViewDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsViewDefinition ( ) { return true ; }
void test23 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test24 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "Apache Derbye" , "Apache Derbye" , "Apache Derbye" , "Apache Derbye" , 479 , "Apache Derbye" , 479 , 479 , 880 , 2147483 , "Apache Derbye" , "Apache Derbye" , 479 , 880 , "Apache Derbye" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "Apache Derbye" , "Apache Derbye" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = derbyDialectExt0 . getColumnNullableAlterSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getColumnNullableAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; return new String [ ] { DialectUtils . getColumnNullableAlterSQL ( info , this , alterClause , true , qualifier , prefs ) } ; }
void test25 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "ALTER TABLE \"lB : \" DROP \"lB : \"" , "ApachV Derby" , "lB : " , "ALTER TABLE \"lB : \" DROP \"lB : \"" , 7 , "ALTER TABLE \"lB : \" DROP \"lB : \"" , 7 , 7 , 7 , 7 , "ALTER TABLE \"lB : \" DROP \"lB : \"" , "lB : " , 7 , 7 , "ALTER TABLE \"lB : \" DROP \"lB : \"" ) ; boolean boolean0 = derbyDialectExt0 . canPasteTo ( ( IDatabaseObjectInfo ) tableColumnInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPasteTo ( IDatabaseObjectInfo info ) { boolean result = true ; DatabaseObjectType type = info . getDatabaseObjectType ( ) ; if ( type . getName ( ) . equalsIgnoreCase ( "database" ) ) { result = false ; } return result ; }
void test26 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test27 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test30 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsProduct ( "Apache Derbye" , "Apache Derbye" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test31 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsProduct ( ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test32 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsProduct ( "ADD" , "ADD" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test34 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "Apache Derbye" , "Apache Derbye" , "Apache Derbye" , "Apache Derbye" , 479 , "Apache Derbye" , 479 , 479 , 880 , 2147483 , "Apache Derbye" , "Apache Derbye" , 479 , 880 , "Apache Derbye" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "Apache Derbye" , "Apache Derbye" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; TableColumnInfo [ ] tableColumnInfoArray0 = new TableColumnInfo [ 4 ] ; tableColumnInfoArray0 [ 0 ] = tableColumnInfo0 ; tableColumnInfoArray0 [ 1 ] = tableColumnInfo0 ; tableColumnInfoArray0 [ 2 ] = tableColumnInfo0 ; tableColumnInfoArray0 [ 3 ] = tableColumnInfo0 ; String [ ] stringArray0 = derbyDialectExt0 . getAddUniqueConstraintSQL ( "Apache Derbye" , "7@CZ~ } [ . 6YY~`n" , tableColumnInfoArray0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddUniqueConstraintSQL ( String tableName , String constraintName , TableColumnInfo [ ] columns , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER TABLE $tableName$ " + / / "ADD $constraint$ $constraintName$ UNIQUE $index$ $indexName$ $indexType$ ( $indexColumnName$ ) " ; StringTemplate st = new StringTemplate ( ST_ADD_UNIQUE_CONSTRAINT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_CONSTRAINT_KEY , "CONSTRAINT" , ST_CONSTRAINT_NAME_KEY , constraintName ) ; return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , columns , qualifier , prefs ) } ; }
void test0 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test1 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test5 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsRenameView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameView ( ) { return false ; }
void test7 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test8 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . canPasteTo ( ( IDatabaseObjectInfo ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPasteTo ( IDatabaseObjectInfo info ) { boolean result = true ; DatabaseObjectType type = info . getDatabaseObjectType ( ) ; if ( type . getName ( ) . equalsIgnoreCase ( "database" ) ) { result = false ; } return result ; }
void test9 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ( String ) null , ( String ) null ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = axionDialectExt0 . getDropPrimaryKeySQL ( ( String ) null , ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test11 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsInsertInto ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsInsertInto ( ) { return true ; }
void test13 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsCreateTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateTable ( ) { return true ; }
void test14 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test15 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; int int0 = axionDialectExt0 . getMaxScale ( 319 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxScale ( int dataType ) { return getMaxPrecision ( dataType ) ; }
void test16 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsDropColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropColumn ( ) { return true ; }
void test17 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test19 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test20 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "c ; 3int { 41RnKM [ 0f" , "AxionAxionAx < pion < 99" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "ALTER TABLE AxionAxionAx < pion < 99 DROP CONSTRAINT \"c ; 3int { 41RnKM [ 0f\"" , "ALTER TABLE AxionAxionAx < pion < 99 DROP CONSTRAINT \"c ; 3int { 41RnKM [ 0f\"" , "ALTER TABLE AxionAxionAx < pion < 99 DROP CONSTRAINT \"c ; 3int { 41RnKM [ 0f\"" , "ALTER TABLE AxionAxionAx < pion < 99 DROP CONSTRAINT \"c ; 3int { 41RnKM [ 0f\"" , ( - 433 ) , "ALTER TABLE AxionAxionAx < pion < 99 DROP CONSTRAINT \"c ; 3int { 41RnKM [ 0f\"" , ( - 433 ) , ( - 433 ) , ( - 433 ) , ( - 433 ) , "ALTER TABLE AxionAxionAx < pion < 99 DROP CONSTRAINT \"c ; 3int { 41RnKM [ 0f\"" , "ALTER TABLE AxionAxionAx < pion < 99 DROP CONSTRAINT \"c ; 3int { 41RnKM [ 0f\"" , ( - 433 ) , ( - 433 ) , "ALTER TABLE AxionAxionAx < pion < 99 DROP CONSTRAINT \"c ; 3int { 41RnKM [ 0f\"" ) ; String string0 = axionDialectExt0 . getColumnDefaultAlterSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDefaultAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String defaultClause = DialectUtils . SET_DEFAULT_CLAUSE ; return DialectUtils . getColumnDefaultAlterSQL ( this , info , alterClause , false , defaultClause , qualifier , prefs ) ; }
void test22 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "2" , "2" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = axionDialectExt0 . getColumnDropSQL ( "2" , "2" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { StringTemplate st = new StringTemplate ( DROP_COLUMN_SQL_TEMPLATE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_COLUMN_NAME_KEY , columnName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test24 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsViewDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsViewDefinition ( ) { return true ; }
void test25 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "c ; 3int { 41RnKM [ 0f" , "AxionAxionAx < pion < 99" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = axionDialectExt0 . getDropForeignKeySQL ( "c ; 3int { 41RnKM [ 0f" , "AxionAxionAx < pion < 99" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test26 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "1 ( pA z4g# + B\"y / is" , "1 ( pA z4g# + B\"y / is" , "1 ( pA z4g# + B\"y / is" , "1 ( pA z4g# + B\"y / is" , 0 , "1 ( pA z4g# + B\"y / is" , 200 , 200 , 0 , 200 , "1 ( pA z4g# + B\"y / is" , "1 ( pA z4g# + B\"y / is" , 0 , 200 , "1 ( pA z4g# + B\"y / is" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = axionDialectExt0 . getColumnNameAlterSQL ( tableColumnInfo0 , tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnNameAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String renameToClause = DialectUtils . RENAME_TO_CLAUSE ; return DialectUtils . getColumnNameAlterSQL ( from , to , alterClause , renameToClause , qualifier , prefs , this ) ; }
void test28 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test33 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; DialectType dialectType0 = axionDialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DialectType getDialectType ( ) { return DialectFactory . getDialectType ( getSession ( ) . getMetaData ( ) ) ; }
void test34 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsSchemasInTableDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSchemasInTableDefinition ( ) { return false ; }
void test37 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test41 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test42 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsProduct ( "nX9 > ! ] " , "nX9 > ! ] " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test43 ( ) throws Throwable { AxionDialectExt axionDialectExt0 = new AxionDialectExt ( ) ; boolean boolean0 = axionDialectExt0 . supportsProduct ( "AxionAxion < 99" , "AxionAxion < 99" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test0 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test1 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test2 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , ( - 1 ) , " { VQF / ! yih } c" , ( - 1 ) , ( - 1 ) , 571 , ( - 1 ) , " { VQF / ! yih } c" , "" , 365 , 365 , " { VQF / ! yih } c" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = hSQLDialectExt0 . getAddAutoIncrementSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddAutoIncrementSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER TABLE $tableName$ ALTER COLUMN $columnName$ IDENTITY" ; StringTemplate st = new StringTemplate ( ST_ADD_AUTO_INCREMENT_STYLE_TWO ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , column . getTableName ( ) , ST_COLUMN_NAME_KEY , column . getColumnName ( ) ) ; return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test3 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test4 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test5 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsCreateView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateView ( ) { return true ; }
void test6 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test7 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "HSQL" , "_dWSu0rBmFfT$#o" , "_dWSu0rBmFfT$#o" , "HSQL" , 1 , "_dWSu0rBmFfT$#o" , 1597 , 172 , ( - 789 ) , ( - 1158 ) , "HSQL" , "_dWSu0rBmFfT$#o" , 0 , 23 , "_dWSu0rBmFfT$#o" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "HSQL" , "_dWSu0rBmFfT$#o" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = hSQLDialectExt0 . getAddColumnSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddColumnSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { ArrayList < String > result = new ArrayList < String > ( ) ; boolean addDefaultClause = true ; boolean supportsNullQualifier = true ; boolean addNullClause = true ; String sql = DialectUtils . getAddColumSQL ( column , this , addDefaultClause , supportsNullQualifier , addNullClause , qualifier , prefs ) ; result . add ( sql ) ; if ( column . getRemarks ( ) ! = null & & ! "" . equals ( column . getRemarks ( ) ) ) { result . add ( getColumnCommentAlterSQL ( column , qualifier , prefs ) ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; }
void test8 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; String string0 = hSQLDialectExt0 . getDisplayName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDisplayName ( ) { return "H2" ; }
void test9 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test10 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test11 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsIndexes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsIndexes ( ) { return true ; }
void test12 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "B | Jp { B > 9p9`0" , "B | Jp { B > 9p9`0" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = hSQLDialectExt0 . getDropIndexSQL ( "B | Jp { B > 9p9`0" , "B | Jp { B > 9p9`0" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP INDEX $indexName$" ; StringTemplate st = new StringTemplate ( ST_DROP_INDEX_STYLE_THREE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_INDEX_NAME_KEY , indexName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test13 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsEmptyTables ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsEmptyTables ( ) { return true ; }
void test14 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test15 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "w'A7U ] g * ( \"" , "w'A7U ] g * ( \"" , "w'A7U ] g * ( \"" , "w'A7U ] g * ( \"" , ( - 1500 ) , "w'A7U ] g * ( \"" , 1339 , 1339 , ( - 1500 ) , 1339 , "w'A7U ] g * ( \"" , "w'A7U ] g * ( \"" , 1852 , 1852 , "w'A7U ] g * ( \"" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "w'A7U ] g * ( \"" , "w'A7U ] g * ( \"" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = hSQLDialectExt0 . getColumnNameAlterSQL ( tableColumnInfo0 , tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnNameAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String renameToClause = DialectUtils . RENAME_TO_CLAUSE ; return DialectUtils . getColumnNameAlterSQL ( from , to , alterClause , renameToClause , qualifier , prefs , this ) ; }
void test16 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test17 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; SequencePropertyMutability sequencePropertyMutability0 = hSQLDialectExt0 . getSequencePropertyMutability ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMinValue ( ) { return _minValue ; }
void test18 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsMultipleRowInserts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsMultipleRowInserts ( ) { return true ; }
void test19 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsDropConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropConstraint ( ) { return true ; }
void test20 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = hSQLDialectExt0 . getDropViewSQL ( "" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropViewSQL ( String viewName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP VIEW $viewName$" ; StringTemplate st = new StringTemplate ( ST_DROP_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test21 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test22 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "R6JU | BXL & z#w^DE" , "R6JU | BXL & z#w^DE" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = hSQLDialectExt0 . getViewDefinitionSQL ( "R6JU | BXL & z#w^DE" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getViewDefinitionSQL ( String viewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "select view_definition " + / / "from information_schema . views " + / / "where table_schema = ? " + / / "and table_name = ? " ; String templateStr = "select view_definition from information_schema . views " + "where table_schema = '$schemaName$' and UPPER ( table_name ) = UPPER ( '$viewName$' ) " ; StringTemplate st = new StringTemplate ( templateStr ) ; st . setAttribute ( ST_SCHEMA_NAME_KEY , qualifier . getSchema ( ) ) ; st . setAttribute ( ST_VIEW_NAME_KEY , viewName ) ; return st . toString ( ) ; }
void test23 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; boolean boolean0 = hSQLDialectExt0 . supportsTablespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTablespace ( ) { return false ; }
void test24 ( ) throws Throwable { HSQLDialectExt hSQLDialectExt0 = new HSQLDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "w'A7U ] g * ( \"" , "w'A7U ] g * ( \"" , "w'A7U ] g * ( \"" , "w'A7U ] g * ( \"" , ( - 1500 ) , "w'A7U ] g * ( \"" , 1339 , 1339 , ( - 1500 ) , 1339 , "w'A7U ] g * ( \"" , "w'A7U ] g * ( \"" , 1852 , 1852 , "w'A7U ] g * ( \"" ) ; boolean boolean0 = hSQLDialectExt0 . canPasteTo ( ( IDatabaseObjectInfo ) tableColumnInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPasteTo ( IDatabaseObjectInfo info ) { boolean result = true ; DatabaseObjectType type = info . getDatabaseObjectType ( ) ; if ( type . getName ( ) . equalsIgnoreCase ( "database" ) ) { result = false ; } return result ; }
void test0 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsEmptyTables ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsEmptyTables ( ) { return true ; }
void test1 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsViewDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsViewDefinition ( ) { return true ; }
void test3 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsCreateIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateIndex ( ) { return true ; }
void test4 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test5 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test6 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getRenameTableSQL ( "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getRenameTableSQL ( String oldTableName , String newTableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER TABLE $oldObjectName$ RENAME TO $newObjectName$" ; StringTemplate st = new StringTemplate ( ST_RENAME_OBJECT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_OLD_OBJECT_NAME_KEY , oldTableName , ST_NEW_OBJECT_NAME_KEY , newTableName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test7 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test8 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsAlterSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test9 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "ma" , "ma" , "ma" , "ma" , 0 , "ma" , 0 , 0 , 0 , 0 , "ma" , "ma" , 0 , 0 , "ma" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getColumnDefaultAlterSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDefaultAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String defaultClause = DialectUtils . SET_DEFAULT_CLAUSE ; return DialectUtils . getColumnDefaultAlterSQL ( this , info , alterClause , false , defaultClause , qualifier , prefs ) ; }
void test10 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsCreateTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateTable ( ) { return true ; }
void test11 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsAccessMethods ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAccessMethods ( ) { return true ; }
void test12 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "8FV ] " , "8FV ] " ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getDropForeignKeySQL ( "8FV ] " , "8FV ] " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test13 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsDropConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropConstraint ( ) { return true ; }
void test15 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; String [ ] stringArray0 = h2DialectExt0 . getIndexStorageOptions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexStorageOptions ( ) { return null ; }
void test16 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "8FV ] " , "8FV ] " ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getDropPrimaryKeySQL ( "X@#D" , "X@#D" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test17 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ( String ) null , ( String ) null ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getDropSequenceSQL ( "1lkP5J^Bi / = ki_y [ " , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropSequenceSQL ( String sequenceName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP SEQUENCE $sequenceName$ $cascade$" ; StringTemplate st = new StringTemplate ( ST_DROP_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test18 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getViewDefinitionSQL ( "TimePeriodAnchor . START" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getViewDefinitionSQL ( String viewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "select view_definition " + / / "from information_schema . views " + / / "where table_schema = ? " + / / "and table_name = ? " ; String templateStr = "select view_definition from information_schema . views " + "where table_schema = '$schemaName$' and UPPER ( table_name ) = UPPER ( '$viewName$' ) " ; StringTemplate st = new StringTemplate ( templateStr ) ; st . setAttribute ( ST_SCHEMA_NAME_KEY , qualifier . getSchema ( ) ) ; st . setAttribute ( ST_VIEW_NAME_KEY , viewName ) ; return st . toString ( ) ; }
void test19 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsRenameView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameView ( ) { return false ; }
void test20 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsAddForeignKeyConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddForeignKeyConstraint ( ) { return true ; }
void test21 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getDropConstraintSQL ( "^0v" , "^0v" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropConstraintSQL ( String tableName , String constraintName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / ALTER TABLE $tableName$ DROP CONSTRAINT $constraintName$ StringTemplate st = new StringTemplate ( ST_DROP_CONSTRAINT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_CONSTRAINT_NAME_KEY , constraintName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test22 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " ( e`zsu`g%Xv#x" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , " [ u~q91kg'op ) in9 ! < " , " ( e`zsu`g%Xv#x" , " ( e`zsu`g%Xv#x" , ( - 1 ) , "supportsSchemasInTableDefinitions" , ( - 1 ) , ( - 1 ) , ( - 1 ) , 1494 , "supportsSchemasInTableDefinitions" , "DROP INDEX " , 1494 , 0 , " [ u~q91kg'op ) in9 ! < " ) ; String [ ] stringArray0 = h2DialectExt0 . getAddAutoIncrementSQL ( tableColumnInfo0 , " [ u~q91kg'op ) in9 ! < " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddAutoIncrementSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER TABLE $tableName$ ALTER COLUMN $columnName$ IDENTITY" ; StringTemplate st = new StringTemplate ( ST_ADD_AUTO_INCREMENT_STYLE_TWO ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , column . getTableName ( ) , ST_COLUMN_NAME_KEY , column . getColumnName ( ) ) ; return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test23 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test24 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsAddColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddColumn ( ) { return true ; }
void test25 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test26 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getSequenceInformationSQL ( ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSequenceInformationSQL ( String sequenceName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "SELECT CURRENT_VALUE , 'NONE' , 'NONE' , CACHE , INCREMENT , 0 " + / / "FROM INFORMATION_SCHEMA . SEQUENCES " + / / "WHERE SEQUENCE_SCHEMA = ? " + / / "AND SEQUENCE_NAME = ? " ; String templateStr = "SELECT CURRENT_VALUE , 'NONE' , 'NONE' , CACHE , INCREMENT , 0 " + "FROM INFORMATION_SCHEMA . SEQUENCES " + "WHERE SEQUENCE_SCHEMA = '$schemaName$' " + "AND SEQUENCE_NAME = '$sequenceName$' " + "AND SEQUENCE_CATALOG = '$catalogName$'" ; StringTemplate st = new StringTemplate ( templateStr ) ; st . setAttribute ( ST_SCHEMA_NAME_KEY , qualifier . getSchema ( ) ) ; st . setAttribute ( ST_CATALOG_NAME_KEY , qualifier . getCatalog ( ) ) ; st . setAttribute ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; return st . toString ( ) ; }
void test27 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getColumnDropSQL ( "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { StringTemplate st = new StringTemplate ( DROP_COLUMN_SQL_TEMPLATE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_COLUMN_NAME_KEY , columnName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test28 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "FM - Y + ^ & gt6 ; nD~" , "FM - Y + ^ & gt6 ; nD~" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getInsertIntoSQL ( "FM - Y + ^ & gt6 ; nD~" , ( List < String > ) null , "FM - Y + ^ & gt6 ; nD~" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getInsertIntoSQL ( String tableName , List < String > columns , String valuesPart , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getInsertIntoSQL ( tableName , columns , valuesPart , qualifier , prefs , this ) ; }
void test29 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test30 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test31 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsCheckOptionsForViews ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCheckOptionsForViews ( ) { return false ; }
void test32 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test33 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsCreateView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateView ( ) { return true ; }
void test34 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test35 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsIndexes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsIndexes ( ) { return true ; }
void test36 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getCreateViewSQL ( "FM - Y + ^ & gt6 ; nD~" , "FM - Y + ^ & gt6 ; nD~" , "FM - Y + ^ & gt6 ; nD~" , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE [ FORCE ] VIEW [ IF NOT EXISTS ] newViewName [ ( columnName [ , . . ] ) ] / / AS select / / "CREATE VIEW $viewName$ " + / / "AS $selectStatement$ $with$ $checkOptionType$ $checkOption$" ; StringTemplate st = new StringTemplate ( ST_CREATE_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName , ST_SELECT_STATEMENT_KEY , definition ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test37 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test38 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsInsertInto ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsInsertInto ( ) { return true ; }
void test39 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test40 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsMultipleRowInserts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsMultipleRowInserts ( ) { return true ; }
void test41 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; String [ ] stringArray0 = h2DialectExt0 . getIndexAccessMethodsTypes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexAccessMethodsTypes ( ) { return new String [ ] { "DEFAULT" , "HASH" } ; }
void test42 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DialectType dialectType0 = h2DialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test43 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test44 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test45 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " ( e`zsu`g%Xv#x" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , " [ u~q91kg'op ) in9 ! < " , " ( e`zsu`g%Xv#x" , " ( e`zsu`g%Xv#x" , ( - 1 ) , "supportsSchemasInTableDefinitions" , ( - 1 ) , ( - 1 ) , ( - 1 ) , 1494 , "supportsSchemasInTableDefinitions" , "DROP INDEX " , 1494 , 0 , " [ u~q91kg'op ) in9 ! < " ) ; String [ ] stringArray0 = h2DialectExt0 . getAddColumnSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddColumnSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { ArrayList < String > result = new ArrayList < String > ( ) ; boolean addDefaultClause = true ; boolean supportsNullQualifier = true ; boolean addNullClause = true ; String sql = DialectUtils . getAddColumSQL ( column , this , addDefaultClause , supportsNullQualifier , addNullClause , qualifier , prefs ) ; result . add ( sql ) ; if ( column . getRemarks ( ) ! = null & & ! "" . equals ( column . getRemarks ( ) ) ) { result . add ( getColumnCommentAlterSQL ( column , qualifier , prefs ) ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; }
void test46 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsDropIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropIndex ( ) { return true ; }
void test47 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " ( e`zsu`g%Xv#x" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getDropViewSQL ( "nNd" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropViewSQL ( String viewName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP VIEW $viewName$" ; StringTemplate st = new StringTemplate ( ST_DROP_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test48 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsAddUniqueConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddUniqueConstraint ( ) { return true ; }
void test50 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsTablespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTablespace ( ) { return false ; }
void test51 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; int int0 = h2DialectExt0 . getTimestampMaximumFractionalDigits ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTimestampMaximumFractionalDigits ( ) { return 9 ; }
void test53 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " ( e`zsu`g%Xv#x" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getDropIndexSQL ( "" , "" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP INDEX $indexName$" ; StringTemplate st = new StringTemplate ( ST_DROP_INDEX_STYLE_THREE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_INDEX_NAME_KEY , indexName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test54 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test55 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "'A ) . '44N" , "'A ) . '44N" , "'A ) . '44N" ) ; boolean boolean0 = h2DialectExt0 . canPasteTo ( ( IDatabaseObjectInfo ) databaseObjectInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPasteTo ( IDatabaseObjectInfo info ) { boolean result = true ; DatabaseObjectType type = info . getDatabaseObjectType ( ) ; if ( type . getName ( ) . equalsIgnoreCase ( "database" ) ) { result = false ; } return result ; }
void test56 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsProduct ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test57 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; boolean boolean0 = h2DialectExt0 . supportsProduct ( ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test58 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; HashSet < String [ ] > hashSet0 = new HashSet < String [ ] > ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = h2DialectExt0 . getAddForeignKeyConstraintSQL ( "" , "" , "" , ( Boolean ) true , ( Boolean ) true , ( Boolean ) true , true , "" , ( Collection < String [ ] > ) hashSet0 , "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddForeignKeyConstraintSQL ( String localTableName , String refTableName , String constraintName , Boolean deferrable , Boolean initiallyDeferred , Boolean matchFull , boolean autoFKIndex , String fkIndexName , Collection < String [ ] > localRefColumns , String onUpdateAction , String onDeleteAction , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / FOREIGN KEY ( columnName [ , . . . ] ) / / REFERENCES [ refTableName ] [ ( refColumnName [ , . . . ] ) ] / / [ ON DELETE { CASCADE | RESTRICT | NO ACTION | SET DEFAULT | SET NULL } ] / / [ ON UPDATE { CASCADE | SET DEFAULT | SET NULL } ] / / "ALTER TABLE $childTableName$ " + / / "ADD $constraint$ $constraintName$ FOREIGN KEY ( $childColumn ; separator = \" , \"$ ) " + / / "REFERENCES $parentTableName$ ( $parentColumn ; separator = \" , \"$ ) " ; StringTemplate fkST = new StringTemplate ( ST_ADD_FOREIGN_KEY_CONSTRAINT_STYLE_ONE ) ; HashMap < String , String > fkValuesMap = DialectUtils . getValuesMap ( ST_CHILD_TABLE_KEY , localTableName ) ; fkValuesMap . put ( ST_CONSTRAINT_KEY , "CONSTRAINT" ) ; fkValuesMap . put ( ST_CONSTRAINT_NAME_KEY , constraintName ) ; fkValuesMap . put ( ST_PARENT_TABLE_KEY , refTableName ) ; StringTemplate childIndexST = null ; HashMap < String , String > ckIndexValuesMap = null ; if ( autoFKIndex ) { / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; childIndexST = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; ckIndexValuesMap = new HashMap < String , String > ( ) ; ckIndexValuesMap . put ( ST_INDEX_NAME_KEY , "fk_child_idx" ) ; ckIndexValuesMap . put ( ST_TABLE_NAME_KEY , localTableName ) ; } return DialectUtils . getAddForeignKeyConstraintSQL ( fkST , fkValuesMap , childIndexST , ckIndexValuesMap , localRefColumns , qualifier , prefs , this ) ; }
void test59 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = h2DialectExt0 . getAlterSequenceSQL ( "" , "" , "" , "" , "" , "" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER SEQUENCE $sequenceName$ " + / / "$restartWith$ $startValue$ " + / / "$incrementBy$ $incrementValue$ " ; StringTemplate st = new StringTemplate ( ST_ALTER_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( restart ) ) { valuesMap . put ( ST_RESTART_WITH_KEY , "RESTART WITH" ) ; valuesMap . put ( ST_START_VALUE_KEY , restart ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_BY_KEY , "INCREMENT BY" ) ; valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test60 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "8FV ] " , "8FV ] " ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = h2DialectExt0 . getAlterSequenceSQL ( " class loader . " , " class loader . " , " class loader . " , "jy YK`gMZFrzq" , " class loader . " , " class loader . " , true , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER SEQUENCE $sequenceName$ " + / / "$restartWith$ $startValue$ " + / / "$incrementBy$ $incrementValue$ " ; StringTemplate st = new StringTemplate ( ST_ALTER_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( restart ) ) { valuesMap . put ( ST_RESTART_WITH_KEY , "RESTART WITH" ) ; valuesMap . put ( ST_START_VALUE_KEY , restart ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_BY_KEY , "INCREMENT BY" ) ; valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test61 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ( String ) null , ( String ) null ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = new String [ 8 ] ; String string0 = h2DialectExt0 . getCreateIndexSQL ( "MJsp , 6% | Gr$` | " , "MJsp , 6% | Gr$` | " , "1lkP5J^Bi / = ki_y [ " , stringArray0 , false , ( String ) null , "q & [ 2V { W" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE { [ UNIQUE [ HASH ] ] INDEX [ [ IF NOT EXISTS ] newIndexName ] / / | PRIMARY KEY [ HASH ] } ON ( columnName [ , . . . ] ) StringTemplate st = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; HashMap < String , String > valuesMap = new HashMap < String , String > ( ) ; if ( unique ) { valuesMap . put ( ST_UNIQUE_KEY , "UNIQUE" ) ; if ( accessMethod ! = null & & "HASH" . equalsIgnoreCase ( accessMethod ) ) { valuesMap . put ( ST_STORAGE_OPTION_KEY , "HASH" ) ; } } valuesMap . put ( ST_INDEX_NAME_KEY , indexName ) ; valuesMap . put ( ST_TABLE_NAME_KEY , tableName ) ; return DialectUtils . getAddIndexSQL ( this , st , valuesMap , columns , qualifier , prefs ) ; }
void test62 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; String [ ] stringArray0 = new String [ 1 ] ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "p < - PPMP" , "p < - PPMP" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getCreateIndexSQL ( ( String ) null , ( String ) null , ( String ) null , stringArray0 , true , "p < - PPMP" , "p < - PPMP" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE { [ UNIQUE [ HASH ] ] INDEX [ [ IF NOT EXISTS ] newIndexName ] / / | PRIMARY KEY [ HASH ] } ON ( columnName [ , . . . ] ) StringTemplate st = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; HashMap < String , String > valuesMap = new HashMap < String , String > ( ) ; if ( unique ) { valuesMap . put ( ST_UNIQUE_KEY , "UNIQUE" ) ; if ( accessMethod ! = null & & "HASH" . equalsIgnoreCase ( accessMethod ) ) { valuesMap . put ( ST_STORAGE_OPTION_KEY , "HASH" ) ; } } valuesMap . put ( ST_INDEX_NAME_KEY , indexName ) ; valuesMap . put ( ST_TABLE_NAME_KEY , tableName ) ; return DialectUtils . getAddIndexSQL ( this , st , valuesMap , columns , qualifier , prefs ) ; }
void test63 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; String [ ] stringArray0 = new String [ 1 ] ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getCreateIndexSQL ( "2" , "2" , "2" , stringArray0 , true , "2" , "2" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE { [ UNIQUE [ HASH ] ] INDEX [ [ IF NOT EXISTS ] newIndexName ] / / | PRIMARY KEY [ HASH ] } ON ( columnName [ , . . . ] ) StringTemplate st = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; HashMap < String , String > valuesMap = new HashMap < String , String > ( ) ; if ( unique ) { valuesMap . put ( ST_UNIQUE_KEY , "UNIQUE" ) ; if ( accessMethod ! = null & & "HASH" . equalsIgnoreCase ( accessMethod ) ) { valuesMap . put ( ST_STORAGE_OPTION_KEY , "HASH" ) ; } } valuesMap . put ( ST_INDEX_NAME_KEY , indexName ) ; valuesMap . put ( ST_TABLE_NAME_KEY , tableName ) ; return DialectUtils . getAddIndexSQL ( this , st , valuesMap , columns , qualifier , prefs ) ; }
void test64 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getCreateSequenceSQL ( "" , "" , "" , "" , "" , "" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String start , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE SEQUENCE [ IF NOT EXISTS ] newSequenceName / / [ START WITH long ] / / [ INCREMENT BY long ] / / [ CACHE long ] / / "CREATE SEQUENCE $sequenceName$ START WITH $startValue$ " + / / "INCREMENT BY $incrementValue$ $cache$ $cacheValue$" ; StringTemplate st = new StringTemplate ( ST_CREATE_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( cache ) ) { valuesMap . put ( ST_CACHE_KEY , "CACHE" ) ; valuesMap . put ( ST_CACHE_VALUE_KEY , cache ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } if ( DialectUtils . isNotEmptyString ( start ) ) { valuesMap . put ( ST_START_VALUE_KEY , start ) ; } return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test65 ( ) throws Throwable { H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = h2DialectExt0 . getCreateSequenceSQL ( "^0v" , "^0v" , "^0v" , "^0v" , "78 / #" , "78 / #" , true , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String start , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE SEQUENCE [ IF NOT EXISTS ] newSequenceName / / [ START WITH long ] / / [ INCREMENT BY long ] / / [ CACHE long ] / / "CREATE SEQUENCE $sequenceName$ START WITH $startValue$ " + / / "INCREMENT BY $incrementValue$ $cache$ $cacheValue$" ; StringTemplate st = new StringTemplate ( ST_CREATE_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( cache ) ) { valuesMap . put ( ST_CACHE_KEY , "CACHE" ) ; valuesMap . put ( ST_CACHE_VALUE_KEY , cache ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } if ( DialectUtils . isNotEmptyString ( start ) ) { valuesMap . put ( ST_START_VALUE_KEY , start ) ; } return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test2 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; DialectType dialectType0 = frontBaseDialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DialectType getDialectType ( ) { return DialectFactory . getDialectType ( getSession ( ) . getMetaData ( ) ) ; }
void test3 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test4 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; String string0 = frontBaseDialectExt0 . getMaxFunction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMaxFunction ( ) { return "max" ; }
void test5 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsDropColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropColumn ( ) { return true ; }
void test6 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsAddColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddColumn ( ) { return true ; }
void test7 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; int int0 = frontBaseDialectExt0 . getPrecisionDigits ( 375 , 375 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getPrecisionDigits ( int columnSize , int dataType ) { return columnSize ; }
void test8 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsAddUniqueConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddUniqueConstraint ( ) { return true ; }
void test9 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; String string0 = frontBaseDialectExt0 . getLengthFunction ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLengthFunction ( int dataType ) { return "length" ; }
void test11 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test14 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; Vector < String > vector0 = new Vector < String > ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = frontBaseDialectExt0 . getInsertIntoSQL ( "Fol0N# { { } - h = c / Q\"" , ( List < String > ) vector0 , "Fol0N# { { } - h = c / Q\"" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getInsertIntoSQL ( String tableName , List < String > columns , String valuesPart , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getInsertIntoSQL ( tableName , columns , valuesPart , qualifier , prefs , this ) ; }
void test16 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsTablespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTablespace ( ) { return false ; }
void test17 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsRenameView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameView ( ) { return false ; }
void test18 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = frontBaseDialectExt0 . getCreateViewSQL ( ( String ) null , ( String ) null , ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE [ FORCE ] VIEW [ IF NOT EXISTS ] newViewName [ ( columnName [ , . . ] ) ] / / AS select / / "CREATE VIEW $viewName$ " + / / "AS $selectStatement$ $with$ $checkOptionType$ $checkOption$" ; StringTemplate st = new StringTemplate ( ST_CREATE_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName , ST_SELECT_STATEMENT_KEY , definition ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test19 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; int int0 = frontBaseDialectExt0 . getMaxScale ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxScale ( int dataType ) { return getMaxPrecision ( dataType ) ; }
void test21 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsInsertInto ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsInsertInto ( ) { return true ; }
void test23 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; String [ ] stringArray0 = frontBaseDialectExt0 . getIndexAccessMethodsTypes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexAccessMethodsTypes ( ) { return new String [ ] { "DEFAULT" , "HASH" } ; }
void test24 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = frontBaseDialectExt0 . getDropIndexSQL ( ( String ) null , ( String ) null , true , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP INDEX $indexName$" ; StringTemplate st = new StringTemplate ( ST_DROP_INDEX_STYLE_THREE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_INDEX_NAME_KEY , indexName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test25 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsAddForeignKeyConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddForeignKeyConstraint ( ) { return true ; }
void test26 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsMultipleRowInserts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsMultipleRowInserts ( ) { return true ; }
void test28 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test29 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsAccessMethods ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAccessMethods ( ) { return true ; }
void test30 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test33 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test36 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsCreateIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateIndex ( ) { return true ; }
void test39 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test40 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsAlterSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test41 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test42 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test43 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsViewDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsViewDefinition ( ) { return true ; }
void test44 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = frontBaseDialectExt0 . getDropPrimaryKeySQL ( "I8'u ] " , "I8'u ] " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test46 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsDropIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropIndex ( ) { return true ; }
void test48 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test49 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsIndexes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsIndexes ( ) { return true ; }
void test52 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test53 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsSchemasInTableDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSchemasInTableDefinition ( ) { return false ; }
void test54 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test55 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test57 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; String [ ] stringArray0 = frontBaseDialectExt0 . getIndexStorageOptions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexStorageOptions ( ) { return null ; }
void test58 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test60 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; int int0 = frontBaseDialectExt0 . getColumnLength ( 1207 , 1207 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test61 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsCreateTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateTable ( ) { return true ; }
void test62 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test63 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = frontBaseDialectExt0 . getDropForeignKeySQL ( "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test64 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsCreateView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateView ( ) { return true ; }
void test65 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "max" , "max" , "max" ) ; boolean boolean0 = frontBaseDialectExt0 . canPasteTo ( ( IDatabaseObjectInfo ) databaseObjectInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPasteTo ( IDatabaseObjectInfo info ) { boolean result = true ; DatabaseObjectType type = info . getDatabaseObjectType ( ) ; if ( type . getName ( ) . equalsIgnoreCase ( "database" ) ) { result = false ; } return result ; }
void test66 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsProduct ( "character_length" , "character_length" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test67 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsProduct ( ( String ) null , " ( > W > p . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test68 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; boolean boolean0 = frontBaseDialectExt0 . supportsProduct ( "FrontBaseFrontBase & 9_V * . J09" , "FrontBaseFrontBase & 9_V * . J09" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test69 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = new String [ 4 ] ; String string0 = frontBaseDialectExt0 . getCreateIndexSQL ( "max" , "max" , "max" , stringArray0 , false , ( String ) null , ( String ) null , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE { [ UNIQUE [ HASH ] ] INDEX [ [ IF NOT EXISTS ] newIndexName ] / / | PRIMARY KEY [ HASH ] } ON ( columnName [ , . . . ] ) StringTemplate st = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; HashMap < String , String > valuesMap = new HashMap < String , String > ( ) ; if ( unique ) { valuesMap . put ( ST_UNIQUE_KEY , "UNIQUE" ) ; if ( accessMethod ! = null & & "HASH" . equalsIgnoreCase ( accessMethod ) ) { valuesMap . put ( ST_STORAGE_OPTION_KEY , "HASH" ) ; } } valuesMap . put ( ST_INDEX_NAME_KEY , indexName ) ; valuesMap . put ( ST_TABLE_NAME_KEY , tableName ) ; return DialectUtils . getAddIndexSQL ( this , st , valuesMap , columns , qualifier , prefs ) ; }
void test70 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; String [ ] stringArray0 = new String [ 5 ] ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = frontBaseDialectExt0 . getCreateIndexSQL ( "%N | 35~ / 9y ? \" [ mG [ KY" , "%N | 35~ / 9y ? \" [ mG [ KY" , "%N | 35~ / 9y ? \" [ mG [ KY" , stringArray0 , true , "%N | 35~ / 9y ? \" [ mG [ KY" , "%N | 35~ / 9y ? \" [ mG [ KY" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE { [ UNIQUE [ HASH ] ] INDEX [ [ IF NOT EXISTS ] newIndexName ] / / | PRIMARY KEY [ HASH ] } ON ( columnName [ , . . . ] ) StringTemplate st = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; HashMap < String , String > valuesMap = new HashMap < String , String > ( ) ; if ( unique ) { valuesMap . put ( ST_UNIQUE_KEY , "UNIQUE" ) ; if ( accessMethod ! = null & & "HASH" . equalsIgnoreCase ( accessMethod ) ) { valuesMap . put ( ST_STORAGE_OPTION_KEY , "HASH" ) ; } } valuesMap . put ( ST_INDEX_NAME_KEY , indexName ) ; valuesMap . put ( ST_TABLE_NAME_KEY , tableName ) ; return DialectUtils . getAddIndexSQL ( this , st , valuesMap , columns , qualifier , prefs ) ; }
void test0 ( ) throws Throwable { LinkedList < IndexColInfo > linkedList0 = new LinkedList < IndexColInfo > ( ) ; TableIndexInfo tableIndexInfo0 = new TableIndexInfo ( "" , "" , "" , ( List < IndexColInfo > ) linkedList0 , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TableIndexInfo ( String table , String tableSchema , String ixName , List < IndexColInfo > cols , boolean unique ) { this . table = table ; this . tableSchema = tableSchema ; this . ixName = ixName ; this . cols = cols ; this . unique = unique ; }
void test1 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "DXFN5 [ , n~4l ( 4i $" , "DXFN5 [ , n~4l ( 4i $" , "DXFN5 [ , n~4l ( 4i $" , "DXFN5 [ , n~4l ( 4i $" , ( - 438 ) , "" , ( - 438 ) , ( - 438 ) , ( - 438 ) , ( - 438 ) , "DXFN5 [ , n~4l ( 4i $" , "DXFN5 [ , n~4l ( 4i $" , ( - 438 ) , ( - 438 ) , "DXFN5 [ , n~4l ( 4i $" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "DXFN5 [ , n~4l ( 4i $" , "DXFN5 [ , n~4l ( 4i $" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = greenplumDialectExt0 . getColumnDefaultAlterSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDefaultAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String defaultClause = DialectUtils . SET_DEFAULT_CLAUSE ; return DialectUtils . getColumnDefaultAlterSQL ( this , info , alterClause , false , defaultClause , qualifier , prefs ) ; }
void test2 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = greenplumDialectExt0 . getDropSequenceSQL ( "" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropSequenceSQL ( String sequenceName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP SEQUENCE $sequenceName$ $cascade$" ; StringTemplate st = new StringTemplate ( ST_DROP_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test3 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = greenplumDialectExt0 . getViewDefinitionSQL ( "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getViewDefinitionSQL ( String viewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "select view_definition " + / / "from information_schema . views " + / / "where table_schema = ? " + / / "and table_name = ? " ; String templateStr = "select view_definition from information_schema . views " + "where table_schema = '$schemaName$' and UPPER ( table_name ) = UPPER ( '$viewName$' ) " ; StringTemplate st = new StringTemplate ( templateStr ) ; st . setAttribute ( ST_SCHEMA_NAME_KEY , qualifier . getSchema ( ) ) ; st . setAttribute ( ST_VIEW_NAME_KEY , viewName ) ; return st . toString ( ) ; }
void test4 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test5 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsCreateTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateTable ( ) { return true ; }
void test6 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsAccessMethods ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAccessMethods ( ) { return true ; }
void test7 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test9 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test10 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsDropConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropConstraint ( ) { return true ; }
void test12 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsAddColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddColumn ( ) { return true ; }
void test13 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test14 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test15 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test16 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsIndexes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsIndexes ( ) { return true ; }
void test17 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsViewDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsViewDefinition ( ) { return true ; }
void test18 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsDropColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropColumn ( ) { return true ; }
void test19 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test20 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsAlterSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test21 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test22 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = greenplumDialectExt0 . getDropConstraintSQL ( "max" , "max" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropConstraintSQL ( String tableName , String constraintName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / ALTER TABLE $tableName$ DROP CONSTRAINT $constraintName$ StringTemplate st = new StringTemplate ( ST_DROP_CONSTRAINT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_CONSTRAINT_NAME_KEY , constraintName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test23 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsTablespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTablespace ( ) { return false ; }
void test24 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsAddForeignKeyConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddForeignKeyConstraint ( ) { return true ; }
void test26 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test27 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test28 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test29 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; int int0 = greenplumDialectExt0 . getMaxScale ( 244 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxScale ( int dataType ) { return getMaxPrecision ( dataType ) ; }
void test31 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsAddUniqueConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddUniqueConstraint ( ) { return true ; }
void test32 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsMultipleRowInserts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsMultipleRowInserts ( ) { return true ; }
void test33 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsSchemasInTableDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSchemasInTableDefinition ( ) { return false ; }
void test34 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; DialectType dialectType0 = greenplumDialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test35 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsRenameView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameView ( ) { return false ; }
void test36 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; int int0 = greenplumDialectExt0 . getMaxPrecision ( ( - 6 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxPrecision ( int dataType ) { / / float ( 54 ) produces an exception : / / / / invalid column format 'float' on column 'float_column' . , / / SQL State : 42000 , Error Code : 2014 if ( dataType = = Types . FLOAT ) { return 53 ; } else { return 31 ; } }
void test37 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test38 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsDropIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropIndex ( ) { return true ; }
void test40 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = greenplumDialectExt0 . getCreateViewSQL ( "" , "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE [ FORCE ] VIEW [ IF NOT EXISTS ] newViewName [ ( columnName [ , . . ] ) ] / / AS select / / "CREATE VIEW $viewName$ " + / / "AS $selectStatement$ $with$ $checkOptionType$ $checkOption$" ; StringTemplate st = new StringTemplate ( ST_CREATE_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName , ST_SELECT_STATEMENT_KEY , definition ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test41 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test42 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test44 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsCreateIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateIndex ( ) { return true ; }
void test45 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsEmptyTables ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsEmptyTables ( ) { return true ; }
void test46 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "X" , "X" , "X" , "X" , 752 , "X" , 752 , ( - 968 ) , ( - 968 ) , ( - 968 ) , "X" , "X" , ( - 968 ) , ( - 968 ) , ( String ) null ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = greenplumDialectExt0 . getColumnNameAlterSQL ( tableColumnInfo0 , tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnNameAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String renameToClause = DialectUtils . RENAME_TO_CLAUSE ; return DialectUtils . getColumnNameAlterSQL ( from , to , alterClause , renameToClause , qualifier , prefs , this ) ; }
void test47 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; SequencePropertyMutability sequencePropertyMutability0 = greenplumDialectExt0 . getSequencePropertyMutability ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCache ( ) { return _cache ; }
void test48 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = greenplumDialectExt0 . getRenameViewSQL ( "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getRenameViewSQL ( String oldViewName , String newViewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String msg = DialectUtils . getUnsupportedMessage ( this , DialectUtils . RENAME_VIEW_TYPE ) ; throw new UnsupportedOperationException ( msg ) ; }
void test49 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = greenplumDialectExt0 . getRenameTableSQL ( "CREATE VIEW \n AS " , "CREATE VIEW \n AS " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getRenameTableSQL ( String oldTableName , String newTableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER TABLE $oldObjectName$ RENAME TO $newObjectName$" ; StringTemplate st = new StringTemplate ( ST_RENAME_OBJECT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_OLD_OBJECT_NAME_KEY , oldTableName , ST_NEW_OBJECT_NAME_KEY , newTableName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test50 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsInsertInto ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsInsertInto ( ) { return true ; }
void test51 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsCreateView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateView ( ) { return true ; }
void test52 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; boolean boolean0 = greenplumDialectExt0 . supportsProduct ( "WM" , "WM" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test53 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = greenplumDialectExt0 . getCreateSequenceSQL ( "" , "" , "" , "" , "" , "" , true , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String start , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE SEQUENCE [ IF NOT EXISTS ] newSequenceName / / [ START WITH long ] / / [ INCREMENT BY long ] / / [ CACHE long ] / / "CREATE SEQUENCE $sequenceName$ START WITH $startValue$ " + / / "INCREMENT BY $incrementValue$ $cache$ $cacheValue$" ; StringTemplate st = new StringTemplate ( ST_CREATE_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( cache ) ) { valuesMap . put ( ST_CACHE_KEY , "CACHE" ) ; valuesMap . put ( ST_CACHE_VALUE_KEY , cache ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } if ( DialectUtils . isNotEmptyString ( start ) ) { valuesMap . put ( ST_START_VALUE_KEY , start ) ; } return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test54 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = greenplumDialectExt0 . getCreateSequenceSQL ( "" , "" , "" , "" , "" , "" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String start , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE SEQUENCE [ IF NOT EXISTS ] newSequenceName / / [ START WITH long ] / / [ INCREMENT BY long ] / / [ CACHE long ] / / "CREATE SEQUENCE $sequenceName$ START WITH $startValue$ " + / / "INCREMENT BY $incrementValue$ $cache$ $cacheValue$" ; StringTemplate st = new StringTemplate ( ST_CREATE_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( cache ) ) { valuesMap . put ( ST_CACHE_KEY , "CACHE" ) ; valuesMap . put ( ST_CACHE_VALUE_KEY , cache ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } if ( DialectUtils . isNotEmptyString ( start ) ) { valuesMap . put ( ST_START_VALUE_KEY , start ) ; } return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test56 ( ) throws Throwable { GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = greenplumDialectExt0 . getAlterSequenceSQL ( "" , "" , "" , "" , "" , "" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER SEQUENCE $sequenceName$ " + / / "$restartWith$ $startValue$ " + / / "$incrementBy$ $incrementValue$ " ; StringTemplate st = new StringTemplate ( ST_ALTER_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( restart ) ) { valuesMap . put ( ST_RESTART_WITH_KEY , "RESTART WITH" ) ; valuesMap . put ( ST_START_VALUE_KEY , restart ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_BY_KEY , "INCREMENT BY" ) ; valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test0 ( ) throws Throwable { HibernateDialect hibernateDialect0 = DialectFactory . getDialect ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" HibernateDialect getDialect ( String dbName ) { return dbNameDialectMap . get ( dbName ) ; }
void test1 ( ) throws Throwable { DialectType dialectType0 = DialectFactory . getDialectType ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DialectType getDialectType ( ) { return DialectFactory . getDialectType ( getSession ( ) . getMetaData ( ) ) ; }
void test3 ( ) throws Throwable { DialectFactory dialectFactory0 = new DialectFactory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test4 ( ) throws Throwable { GenericDialectExt genericDialectExt0 = ( GenericDialectExt ) DialectFactory . getDialect ( 1 , ( JFrame ) null , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddPrimaryKey ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * generating SQL for dropping primary keys from existing tables . * * @return true if dropping primary keys is supported ; false otherwise . * / boolean supportsDropPrimaryKey ( ) ; / * * * For the given columnInfo , this provides the type name that is used to * re - create this column in a new table . This method also delegates to * getJavaTypeForNativeType for type OTHER ( 1111 ) . * * @param tcInfo * the TableColumnInfo describing the column * @return the column type name * / String getTypeName ( TableColumnInfo tcInfo ) ; / * * * This will return the java . sql . Types constant that the specified * type name can be stored in . * * @param nativeColumnTypeName * the column type name * @return a java . sql . Types constant representing the java column type this * type is compatible with . * / int getJavaTypeForNativeType ( String nativeColumnTypeName ) ; int getTimestampMaximumFractionalDigits ( ) ; / * * * Returns a literal string which is acceptable for SQL that update , * insert or delete statements on a row which contains a column whose data type accepts * binary data . * * @param binaryData * the actual bytes that form the binary data value * @return a literal string that is acceptable to be used in an insert , * update or delete statement . * / String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test5 ( ) throws Throwable { PostgreSQLDialectExt postgreSQLDialectExt0 = ( PostgreSQLDialectExt ) DialectFactory . getDialectIgnoreCase ( "y9J & q" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" HibernateDialect getDialectIgnoreCase ( String dbName ) { for ( String displayName : dbNameDialectMap . keySet ( ) ) { if ( displayName . toLowerCase ( ) . equals ( dbName . toLowerCase ( ) ) ) { return dbNameDialectMap . get ( displayName ) ; } } return null ; }
void test6 ( ) throws Throwable { InformixDialectExt informixDialectExt0 = ( InformixDialectExt ) DialectFactory . getDialectIgnoreCase ( "informix" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTimestampMaximumFractionalDigits ( ) { return 9 ; }
void test7 ( ) throws Throwable { GenericDialectExt genericDialectExt0 = ( GenericDialectExt ) DialectFactory . getDialect ( 0 , ( JFrame ) null , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test1 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test2 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsCreateView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateView ( ) { return true ; }
void test3 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsAddColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddColumn ( ) { return true ; }
void test4 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sybaseDialectExt0 . getViewDefinitionSQL ( "gn0Wbpg | * * PnOw ? " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getViewDefinitionSQL ( String viewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "select view_definition " + / / "from information_schema . views " + / / "where table_schema = ? " + / / "and table_name = ? " ; String templateStr = "select view_definition from information_schema . views " + "where table_schema = '$schemaName$' and UPPER ( table_name ) = UPPER ( '$viewName$' ) " ; StringTemplate st = new StringTemplate ( templateStr ) ; st . setAttribute ( ST_SCHEMA_NAME_KEY , qualifier . getSchema ( ) ) ; st . setAttribute ( ST_VIEW_NAME_KEY , viewName ) ; return st . toString ( ) ; }
void test5 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsInsertInto ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsInsertInto ( ) { return true ; }
void test6 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test7 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; String [ ] stringArray0 = sybaseDialectExt0 . getIndexStorageOptions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexStorageOptions ( ) { return null ; }
void test8 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "Methods cannot be invoked on a closed connection" , "Methods cannot be invoked on a closed connection" , "Methods cannot be invoked on a closed connection" , "Methods cannot be invoked on a closed connection" , 1 , "Methods cannot be invoked on a closed connection" , 17 , 1 , ( - 947 ) , ( - 947 ) , "Methods cannot be invoked on a closed connection" , "Methods cannot be invoked on a closed connection" , ( - 947 ) , 108 , "Methods cannot be invoked on a closed connection" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "Methods cannot be invoked on a closed connection" , "y7U5a . Ftjhh5bkn$" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = sybaseDialectExt0 . getAddColumnSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddColumnSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { ArrayList < String > result = new ArrayList < String > ( ) ; boolean addDefaultClause = true ; boolean supportsNullQualifier = true ; boolean addNullClause = true ; String sql = DialectUtils . getAddColumSQL ( column , this , addDefaultClause , supportsNullQualifier , addNullClause , qualifier , prefs ) ; result . add ( sql ) ; if ( column . getRemarks ( ) ! = null & & ! "" . equals ( column . getRemarks ( ) ) ) { result . add ( getColumnCommentAlterSQL ( column , qualifier , prefs ) ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; }
void test11 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test12 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "datalength" , "datalength" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sybaseDialectExt0 . getDropPrimaryKeySQL ( "datalength" , "datalength" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test13 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsAccessMethods ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAccessMethods ( ) { return true ; }
void test14 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; String string0 = sybaseDialectExt0 . getLengthFunction ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLengthFunction ( int dataType ) { return "length" ; }
void test15 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "` | k = #3 - ) tT ] ) ~K5 > 'r" , "ALTER TABLE null\n DROP CONSTRAINT \"null\"" ) ; String string0 = sybaseDialectExt0 . getDropViewSQL ( "` | k = #3 - ) tT ] ) ~K5 > 'r" , true , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropViewSQL ( String viewName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP VIEW $viewName$" ; StringTemplate st = new StringTemplate ( ST_DROP_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test16 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsDropIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropIndex ( ) { return true ; }
void test17 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsEmptyTables ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsEmptyTables ( ) { return true ; }
void test18 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " ) o : aQEpQN < 8U < xm : " , " ) o : aQEpQN < 8U < xm : " ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , 0 , "" , 0 , 0 , 0 , 0 , "" , " > H3nl9 ! cS / } S | lR" , 0 , 0 , " > H3nl9 ! cS / } S | lR" ) ; String string0 = sybaseDialectExt0 . getColumnNameAlterSQL ( tableColumnInfo0 , tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnNameAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String renameToClause = DialectUtils . RENAME_TO_CLAUSE ; return DialectUtils . getColumnNameAlterSQL ( from , to , alterClause , renameToClause , qualifier , prefs , this ) ; }
void test19 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sybaseDialectExt0 . getColumnDropSQL ( "DefaultIntervalCategoryDataset : the number of categories in the start value dataset does not match the number of categories in the end value dataset . " , "DefaultIntervalCategoryDataset : the number of categories in the start value dataset does not match the number of categories in the end value dataset . " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { StringTemplate st = new StringTemplate ( DROP_COLUMN_SQL_TEMPLATE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_COLUMN_NAME_KEY , columnName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test20 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsTablespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTablespace ( ) { return false ; }
void test21 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsDropColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropColumn ( ) { return true ; }
void test22 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test23 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; String [ ] stringArray0 = sybaseDialectExt0 . getIndexAccessMethodsTypes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexAccessMethodsTypes ( ) { return new String [ ] { "DEFAULT" , "HASH" } ; }
void test24 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsAddForeignKeyConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddForeignKeyConstraint ( ) { return true ; }
void test25 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsAddUniqueConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddUniqueConstraint ( ) { return true ; }
void test26 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsViewDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsViewDefinition ( ) { return true ; }
void test27 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test28 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsCheckOptionsForViews ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCheckOptionsForViews ( ) { return false ; }
void test29 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsIndexes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsIndexes ( ) { return true ; }
void test31 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test33 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test34 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsDropConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropConstraint ( ) { return true ; }
void test35 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsCreateIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateIndex ( ) { return true ; }
void test36 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test39 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsRenameView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameView ( ) { return false ; }
void test40 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sybaseDialectExt0 . getRenameTableSQL ( ( String ) null , ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getRenameTableSQL ( String oldTableName , String newTableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER TABLE $oldObjectName$ RENAME TO $newObjectName$" ; StringTemplate st = new StringTemplate ( ST_RENAME_OBJECT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_OLD_OBJECT_NAME_KEY , oldTableName , ST_NEW_OBJECT_NAME_KEY , newTableName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test41 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsMultipleRowInserts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsMultipleRowInserts ( ) { return true ; }
void test42 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test44 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test45 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sybaseDialectExt0 . getDropIndexSQL ( ( String ) null , ( String ) null , true , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP INDEX $indexName$" ; StringTemplate st = new StringTemplate ( ST_DROP_INDEX_STYLE_THREE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_INDEX_NAME_KEY , indexName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test46 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test47 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsAlterSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test49 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; byte [ ] byteArray0 = new byte [ 4 ] ; String string0 = sybaseDialectExt0 . getBinaryLiteralString ( byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test50 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sybaseDialectExt0 . getDropForeignKeySQL ( "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test51 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ( String ) null , ( String ) null ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = sybaseDialectExt0 . getRenameViewSQL ( ( String ) null , ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getRenameViewSQL ( String oldViewName , String newViewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String msg = DialectUtils . getUnsupportedMessage ( this , DialectUtils . RENAME_VIEW_TYPE ) ; throw new UnsupportedOperationException ( msg ) ; }
void test52 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test53 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DialectType dialectType0 = sybaseDialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DialectType getDialectType ( ) { return DialectFactory . getDialectType ( getSession ( ) . getMetaData ( ) ) ; }
void test54 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sybaseDialectExt0 . getDropConstraintSQL ( ( String ) null , ( String ) null , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropConstraintSQL ( String tableName , String constraintName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / ALTER TABLE $tableName$ DROP CONSTRAINT $constraintName$ StringTemplate st = new StringTemplate ( ST_DROP_CONSTRAINT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_CONSTRAINT_NAME_KEY , constraintName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test55 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test57 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; String string0 = sybaseDialectExt0 . getNullColumnString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getNullColumnString ( ) ; / * * * Returns the name of the aggregate function that determines the max value * of an expression . * * @return the name of the function to be applied to a set to determine the * element with the highest numeric value . * / String getMaxFunction ( ) ; / * * * Returns the name of the function that measures the length of a character * string . * * @param dataType * the java . sql . Types data type . Some databases have different * length functions for different data types . * @return the name of the function to be applied to a column to determine * the length of that column in a particular record . * / String getLengthFunction ( int dataType ) ; / * * * Returns the maximum precision allowed by the database for number type * fields that specify the length of the number to the left of the decimal * point in digits . If the HibernateDialect implementation doesn't ever use * $p in any call to registerColumnType ( ) , then this maximum precsision will * not be used . * * @param dataType * the java . sql . Types data type . * @return the maximum number that can be used in a column declaration for * precision for the specified type . * / int getMaxPrecision ( int dataType ) ; / * * * Returns the maximum scale allowed by the database for number type fields * that specify the length of the number to the right of the decimal point * in digits . If the HibernateDialect implementation doesn't ever use $s in * any call to registerColumnType ( ) , then this maximum scale will not be * used . * * @param dataType * the java . sql . Types data type . * @return the maximum number that can be used in a column declaration for * scale for the specified type . * / int getMaxScale ( int dataType ) ; / * * * Returns the number of digits of precision is represented by the specifed * columnSize for the specified dataType . Some DBs represent precision as * the total number of digits on the right or left of the decimal . That is * what we want . Others ( like PostgreSQL ) give the number of bytes of * storage a column can use - less than useful , since the SQL - 92 says * "number of digits" and this is what most other DBs use . * * @param columnSize * the size of the column as reported by the driver . * @param dataType * the java . sql . Types data type . * @return a number indicating the total number of digits ( includes both * sides of the decimal point ) the column can represent . * / int getPrecisionDigits ( int columnSize , int dataType ) ; / * * * Some jdbc drivers are hopelessly broken with regard to reporting the * COLUMN_SIZE . For example , MaxDB has a "long byte" data type which can * store up to 2G of data , yet the driver reports that the column size is * "8" - real helpful . So for drivers that have this problem , return the * "proper" maximum column length for the specified dataType . If the driver * doesn't have this problem , just return the columnSize . * * @param columnSize * the size of the column as reported by the jdbc driver * @param dataType * the type of the column . * @return the specified columnSize if the jdbc driver isn't broken ; * otherwise , the maximum column size for the specified dataType if * the driver is broken . * / int getColumnLength ( int columnSize , int dataType ) ; / * * * Returns boolean value indicating whether or not this dialect supports the * specified database product / version . * * @param databaseProductName * the name of the database as reported by * DatabaseMetaData . getDatabaseProductName ( ) * @param databaseProductVersion * the version of the database as reported by * DatabaseMetaData . getDatabaseProductVersion ( ) * @return true if this dialect can be used for the specified product name * and version ; false otherwise . * / boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) ; / * * * The string which identifies this dialect in the dialect chooser . * * @return a descriptive name that tells the user what database this dialect * is design to work with . * / String getDisplayName ( ) ; / * * * Returns a boolean value indicating whether or not this dialect supports * adding comments to columns . * * @return true if column comments are supported ; false otherwise . * / boolean supportsColumnComment ( ) ; / * * * Returns the SQL statement to use to add a comment to the specified column * of the specified table . * * @param info * information about the column such as type , name , etc . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * @throws UnsupportedOperationException * if the database doesn't support annotating columns with a * comment . * / String getColumnCommentAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping columns from tables . * * @return true if the database supports dropping columns ; false otherwise . * / boolean supportsDropColumn ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports changing a column from null to not - null and vice versa . * * @return true if the database supports dropping columns ; false otherwise . * / boolean supportsAlterColumnNull ( ) ; / * * * Returns the SQL that forms the command to drop the specified colum in the * specified table . * * @param tableName * the name of the table that has the column * @param columnName * the name of the column to drop . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql for dropping the specified column * @throw UnsupportedOperationException if the database doesn't support * dropping columns . * / String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException ; / * * * Returns the SQL that forms the command to drop the specified table . If * cascade contraints is supported by the dialect and cascadeConstraints is * true , then a drop statement with cascade constraints clause will be * formed . * * @param iTableInfo * the table to drop * @param cascadeConstraints * whether or not to drop any FKs that may reference the * specified table . * @param isMaterializedView * whether or not the specified table info is actually a * materialized view * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the drop SQL command . * / List < String > getTableDropSQL ( ITableInfo iTableInfo , boolean cascadeConstraints , boolean isMaterializedView , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL that forms the command to add a primary key to the * specified table composed of the given column names . * * @param pkName * the name of the constraint * @param ti * the table to add a primary key to * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @param columnNames * the columns that form the key * @return * / String [ ] getAddPrimaryKeySQL ( String pkName , TableColumnInfo [ ] colInfos , ITableInfo ti , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL fragment for adding a column in an alter table statement . * * @return * / String getAddColumnString ( ) ; / * * * Returns the SQL used to alter the nullability of the specified column * * @param info * the column to modify * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL to execute * / String [ ] getColumnNullableAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports renaming columns . * * @return true if the database supports changing the name of columns ; false * otherwise . * / boolean supportsRenameColumn ( ) ; / * * * Returns the SQL that is used to change the column name . * * @param from * the TableColumnInfo as it is * @param to * the TableColumnInfo as it wants to be * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL to make the change * / String getColumnNameAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns a boolean value indicating whether or not this dialect supports * modifying a columns type . * * @return true if supported ; false otherwise * / boolean supportsAlterColumnType ( ) ; / * * * Returns the SQL that is used to change the column type . * * @param from * the TableColumnInfo as it is * @param to * the TableColumnInfo as it wants to be * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL to make the change * @throw UnsupportedOperationException if the database doesn't support * modifying column types . * / List < String > getColumnTypeAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException ; / * * * Returns a boolean value indicating whether or not this database dialect * supports changing a column's default value . * * @return true if the database supports modifying column defaults ; false * otherwise * / boolean supportsAlterColumnDefault ( ) ; / * * * Returns the SQL command to change the specified column's default value * * @param info * the column to modify and it's default value . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return SQL to make the change * / String getColumnDefaultAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL command to drop the specified table's primary key . * * @param pkName * the name of the primary key that should be dropped * @param tableName * the name of the table whose primary key should be dropped * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * / String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL command to drop the specified table's foreign key * constraint . * * @param fkName * the name of the foreign key that should be dropped * @param tableName * the name of the table whose foreign key should be dropped * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * / String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the SQL command to create the specified table ( columns appear in * the same order as they are stored in the database ) . * * @param tables * the tables to get create statements for * @param md * the metadata from the ISession * @param prefs * preferences about how the resultant SQL commands should be * formed . * @param isJdbcOdbc * whether or not the connection is via JDBC - ODBC bridge . * @return the SQL that is used to create the specified table * / List < String > getCreateTableSQL ( List < ITableInfo > tables , ISQLDatabaseMetaData md , CreateScriptPreferences prefs , boolean isJdbcOdbc ) throws SQLException ; / * * * Returns the SQL command to create the specified table . Optionally , if * sortColumns is true , colums will be sorted by column name in ascending * order . * * @param tables * the tables to get create statements for * @param md * the metadata from the ISession * @param prefs * preferences about how the resultant SQL commands should be * formed . * @param isJdbcOdbc * whether or not the connection is via JDBC - ODBC bridge . * @param sortColumns * whether or not to sort columns according to their column name . * * @return the SQL that is used to create the specified table * / List < String > getCreateTableSQL ( List < ITableInfo > tables , ISQLDatabaseMetaData md , CreateScriptPreferences prefs , boolean isJdbcOdbc , boolean sortColumns ) throws SQLException ; / * * * Returns the DialectType enum value associated with this dialect . * * @return the DialectType * / DialectType getDialectType ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports sequences . * * @return true if the database supports sequence ; false otherwise . * / boolean supportsSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * suports tablespaces . Specifically , when creating an index , some databases * allow a tablespace to be specified to create the index in , recognizing * that indexes can be quite large . * * @return true if the database supports tablespaces ; false otherwise . * / boolean supportsTablespace ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports indexes . * * @return true if the database supports indexes ; false otherwise . * / boolean supportsIndexes ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports access methods . * * @return true if the database supports access methods ; false otherwise . * / boolean supportsAccessMethods ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports auto - increment on columns . * * @return true if the database supports auto - increment ; false otherwise . * / boolean supportsAutoIncrement ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports check options for views . * * @return true if the database supports check options for views ; false * otherwise . * / boolean supportsCheckOptionsForViews ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports empty tables . * * @return true if the database supports empty tables ; false otherwise . * / boolean supportsEmptyTables ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports the optional SQL feature "row value constructors" ( F641 ) that * allows to insert multiple rows in a single insert statement . * * @return true if the database supports multiple row inserts ; false * otherwise . * / boolean supportsMultipleRowInserts ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports adding columns to existing tables * * @return true if the database supports adding columns ; false otherwise . * / boolean supportsAddColumn ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports adding foreign key constraints . * * @return true if the database supports adding foreign key constraints ; * false otherwise . * / boolean supportsAddForeignKeyConstraint ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports adding unique constraints . * * @return true if the database supports adding unique constraints ; false * otherwise . * / boolean supportsAddUniqueConstraint ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports altering sequences . * * @return true if the database supports altering sequences ; false * otherwise . * / boolean supportsAlterSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating indexes . * * @return true if the database supports creating indexes ; false otherwise . * / boolean supportsCreateIndex ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating sequences . * * @return true if the database supports creating sequences ; false * otherwise . * / boolean supportsCreateSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating tables . * * @return true if the database supports creating tables ; false otherwise . * / boolean supportsCreateTable ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports creating views . * * @return true if the database supports creating views ; false otherwise . * / boolean supportsCreateView ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping constraints . * * @return true if the database supports dropping constraints ; false * otherwise . * / boolean supportsDropConstraint ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping indexes . * * @return true if the database supports dropping indexes ; false otherwise . * / boolean supportsDropIndex ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping sequences . * * @return true if the database supports dropping sequences ; false * otherwise . * / boolean supportsDropSequence ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports dropping views . * * @return true if the database supports dropping views ; false otherwise . * / boolean supportsDropView ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports inserting rows . * * @return true if the database supports inserting rows ; false otherwise . * / boolean supportsInsertInto ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports renaming tables . * * @return true if the database supports renaming tables ; false otherwise . * / boolean supportsRenameTable ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports renaming views . * * @return true if the database supports renaming views ; false otherwise . * / boolean supportsRenameView ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports gathering information about sequences . * * @return true if the database supports gathering information about * sequences ; false otherwise . * / boolean supportsSequenceInformation ( ) ; / * * * Returns a boolean value indicating whether or not this database dialect * supports updating rows . * * @return true if the database supports updating rows ; false otherwise . * / boolean supportsUpdate ( ) ; / * * * Gets the index access methods that this dialect supports used when * creating indexes . * * @return all the access methods supported by this dialect . * / String [ ] getIndexAccessMethodsTypes ( ) ; / * * * Gets the index storage options that this dialect supports used when * creating indexes . * * @return all the access methods supported by this dialect . * / String [ ] getIndexStorageOptions ( ) ; / * * * Gets the SQL command to create a new table . * * @param tableName * simple name of the table * @param columns * columns of the table * @param primaryKeys * primary keys of the table * @param prefs * preferences for generated sql scripts * @param qualifier * qualifier of the table * @return the sql command to create a table . * / String getCreateTableSQL ( String tableName , List < TableColumnInfo > columns , List < TableColumnInfo > primaryKeys , SqlGenerationPreferences prefs , DatabaseObjectQualifier qualifier ) ; / * * * Gets the SQL command to rename a table . * * @param oldTableName * old name of the table * @param newTableName * new name of the table * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to rename a table . * / String getRenameTableSQL ( String oldTableName , String newTableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to create a view . * * @param viewName * name of the view * @param definition * old definition of the view . * @param checkOption * CHECK OPTION . CASCADE , LOCAL or null for no check option . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to create a view . * / String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to rename a view . * * @param oldViewName * old name of the view * @param newViewName * new name of the view * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command * / String [ ] getRenameViewSQL ( String oldViewName , String newViewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop a view . * * @param viewName * name of the view * @param cascade * cascade true if automatically drop object that depend on the * view ( such as other views ) . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the SQL command to drop a view . * / String getDropViewSQL ( String viewName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to create an index . * * @param indexName * name of the index to be created * @param tableName * name of the table * @param accessMethod * the index access method to use ( for example , b - tree , r - tree , * hash , etc . ) * @param columns * columns where the index should be stored for * @param unique * true if the index should be unique * @param tablespace * tablespace for the index ( leave empty for no tablespace ) * @param constraints * constraints for the index ( leave empty for no constraints ) * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to create an index . * / String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop an index . * * @param tableName * name of the table that the index indexes . This can be null . * @param indexName * name of the index * @param cascade * true if automatically drop object that depend on the view * ( such as other views ) . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to drop an index . * / String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to create a sequence . * * @param sequenceName * name of the sequence * @param increment * increment value * @param minimum * minimum value ( leave empty for NO MINVALUE ) * @param maximum * maximum value ( leave empty for NO MINVALUE ) * @param start * start value ( leave empty for default ) * @param cache * cache value , how many sequences should be preallocated ( leave * empty for default ) * @param cycle * true if the sequence should wrap around when the max - / minvalue * has been reached ( leave empty for NO CYCLE ) * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to create a sequence . * / String getCreateSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String start , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to alter a sequence . * * @param sequenceName * name of the sequence . * @param increment * increment value . * @param minimum * minimum value . * @param maximum * maximum value . * @param restart * start value . * @param cache * cache value , how many sequences should be preallocated . * @param cycle * true if the sequence should wrap around when the max - / minvalue * has been reached . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command statements * / String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to query the specific database to find out the * information about the sequence . The query should return the following * fields : last_value , max_value , min_value , cache_value , increment_by , * is_cycled * * @param sequenceName * the name of the sequence . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to query the database . * / String getSequenceInformationSQL ( String sequenceName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop a sequence . * * @param sequenceName * name of the sequence * @param cascade * true if automatically drop object that depend on the view * ( such as other views ) . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to drop a sequence . * / String getDropSequenceSQL ( String sequenceName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to add a foreign key constraint to a table . * * @param localTableName * name of the table where the foreign key should be stored . * @param refTableName * name of the table where the foreign key should reference to . * @param constraintName * name of the constraint . Leave it empty and it won't create a * CONSTRAINT name . * @param deferrable * true if the constraint is deferrable , false if not . * @param initiallyDeferred * true if the constraint is deferrable and initially deferred , * false if not . * @param matchFull * true if the referenced columns using MATCH FULL . * @param autoFKIndex * true to create an additional INDEX with the given fkIndexName * Name . * @param fkIndexName * name of the foreign key index name . * @param localRefColumns * local and referenced column collection . In the first Element * of the String Array should be the local column name and in the * second Element the referenced Table column name . * @param onUpdateAction * update action . For example "RESTRICT" . * @param onDeleteAction * delete action . For exampel "NO ACTION" . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add a foreign key constraint . * / String [ ] getAddForeignKeyConstraintSQL ( String localTableName , String refTableName , String constraintName , Boolean deferrable , Boolean initiallyDeferred , Boolean matchFull , boolean autoFKIndex , String fkIndexName , Collection < String [ ] > localRefColumns , String onUpdateAction , String onDeleteAction , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to add a unique constraint to a table . * * @param tableName * name of the table where the unique constraint should be added * to . * @param constraintName * name of the constraint . * @param columns * the unique columns . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add a unique constraint . * / String [ ] getAddUniqueConstraintSQL ( String tableName , String constraintName , TableColumnInfo [ ] columns , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL to add an auto - increment to a column . * * @param column * column to where the auto - increment should be added to . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add auto - increment . * / String [ ] getAddAutoIncrementSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL to add an auto - increment to a column . * * @param column * column to where the auto - increment should be added to . * @param sequenceName * if a sequence is created for the purpose of generating the * next auto - incremented value , then this is the name of the * sequence . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add auto - increment . * / String [ ] getAddAutoIncrementSQL ( TableColumnInfo column , String sequenceName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to drop a constraint from a table . * * @param tableName * name of the table where the constraint should be dropped from . * @param constraintName * name of the constraint . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to drop a constraint . * / String getDropConstraintSQL ( String tableName , String constraintName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to insert data into a table . * < p / > * If the list of columns is empty or null the SQL will look like : INSERT * INTO tablename valuesPart ; * < p / > * instead of : INSERT INTO tablename ( column1 , column2 , . . . ) valuesPart ; * * @param tableName * simple name of the table * @param columns * columns of the table * @param valuesPart * either a query or a VALUES ( . . . ) string that defines the data * to insert * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to insert data . * / String getInsertIntoSQL ( String tableName , List < String > columns , String valuesPart , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to update the specified columns with the specified * values . * * @param tableName * simple name of the table * @param setColumns * columns to be set * @param setValues * values the columns should be set with * @param fromTables * simple names of the tables in the FROM clause * @param whereColumns * columns in the WHERE clause * @param whereValues * values of the columns in the WHERE clause * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to update data . * / String [ ] getUpdateSQL ( String tableName , String [ ] setColumns , String [ ] setValues , String [ ] fromTables , String [ ] whereColumns , String [ ] whereValues , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Gets the SQL command to add a column to the specified table . * * @param column * information about the column * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return the sql command to add a column * @throws UnsupportedOperationException * if the database doesn't support adding columns after a table * has already been created . Use supportsAddColumn before * calling this to avoid that . * / String [ ] getAddColumnSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * The character specific to this dialect used to close a quoted identifier . * * @return The dialect's specific close quote character . * / char closeQuote ( ) ; / * * * The character specific to this dialect used to begin a quoted identifier . * * @return The dialect's specific open quote character . * / char openQuote ( ) ; / * * * Whether or not the definition of a view can be determined via a query * that is returned from getViewDefinitionSQL method * * @return true if getViewDefinitionSQL yields a non - null value ; false * otherwise . * / boolean supportsViewDefinition ( ) ; / * * * Returns the SQL that can be used to query the data dictionary for the * body of a view . This should exclude the "CREATE VIEW < viewname > AS" * prefix and just return the query . This can return null if the database * doesn't provide access to this definition . * * @param viewName * the name of the view to get the definition for . * @param qualifier * qualifier of the table * @param prefs * preferences for generated sql scripts * @return * / String getViewDefinitionSQL ( String viewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns the qualified identifier based on the specified qualifier and * user preferences . * * @param identifier * @param qualifier * @param prefs * @return * / String getQualifiedIdentifier ( String identifier , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) ; / * * * Returns a boolean indicating whether or not this dialect supports * correlated sub - queries . * * @return true if support for correlated sub - queries and false otherwise . * / boolean supportsCorrelatedSubQuery ( ) ; / * * * Gets the sequence property mutability , which describes which properties * of a sequence can be changed , and which cannot . * * @return the SequencePropertyMutability * / SequencePropertyMutability getSequencePropertyMutability ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * timestamps with fractional second precision . For dialects that do , * Timestamp . getNanos returns the sub - second fractional value . * * @return true if support for sub - second precision , or false if timestamps * are granular only to the second . * / boolean supportsSubSecondTimestamps ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * generating SQL for adding primary keys to existing tables . * * @return true if adding primary keys is supported ; false otherwise . * / boolean supportsAddPrimaryKey ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * generating SQL for dropping primary keys from existing tables . * * @return true if dropping primary keys is supported ; false otherwise . * / boolean supportsDropPrimaryKey ( ) ; / * * * For the given columnInfo , this provides the type name that is used to * re - create this column in a new table . This method also delegates to * getJavaTypeForNativeType for type OTHER ( 1111 ) . * * @param tcInfo * the TableColumnInfo describing the column * @return the column type name * / String getTypeName ( TableColumnInfo tcInfo ) ; / * * * This will return the java . sql . Types constant that the specified * type name can be stored in . * * @param nativeColumnTypeName * the column type name * @return a java . sql . Types constant representing the java column type this * type is compatible with . * / int getJavaTypeForNativeType ( String nativeColumnTypeName ) ; int getTimestampMaximumFractionalDigits ( ) ; / * * * Returns a literal string which is acceptable for SQL that update , * insert or delete statements on a row which contains a column whose data type accepts * binary data . * * @param binaryData * the actual bytes that form the binary data value * @return a literal string that is acceptable to be used in an insert , * update or delete statement . * / String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test58 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test59 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "Vy\"" , "%a { Ob#" , "" , "%a { Ob#" , 0 , ( String ) null , 0 , 0 , 0 , 0 , ( String ) null , "%a { Ob#" , ( - 853 ) , ( - 1 ) , "Vy\"" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = sybaseDialectExt0 . getColumnNullableAlterSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getColumnNullableAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; return new String [ ] { DialectUtils . getColumnNullableAlterSQL ( info , this , alterClause , true , qualifier , prefs ) } ; }
void test60 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsCreateTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateTable ( ) { return true ; }
void test61 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "sql serverv | > { c" , "sql serverv | > { c" , "sql serverv | > { c" , "sql serverv | > { c" , ( - 1 ) , "sql serverv | > { c" , ( - 1 ) , ( - 1 ) , ( - 1 ) , 34 , "sql serverv | > { c" , "sql serverv | > { c" , ( - 1 ) , ( - 1 ) , "sql serverv | > { c" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "sql serverv | > { c" , "sql serverv | > { c" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; List < String > list0 = sybaseDialectExt0 . getColumnTypeAlterSQL ( tableColumnInfo0 , tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test62 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "ALTER TABLE datalength DROP CONSTRAINT \"datalength\"" , "ALTER TABLE datalength DROP CONSTRAINT \"datalength\"" , "ALTER TABLE datalength DROP CONSTRAINT \"datalength\"" ) ; boolean boolean0 = sybaseDialectExt0 . canPasteTo ( ( IDatabaseObjectInfo ) databaseObjectInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPasteTo ( IDatabaseObjectInfo info ) { boolean result = true ; DatabaseObjectType type = info . getDatabaseObjectType ( ) ; if ( type . getName ( ) . equalsIgnoreCase ( "database" ) ) { result = false ; } return result ; }
void test63 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; int int0 = sybaseDialectExt0 . getMaxScale ( 8 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxScale ( int dataType ) { return getMaxPrecision ( dataType ) ; }
void test64 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; int int0 = sybaseDialectExt0 . getMaxScale ( 4 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxScale ( int dataType ) { return getMaxPrecision ( dataType ) ; }
void test65 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsProduct ( "datalength" , "datalength" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test66 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsProduct ( ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test67 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsProduct ( "adaptiveincrementb" , "adaptiveincrementb" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test68 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; boolean boolean0 = sybaseDialectExt0 . supportsProduct ( "sql serverv | > { c" , "sql serverv | > { c" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test69 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; String [ ] stringArray0 = new String [ 4 ] ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sybaseDialectExt0 . getCreateIndexSQL ( "" , "" , "" , stringArray0 , false , ( String ) null , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE { [ UNIQUE [ HASH ] ] INDEX [ [ IF NOT EXISTS ] newIndexName ] / / | PRIMARY KEY [ HASH ] } ON ( columnName [ , . . . ] ) StringTemplate st = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; HashMap < String , String > valuesMap = new HashMap < String , String > ( ) ; if ( unique ) { valuesMap . put ( ST_UNIQUE_KEY , "UNIQUE" ) ; if ( accessMethod ! = null & & "HASH" . equalsIgnoreCase ( accessMethod ) ) { valuesMap . put ( ST_STORAGE_OPTION_KEY , "HASH" ) ; } } valuesMap . put ( ST_INDEX_NAME_KEY , indexName ) ; valuesMap . put ( ST_TABLE_NAME_KEY , tableName ) ; return DialectUtils . getAddIndexSQL ( this , st , valuesMap , columns , qualifier , prefs ) ; }
void test71 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sybaseDialectExt0 . getCreateViewSQL ( ( String ) null , ( String ) null , ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE [ FORCE ] VIEW [ IF NOT EXISTS ] newViewName [ ( columnName [ , . . ] ) ] / / AS select / / "CREATE VIEW $viewName$ " + / / "AS $selectStatement$ $with$ $checkOptionType$ $checkOption$" ; StringTemplate st = new StringTemplate ( ST_CREATE_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName , ST_SELECT_STATEMENT_KEY , definition ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test72 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " ) o : aQEpQN < 8U < xm : " , " ) o : aQEpQN < 8U < xm : " ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sybaseDialectExt0 . getCreateViewSQL ( "" , "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE [ FORCE ] VIEW [ IF NOT EXISTS ] newViewName [ ( columnName [ , . . ] ) ] / / AS select / / "CREATE VIEW $viewName$ " + / / "AS $selectStatement$ $with$ $checkOptionType$ $checkOption$" ; StringTemplate st = new StringTemplate ( ST_CREATE_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName , ST_SELECT_STATEMENT_KEY , definition ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test73 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sybaseDialectExt0 . getCreateViewSQL ( "rtrim" , "rtrim" , "rtrim" , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE [ FORCE ] VIEW [ IF NOT EXISTS ] newViewName [ ( columnName [ , . . ] ) ] / / AS select / / "CREATE VIEW $viewName$ " + / / "AS $selectStatement$ $with$ $checkOptionType$ $checkOption$" ; StringTemplate st = new StringTemplate ( ST_CREATE_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName , ST_SELECT_STATEMENT_KEY , definition ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test74 ( ) throws Throwable { SybaseDialectExt sybaseDialectExt0 = new SybaseDialectExt ( ) ; String [ ] stringArray0 = new String [ 8 ] ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "java . math . BigInteger" , ( String ) null ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray1 = sybaseDialectExt0 . getUpdateSQL ( ( String ) null , stringArray0 , stringArray0 , stringArray0 , stringArray0 , stringArray0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getUpdateSQL ( String tableName , String [ ] setColumns , String [ ] setValues , String [ ] fromTables , String [ ] whereColumns , String [ ] whereValues , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { StringTemplate st = new StringTemplate ( ST_UPDATE_CORRELATED_QUERY_STYLE_TWO ) ; return DialectUtils . getUpdateSQL ( st , tableName , setColumns , setValues , fromTables , whereColumns , whereValues , qualifier , prefs , this ) ; }
void test0 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "'maxX' cannot be INF or NaN . " , "'maxX' cannot be INF or NaN . " ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getDropPrimaryKeySQL ( "" , " [ ! _VB\\czwD" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test1 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test2 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test3 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsInsertInto ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsInsertInto ( ) { return true ; }
void test4 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; String string0 = derbyDialectExt0 . getMaxFunction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMaxFunction ( ) { return "max" ; }
void test5 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test6 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsAlterSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test7 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "log4j . defaultinitoverride" , "log4j . defaultinitoverride" , "log4j . defaultinitoverride" , "log4j . defaultinitoverride" , ( - 1600 ) , "log4j . defaultinitoverride" , ( - 480 ) , ( - 1600 ) , ( - 1600 ) , ( - 1600 ) , "log4j . defaultinitoverride" , "log4j . defaultinitoverride" , ( - 480 ) , ( - 1600 ) , "log4j . defaultinitoverride" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = dB2DialectExt0 . getColumnNullableAlterSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getColumnNullableAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; return new String [ ] { DialectUtils . getColumnNullableAlterSQL ( info , this , alterClause , true , qualifier , prefs ) } ; }
void test8 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsEmptyTables ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsEmptyTables ( ) { return true ; }
void test9 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test10 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DialectType dialectType0 = dB2DialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test11 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = derbyDialectExt0 . getDropViewSQL ( ( String ) null , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropViewSQL ( String viewName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP VIEW $viewName$" ; StringTemplate st = new StringTemplate ( ST_DROP_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test12 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; int int0 = dB2DialectExt0 . getPrecisionDigits ( 0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getPrecisionDigits ( int columnSize , int dataType ) { return columnSize ; }
void test13 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getDropForeignKeySQL ( "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test15 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test16 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsDropConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropConstraint ( ) { return true ; }
void test17 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsAddColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddColumn ( ) { return true ; }
void test18 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test19 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsDropIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropIndex ( ) { return true ; }
void test20 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "Q%5JH ( " , "Q%5JH ( " , "Q%5JH ( " , "Q%5JH ( " , ( - 1 ) , "Q%5JH ( " , 0 , 636 , ( - 1559 ) , 0 , "Q%5JH ( " , "Q%5JH ( " , 674 , ( - 999 ) , "Q%5JH ( " ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getColumnCommentAlterSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnCommentAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { return DialectUtils . getColumnCommentAlterSQL ( info , qualifier , prefs , this ) ; }
void test21 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsDropColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropColumn ( ) { return true ; }
void test22 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "'maxX' cannot be INF or NaN . " , "'maxX' cannot be INF or NaN . " ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getCreateViewSQL ( "" , "" , "'maxX' cannot be INF or NaN . " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE [ FORCE ] VIEW [ IF NOT EXISTS ] newViewName [ ( columnName [ , . . ] ) ] / / AS select / / "CREATE VIEW $viewName$ " + / / "AS $selectStatement$ $with$ $checkOptionType$ $checkOption$" ; StringTemplate st = new StringTemplate ( ST_CREATE_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName , ST_SELECT_STATEMENT_KEY , definition ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test23 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; int int0 = dB2DialectExt0 . getTimestampMaximumFractionalDigits ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTimestampMaximumFractionalDigits ( ) { return 9 ; }
void test24 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsCreateView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateView ( ) { return true ; }
void test25 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test26 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsAccessMethods ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAccessMethods ( ) { return true ; }
void test27 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsAddForeignKeyConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddForeignKeyConstraint ( ) { return true ; }
void test28 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsTablespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTablespace ( ) { return false ; }
void test29 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsViewDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsViewDefinition ( ) { return true ; }
void test30 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "ADD" , "ADD" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = derbyDialectExt0 . getColumnCommentAlterSQL ( "ADD" , "ADD" , "ADD" , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) derbyDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnCommentAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { return DialectUtils . getColumnCommentAlterSQL ( info , qualifier , prefs , this ) ; }
void test31 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "'maxX' cannot be INF or NaN . " , "'maxX' cannot be INF or NaN . " ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getDropSequenceSQL ( "'maxX' cannot be INF or NaN . " , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropSequenceSQL ( String sequenceName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP SEQUENCE $sequenceName$ $cascade$" ; StringTemplate st = new StringTemplate ( ST_DROP_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test32 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsCreateIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateIndex ( ) { return true ; }
void test33 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; String string0 = dB2DialectExt0 . getLengthFunction ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLengthFunction ( int dataType ) { return "length" ; }
void test34 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getRenameTableSQL ( "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getRenameTableSQL ( String oldTableName , String newTableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER TABLE $oldObjectName$ RENAME TO $newObjectName$" ; StringTemplate st = new StringTemplate ( ST_RENAME_OBJECT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_OLD_OBJECT_NAME_KEY , oldTableName , ST_NEW_OBJECT_NAME_KEY , newTableName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test35 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getColumnDropSQL ( "@q & HrG9QP1_4m ) P" , "@q & HrG9QP1_4m ) P" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { StringTemplate st = new StringTemplate ( DROP_COLUMN_SQL_TEMPLATE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_COLUMN_NAME_KEY , columnName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test36 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getViewDefinitionSQL ( "Q`" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getViewDefinitionSQL ( String viewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "select view_definition " + / / "from information_schema . views " + / / "where table_schema = ? " + / / "and table_name = ? " ; String templateStr = "select view_definition from information_schema . views " + "where table_schema = '$schemaName$' and UPPER ( table_name ) = UPPER ( '$viewName$' ) " ; StringTemplate st = new StringTemplate ( templateStr ) ; st . setAttribute ( ST_SCHEMA_NAME_KEY , qualifier . getSchema ( ) ) ; st . setAttribute ( ST_VIEW_NAME_KEY , viewName ) ; return st . toString ( ) ; }
void test37 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; byte [ ] byteArray0 = new byte [ 1 ] ; String string0 = dB2DialectExt0 . getBinaryLiteralString ( byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test38 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "ADD" , "ADD" , "QvPu" , "ADD" , ( int ) '\"' , "ADD" , ( - 387 ) , 31 , 1 , 1 , "ADD" , "ADD" , ( int ) '\"' , ( - 387 ) , "ADD" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = dB2DialectExt0 . getAddAutoIncrementSQL ( tableColumnInfo0 , "QvPu" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddAutoIncrementSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER TABLE $tableName$ ALTER COLUMN $columnName$ IDENTITY" ; StringTemplate st = new StringTemplate ( ST_ADD_AUTO_INCREMENT_STYLE_TWO ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , column . getTableName ( ) , ST_COLUMN_NAME_KEY , column . getColumnName ( ) ) ; return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test39 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test40 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test42 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsAddUniqueConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddUniqueConstraint ( ) { return true ; }
void test43 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test45 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; int int0 = dB2DialectExt0 . getColumnLength ( 313 , 313 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test46 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsCreateTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateTable ( ) { return true ; }
void test47 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , 0 , "" , ( - 365 ) , 0 , ( - 365 ) , 1284 , "" , "" , ( - 365 ) , 1284 , ( String ) null ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getColumnDefaultAlterSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDefaultAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String defaultClause = DialectUtils . SET_DEFAULT_CLAUSE ; return DialectUtils . getColumnDefaultAlterSQL ( this , info , alterClause , false , defaultClause , qualifier , prefs ) ; }
void test48 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsIndexes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsIndexes ( ) { return true ; }
void test49 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "ADD" , "ADD" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = derbyDialectExt0 . getDropIndexSQL ( " , " , "" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP INDEX $indexName$" ; StringTemplate st = new StringTemplate ( ST_DROP_INDEX_STYLE_THREE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_INDEX_NAME_KEY , indexName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test50 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsMultipleRowInserts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsMultipleRowInserts ( ) { return true ; }
void test51 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test52 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test53 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test54 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; String [ ] stringArray0 = dB2DialectExt0 . getIndexStorageOptions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexStorageOptions ( ) { return null ; }
void test55 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; boolean boolean0 = derbyDialectExt0 . supportsRenameView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameView ( ) { return false ; }
void test56 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test57 ( ) throws Throwable { DerbyDialectExt derbyDialectExt0 = new DerbyDialectExt ( ) ; String [ ] stringArray0 = derbyDialectExt0 . getIndexAccessMethodsTypes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexAccessMethodsTypes ( ) { return new String [ ] { "DEFAULT" , "HASH" } ; }
void test58 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "qb [ < FmiCB`esT'a6lZ" , "qb [ < FmiCB`esT'a6lZ" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getDropConstraintSQL ( "qb [ < FmiCB`esT'a6lZ" , "qb [ < FmiCB`esT'a6lZ" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropConstraintSQL ( String tableName , String constraintName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / ALTER TABLE $tableName$ DROP CONSTRAINT $constraintName$ StringTemplate st = new StringTemplate ( ST_DROP_CONSTRAINT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_CONSTRAINT_NAME_KEY , constraintName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test59 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , 0 , "" , 0 , 1 , 290 , 1 , "" , "" , 1242 , ( - 359 ) , "" ) ; boolean boolean0 = dB2DialectExt0 . canPasteTo ( ( IDatabaseObjectInfo ) tableColumnInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPasteTo ( IDatabaseObjectInfo info ) { boolean result = true ; DatabaseObjectType type = info . getDatabaseObjectType ( ) ; if ( type . getName ( ) . equalsIgnoreCase ( "database" ) ) { result = false ; } return result ; }
void test60 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; int int0 = dB2DialectExt0 . getMaxScale ( ( int ) '\"' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxScale ( int dataType ) { return getMaxPrecision ( dataType ) ; }
void test61 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsProduct ( "ADD" , "QvPu" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test62 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsProduct ( ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test63 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; boolean boolean0 = dB2DialectExt0 . supportsProduct ( "DB223w ; Uj" , "DB223w ; Uj" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test64 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = dB2DialectExt0 . getAlterSequenceSQL ( "DB2atan2" , "DB2atan2" , "DB2atan2" , "DB2atan2" , "DB2atan2" , "DB2atan2" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER SEQUENCE $sequenceName$ " + / / "$restartWith$ $startValue$ " + / / "$incrementBy$ $incrementValue$ " ; StringTemplate st = new StringTemplate ( ST_ALTER_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( restart ) ) { valuesMap . put ( ST_RESTART_WITH_KEY , "RESTART WITH" ) ; valuesMap . put ( ST_START_VALUE_KEY , restart ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_BY_KEY , "INCREMENT BY" ) ; valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test65 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = dB2DialectExt0 . getAlterSequenceSQL ( "Q`" , "ADD" , "ADD" , "ADD" , "Q`" , "Q`" , true , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER SEQUENCE $sequenceName$ " + / / "$restartWith$ $startValue$ " + / / "$incrementBy$ $incrementValue$ " ; StringTemplate st = new StringTemplate ( ST_ALTER_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( restart ) ) { valuesMap . put ( ST_RESTART_WITH_KEY , "RESTART WITH" ) ; valuesMap . put ( ST_START_VALUE_KEY , restart ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_BY_KEY , "INCREMENT BY" ) ; valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test66 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getSequenceInformationSQL ( "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSequenceInformationSQL ( String sequenceName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "SELECT CURRENT_VALUE , 'NONE' , 'NONE' , CACHE , INCREMENT , 0 " + / / "FROM INFORMATION_SCHEMA . SEQUENCES " + / / "WHERE SEQUENCE_SCHEMA = ? " + / / "AND SEQUENCE_NAME = ? " ; String templateStr = "SELECT CURRENT_VALUE , 'NONE' , 'NONE' , CACHE , INCREMENT , 0 " + "FROM INFORMATION_SCHEMA . SEQUENCES " + "WHERE SEQUENCE_SCHEMA = '$schemaName$' " + "AND SEQUENCE_NAME = '$sequenceName$' " + "AND SEQUENCE_CATALOG = '$catalogName$'" ; StringTemplate st = new StringTemplate ( templateStr ) ; st . setAttribute ( ST_SCHEMA_NAME_KEY , qualifier . getSchema ( ) ) ; st . setAttribute ( ST_CATALOG_NAME_KEY , qualifier . getCatalog ( ) ) ; st . setAttribute ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; return st . toString ( ) ; }
void test67 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getSequenceInformationSQL ( "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSequenceInformationSQL ( String sequenceName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "SELECT CURRENT_VALUE , 'NONE' , 'NONE' , CACHE , INCREMENT , 0 " + / / "FROM INFORMATION_SCHEMA . SEQUENCES " + / / "WHERE SEQUENCE_SCHEMA = ? " + / / "AND SEQUENCE_NAME = ? " ; String templateStr = "SELECT CURRENT_VALUE , 'NONE' , 'NONE' , CACHE , INCREMENT , 0 " + "FROM INFORMATION_SCHEMA . SEQUENCES " + "WHERE SEQUENCE_SCHEMA = '$schemaName$' " + "AND SEQUENCE_NAME = '$sequenceName$' " + "AND SEQUENCE_CATALOG = '$catalogName$'" ; StringTemplate st = new StringTemplate ( templateStr ) ; st . setAttribute ( ST_SCHEMA_NAME_KEY , qualifier . getSchema ( ) ) ; st . setAttribute ( ST_CATALOG_NAME_KEY , qualifier . getCatalog ( ) ) ; st . setAttribute ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; return st . toString ( ) ; }
void test0 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test1 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsAddUniqueConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddUniqueConstraint ( ) { return true ; }
void test2 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsMultipleRowInserts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsMultipleRowInserts ( ) { return true ; }
void test3 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test4 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test5 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test6 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test7 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsSchemasInTableDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSchemasInTableDefinition ( ) { return false ; }
void test8 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsInsertInto ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsInsertInto ( ) { return true ; }
void test9 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsProduct ( "FabV & [ Cw ( PAG N\"T + P" , "FabV & [ Cw ( PAG N\"T + P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test10 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsDropPrimaryKey ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropPrimaryKey ( ) ; / * * * For the given columnInfo , this provides the type name that is used to * re - create this column in a new table . This method also delegates to * getJavaTypeForNativeType for type OTHER ( 1111 ) . * * @param tcInfo * the TableColumnInfo describing the column * @return the column type name * / String getTypeName ( TableColumnInfo tcInfo ) ; / * * * This will return the java . sql . Types constant that the specified * type name can be stored in . * * @param nativeColumnTypeName * the column type name * @return a java . sql . Types constant representing the java column type this * type is compatible with . * / int getJavaTypeForNativeType ( String nativeColumnTypeName ) ; int getTimestampMaximumFractionalDigits ( ) ; / * * * Returns a literal string which is acceptable for SQL that update , * insert or delete statements on a row which contains a column whose data type accepts * binary data . * * @param binaryData * the actual bytes that form the binary data value * @return a literal string that is acceptable to be used in an insert , * update or delete statement . * / String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test11 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test12 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsRenameView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameView ( ) { return false ; }
void test13 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test14 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsCheckOptionsForViews ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCheckOptionsForViews ( ) { return false ; }
void test15 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test16 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsCreateView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateView ( ) { return true ; }
void test17 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsAccessMethods ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAccessMethods ( ) { return true ; }
void test18 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsDropConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropConstraint ( ) { return true ; }
void test19 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsEmptyTables ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsEmptyTables ( ) { return true ; }
void test20 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsCreateIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateIndex ( ) { return true ; }
void test21 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsAlterSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test22 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsCreateTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateTable ( ) { return true ; }
void test23 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test24 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsAddForeignKeyConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddForeignKeyConstraint ( ) { return true ; }
void test25 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test26 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test28 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsIndexes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsIndexes ( ) { return true ; }
void test29 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test30 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsAddPrimaryKey ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddPrimaryKey ( ) ; / * * * Returns a boolean indicating whether or not this dialect supports * generating SQL for dropping primary keys from existing tables . * * @return true if dropping primary keys is supported ; false otherwise . * / boolean supportsDropPrimaryKey ( ) ; / * * * For the given columnInfo , this provides the type name that is used to * re - create this column in a new table . This method also delegates to * getJavaTypeForNativeType for type OTHER ( 1111 ) . * * @param tcInfo * the TableColumnInfo describing the column * @return the column type name * / String getTypeName ( TableColumnInfo tcInfo ) ; / * * * This will return the java . sql . Types constant that the specified * type name can be stored in . * * @param nativeColumnTypeName * the column type name * @return a java . sql . Types constant representing the java column type this * type is compatible with . * / int getJavaTypeForNativeType ( String nativeColumnTypeName ) ; int getTimestampMaximumFractionalDigits ( ) ; / * * * Returns a literal string which is acceptable for SQL that update , * insert or delete statements on a row which contains a column whose data type accepts * binary data . * * @param binaryData * the actual bytes that form the binary data value * @return a literal string that is acceptable to be used in an insert , * update or delete statement . * / String getBinaryLiteralString ( byte [ ] binaryData ) ; }
void test31 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsTablespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTablespace ( ) { return false ; }
void test32 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsViewDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsViewDefinition ( ) { return true ; }
void test33 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test34 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsSubSecondTimestamps ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSubSecondTimestamps ( ) { return false ; }
void test35 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsDropColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropColumn ( ) { return true ; }
void test36 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test37 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsAddColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddColumn ( ) { return true ; }
void test38 ( ) throws Throwable { TeiidDialectExt teiidDialectExt0 = new TeiidDialectExt ( ) ; boolean boolean0 = teiidDialectExt0 . supportsDropIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropIndex ( ) { return true ; }
void test0 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsDropColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropColumn ( ) { return true ; }
void test2 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsSchemasInTableDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSchemasInTableDefinition ( ) { return false ; }
void test3 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " , un java system high availabilitypq > @oe~z" , " , un java system high availabilitypq > @oe~z" , " , un java system high availabilitypq > @oe~z" , " , un java system high availabilitypq > @oe~z" , ( - 1727 ) , " , un java system high availabilitypq > @oe~z" , ( - 1727 ) , ( - 1727 ) , 3 , ( - 1727 ) , " , un java system high availabilitypq > @oe~z" , " , un java system high availabilitypq > @oe~z" , 3 , 3 , " , un java system high availabilitypq > @oe~z" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " , un java system high availabilitypq > @oe~z" , " , un java system high availabilitypq > @oe~z" ) ; String string0 = hADBDialectExt0 . getColumnNameAlterSQL ( tableColumnInfo0 , tableColumnInfo0 , databaseObjectQualifier0 , ( SqlGenerationPreferences ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnNameAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String renameToClause = DialectUtils . RENAME_TO_CLAUSE ; return DialectUtils . getColumnNameAlterSQL ( from , to , alterClause , renameToClause , qualifier , prefs , this ) ; }
void test4 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test5 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test8 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test14 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test16 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsCreateTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateTable ( ) { return true ; }
void test19 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsAddColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddColumn ( ) { return true ; }
void test20 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test21 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test24 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; String string0 = hADBDialectExt0 . getMaxFunction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMaxFunction ( ) { return "max" ; }
void test25 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsRenameView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameView ( ) { return false ; }
void test26 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test27 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; DialectType dialectType0 = hADBDialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DialectType getDialectType ( ) { return DialectFactory . getDialectType ( getSession ( ) . getMetaData ( ) ) ; }
void test28 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test31 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; String string0 = hADBDialectExt0 . getLengthFunction ( 1001 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLengthFunction ( int dataType ) { return "length" ; }
void test32 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsInsertInto ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsInsertInto ( ) { return true ; }
void test34 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; int int0 = hADBDialectExt0 . getMaxScale ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getMaxScale ( int dataType ) { return getMaxPrecision ( dataType ) ; }
void test36 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = hADBDialectExt0 . getDropPrimaryKeySQL ( "char_length" , "char_length" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test37 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "5^O , nxX = H ] qzf" , "5^O , nxX = H ] qzf" , "5^O , nxX = H ] qzf" , "5^O , nxX = H ] qzf" , ( - 1 ) , "5^O , nxX = H ] qzf" , ( - 1 ) , ( - 1 ) , 0 , 0 , "5^O , nxX = H ] qzf" , "5^O , nxX = H ] qzf" , ( - 1 ) , 1800 , "5^O , nxX = H ] qzf" ) ; boolean boolean0 = hADBDialectExt0 . canPasteTo ( ( IDatabaseObjectInfo ) tableColumnInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canPasteTo ( IDatabaseObjectInfo info ) { boolean result = true ; DatabaseObjectType type = info . getDatabaseObjectType ( ) ; if ( type . getName ( ) . equalsIgnoreCase ( "database" ) ) { result = false ; } return result ; }
void test40 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = hADBDialectExt0 . getDropForeignKeySQL ( "21H2 ; \" , | x@ ? " , ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test42 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test44 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; int int0 = hADBDialectExt0 . getColumnLength ( 2005 , 2005 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test45 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; int int0 = hADBDialectExt0 . getColumnLength ( 360 , 360 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test46 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsProduct ( "sun java system high availabilitylast - modified" , "sun java system high availabilitylast - modified" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test47 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsProduct ( ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test48 ( ) throws Throwable { HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; boolean boolean0 = hADBDialectExt0 . supportsProduct ( "last - modified" , "last - modified" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test1 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " . P" , " . P" , " . P" , " . P" , ( - 1 ) , " . P" , 23514 , 548 , 23514 , 23514 , " . P" , " . P" , 1830 , 338 , " . P" ) ; TableColumnInfo tableColumnInfo1 = DialectUtils . getRenamedColumn ( tableColumnInfo0 , " . P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRadix ( ) { return _radix ; }
void test2 ( ) throws Throwable { SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; MySQL5DialectExt mySQL5DialectExt0 = new MySQL5DialectExt ( ) ; String string0 = DialectUtils . getDropForeignKeySQL ( "" , "" , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 , ( HibernateDialect ) mySQL5DialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test3 ( ) throws Throwable { Vector < ITableInfo > vector0 = new Vector < ITableInfo > ( ) ; DaffodilDialectExt daffodilDialectExt0 = new DaffodilDialectExt ( ) ; CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; List < String > list0 = DialectUtils . getCreateTableSQL ( ( List < ITableInfo > ) vector0 , ( ISQLDatabaseMetaData ) null , ( HibernateDialect ) daffodilDialectExt0 , createScriptPreferences0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test4 ( ) throws Throwable { SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; MAXDBDialectExt mAXDBDialectExt0 = new MAXDBDialectExt ( ) ; String string0 = DialectUtils . getColumnDropSQL ( "6O D | HZ" , "6O D | HZ" , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 , ( HibernateDialect ) mAXDBDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { StringTemplate st = new StringTemplate ( DROP_COLUMN_SQL_TEMPLATE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_COLUMN_NAME_KEY , columnName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test5 ( ) throws Throwable { DB2DialectExt dB2DialectExt0 = new DB2DialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = dB2DialectExt0 . getDropIndexSQL ( "Ea > VK = 7p ? Q > & & aq : + " , " ON UPDATE " , true , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP INDEX $indexName$" ; StringTemplate st = new StringTemplate ( ST_DROP_INDEX_STYLE_THREE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_INDEX_NAME_KEY , indexName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test7 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " > 3" , " > 3" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " > 3" , "ALTER TABLE > 3 RENAME TO > 3" , " > 3" , " > 3" , 39 , "ALTER TABLE > 3 RENAME TO > 3" , 39 , 888 , 888 , ( - 203 ) , " > 3" , "ALTER TABLE > 3 RENAME TO > 3" , 39 , 834 , " > 3" ) ; String [ ] stringArray0 = DialectUtils . getAddSimulatedAutoIncrementColumn ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) h2DialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddSimulatedAutoIncrementColumn ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs , HibernateDialect dialect ) { ArrayList < String > result = new ArrayList < String > ( ) ; String tableName = shapeQualifiableIdentifier ( column . getTableName ( ) , qualifier , prefs , dialect ) ; String columnName = shapeIdentifier ( column . getColumnName ( ) , prefs , dialect ) ; String sequenceName = shapeIdentifier ( tableName + "_" + columnName + "_" + "seq" , prefs , dialect ) ; / / TODO Probably want to allow the user to set these sequence properties / / ? ? / / Sequence settings . String sequenceIncrement = "1" ; String minimum = "1" ; String maximum = null ; String start = "1" ; String cacheClause = null ; boolean cycle = false ; result . add ( dialect . getCreateSequenceSQL ( sequenceName , sequenceIncrement , minimum , maximum , start , cacheClause , cycle , qualifier , prefs ) ) ; StringBuilder triggerSql = new StringBuilder ( ) ; triggerSql . append ( "CREATE TRIGGER " ) ; triggerSql . append ( columnName ) ; triggerSql . append ( "_trigger \n" ) ; triggerSql . append ( "NO CASCADE BEFORE INSERT ON " ) ; triggerSql . append ( tableName ) ; triggerSql . append ( " REFERENCING NEW AS n \n" ) ; triggerSql . append ( "FOR EACH ROW \n" ) ; triggerSql . append ( "SET n . " ) ; triggerSql . append ( columnName ) ; triggerSql . append ( " = NEXTVAL FOR " ) ; triggerSql . append ( sequenceName ) ; result . add ( triggerSql . toString ( ) ) ; return result . toArray ( new String [ result . size ( ) ] ) ; }
void test8 ( ) throws Throwable { DialectUtils dialectUtils0 = new DialectUtils ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test9 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "n" , "n" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "CREATE SEQUENCE L < Uke } n1\nINCREMENT BY L < Uke } n1 MINVALUE L < Uke } n1 MAXVALUE n \nSTART WITH n CACHE L < Uke } n1 L < Uke } n1" , "L < Uke } n1" , "L < Uke } n1" , "n" , ( - 1646 ) , "D6" , 292 , 21 , 21 , ( - 1990 ) , "n" , "~ceEi" , 21 , ( - 268 ) , "CREATE SEQUENCE L < Uke } n1\nINCREMENT BY L < Uke } n1 MINVALUE L < Uke } n1 MAXVALUE n \nSTART WITH n CACHE L < Uke } n1 L < Uke } n1" ) ; String string0 = DialectUtils . getColumnNullableAlterSQL ( tableColumnInfo0 , ( HibernateDialect ) greenplumDialectExt0 , "~ceEi" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getColumnNullableAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; return new String [ ] { DialectUtils . getColumnNullableAlterSQL ( info , this , alterClause , true , qualifier , prefs ) } ; }
void test10 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( " > 3" , " > 3" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; String string0 = DialectUtils . getRenameTableSQL ( " > 3" , " > 3" , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) h2DialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getRenameTableSQL ( String oldTableName , String newTableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER TABLE $oldObjectName$ RENAME TO $newObjectName$" ; StringTemplate st = new StringTemplate ( ST_RENAME_OBJECT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_OLD_OBJECT_NAME_KEY , oldTableName , ST_NEW_OBJECT_NAME_KEY , newTableName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test11 ( ) throws Throwable { SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " . P" , " . P" , " . P" , " . P" , ( - 1 ) , " . P" , 23514 , 548 , 23514 , 23514 , " . P" , " . P" , 1830 , 338 , " . P" ) ; GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; String string0 = DialectUtils . getAddColumSQL ( tableColumnInfo0 , ( HibernateDialect ) greenplumDialectExt0 , true , true , true , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAddColumSQL ( TableColumnInfo info , HibernateDialect dialect , boolean addDefaultClause , boolean supportsNullQualifier , boolean addNullClause , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException , HibernateException { StringBuilder result = new StringBuilder ( ) ; result . append ( DialectUtils . ALTER_TABLE_CLAUSE + " " ) ; result . append ( shapeQualifiableIdentifier ( info . getTableName ( ) , qualifier , prefs , dialect ) ) ; result . append ( " " ) ; result . append ( dialect . getAddColumnString ( ) . toUpperCase ( ) ) ; result . append ( " " ) ; if ( prefs . isQuoteColumnNames ( ) ) { result . append ( shapeIdentifier ( info . getColumnName ( ) , prefs , dialect ) ) ; } else { result . append ( info . getColumnName ( ) ) ; } result . append ( " " ) ; result . append ( dialect . getTypeName ( info . getDataType ( ) , info . getColumnSize ( ) , info . getColumnSize ( ) , info . getDecimalDigits ( ) ) ) ; if ( addDefaultClause ) { appendDefaultClause ( info , result ) ; } if ( addNullClause ) { if ( info . isNullable ( ) . equals ( "NO" ) ) { result . append ( " NOT NULL " ) ; } else { if ( supportsNullQualifier ) { result . append ( " NULL " ) ; } } } return result . toString ( ) ; }
void test12 ( ) throws Throwable { SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , 791 , "" , 0 , 791 , 791 , 791 , "" , "" , 1909 , 0 , "" ) ; FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; String string0 = DialectUtils . getColumnCommentAlterSQL ( tableColumnInfo0 , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 , ( HibernateDialect ) frontBaseDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnCommentAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { return DialectUtils . getColumnCommentAlterSQL ( info , qualifier , prefs , this ) ; }
void test13 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; MySQL5DialectExt mySQL5DialectExt0 = new MySQL5DialectExt ( ) ; String string0 = DialectUtils . getColumnCommentAlterSQL ( "" , ( String ) null , ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) mySQL5DialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnCommentAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { return DialectUtils . getColumnCommentAlterSQL ( info , qualifier , prefs , this ) ; }
void test14 ( ) throws Throwable { SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "r" , "r" , "r" , "r" , 792 , "r" , 0 , 792 , 792 , 792 , "r" , "r" , 1909 , 0 , "r" ) ; FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; String string0 = DialectUtils . getColumnCommentAlterSQL ( tableColumnInfo0 , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 , ( HibernateDialect ) frontBaseDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnCommentAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { return DialectUtils . getColumnCommentAlterSQL ( info , qualifier , prefs , this ) ; }
void test15 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; H2DialectExt h2DialectExt0 = new H2DialectExt ( ) ; String string0 = DialectUtils . getColumnDropSQL ( "o " , "o " , "o " , true , "o " , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) h2DialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { StringTemplate st = new StringTemplate ( DROP_COLUMN_SQL_TEMPLATE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_COLUMN_NAME_KEY , columnName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test17 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "TEMPLATE_ARGS" , "TEMPLATE_ARGS" , " . P" , "TEMPLATE_ARGS" , 23519 , " . P" , ( - 1 ) , 23519 , ( - 1 ) , ( - 1 ) , "net . sourceforge . squirrel_sql . fw . dialects . IntersystemsCacheDialectExt@2889b3b9" , "net . sourceforge . squirrel_sql . fw . dialects . IntersystemsCacheDialectExt@2889b3b9" , ( - 1639 ) , ( - 1032 ) , "TEMPLATE_ARGS" ) ; IngresDialectExt ingresDialectExt0 = new IngresDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "`Fgj$S ) q" , "TEMPLATE_ARGS" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = DialectUtils . getColumnNullableAlterSQL ( tableColumnInfo0 , false , ( HibernateDialect ) ingresDialectExt0 , "`Fgj$S ) q" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getColumnNullableAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; return new String [ ] { DialectUtils . getColumnNullableAlterSQL ( info , this , alterClause , true , qualifier , prefs ) } ; }
void test18 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "O ) PasF ? ^$ ! fm ! S#CJ" , "0twVP | b { ey" , "" , "O ) PasF ? ^$ ! fm ! S#CJ" , 0 , "" , 0 , 0 , 91 , ( - 1366 ) , "O ) PasF ? ^$ ! fm ! S#CJ" , "0twVP | b { ey" , 0 , 0 , "O ) PasF ? ^$ ! fm ! S#CJ" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "0twVP | b { ey" , "O ) PasF ? ^$ ! fm ! S#CJ" ) ; TableColumnInfo [ ] tableColumnInfoArray0 = new TableColumnInfo [ 6 ] ; tableColumnInfoArray0 [ 0 ] = tableColumnInfo0 ; tableColumnInfoArray0 [ 1 ] = tableColumnInfo0 ; tableColumnInfoArray0 [ 2 ] = tableColumnInfo0 ; tableColumnInfoArray0 [ 3 ] = tableColumnInfo0 ; tableColumnInfoArray0 [ 4 ] = tableColumnInfo0 ; tableColumnInfoArray0 [ 5 ] = tableColumnInfo0 ; ArrayList < String > arrayList0 = new ArrayList < String > ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; DialectUtils . getMultiColNotNullSQL ( tableColumnInfoArray0 , ( HibernateDialect ) frontBaseDialectExt0 , "0twVP | b { ey" , false , arrayList0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test19 ( ) throws Throwable { SQLServerDialectExt sQLServerDialectExt0 = new SQLServerDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "5VH" , "5VH" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; TableColumnInfo [ ] tableColumnInfoArray0 = new TableColumnInfo [ 2 ] ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "_ = QH#2nb3zS" , "S4EQ\u0004^jJ$Y | hbg" , ( String ) null , "CREATE SEQUENCE _ = QH#2nb3zS\nINCREMENT BY _ = QH#2nb3zS NO MINVALUE NO MAXVALUE\n" , ( int ) ( byte ) ( - 124 ) , "S4EQ\u0004^jJ$Y | hbg" , 0 , 898 , 1154 , 1154 , ( String ) null , "S4EQ\u0004^jJ$Y | hbg" , ( - 722 ) , 97 , "S4EQ\u0004^jJ$Y | hbg" ) ; tableColumnInfoArray0 [ 1 ] = tableColumnInfo0 ; tableColumnInfoArray0 [ 0 ] = tableColumnInfo0 ; String string0 = DialectUtils . getAddUniqueConstraintSQL ( ( String ) null , "S4EQ\u0004^jJ$Y | hbg" , tableColumnInfoArray0 , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) sQLServerDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddUniqueConstraintSQL ( String tableName , String constraintName , TableColumnInfo [ ] columns , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER TABLE $tableName$ " + / / "ADD $constraint$ $constraintName$ UNIQUE $index$ $indexName$ $indexType$ ( $indexColumnName$ ) " ; StringTemplate st = new StringTemplate ( ST_ADD_UNIQUE_CONSTRAINT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_CONSTRAINT_KEY , "CONSTRAINT" , ST_CONSTRAINT_NAME_KEY , constraintName ) ; return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , columns , qualifier , prefs ) } ; }
void test20 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( ( String ) null , ( String ) null , ( String ) null , ( String ) null , 1380 , "" , 1380 , ( - 481 ) , ( - 481 ) , 55 , "" , ( String ) null , 439 , 105 , ( String ) null ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; String string0 = DialectUtils . getColumnNameAlterSQL ( tableColumnInfo0 , tableColumnInfo0 , ( String ) null , "rXWeW\rS5hzV3v ( L2#A" , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) commonHibernateDialect0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnNameAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String renameToClause = DialectUtils . RENAME_TO_CLAUSE ; return DialectUtils . getColumnNameAlterSQL ( from , to , alterClause , renameToClause , qualifier , prefs , this ) ; }
void test21 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "O ) PasF ? ^$ ! fm ! S#CJ" , "0twVP | b { ey" , "" , ( String ) null , 0 , "" , 0 , 0 , 91 , ( - 1366 ) , "O ) PasF ? ^$ ! fm ! S#CJ" , "0twVP | b { ey" , 0 , 0 , "O ) PasF ? ^$ ! fm ! S#CJ" ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "0twVP | b { ey" , ( String ) null ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = frontBaseDialectExt0 . getColumnDefaultAlterSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDefaultAlterSQL ( TableColumnInfo info , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String defaultClause = DialectUtils . SET_DEFAULT_CLAUSE ; return DialectUtils . getColumnDefaultAlterSQL ( this , info , alterClause , false , defaultClause , qualifier , prefs ) ; }
void test23 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "n" , "n" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "CREATE SEQUENCE L < Uke } n1\nINCREMENT BY L < Uke } n1 MINVALUE L < Uke } n1 MAXVALUE n \nSTART WITH n CACHE L < Uke } n1 L < Uke } n1" , "L < Uke } n1" , "L < Uke } n1" , "n" , ( - 1646 ) , "D6" , 292 , 21 , 21 , ( - 1990 ) , "n" , "~ceEi" , 21 , ( - 268 ) , "CREATE SEQUENCE L < Uke } n1\nINCREMENT BY L < Uke } n1 MINVALUE L < Uke } n1 MAXVALUE n \nSTART WITH n CACHE L < Uke } n1 L < Uke } n1" ) ; String string0 = DialectUtils . getColumnRenameSQL ( tableColumnInfo0 , tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) greenplumDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnRenameSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs , HibernateDialect dialect ) { StringBuilder result = new StringBuilder ( ) ; String shapedTable = shapeQualifiableIdentifier ( from . getTableName ( ) , qualifier , prefs , dialect ) ; String shapedFromColumn = from . getColumnName ( ) ; if ( prefs . isQuoteColumnNames ( ) ) { shapedFromColumn = shapeIdentifier ( from . getColumnName ( ) , prefs , dialect ) ; } String shapedToColumn = to . getColumnName ( ) ; if ( prefs . isQuoteColumnNames ( ) ) { shapedToColumn = shapeIdentifier ( to . getColumnName ( ) , prefs , dialect ) ; } result . append ( "RENAME COLUMN " ) ; result . append ( shapedTable ) ; result . append ( " . " ) ; result . append ( shapedFromColumn ) ; result . append ( " TO " ) ; result . append ( shapedToColumn ) ; return result . toString ( ) ; }
void test30 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "6NO" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; HADBDialectExt hADBDialectExt0 = new HADBDialectExt ( ) ; String string0 = hADBDialectExt0 . getDropPrimaryKeySQL ( "ALTER TABLE 6NO DROP CONSTRAINT \"\" CASCADE" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test31 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "6NO" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; MySQL5DialectExt mySQL5DialectExt0 = new MySQL5DialectExt ( ) ; String string0 = DialectUtils . getDropPrimaryKeySQL ( "" , "6NO" , true , true , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) mySQL5DialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test32 ( ) throws Throwable { InformixDialectExt informixDialectExt0 = new InformixDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "QIiH8kq * H`p < h : wy" , "`" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = informixDialectExt0 . getDropPrimaryKeySQL ( "QIiH8kq * H`p < h : wy" , "`" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test33 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; Boolean boolean0 = Boolean . FALSE ; FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; String string0 = DialectUtils . getDropIndexSQL ( "" , ( String ) null , boolean0 , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) firebirdDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP INDEX $indexName$" ; StringTemplate st = new StringTemplate ( ST_DROP_INDEX_STYLE_THREE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_INDEX_NAME_KEY , indexName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test34 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "n" , "n" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; OracleDialectExt oracleDialectExt0 = new OracleDialectExt ( ) ; String string0 = oracleDialectExt0 . getDropSequenceSQL ( "L < Uke } n1" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropSequenceSQL ( String sequenceName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP SEQUENCE $sequenceName$ $cascade$" ; StringTemplate st = new StringTemplate ( ST_DROP_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test35 ( ) throws Throwable { Boolean boolean0 = Boolean . TRUE ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "net . sourceforge . squirrel_sql . fw . dialects . IntersystemsCacheDialectExt@7819d0b6" , "net . sourceforge . squirrel_sql . fw . dialects . IntersystemsCacheDialectExt@7819d0b6" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; String string0 = DialectUtils . getDropSequenceSQL ( "net . sourceforge . squirrel_sql . fw . dialects . IntersystemsCacheDialectExt@7819d0b6" , boolean0 , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) commonHibernateDialect0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropSequenceSQL ( String sequenceName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP SEQUENCE $sequenceName$ $cascade$" ; StringTemplate st = new StringTemplate ( ST_DROP_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test36 ( ) throws Throwable { SQLServerDialectExt sQLServerDialectExt0 = new SQLServerDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "5VH" , "5VH" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sQLServerDialectExt0 . getDropConstraintSQL ( "5VH" , "5VH" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropConstraintSQL ( String tableName , String constraintName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / ALTER TABLE $tableName$ DROP CONSTRAINT $constraintName$ StringTemplate st = new StringTemplate ( ST_DROP_CONSTRAINT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_CONSTRAINT_NAME_KEY , constraintName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test37 ( ) throws Throwable { SQLServerDialectExt sQLServerDialectExt0 = new SQLServerDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "5VH" , "5VH" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = sQLServerDialectExt0 . getDropViewSQL ( "ALTER TABLE 5VH\n DROP CONSTRAINT \"5VH\"" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropViewSQL ( String viewName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP VIEW $viewName$" ; StringTemplate st = new StringTemplate ( ST_DROP_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test38 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; PointbaseDialectExt pointbaseDialectExt0 = new PointbaseDialectExt ( ) ; String [ ] stringArray0 = new String [ 10 ] ; String string0 = DialectUtils . getAddIndexSQL ( ( HibernateDialect ) pointbaseDialectExt0 , "" , "" , "" , stringArray0 , false , "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAddIndexSQL ( String indexName , boolean unique , TableColumnInfo [ ] columns , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs , HibernateDialect dialect ) { StringBuilder result = new StringBuilder ( ) ; String shapedTable = shapeQualifiableIdentifier ( columns [ 0 ] . getTableName ( ) , qualifier , prefs , dialect ) ; String shapedIndexName = indexName ; if ( prefs . isQuoteConstraintNames ( ) ) { shapedIndexName = shapeIdentifier ( indexName , prefs , dialect ) ; } if ( unique ) { result . append ( "CREATE UNIQUE INDEX " ) ; } else { result . append ( "CREATE INDEX " ) ; } result . append ( shapedIndexName ) ; result . append ( " ON " ) ; result . append ( shapedTable ) ; result . append ( " " ) ; result . append ( getColumnList ( columns , qualifier , prefs , dialect ) ) ; return result . toString ( ) ; }
void test39 ( ) throws Throwable { GenericDialectExt genericDialectExt0 = new GenericDialectExt ( ) ; String [ ] stringArray0 = new String [ 9 ] ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = DialectUtils . getAddIndexSQL ( ( HibernateDialect ) genericDialectExt0 , ( String ) null , ( String ) null , ( String ) null , stringArray0 , true , "Z4AJZ5P" , ( String ) null , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAddIndexSQL ( String indexName , boolean unique , TableColumnInfo [ ] columns , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs , HibernateDialect dialect ) { StringBuilder result = new StringBuilder ( ) ; String shapedTable = shapeQualifiableIdentifier ( columns [ 0 ] . getTableName ( ) , qualifier , prefs , dialect ) ; String shapedIndexName = indexName ; if ( prefs . isQuoteConstraintNames ( ) ) { shapedIndexName = shapeIdentifier ( indexName , prefs , dialect ) ; } if ( unique ) { result . append ( "CREATE UNIQUE INDEX " ) ; } else { result . append ( "CREATE INDEX " ) ; } result . append ( shapedIndexName ) ; result . append ( " ON " ) ; result . append ( shapedTable ) ; result . append ( " " ) ; result . append ( getColumnList ( columns , qualifier , prefs , dialect ) ) ; return result . toString ( ) ; }
void test40 ( ) throws Throwable { SQLServerDialectExt sQLServerDialectExt0 = new SQLServerDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "5VH" , "5VH" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = new String [ 4 ] ; String string0 = DialectUtils . getAddIndexSQL ( ( HibernateDialect ) sQLServerDialectExt0 , "S4EQ\u0004^jJ$Y | hbg" , "S4EQ\u0004^jJ$Y | hbg" , "S4EQ\u0004^jJ$Y | hbg" , stringArray0 , false , ( String ) null , "S4EQ\u0004^jJ$Y | hbg" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAddIndexSQL ( String indexName , boolean unique , TableColumnInfo [ ] columns , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs , HibernateDialect dialect ) { StringBuilder result = new StringBuilder ( ) ; String shapedTable = shapeQualifiableIdentifier ( columns [ 0 ] . getTableName ( ) , qualifier , prefs , dialect ) ; String shapedIndexName = indexName ; if ( prefs . isQuoteConstraintNames ( ) ) { shapedIndexName = shapeIdentifier ( indexName , prefs , dialect ) ; } if ( unique ) { result . append ( "CREATE UNIQUE INDEX " ) ; } else { result . append ( "CREATE INDEX " ) ; } result . append ( shapedIndexName ) ; result . append ( " ON " ) ; result . append ( shapedTable ) ; result . append ( " " ) ; result . append ( getColumnList ( columns , qualifier , prefs , dialect ) ) ; return result . toString ( ) ; }
void test41 ( ) throws Throwable { InformixDialectExt informixDialectExt0 = new InformixDialectExt ( ) ; String [ ] stringArray0 = new String [ 7 ] ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "QIiH8kq * H`p < h : wy" , "QIiH8kq * H`p < h : wy" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = DialectUtils . getCreateIndexSQL ( "QIiH8kq * H`p < h : wy" , "QIiH8kq * H`p < h : wy" , "QIiH8kq * H`p < h : wy" , stringArray0 , false , "QIiH8kq * H`p < h : wy" , "QIiH8kq * H`p < h : wy" , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) informixDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE { [ UNIQUE [ HASH ] ] INDEX [ [ IF NOT EXISTS ] newIndexName ] / / | PRIMARY KEY [ HASH ] } ON ( columnName [ , . . . ] ) StringTemplate st = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; HashMap < String , String > valuesMap = new HashMap < String , String > ( ) ; if ( unique ) { valuesMap . put ( ST_UNIQUE_KEY , "UNIQUE" ) ; if ( accessMethod ! = null & & "HASH" . equalsIgnoreCase ( accessMethod ) ) { valuesMap . put ( ST_STORAGE_OPTION_KEY , "HASH" ) ; } } valuesMap . put ( ST_INDEX_NAME_KEY , indexName ) ; valuesMap . put ( ST_TABLE_NAME_KEY , tableName ) ; return DialectUtils . getAddIndexSQL ( this , st , valuesMap , columns , qualifier , prefs ) ; }
void test42 ( ) throws Throwable { InformixDialectExt informixDialectExt0 = new InformixDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "QIiH8kq * H`p < h : wy" , "`" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = new String [ 7 ] ; String string0 = DialectUtils . getCreateIndexSQL ( "QIiH8kq * H`p < h : wy" , "QIiH8kq * H`p < h : wy" , "QIiH8kq * H`p < h : wy" , stringArray0 , true , ( String ) null , ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) informixDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE { [ UNIQUE [ HASH ] ] INDEX [ [ IF NOT EXISTS ] newIndexName ] / / | PRIMARY KEY [ HASH ] } ON ( columnName [ , . . . ] ) StringTemplate st = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; HashMap < String , String > valuesMap = new HashMap < String , String > ( ) ; if ( unique ) { valuesMap . put ( ST_UNIQUE_KEY , "UNIQUE" ) ; if ( accessMethod ! = null & & "HASH" . equalsIgnoreCase ( accessMethod ) ) { valuesMap . put ( ST_STORAGE_OPTION_KEY , "HASH" ) ; } } valuesMap . put ( ST_INDEX_NAME_KEY , indexName ) ; valuesMap . put ( ST_TABLE_NAME_KEY , tableName ) ; return DialectUtils . getAddIndexSQL ( this , st , valuesMap , columns , qualifier , prefs ) ; }
void test43 ( ) throws Throwable { FrontBaseDialectExt frontBaseDialectExt0 = new FrontBaseDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = frontBaseDialectExt0 . getCreateViewSQL ( "org . apache . log4j . CategoryKey" , "org . apache . log4j . CategoryKey" , "org . apache . log4j . CategoryKey" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE [ FORCE ] VIEW [ IF NOT EXISTS ] newViewName [ ( columnName [ , . . ] ) ] / / AS select / / "CREATE VIEW $viewName$ " + / / "AS $selectStatement$ $with$ $checkOptionType$ $checkOption$" ; StringTemplate st = new StringTemplate ( ST_CREATE_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName , ST_SELECT_STATEMENT_KEY , definition ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test44 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; PointbaseDialectExt pointbaseDialectExt0 = new PointbaseDialectExt ( ) ; String string0 = DialectUtils . getCreateSequenceSQL ( ( String ) null , "" , "" , "" , "" , "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) pointbaseDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String start , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE SEQUENCE [ IF NOT EXISTS ] newSequenceName / / [ START WITH long ] / / [ INCREMENT BY long ] / / [ CACHE long ] / / "CREATE SEQUENCE $sequenceName$ START WITH $startValue$ " + / / "INCREMENT BY $incrementValue$ $cache$ $cacheValue$" ; StringTemplate st = new StringTemplate ( ST_CREATE_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( cache ) ) { valuesMap . put ( ST_CACHE_KEY , "CACHE" ) ; valuesMap . put ( ST_CACHE_VALUE_KEY , cache ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } if ( DialectUtils . isNotEmptyString ( start ) ) { valuesMap . put ( ST_START_VALUE_KEY , start ) ; } return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test45 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "n" , "n" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; String string0 = DialectUtils . getCreateSequenceSQL ( "L < Uke } n1" , "L < Uke } n1" , "L < Uke } n1" , "n" , "n" , "L < Uke } n1" , "L < Uke } n1" , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) greenplumDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String start , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE SEQUENCE [ IF NOT EXISTS ] newSequenceName / / [ START WITH long ] / / [ INCREMENT BY long ] / / [ CACHE long ] / / "CREATE SEQUENCE $sequenceName$ START WITH $startValue$ " + / / "INCREMENT BY $incrementValue$ $cache$ $cacheValue$" ; StringTemplate st = new StringTemplate ( ST_CREATE_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( cache ) ) { valuesMap . put ( ST_CACHE_KEY , "CACHE" ) ; valuesMap . put ( ST_CACHE_VALUE_KEY , cache ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } if ( DialectUtils . isNotEmptyString ( start ) ) { valuesMap . put ( ST_START_VALUE_KEY , start ) ; } return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test46 ( ) throws Throwable { SQLServerDialectExt sQLServerDialectExt0 = new SQLServerDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "5VH" , "5VH" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = DialectUtils . getCreateSequenceSQL ( "_ = QH#2nb3zS" , "_ = QH#2nb3zS" , ( String ) null , ( String ) null , ( String ) null , ( String ) null , ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) sQLServerDialectExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String start , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE SEQUENCE [ IF NOT EXISTS ] newSequenceName / / [ START WITH long ] / / [ INCREMENT BY long ] / / [ CACHE long ] / / "CREATE SEQUENCE $sequenceName$ START WITH $startValue$ " + / / "INCREMENT BY $incrementValue$ $cache$ $cacheValue$" ; StringTemplate st = new StringTemplate ( ST_CREATE_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( cache ) ) { valuesMap . put ( ST_CACHE_KEY , "CACHE" ) ; valuesMap . put ( ST_CACHE_VALUE_KEY , cache ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } if ( DialectUtils . isNotEmptyString ( start ) ) { valuesMap . put ( ST_START_VALUE_KEY , start ) ; } return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test47 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; NetezzaDialextExt netezzaDialextExt0 = new NetezzaDialextExt ( ) ; String string0 = DialectUtils . getAlterSequenceSQL ( "" , ( String ) null , "" , "" , "" , "" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) netezzaDialextExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER SEQUENCE $sequenceName$ " + / / "$restartWith$ $startValue$ " + / / "$incrementBy$ $incrementValue$ " ; StringTemplate st = new StringTemplate ( ST_ALTER_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( restart ) ) { valuesMap . put ( ST_RESTART_WITH_KEY , "RESTART WITH" ) ; valuesMap . put ( ST_START_VALUE_KEY , restart ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_BY_KEY , "INCREMENT BY" ) ; valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test48 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "r" , ( String ) null ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; NetezzaDialextExt netezzaDialextExt0 = new NetezzaDialextExt ( ) ; String string0 = DialectUtils . getAlterSequenceSQL ( "r" , "r" , "r" , ( String ) null , ( String ) null , "r" , ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 , ( HibernateDialect ) netezzaDialextExt0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER SEQUENCE $sequenceName$ " + / / "$restartWith$ $startValue$ " + / / "$incrementBy$ $incrementValue$ " ; StringTemplate st = new StringTemplate ( ST_ALTER_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( restart ) ) { valuesMap . put ( ST_RESTART_WITH_KEY , "RESTART WITH" ) ; valuesMap . put ( ST_START_VALUE_KEY , restart ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_BY_KEY , "INCREMENT BY" ) ; valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test49 ( ) throws Throwable { DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "net . sourceforge . squirrel_sql . fw . dialects . IntersystemsCacheDialectExt@7819d0b6" , "net . sourceforge . squirrel_sql . fw . dialects . IntersystemsCacheDialectExt@7819d0b6" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; SQLServerDialectExt sQLServerDialectExt0 = new SQLServerDialectExt ( ) ; String string0 = sQLServerDialectExt0 . getInsertIntoSQL ( "net . sourceforge . squirrel_sql . fw . dialects . IntersystemsCacheDialectExt@7819d0b6" , ( List < String > ) null , "eMzlC , K & Q4Zp , 1 ( \"" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getInsertIntoSQL ( String tableName , List < String > columns , String valuesPart , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getInsertIntoSQL ( tableName , columns , valuesPart , qualifier , prefs , this ) ; }
void test51 ( ) throws Throwable { String string0 = DialectUtils . formatQualified ( "5VH" , "S4EQ\u0004^jJ$Y | hbg" , false , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String formatQualified ( String table , String schema , boolean qualifyTableNames , boolean useDoubleQuotes ) { if ( qualifyTableNames & & null ! = schema & & 0 < schema . trim ( ) . length ( ) ) { if ( useDoubleQuotes ) { return "\"" + schema + "\" . \"" + table + "\"" ; } else { return schema + " . " + table ; } } else { return table ; } }
void test52 ( ) throws Throwable { String string0 = DialectUtils . formatQualified ( "L < Uke } n1" , "n" , true , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String formatQualified ( String table , String schema , boolean qualifyTableNames , boolean useDoubleQuotes ) { if ( qualifyTableNames & & null ! = schema & & 0 < schema . trim ( ) . length ( ) ) { if ( useDoubleQuotes ) { return "\"" + schema + "\" . \"" + table + "\"" ; } else { return schema + " . " + table ; } } else { return table ; } }
void test53 ( ) throws Throwable { String string0 = DialectUtils . formatQualified ( "L < Uke } n1" , "n" , true , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String formatQualified ( String table , String schema , boolean qualifyTableNames , boolean useDoubleQuotes ) { if ( qualifyTableNames & & null ! = schema & & 0 < schema . trim ( ) . length ( ) ) { if ( useDoubleQuotes ) { return "\"" + schema + "\" . \"" + table + "\"" ; } else { return schema + " . " + table ; } } else { return table ; } }
void test54 ( ) throws Throwable { SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; sqlGenerationPreferences0 . setQualifyTableNames ( false ) ; String string0 = DialectUtils . getRenameViewSQL ( "_R & Ns / & | tP WT" , "_R & Ns / & | tP WT" , "_R & Ns / & | tP WT" , "_R & Ns / & | tP WT" , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 , ( HibernateDialect ) commonHibernateDialect0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getRenameViewSQL ( String oldViewName , String newViewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String msg = DialectUtils . getUnsupportedMessage ( this , DialectUtils . RENAME_VIEW_TYPE ) ; throw new UnsupportedOperationException ( msg ) ; }
void test55 ( ) throws Throwable { SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; CommonHibernateDialect commonHibernateDialect0 = new CommonHibernateDialect ( ) ; sqlGenerationPreferences0 . setQuoteIdentifiers ( false ) ; String string0 = DialectUtils . getRenameViewSQL ( "_R & Ns / & | tP WT" , "_R & Ns / & | tP WT" , "_R & Ns / & | tP WT" , "_R & Ns / & | tP WT" , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 , ( HibernateDialect ) commonHibernateDialect0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getRenameViewSQL ( String oldViewName , String newViewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String msg = DialectUtils . getUnsupportedMessage ( this , DialectUtils . RENAME_VIEW_TYPE ) ; throw new UnsupportedOperationException ( msg ) ; }
void test56 ( ) throws Throwable { SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " . P" , " . P" , " . P" , " . P" , ( - 1 ) , " . P" , 23532 , 548 , 23532 , 23532 , " . P" , " . P" , 1830 , 338 , " . P" ) ; GreenplumDialectExt greenplumDialectExt0 = new GreenplumDialectExt ( ) ; String string0 = DialectUtils . getAddColumSQL ( tableColumnInfo0 , ( HibernateDialect ) greenplumDialectExt0 , false , false , false , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAddColumSQL ( TableColumnInfo info , HibernateDialect dialect , boolean addDefaultClause , boolean supportsNullQualifier , boolean addNullClause , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException , HibernateException { StringBuilder result = new StringBuilder ( ) ; result . append ( DialectUtils . ALTER_TABLE_CLAUSE + " " ) ; result . append ( shapeQualifiableIdentifier ( info . getTableName ( ) , qualifier , prefs , dialect ) ) ; result . append ( " " ) ; result . append ( dialect . getAddColumnString ( ) . toUpperCase ( ) ) ; result . append ( " " ) ; if ( prefs . isQuoteColumnNames ( ) ) { result . append ( shapeIdentifier ( info . getColumnName ( ) , prefs , dialect ) ) ; } else { result . append ( info . getColumnName ( ) ) ; } result . append ( " " ) ; result . append ( dialect . getTypeName ( info . getDataType ( ) , info . getColumnSize ( ) , info . getColumnSize ( ) , info . getDecimalDigits ( ) ) ) ; if ( addDefaultClause ) { appendDefaultClause ( info , result ) ; } if ( addNullClause ) { if ( info . isNullable ( ) . equals ( "NO" ) ) { result . append ( " NOT NULL " ) ; } else { if ( supportsNullQualifier ) { result . append ( " NULL " ) ; } } } return result . toString ( ) ; }
void test57 ( ) throws Throwable { GenericDialectExt genericDialectExt0 = new GenericDialectExt ( ) ; StringTemplate stringTemplate0 = ASTExpr . MAP_KEY_VALUE ; HashMap < String , String > hashMap0 = new HashMap < String , String > ( 0 ) ; String [ ] stringArray0 = new String [ 9 ] ; stringArray0 [ 0 ] = "I`%WtNK1h#nBsZ ! t" ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; DialectUtils . bindTemplateAttributes ( ( HibernateDialect ) genericDialectExt0 , stringTemplate0 , hashMap0 , stringArray0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String bindTemplateAttributes ( HibernateDialect dialect , StringTemplate st , HashMap < String , String > valuesMap , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { bindAttributes ( dialect , st , valuesMap , qualifier , prefs ) ; return st . toString ( ) ; }
void test59 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 7 ] ; String string0 = DialectUtils . toHexString ( byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toHexString ( byte [ ] bytes ) { char [ ] hexArray = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } ; char [ ] hexChars = new char [ bytes . length * 2 ] ; int v ; for ( int j = 0 ; j < bytes . length ; j + + ) { v = bytes [ j ] & 0xFF ; hexChars [ j * 2 ] = hexArray [ v / 16 ] ; hexChars [ j * 2 + 1 ] = hexArray [ v % 16 ] ; } return new String ( hexChars ) ; }
void test0 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUpdateRefAction ( ) { return updateRefAction ; }
void test1 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; createScriptPreferences0 . setDeleteAction ( 3 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateAction ( ) { return updateAction ; }
void test2 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; int int0 = createScriptPreferences0 . getDeleteAction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeleteRefAction ( ) { return deleteRefAction ; }
void test3 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; createScriptPreferences0 . setQualifyTableNames ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isQualifyTableNames ( ) { return qualifyTableNames ; }
void test4 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; boolean boolean0 = createScriptPreferences0 . isDeleteRefAction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateAction ( ) { return updateAction ; }
void test5 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; int int0 = createScriptPreferences0 . getUpdateAction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUpdateRefAction ( ) { return updateRefAction ; }
void test6 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; boolean boolean0 = createScriptPreferences0 . isUpdateRefAction ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteAction ( ) { return deleteAction ; }
void test7 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; createScriptPreferences0 . isIncludeExternalReferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateAction ( ) { return updateAction ; }
void test8 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; createScriptPreferences0 . setUseDoubleQuotes ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteAction ( ) { return deleteAction ; }
void test9 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; createScriptPreferences0 . setUpdateAction ( 3 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteAction ( ) { return deleteAction ; }
void test10 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; createScriptPreferences0 . isQualifyTableNames ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteAction ( ) { return deleteAction ; }
void test11 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; createScriptPreferences0 . setDeleteRefAction ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteAction ( ) { return deleteAction ; }
void test12 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; createScriptPreferences0 . setConstraintsAtEnd ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUpdateRefAction ( ) { return updateRefAction ; }
void test13 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; createScriptPreferences0 . isUseDoubleQuotes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeleteRefAction ( ) { return deleteRefAction ; }
void test14 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; createScriptPreferences0 . isConstraintsAtEnd ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeleteRefAction ( ) { return deleteRefAction ; }
void test15 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; createScriptPreferences0 . setIncludeExternalReferences ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeleteRefAction ( ) { return deleteRefAction ; }
void test16 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; String string0 = createScriptPreferences0 . getRefActionByType ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteAction ( ) { return deleteAction ; }
void test17 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; String string0 = createScriptPreferences0 . getRefActionByType ( 886 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeleteRefAction ( ) { return deleteRefAction ; }
void test18 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; String string0 = createScriptPreferences0 . getRefActionByType ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDeleteAction ( ) { return deleteAction ; }
void test19 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; String string0 = createScriptPreferences0 . getRefActionByType ( 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDeleteRefAction ( ) { return deleteRefAction ; }
void test20 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; String string0 = createScriptPreferences0 . getRefActionByType ( 3 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUpdateRefAction ( ) { return updateRefAction ; }
void test21 ( ) throws Throwable { CreateScriptPreferences createScriptPreferences0 = new CreateScriptPreferences ( ) ; String string0 = createScriptPreferences0 . getRefActionByType ( 4 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUpdateAction ( ) { return updateAction ; }
void test0 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsAutoIncrement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAutoIncrement ( ) { return true ; }
void test1 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsAlterColumnNull ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnNull ( ) { return true ; }
void test2 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; String [ ] stringArray0 = firebirdDialectExt0 . getIndexAccessMethodsTypes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexAccessMethodsTypes ( ) { return new String [ ] { "DEFAULT" , "HASH" } ; }
void test3 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsAddUniqueConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddUniqueConstraint ( ) { return true ; }
void test4 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsAlterSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test5 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsSubSecondTimestamps ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSubSecondTimestamps ( ) { return false ; }
void test6 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsCreateSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateSequence ( ) { return true ; }
void test7 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsDropView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropView ( ) { return true ; }
void test9 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsRenameTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameTable ( ) { return true ; }
void test10 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsDropConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropConstraint ( ) { return true ; }
void test11 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; String string0 = firebirdDialectExt0 . getDropViewSQL ( "" , true , ( DatabaseObjectQualifier ) null , ( SqlGenerationPreferences ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropViewSQL ( String viewName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP VIEW $viewName$" ; StringTemplate st = new StringTemplate ( ST_DROP_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test12 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsSequenceInformation ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequenceInformation ( ) { return true ; }
void test13 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "ALTER TABLE $tableName$ ADD CONSTRAINT $constraintName$ UNIQUE ( $columnName ; separator = \" , \"$ ) " , "Ev" , "ALTER TABLE $tableName$ ADD CONSTRAINT $constraintName$ UNIQUE ( $columnName ; separator = \" , \"$ ) " , "ALTER TABLE $tableName$ ADD CONSTRAINT $constraintName$ UNIQUE ( $columnName ; separator = \" , \"$ ) " , 0 , "ALTER TABLE $tableName$ ADD CONSTRAINT $constraintName$ UNIQUE ( $columnName ; separator = \" , \"$ ) " , ( - 258 ) , 0 , 194 , ( - 1993 ) , "ALTER TABLE $tableName$ ADD CONSTRAINT $constraintName$ UNIQUE ( $columnName ; separator = \" , \"$ ) " , "Ev" , 0 , 194 , "ALTER TABLE $tableName$ ADD CONSTRAINT $constraintName$ UNIQUE ( $columnName ; separator = \" , \"$ ) " ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = firebirdDialectExt0 . getAddAutoIncrementSQL ( tableColumnInfo0 , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddAutoIncrementSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER TABLE $tableName$ ALTER COLUMN $columnName$ IDENTITY" ; StringTemplate st = new StringTemplate ( ST_ADD_AUTO_INCREMENT_STYLE_TWO ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , column . getTableName ( ) , ST_COLUMN_NAME_KEY , column . getColumnName ( ) ) ; return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test14 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsCreateView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateView ( ) { return true ; }
void test15 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsCorrelatedSubQuery ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCorrelatedSubQuery ( ) { return true ; }
void test16 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsAlterColumnDefault ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnDefault ( ) { return true ; }
void test17 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsSchemasInTableDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSchemasInTableDefinition ( ) { return false ; }
void test18 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsAddColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddColumn ( ) { return true ; }
void test19 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsMultipleRowInserts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsMultipleRowInserts ( ) { return true ; }
void test21 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsViewDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsViewDefinition ( ) { return true ; }
void test22 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "" , "ALTER TABLE FirebirdA0#iYY#c7kL@r1a ALTER COLUMN \"FirebirdA0#iYY#c7kL@r1a\" TO \"FirebirdA0#iYY#c7kL@r1a\"" ) ; String string0 = firebirdDialectExt0 . getViewDefinitionSQL ( "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getViewDefinitionSQL ( String viewName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "select view_definition " + / / "from information_schema . views " + / / "where table_schema = ? " + / / "and table_name = ? " ; String templateStr = "select view_definition from information_schema . views " + "where table_schema = '$schemaName$' and UPPER ( table_name ) = UPPER ( '$viewName$' ) " ; StringTemplate st = new StringTemplate ( templateStr ) ; st . setAttribute ( ST_SCHEMA_NAME_KEY , qualifier . getSchema ( ) ) ; st . setAttribute ( ST_VIEW_NAME_KEY , viewName ) ; return st . toString ( ) ; }
void test23 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsCheckOptionsForViews ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCheckOptionsForViews ( ) { return false ; }
void test24 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; String [ ] stringArray0 = firebirdDialectExt0 . getIndexStorageOptions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getIndexStorageOptions ( ) { return null ; }
void test25 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; String string0 = firebirdDialectExt0 . getLengthFunction ( ( int ) ( byte ) 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLengthFunction ( int dataType ) { return "length" ; }
void test26 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsEmptyTables ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsEmptyTables ( ) { return true ; }
void test27 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsTablespace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTablespace ( ) { return false ; }
void test28 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; String string0 = firebirdDialectExt0 . getDropSequenceSQL ( "" , false , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropSequenceSQL ( String sequenceName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP SEQUENCE $sequenceName$ $cascade$" ; StringTemplate st = new StringTemplate ( ST_DROP_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test29 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsSequence ( ) { return true ; }
void test31 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUpdate ( ) { return true ; }
void test32 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsCreateIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateIndex ( ) { return true ; }
void test33 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsAlterColumnType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterColumnType ( ) { return true ; }
void test34 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "D ? " , "D ? " , "D ? " , 1 , "D ? " , 1 , 1 , 1 , 0 , "" , "" , 0 , 0 , "D ? " ) ; String [ ] stringArray0 = firebirdDialectExt0 . getAddColumnSQL ( tableColumnInfo0 , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAddColumnSQL ( TableColumnInfo column , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { ArrayList < String > result = new ArrayList < String > ( ) ; boolean addDefaultClause = true ; boolean supportsNullQualifier = true ; boolean addNullClause = true ; String sql = DialectUtils . getAddColumSQL ( column , this , addDefaultClause , supportsNullQualifier , addNullClause , qualifier , prefs ) ; result . add ( sql ) ; if ( column . getRemarks ( ) ! = null & & ! "" . equals ( column . getRemarks ( ) ) ) { result . add ( getColumnCommentAlterSQL ( column , qualifier , prefs ) ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; }
void test35 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = firebirdDialectExt0 . getDropPrimaryKeySQL ( " , p`rs < & ! Sd4~" , " , p`rs < & ! Sd4~" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropPrimaryKeySQL ( String pkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropPrimaryKeySQL ( pkName , tableName , false , false , qualifier , prefs , this ) ; }
void test36 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsRenameView ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameView ( ) { return false ; }
void test38 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "c ; 3in4t@ { 41RnKM [ 0f" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = firebirdDialectExt0 . getDropForeignKeySQL ( "c ; 3in4t@ { 41RnKM [ 0f" , "" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropForeignKeySQL ( String fkName , String tableName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { return DialectUtils . getDropForeignKeySQL ( fkName , tableName , qualifier , prefs , this ) ; }
void test40 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsAddForeignKeyConstraint ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAddForeignKeyConstraint ( ) { return true ; }
void test42 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = firebirdDialectExt0 . getColumnDropSQL ( "D ? " , "D ? " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnDropSQL ( String tableName , String columnName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) throws UnsupportedOperationException { StringTemplate st = new StringTemplate ( DROP_COLUMN_SQL_TEMPLATE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_COLUMN_NAME_KEY , columnName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test43 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = firebirdDialectExt0 . getDropIndexSQL ( "" , "Firebird & 9_V * . J09" , false , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropIndexSQL ( String tableName , String indexName , boolean cascade , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "DROP INDEX $indexName$" ; StringTemplate st = new StringTemplate ( ST_DROP_INDEX_STYLE_THREE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_INDEX_NAME_KEY , indexName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test44 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsIndexes ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsIndexes ( ) { return true ; }
void test45 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( "c ; 3in4t@ { 41RnKM [ 0f" , "" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = firebirdDialectExt0 . getDropConstraintSQL ( "c ; 3in4t@ { 41RnKM [ 0f" , "BH^CRML [ ~ ? " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDropConstraintSQL ( String tableName , String constraintName , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / ALTER TABLE $tableName$ DROP CONSTRAINT $constraintName$ StringTemplate st = new StringTemplate ( ST_DROP_CONSTRAINT_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_TABLE_NAME_KEY , tableName , ST_CONSTRAINT_NAME_KEY , constraintName ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test46 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsRenameColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsRenameColumn ( ) { return true ; }
void test47 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String [ ] stringArray0 = firebirdDialectExt0 . getAlterSequenceSQL ( "Firebird & 9_V * . J09" , "DROP INDEX Firebird & 9_V * . J09" , "" , "" , ( String ) null , ( String ) null , false , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAlterSequenceSQL ( String sequenceName , String increment , String minimum , String maximum , String restart , String cache , boolean cycle , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / "ALTER SEQUENCE $sequenceName$ " + / / "$restartWith$ $startValue$ " + / / "$incrementBy$ $incrementValue$ " ; StringTemplate st = new StringTemplate ( ST_ALTER_SEQUENCE_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_SEQUENCE_NAME_KEY , sequenceName ) ; if ( DialectUtils . isNotEmptyString ( restart ) ) { valuesMap . put ( ST_RESTART_WITH_KEY , "RESTART WITH" ) ; valuesMap . put ( ST_START_VALUE_KEY , restart ) ; } if ( DialectUtils . isNotEmptyString ( increment ) ) { valuesMap . put ( ST_INCREMENT_BY_KEY , "INCREMENT BY" ) ; valuesMap . put ( ST_INCREMENT_VALUE_KEY , increment ) ; } return new String [ ] { DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) } ; }
void test48 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsDropIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropIndex ( ) { return true ; }
void test49 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; int int0 = firebirdDialectExt0 . getPrecisionDigits ( 4 , ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getPrecisionDigits ( int columnSize , int dataType ) { return columnSize ; }
void test50 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; DialectType dialectType0 = firebirdDialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DialectType getDialectType ( ) { return DialectFactory . getDialectType ( getSession ( ) . getMetaData ( ) ) ; }
void test51 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsColumnComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test52 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsDropSequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsDropSequence ( ) { return true ; }
void test53 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "FirebirdA0#iYY#c7kL@r1a" , "FirebirdA0#iYY#c7kL@r1a" , "FirebirdA0#iYY#c7kL@r1a" , "FirebirdA0#iYY#c7kL@r1a" , 58 , "FirebirdA0#iYY#c7kL@r1a" , 58 , 58 , 58 , 745 , "FirebirdA0#iYY#c7kL@r1a" , "FirebirdA0#iYY#c7kL@r1a" , 745 , ( - 1 ) , "FirebirdA0#iYY#c7kL@r1a" ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = firebirdDialectExt0 . getColumnNameAlterSQL ( tableColumnInfo0 , tableColumnInfo0 , ( DatabaseObjectQualifier ) null , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnNameAlterSQL ( TableColumnInfo from , TableColumnInfo to , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { String alterClause = DialectUtils . ALTER_COLUMN_CLAUSE ; String renameToClause = DialectUtils . RENAME_TO_CLAUSE ; return DialectUtils . getColumnNameAlterSQL ( from , to , alterClause , renameToClause , qualifier , prefs , this ) ; }
void test55 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsCreateTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCreateTable ( ) { return true ; }
void test56 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsAccessMethods ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAccessMethods ( ) { return true ; }
void test57 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; int int0 = firebirdDialectExt0 . getColumnLength ( 31 , ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test58 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; int int0 = firebirdDialectExt0 . getColumnLength ( 1110 , 6 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test59 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; int int0 = firebirdDialectExt0 . getColumnLength ( 0 , 7 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test60 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; int int0 = firebirdDialectExt0 . getColumnLength ( 1110 , ( - 4 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test61 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; int int0 = firebirdDialectExt0 . getColumnLength ( 2001 , 2001 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test62 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsProduct ( "BH^CRML [ ~ ? " , "BH^CRML [ ~ ? " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test63 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsProduct ( ( String ) null , "BH^CRML [ ~ ? " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test64 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; boolean boolean0 = firebirdDialectExt0 . supportsProduct ( "Firebird & 9_V * . J09" , "Firebird & 9_V * . J09" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test67 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; String [ ] stringArray0 = new String [ 7 ] ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = firebirdDialectExt0 . getCreateIndexSQL ( "line . separatr" , "line . separatr" , "line . separatr" , stringArray0 , false , "line . separatr" , ( String ) null , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE { [ UNIQUE [ HASH ] ] INDEX [ [ IF NOT EXISTS ] newIndexName ] / / | PRIMARY KEY [ HASH ] } ON ( columnName [ , . . . ] ) StringTemplate st = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; HashMap < String , String > valuesMap = new HashMap < String , String > ( ) ; if ( unique ) { valuesMap . put ( ST_UNIQUE_KEY , "UNIQUE" ) ; if ( accessMethod ! = null & & "HASH" . equalsIgnoreCase ( accessMethod ) ) { valuesMap . put ( ST_STORAGE_OPTION_KEY , "HASH" ) ; } } valuesMap . put ( ST_INDEX_NAME_KEY , indexName ) ; valuesMap . put ( ST_TABLE_NAME_KEY , tableName ) ; return DialectUtils . getAddIndexSQL ( this , st , valuesMap , columns , qualifier , prefs ) ; }
void test68 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; String [ ] stringArray0 = new String [ 8 ] ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; String string0 = firebirdDialectExt0 . getCreateIndexSQL ( "BH^CRML [ ~ ? " , "BH^CRML [ ~ ? " , "BH^CRML [ ~ ? " , stringArray0 , true , "BH^CRML" , "BH^CRML [ ~ ? " , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateIndexSQL ( String indexName , String tableName , String accessMethod , String [ ] columns , boolean unique , String tablespace , String constraints , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE { [ UNIQUE [ HASH ] ] INDEX [ [ IF NOT EXISTS ] newIndexName ] / / | PRIMARY KEY [ HASH ] } ON ( columnName [ , . . . ] ) StringTemplate st = new StringTemplate ( ST_CREATE_INDEX_STYLE_TWO ) ; / / "CREATE $unique$ $storageOption$ INDEX $indexName$ " + / / "ON $tableName$ ( $columnName ; separator = \" , \"$ ) " ; HashMap < String , String > valuesMap = new HashMap < String , String > ( ) ; if ( unique ) { valuesMap . put ( ST_UNIQUE_KEY , "UNIQUE" ) ; if ( accessMethod ! = null & & "HASH" . equalsIgnoreCase ( accessMethod ) ) { valuesMap . put ( ST_STORAGE_OPTION_KEY , "HASH" ) ; } } valuesMap . put ( ST_INDEX_NAME_KEY , indexName ) ; valuesMap . put ( ST_TABLE_NAME_KEY , tableName ) ; return DialectUtils . getAddIndexSQL ( this , st , valuesMap , columns , qualifier , prefs ) ; }
void test69 ( ) throws Throwable { FirebirdDialectExt firebirdDialectExt0 = new FirebirdDialectExt ( ) ; SqlGenerationPreferences sqlGenerationPreferences0 = new SqlGenerationPreferences ( ) ; DatabaseObjectQualifier databaseObjectQualifier0 = new DatabaseObjectQualifier ( ) ; String string0 = firebirdDialectExt0 . getCreateViewSQL ( "ALTER TABLE $tableName$ ADD CONSTRAINT $constraintName$ UNIQUE ( $columnName ; separator = \" , \"$ ) " , "KTSq & HK~a%sEH" , "KTSq & HK~a%sEH" , databaseObjectQualifier0 , sqlGenerationPreferences0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCreateViewSQL ( String viewName , String definition , String checkOption , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs ) { / / CREATE [ FORCE ] VIEW [ IF NOT EXISTS ] newViewName [ ( columnName [ , . . ] ) ] / / AS select / / "CREATE VIEW $viewName$ " + / / "AS $selectStatement$ $with$ $checkOptionType$ $checkOption$" ; StringTemplate st = new StringTemplate ( ST_CREATE_VIEW_STYLE_ONE ) ; HashMap < String , String > valuesMap = DialectUtils . getValuesMap ( ST_VIEW_NAME_KEY , viewName , ST_SELECT_STATEMENT_KEY , definition ) ; return DialectUtils . bindTemplateAttributes ( this , st , valuesMap , qualifier , prefs ) ; }
void test1 ( ) throws Throwable { GenericDialectExt genericDialectExt0 = new GenericDialectExt ( ) ; boolean boolean0 = genericDialectExt0 . supportsProduct ( "m | b_2B | Ifz" , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsProduct ( String databaseProductName , String databaseProductVersion ) { if ( databaseProductName = = null ) { return false ; } if ( databaseProductName . trim ( ) . startsWith ( "H2" ) ) { / / We don't yet have the need to discriminate by version . return true ; } return false ; }
void test2 ( ) throws Throwable { GenericDialectExt genericDialectExt0 = new GenericDialectExt ( ) ; DialectType dialectType0 = genericDialectExt0 . getDialectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DialectType getDialectType ( ) { return DialectFactory . getDialectType ( getSession ( ) . getMetaData ( ) ) ; }
void test0 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isDB2 ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDB2 ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , db2Dialect ) ; }
void test1 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isMSSQLServer ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMSSQLServer ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , sqlserverDialect ) ; }
void test2 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; GenericDialectExt genericDialectExt0 = ( GenericDialectExt ) dialectFactoryImpl0 . getDialect ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnComment ( ) { return true ; }
void test3 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isFirebird ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFirebird ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , firebirdDialect ) ; }
void test4 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isDaffodil ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDaffodil ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , daffodilDialect ) ; }
void test5 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; HibernateDialect hibernateDialect0 = dialectFactoryImpl0 . getDialect ( "' . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" HibernateDialect getDialect ( String dbName ) { return dbNameDialectMap . get ( dbName ) ; }
void test6 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isHADB ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isHADB ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , hadbDialect ) ; }
void test7 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isInterbase ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInterbase ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , interbaseDialect ) ; }
void test8 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isH2 ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isH2 ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , h2Dialect ) ; }
void test9 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isFrontBase ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFrontBase ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , frontbaseDialect ) ; }
void test10 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isTimesTen ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTimesTen ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , timestenDialect ) ; }
void test11 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isGreenplum ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isGreenplum ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , greenplumDialect ) ; }
void test12 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isProgress ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isProgress ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , progressDialect ) ; }
void test13 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; Object [ ] objectArray0 = dialectFactoryImpl0 . getDbNames ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object [ ] getDbNames ( ) { Set < String > keyset = dbNameDialectMap . keySet ( ) ; Object [ ] keys = keyset . toArray ( ) ; Arrays . sort ( keys ) ; return keys ; }
void test14 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; HibernateDialect hibernateDialect0 = dialectFactoryImpl0 . getDialectIgnoreCase ( "7Ulkuy\"Zcn`k + , L\" + 8" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" HibernateDialect getDialectIgnoreCase ( String dbName ) { for ( String displayName : dbNameDialectMap . keySet ( ) ) { if ( displayName . toLowerCase ( ) . equals ( dbName . toLowerCase ( ) ) ) { return dbNameDialectMap . get ( displayName ) ; } } return null ; }
void test15 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isIngres ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIngres ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , ingresDialect ) ; }
void test16 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; Object [ ] objectArray0 = dialectFactoryImpl0 . getSupportedDialects ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object [ ] getSupportedDialects ( ) { Collection < HibernateDialect > c = dbNameDialectMap . values ( ) ; return c . toArray ( ) ; }
void test17 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isPostgreSQL ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPostgreSQL ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , postgreSQLDialect ) ; }
void test18 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isMaxDB ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMaxDB ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , maxDbDialect ) ; }
void test19 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isMySQL5 ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMySQL5 ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , mysql5Dialect ) ; }
void test20 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isPointbase ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPointbase ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , pointbaseDialect ) ; }
void test21 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isNetezza ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNetezza ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , netezzaDialect ) ; }
void test22 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isSyBase ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSyBase ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , sybaseDialect ) ; }
void test23 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isMySQL ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMySQL ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , mysqlDialect ) ; }
void test24 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isOracle ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isOracle ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , oracle9iDialect ) ; }
void test25 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isMcKoi ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isMcKoi ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , mckoiDialect ) ; }
void test26 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; GenericDialectExt genericDialectExt0 = ( GenericDialectExt ) dialectFactoryImpl0 . getDialect ( 0 , ( JFrame ) null , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsAlterSequence ( ) { return true ; }
void test27 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isIntersystemsCacheDialectExt ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIntersystemsCacheDialectExt ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , intersystemsCacheDialectExt ) ; }
void test28 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isInformix ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInformix ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , informixDialect ) ; }
void test29 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; DialectType dialectType0 = dialectFactoryImpl0 . getDialectType ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DialectType getDialectType ( ) { return DialectFactory . getDialectType ( getSession ( ) . getMetaData ( ) ) ; }
void test30 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isHSQL ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isHSQL ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , hsqlDialect ) ; }
void test31 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isDerby ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDerby ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , derbyDialect ) ; }
void test32 ( ) throws Throwable { DialectFactoryImpl dialectFactoryImpl0 = new DialectFactoryImpl ( ) ; boolean boolean0 = dialectFactoryImpl0 . isAxion ( ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAxion ( ISQLDatabaseMetaData md ) { return dialectSupportsProduct ( md , axionDialect ) ; }
void test0 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; int int0 = teiidDialect0 . registerResultSetOutParameter ( ( CallableStatement ) null , ( - 716 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int registerResultSetOutParameter ( CallableStatement statement , int col ) throws SQLException { return col ; }
void test1 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; boolean boolean0 = teiidDialect0 . supportsCurrentTimestampSelection ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCurrentTimestampSelection ( ) { return true ; }
void test2 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; boolean boolean0 = teiidDialect0 . dropConstraints ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean dropConstraints ( ) { return false ; }
void test3 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; boolean boolean0 = teiidDialect0 . supportsOuterJoinForUpdate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsOuterJoinForUpdate ( ) { return false ; }
void test4 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; boolean boolean0 = teiidDialect0 . supportsUnique ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUnique ( ) { return false ; }
void test5 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; String string0 = teiidDialect0 . getSelectGUIDString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSelectGUIDString ( ) { return "select uuid ( ) " ; / / $NON - NLS - 1$ }
void test6 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; String string0 = teiidDialect0 . getForUpdateString ( "now" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getForUpdateString ( ) { return "" ; / / $NON - NLS - 1$ }
void test7 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; String string0 = teiidDialect0 . getForUpdateNowaitString ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getForUpdateNowaitString ( ) { return "" ; / / $NON - NLS - 1$ }
void test8 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; boolean boolean0 = teiidDialect0 . supportsCascadeDelete ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsCascadeDelete ( ) { return false ; }
void test9 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; boolean boolean0 = teiidDialect0 . supportsVariableLimit ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TeiidDialect ( ) { / / Register types registerColumnType ( Types . CHAR , "char" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . VARCHAR , "string" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . BIT , "boolean" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . TINYINT , "byte" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . SMALLINT , "short" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . INTEGER , "integer" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . BIGINT , "long" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . REAL , "float" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . FLOAT , "float" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . DOUBLE , "double" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . NUMERIC , "bigdecimal" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . DATE , "date" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . TIME , "time" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . TIMESTAMP , "timestamp" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . BLOB , "blob" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . VARBINARY , "blob" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . CLOB , "clob" ) ; / / $NON - NLS - 1$ registerColumnType ( Types . JAVA_OBJECT , "object" ) ; / / $NON - NLS - 1$ registerFunction ( "acos" , new StandardSQLFunction ( "acos" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "asin" , new StandardSQLFunction ( "asin" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "atan" , new StandardSQLFunction ( "atan" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "atan2" , new StandardSQLFunction ( "atan2" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "ceil" , new StandardSQLFunction ( "ceiling" ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "cos" , new StandardSQLFunction ( "cos" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "cot" , new StandardSQLFunction ( "cot" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "degrees" , new StandardSQLFunction ( "degrees" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "exp" , new StandardSQLFunction ( "exp" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "floor" , new StandardSQLFunction ( "floor" ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "formatbigdecimal" , new StandardSQLFunction ( "formatbigdecimal" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "formatbiginteger" , new StandardSQLFunction ( "formatbiginteger" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "formatdouble" , new StandardSQLFunction ( "formatdouble" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "formatfloat" , new StandardSQLFunction ( "formatfloat" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "formatinteger" , new StandardSQLFunction ( "formatinteger" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "formatlong" , new StandardSQLFunction ( "formatlong" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "log" , new StandardSQLFunction ( "log" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "mod" , new StandardSQLFunction ( "mod" ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "parsebigdecimal" , new StandardSQLFunction ( "parsebigdecimal" , Hibernate . BIG_DECIMAL ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "parsebiginteger" , new StandardSQLFunction ( "parsebiginteger" , Hibernate . BIG_INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "parsedouble" , new StandardSQLFunction ( "parsedouble" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "parsefloat" , new StandardSQLFunction ( "parsefloat" , Hibernate . FLOAT ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "parseinteger" , new StandardSQLFunction ( "parseinteger" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "parselong" , new StandardSQLFunction ( "parselong" , Hibernate . LONG ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "pi" , new StandardSQLFunction ( "pi" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "power" , new StandardSQLFunction ( "power" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "radians" , new StandardSQLFunction ( "radians" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "round" , new StandardSQLFunction ( "round" ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "sign" , new StandardSQLFunction ( "sign" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "sin" , new StandardSQLFunction ( "sin" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "tan" , new StandardSQLFunction ( "tan" , Hibernate . DOUBLE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "ascii" , new StandardSQLFunction ( "ascii" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "chr" , new StandardSQLFunction ( "chr" , Hibernate . CHARACTER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "char" , new StandardSQLFunction ( "char" , Hibernate . CHARACTER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "concat" , new VarArgsSQLFunction ( Hibernate . STRING , "" , " | | " , "" ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ / / $NON - NLS - 3$ / / $NON - NLS - 4$ registerFunction ( "initcap" , new StandardSQLFunction ( "initcap" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "insert" , new StandardSQLFunction ( "insert" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "lcase" , new StandardSQLFunction ( "lcase" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "left" , new StandardSQLFunction ( "left" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "locate" , new StandardSQLFunction ( "locate" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "lpad" , new StandardSQLFunction ( "lpad" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "ltrim" , new StandardSQLFunction ( "ltrim" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "repeat" , new StandardSQLFunction ( "repeat" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "replace" , new StandardSQLFunction ( "replace" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "right" , new StandardSQLFunction ( "right" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "rpad" , new StandardSQLFunction ( "rpad" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "rtrim" , new StandardSQLFunction ( "rtrim" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "substring" , new StandardSQLFunction ( "substring" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "translate" , new StandardSQLFunction ( "translate" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "ucase" , new StandardSQLFunction ( "ucase" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "curdate" , new NoArgSQLFunction ( "curdate" , Hibernate . DATE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "curtime" , new NoArgSQLFunction ( "curtime" , Hibernate . TIME ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "now" , new NoArgSQLFunction ( "now" , Hibernate . TIMESTAMP ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "dayname" , new StandardSQLFunction ( "dayname" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "dayofmonth" , new StandardSQLFunction ( "dayofmonth" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "dayofweek" , new StandardSQLFunction ( "dayofweek" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "dayofyear" , new StandardSQLFunction ( "dayofyear" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "formatdate" , new StandardSQLFunction ( "formatdate" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "formattime" , new StandardSQLFunction ( "formattime" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "formattimestamp" , new StandardSQLFunction ( "formattimestamp" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "hour" , new StandardSQLFunction ( "hour" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "minute" , new StandardSQLFunction ( "minute" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "monthname" , new StandardSQLFunction ( "monthname" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "parsedate" , new StandardSQLFunction ( "parsedate" , Hibernate . DATE ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "parsetime" , new StandardSQLFunction ( "parsetime" , Hibernate . TIME ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "parsetimestamp" , new StandardSQLFunction ( "parsetimestamp" , Hibernate . TIMESTAMP ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "second" , new StandardSQLFunction ( "second" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "timestampcreate" , new StandardSQLFunction ( "timestampcreate" , Hibernate . TIMESTAMP ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "timestampAdd" , new StandardSQLFunction ( "timestampAdd" ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "timestampDiff" , new StandardSQLFunction ( "timestampDiff" , Hibernate . LONG ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "week" , new StandardSQLFunction ( "week" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "year" , new StandardSQLFunction ( "year" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "modifytimezone" , new StandardSQLFunction ( "modifytimezone" , Hibernate . TIMESTAMP ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "convert" , new StandardSQLFunction ( "convert" ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "to_bytes" , new StandardSQLFunction ( "to_bytes" , Hibernate . BLOB ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "to_chars" , new StandardSQLFunction ( "to_chars" , Hibernate . CLOB ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "from_unittime" , new StandardSQLFunction ( "from_unittime" , Hibernate . TIMESTAMP ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "session_id" , new StandardSQLFunction ( "session_id" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "uuid" , new StandardSQLFunction ( "uuid" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "unescape" , new StandardSQLFunction ( "unescape" , Hibernate . STRING ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "array_get" , new StandardSQLFunction ( "uuid" , Hibernate . OBJECT ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ registerFunction ( "array_length" , new StandardSQLFunction ( "unescape" , Hibernate . INTEGER ) ) ; / / $NON - NLS - 1$ / / $NON - NLS - 2$ }
void test10 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; boolean boolean0 = teiidDialect0 . supportsUnionAll ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsUnionAll ( ) { return true ; }
void test11 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; String string0 = teiidDialect0 . getForUpdateNowaitString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getForUpdateNowaitString ( ) { return "" ; / / $NON - NLS - 1$ }
void test12 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; boolean boolean0 = teiidDialect0 . supportsColumnCheck ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsColumnCheck ( ) { return false ; }
void test13 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; String string0 = teiidDialect0 . getCurrentTimestampSQLFunctionName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCurrentTimestampSQLFunctionName ( ) { return "now" ; / / $NON - NLS - 1$ }
void test14 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; boolean boolean0 = teiidDialect0 . isCurrentTimestampSelectStringCallable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCurrentTimestampSelectStringCallable ( ) { return false ; }
void test15 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; boolean boolean0 = teiidDialect0 . supportsTableCheck ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean supportsTableCheck ( ) { return false ; }
void test16 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; String string0 = teiidDialect0 . getForUpdateString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getForUpdateString ( ) { return "" ; / / $NON - NLS - 1$ }
void test17 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; LockMode lockMode0 = DefaultLoadEventListener . DEFAULT_LOCK_MODE ; String string0 = teiidDialect0 . getForUpdateString ( lockMode0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getForUpdateString ( ) { return "" ; / / $NON - NLS - 1$ }
void test18 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; boolean boolean0 = teiidDialect0 . hasAlterTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasAlterTable ( ) { return false ; }
void test19 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; String string0 = teiidDialect0 . toBooleanValueString ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toBooleanValueString ( boolean arg0 ) { if ( arg0 ) { return " { b'true' } " ; / / $NON - NLS - 1$ } return " { b'false' } " ; / / $NON - NLS - 1$ }
void test20 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; String string0 = teiidDialect0 . toBooleanValueString ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toBooleanValueString ( boolean arg0 ) { if ( arg0 ) { return " { b'true' } " ; / / $NON - NLS - 1$ } return " { b'false' } " ; / / $NON - NLS - 1$ }
void test21 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; String string0 = teiidDialect0 . getLimitString ( "select uuid ( ) " , ( - 25 ) , ( - 25 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLimitString ( String querySelect , boolean hasOffset ) { return new StringBuffer ( querySelect . length ( ) + 20 ) . append ( querySelect ) . append ( hasOffset ? " limit ? , ? " : " limit ? " ) / / $NON - NLS - 1$ / / $NON - NLS - 2$ . toString ( ) ; }
void test22 ( ) throws Throwable { TeiidDialect teiidDialect0 = new TeiidDialect ( ) ; String string0 = teiidDialect0 . getLimitString ( "e ! n qP6 ; " , 6 , 6 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLimitString ( String querySelect , boolean hasOffset ) { return new StringBuffer ( querySelect . length ( ) + 20 ) . append ( querySelect ) . append ( hasOffset ? " limit ? , ? " : " limit ? " ) / / $NON - NLS - 1$ / / $NON - NLS - 2$ . toString ( ) ; }
void test0 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test1 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; baseQueryTokenizerPreferenceBean0 . setClientVersion ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStatementSeparator ( ) { if ( null = = _session ) { return " ; " ; } else { return _session . getProperties ( ) . getSQLStatementSeparator ( ) ; } }
void test2 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; baseQueryTokenizerPreferenceBean0 . getClientVersion ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComments ( ) ; / * * * @param installCustomQueryTokenizer the installCustomQueryTokenizer to set * / void setInstallCustomQueryTokenizer ( boolean installCustomQueryTokenizer ) ; / * * * @return the installCustomQueryTokenizer * / boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test3 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; String string0 = baseQueryTokenizerPreferenceBean0 . getLineComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test4 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean1 = ( BaseQueryTokenizerPreferenceBean ) baseQueryTokenizerPreferenceBean0 . clone ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComments ( ) ; / * * * @param installCustomQueryTokenizer the installCustomQueryTokenizer to set * / void setInstallCustomQueryTokenizer ( boolean installCustomQueryTokenizer ) ; / * * * @return the installCustomQueryTokenizer * / boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test5 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; baseQueryTokenizerPreferenceBean0 . setClientName ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test6 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; String string0 = baseQueryTokenizerPreferenceBean0 . getStatementSeparator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getProcedureSeparator ( ) ; / * * * @param lineComment the lineComment to set * / void setLineComment ( String lineComment ) ; / * * * @return the lineComment * / String getLineComment ( ) ; / * * * @param removeMultiLineComments the removeMultiLineComments to set * / void setRemoveMultiLineComments ( boolean removeMultiLineComments ) ; / * * * @return the removeMultiLineComments * / boolean isRemoveMultiLineComments ( ) ; / * * * @param installCustomQueryTokenizer the installCustomQueryTokenizer to set * / void setInstallCustomQueryTokenizer ( boolean installCustomQueryTokenizer ) ; / * * * @return the installCustomQueryTokenizer * / boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test7 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; String string0 = baseQueryTokenizerPreferenceBean0 . getProcedureSeparator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComments ( ) ; / * * * @param installCustomQueryTokenizer the installCustomQueryTokenizer to set * / void setInstallCustomQueryTokenizer ( boolean installCustomQueryTokenizer ) ; / * * * @return the installCustomQueryTokenizer * / boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test8 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getProcedureSeparator ( ) ; / * * * @param lineComment the lineComment to set * / void setLineComment ( String lineComment ) ; / * * * @return the lineComment * / String getLineComment ( ) ; / * * * @param removeMultiLineComments the removeMultiLineComments to set * / void setRemoveMultiLineComments ( boolean removeMultiLineComments ) ; / * * * @return the removeMultiLineComments * / boolean isRemoveMultiLineComments ( ) ; / * * * @param installCustomQueryTokenizer the installCustomQueryTokenizer to set * / void setInstallCustomQueryTokenizer ( boolean installCustomQueryTokenizer ) ; / * * * @return the installCustomQueryTokenizer * / boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test9 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLineComment ( ) ; / * * * @param removeMultiLineComments the removeMultiLineComments to set * / void setRemoveMultiLineComments ( boolean removeMultiLineComments ) ; / * * * @return the removeMultiLineComments * / boolean isRemoveMultiLineComments ( ) ; / * * * @param installCustomQueryTokenizer the installCustomQueryTokenizer to set * / void setInstallCustomQueryTokenizer ( boolean installCustomQueryTokenizer ) ; / * * * @return the installCustomQueryTokenizer * / boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test10 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; boolean boolean0 = baseQueryTokenizerPreferenceBean0 . isRemoveMultiLineComments ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLineComment ( ) ; / * * * @param removeMultiLineComments the removeMultiLineComments to set * / void setRemoveMultiLineComments ( boolean removeMultiLineComments ) ; / * * * @return the removeMultiLineComments * / boolean isRemoveMultiLineComments ( ) ; / * * * @param installCustomQueryTokenizer the installCustomQueryTokenizer to set * / void setInstallCustomQueryTokenizer ( boolean installCustomQueryTokenizer ) ; / * * * @return the installCustomQueryTokenizer * / boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test11 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; boolean boolean0 = baseQueryTokenizerPreferenceBean0 . isInstallCustomQueryTokenizer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComments ( ) ; / * * * @param installCustomQueryTokenizer the installCustomQueryTokenizer to set * / void setInstallCustomQueryTokenizer ( boolean installCustomQueryTokenizer ) ; / * * * @return the installCustomQueryTokenizer * / boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test12 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test13 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; baseQueryTokenizerPreferenceBean0 . getClientName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStatementSeparator ( ) { if ( null = = _session ) { return " ; " ; } else { return _session . getProperties ( ) . getSQLStatementSeparator ( ) ; } }
void test14 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isInstallCustomQueryTokenizer ( ) ; / * * * Retrieve the client to use . This is only used if < TT > useAnonymousClient < / TT > * is false . * * @return Client name . * / String getClientName ( ) ; / * * * Set the client name . * * @param value * Client name * / void setClientName ( String value ) ; / * * * Retrieve the client version to use . This is only used if < TT > useAnonymousLogon < / TT > * is false . * * @return Client version . * / String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test0 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; defaultTableModel0 . setRowCount ( 1894 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test1 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) xYDatasetTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test2 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test3 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSortedAscending ( ) { return _ascending ; }
void test4 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) xYDatasetTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean sortByColumn ( int column ) { boolean b = true ; if ( column = = _sortedColumn ) { b = ! _ascending ; } sortByColumn ( column , b ) ; return b ; }
void test5 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) xYDatasetTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test6 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setValueAt ( Object value , int row , int col ) { if ( col = = IColumnIndexes . IDX_VALUE ) { SQLDriverProperty sdp = _props . getDriverProperty ( row ) ; sdp . setValue ( value . toString ( ) ) ; } else if ( col = = IColumnIndexes . IDX_SPECIFY ) { SQLDriverProperty sdp = _props . getDriverProperty ( row ) ; Boolean bool = Boolean . valueOf ( value . toString ( ) ) ; sdp . setIsSpecified ( bool . booleanValue ( ) ) ; } else { throw new IllegalStateException ( "Can only edit value / specify column . Trying to edit " + col ) ; } }
void test7 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) xYDatasetTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test8 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) xYDatasetTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test9 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test10 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) xYDatasetTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test11 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 1 ] ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( objectArray0 , 0 ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String insertRow ( Object [ ] values , ColumnDisplayDefinition [ ] colDefs ) { return _dataSetUpdateableTableModel . insertRow ( values , colDefs ) ; }
void test12 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) xYDatasetTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test13 ( ) throws Throwable { SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test14 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) xYDatasetTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test15 ( ) throws Throwable { Object [ ] [ ] objectArray0 = new Object [ 8 ] [ 8 ] ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( objectArray0 , objectArray0 [ 3 ] ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test16 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) xYDatasetTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test17 ( ) throws Throwable { SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String deleteRows ( Object [ ] [ ] rowData , ColumnDisplayDefinition [ ] colDefs ) { return _dataSetUpdateableTableModel . deleteRows ( rowData , colDefs ) ; }
void test18 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String deleteRows ( Object [ ] [ ] rowData , ColumnDisplayDefinition [ ] colDefs ) { return _dataSetUpdateableTableModel . deleteRows ( rowData , colDefs ) ; }
void test19 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) xYDatasetTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean sortByColumn ( int column ) { boolean b = true ; if ( column = = _sortedColumn ) { b = ! _ascending ; } sortByColumn ( column , b ) ; return b ; }
void test20 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test21 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 1 ] ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( objectArray0 , 0 ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSortedAscending ( ) { return _ascending ; }
void test22 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test23 ( ) throws Throwable { Object [ ] [ ] objectArray0 = new Object [ 8 ] [ 8 ] ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( objectArray0 , objectArray0 [ 3 ] ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test24 ( ) throws Throwable { SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test25 ( ) throws Throwable { Object [ ] [ ] objectArray0 = new Object [ 1 ] [ 4 ] ; Object [ ] objectArray1 = new Object [ 15 ] ; objectArray1 [ 0 ] = ( Object ) "uninitializedValue" ; objectArray0 [ 0 ] = objectArray1 ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( objectArray0 , objectArray1 ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSortedColumn ( ) { return _sortedColumn ; }
void test26 ( ) throws Throwable { Object [ ] [ ] objectArray0 = new Object [ 8 ] [ 8 ] ; Object [ ] objectArray1 = new Object [ 2 ] ; Object object0 = RenderingHints . VALUE_INTERPOLATION_NEAREST_NEIGHBOR ; objectArray1 [ 0 ] = object0 ; objectArray0 [ 0 ] = objectArray1 ; objectArray0 [ 2 ] = objectArray0 [ 0 ] ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( objectArray0 , objectArray0 [ 3 ] ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test0 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test2 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test3 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test4 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test5 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test6 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test7 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test8 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test9 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test10 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test11 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test12 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test13 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test14 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void mouseReleased ( MouseEvent arg0 ) { }
void test15 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test16 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLabel ( ) { return _label ; }
void test17 ( ) throws Throwable { ButtonTableHeader buttonTableHeader0 = new ButtonTableHeader ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCurrentlySortedColumnIdx ( ) { return _currentlySortedColumnIdx ; }
void test0 ( ) throws Throwable { SortedListModel sortedListModel0 = new SortedListModel ( ) ; sortedListModel0 . add ( 512 , ( Object ) "text" ) ; sortedListModel0 . insertElementAt ( 512 , ( Object ) "text" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { SortedListModel sortedListModel0 = new SortedListModel ( ) ; sortedListModel0 . addElement ( ( Object ) "java . awt . geom . Rectangle2D$Double [ x = - 1593 . 3908946784009 , y = 0 . 0 , w = 1 . 0 , h = 1642 . 4740766556645 ] " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test3 ( ) throws Throwable { SortedListModel sortedListModel0 = new SortedListModel ( ) ; sortedListModel0 . addElement ( ( Object ) "java . awt . geom . Rectangle2D$Double [ x = - 1593 . 3908946784009 , y = 0 . 0 , w = 1 . 0 , h = 1642 . 4740766556645 ] " ) ; sortedListModel0 . insertElementAt ( 0 , ( Object ) "LongDescription" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test0 ( ) throws Throwable { IntegerField integerField0 = new IntegerField ( ) ; integerField0 . setInt ( 46 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getInt ( ) { String text = getText ( ) ; if ( text = = null | | text . length ( ) = = 0 ) { return 0 ; } return Integer . parseInt ( text ) ; }
void test1 ( ) throws Throwable { IntegerField integerField0 = new IntegerField ( 60 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IntegerField ( ) { super ( ) ; }
void test2 ( ) throws Throwable { IntegerField integerField0 = new IntegerField ( ) ; int int0 = integerField0 . getInt ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getInt ( ) { String text = getText ( ) ; if ( text = = null | | text . length ( ) = = 0 ) { return 0 ; } return Integer . parseInt ( text ) ; }
void test3 ( ) throws Throwable { IntegerField . IntegerDocument integerField_IntegerDocument0 = new IntegerField . IntegerDocument ( ) ; StyledEditorKit styledEditorKit0 = new StyledEditorKit ( ) ; MutableAttributeSet mutableAttributeSet0 = styledEditorKit0 . getInputAttributes ( ) ; integerField_IntegerDocument0 . insertString ( 60 , ( String ) null , ( AttributeSet ) mutableAttributeSet0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IntegerField ( ) { super ( ) ; }
void test0 ( ) throws Throwable { CharField charField0 = new CharField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" char getChar ( ) { String text = getText ( ) ; if ( text = = null | | text . length ( ) = = 0 ) { return ' ' ; } return text . charAt ( 0 ) ; }
void test1 ( ) throws Throwable { CharField charField0 = new CharField ( 'O' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test2 ( ) throws Throwable { CharField charField0 = new CharField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test3 ( ) throws Throwable { CharField charField0 = new CharField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" char getChar ( ) { String text = getText ( ) ; if ( text = = null | | text . length ( ) = = 0 ) { return ' ' ; } return text . charAt ( 0 ) ; }
void test4 ( ) throws Throwable { CharField . CharacterDocument charField_CharacterDocument0 = new CharField . CharacterDocument ( ) ; charField_CharacterDocument0 . insertString ( ( - 2045 ) , "" , ( AttributeSet ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getLength ( ) ; / * * * @return the starting text position * / int getStart ( ) ; / * * * @param position the position at which the status should be determined * @return whether the text between the start position and < em > position < / em > must be replaced * / boolean mustReplace ( int position ) ; }
void test0 ( ) throws Throwable { MemoryComboBox memoryComboBox0 = new MemoryComboBox ( ) ; memoryComboBox0 . addItem ( ( Object ) "SORTED" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addItem ( Object item ) { if ( item ! = null ) { removeItem ( item ) ; insertItemAt ( item , 0 ) ; setSelectedIndex ( 0 ) ; if ( _maxMemoryCount > NO_MAX & & getItemCount ( ) > _maxMemoryCount ) { removeItemAt ( getItemCount ( ) - 1 ) ; } } }
void test1 ( ) throws Throwable { MemoryComboBox memoryComboBox0 = new MemoryComboBox ( 0 ) ; memoryComboBox0 . addItem ( ( Object ) false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addItem ( Object item ) { if ( item ! = null ) { removeItem ( item ) ; insertItemAt ( item , 0 ) ; setSelectedIndex ( 0 ) ; if ( _maxMemoryCount > NO_MAX & & getItemCount ( ) > _maxMemoryCount ) { removeItemAt ( getItemCount ( ) - 1 ) ; } } }
void test2 ( ) throws Throwable { MemoryComboBox memoryComboBox0 = new MemoryComboBox ( 2 ) ; memoryComboBox0 . addItem ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addItem ( Object item ) { if ( item ! = null ) { removeItem ( item ) ; insertItemAt ( item , 0 ) ; setSelectedIndex ( 0 ) ; if ( _maxMemoryCount > NO_MAX & & getItemCount ( ) > _maxMemoryCount ) { removeItemAt ( getItemCount ( ) - 1 ) ; } } }
void test0 ( ) throws Throwable { SortableTable sortableTable0 = new SortableTable ( ( SortableTableModel ) null ) ; ButtonTableHeader buttonTableHeader0 = ( ButtonTableHeader ) sortableTable0 . getTableHeader ( ) ; DefaultTableColumnModel defaultTableColumnModel0 = ( DefaultTableColumnModel ) buttonTableHeader0 . getColumnModel ( ) ; SortableTable sortableTable1 = new SortableTable ( ( SortableTableModel ) null , ( TableColumnModel ) defaultTableColumnModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SortableTable ( TableModel model ) { super ( new SortableTableModel ( model ) ) ; init ( ) ; }
void test1 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; SortableTable sortableTable0 = new SortableTable ( ( TableModel ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SortableTable ( TableModel model ) { super ( new SortableTableModel ( model ) ) ; init ( ) ; }
void test2 ( ) throws Throwable { Object [ ] [ ] objectArray0 = new Object [ 8 ] [ 6 ] ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( objectArray0 , objectArray0 [ 0 ] ) ; DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel ( ) ; SortableTable sortableTable0 = new SortableTable ( ( TableModel ) defaultTableModel0 , ( TableColumnModel ) defaultTableColumnModel0 ) ; SortableTableModel sortableTableModel0 = sortableTable0 . getSortableTableModel ( ) ; sortableTable0 . setSortableTableModel ( sortableTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setSortableTableModel ( SortableTableModel model ) { super . setModel ( model ) ; }
void test0 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void dispose ( ) { Dimension size = getSize ( ) ; Preferences . userRoot ( ) . putInt ( PREF_KEY_NEW_SESSION_PROPS_SHEET_WIDTH , size . width ) ; Preferences . userRoot ( ) . putInt ( PREF_KEY_NEW_SESSION_PROPS_SHEET_HEIGHT , size . height ) ; ( getClass ( ) ) { s_instance = null ; } super . dispose ( ) ; }
void test1 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void show ( Component invoker , int x , int y ) { super . show ( invoker , x , y ) ; }
void test2 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void updateActions ( ) { boolean isEditable = _comp ! = null & & _comp . isEditable ( ) ; _cut . setEnabled ( isEditable ) ; _paste . setEnabled ( isEditable ) ; }
void test3 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isVisible ( ) ; / * * * Named with underline to avoid being automatically implemented by JInternalFrame . moveToFront ( ) in InternalFrameDelegate * / void _moveToFront ( ) ; void setDefaultCloseOperation ( int operation ) ; int getDefaultCloseOperation ( ) ; Container getContentPane ( ) ; void pack ( ) ; String getTitle ( ) ; void makeToolWindow ( boolean isToolWindow ) ; void _dispose ( ) ; void _setTitle ( String title ) ; void _updateUI ( ) ; void _setVisible ( boolean aFlag ) ; void _addNotify ( ) ; void centerWithinDesktop ( ) ; Container getAwtContainer ( ) ; void setContentPane ( JPanel contentPane ) ; void showOk ( String msg ) ; Dimension getSize ( ) ; void setSize ( Dimension size ) ; void addFocusListener ( FocusListener focusListener ) ; void removeFocusListener ( FocusListener focusListener ) ; void addVetoableChangeListener ( VetoableChangeListener vetoableChangeListener ) ; void removeVetoableChangeListener ( VetoableChangeListener vetoableChangeListener ) ; / * * * * @return Will be null when tabbed mode is used . * / JInternalFrame getInternalFrame ( ) ; void setBounds ( Rectangle rectangle ) ; Rectangle getBounds ( ) ; void setSelected ( boolean b ) throws PropertyVetoException ; void setLayer ( Integer layer ) ; void putClientProperty ( Object key , Object prop ) ; Object getClientProperty ( Object key ) ; void fireWidgetClosing ( ) ; void fireWidgetClosed ( ) ; void validate ( ) ; void setFrameIcon ( Icon icon ) ; void toFront ( ) ; void requestFocus ( ) ; void setMaximum ( boolean b ) throws PropertyVetoException ; void setBorder ( Border border ) ; void setPreferredSize ( Dimension dimension ) ; boolean isToolWindow ( ) ; boolean isClosed ( ) ; boolean isIcon ( ) ; }
void test4 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTextComponent getTextComponent ( ) { return _comp ; }
void test5 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setItemAction ( int optionType , Action action ) { if ( optionType < 0 | | optionType > IOptionTypes . LAST_ENTRY ) { throw new IllegalArgumentException ( "Invalid option type : " + optionType ) ; } if ( action = = null ) { throw new IllegalArgumentException ( "Action = = null" ) ; } int idx = getComponentIndex ( _menuItems [ optionType ] ) ; remove ( idx ) ; insert ( action , idx ) ; _menuItems [ optionType ] = ( JMenuItem ) getComponent ( idx ) ; }
void test6 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setItemAction ( int optionType , Action action ) { if ( optionType < 0 | | optionType > IOptionTypes . LAST_ENTRY ) { throw new IllegalArgumentException ( "Invalid option type : " + optionType ) ; } if ( action = = null ) { throw new IllegalArgumentException ( "Action = = null" ) ; } int idx = getComponentIndex ( _menuItems [ optionType ] ) ; remove ( idx ) ; insert ( action , idx ) ; _menuItems [ optionType ] = ( JMenuItem ) getComponent ( idx ) ; }
void test7 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setItemAction ( int optionType , Action action ) { if ( optionType < 0 | | optionType > IOptionTypes . LAST_ENTRY ) { throw new IllegalArgumentException ( "Invalid option type : " + optionType ) ; } if ( action = = null ) { throw new IllegalArgumentException ( "Action = = null" ) ; } int idx = getComponentIndex ( _menuItems [ optionType ] ) ; remove ( idx ) ; insert ( action , idx ) ; _menuItems [ optionType ] = ( JMenuItem ) getComponent ( idx ) ; }
void test8 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setItemAction ( int optionType , Action action ) { if ( optionType < 0 | | optionType > IOptionTypes . LAST_ENTRY ) { throw new IllegalArgumentException ( "Invalid option type : " + optionType ) ; } if ( action = = null ) { throw new IllegalArgumentException ( "Action = = null" ) ; } int idx = getComponentIndex ( _menuItems [ optionType ] ) ; remove ( idx ) ; insert ( action , idx ) ; _menuItems [ optionType ] = ( JMenuItem ) getComponent ( idx ) ; }
void test9 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void actionPerformed ( ActionEvent evt ) { IDatabaseObjectInfo [ ] catalogs = _tree . getSelectedDatabaseObjects ( ) ; if ( catalogs . length = = 1 ) { String catalog = catalogs [ 0 ] . getSimpleName ( ) ; try { new SetDefaultCatalogCommand ( _tree . getSession ( ) , catalog ) . execute ( ) ; } catch ( Throwable th ) { _tree . getSession ( ) . showErrorMessage ( th ) ; s_log . error ( "Error occured setting session catalog to " + catalog , th ) ; } } else { _tree . getSession ( ) . getApplication ( ) . showErrorDialog ( "Must select a single catalog" ) ; } / / IApplication app = getApplication ( ) ; / / CursorChanger cursorChg = new CursorChanger ( app . getMainFrame ( ) ) ; / / cursorChg . show ( ) ; / / try / / { / / new ShowNativeSQLCommand ( _session ) . execute ( ) ; / / } / / finally / / { / / cursorChg . restore ( ) ; / / } }
void test10 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void actionPerformed ( ActionEvent evt ) { IDatabaseObjectInfo [ ] catalogs = _tree . getSelectedDatabaseObjects ( ) ; if ( catalogs . length = = 1 ) { String catalog = catalogs [ 0 ] . getSimpleName ( ) ; try { new SetDefaultCatalogCommand ( _tree . getSession ( ) , catalog ) . execute ( ) ; } catch ( Throwable th ) { _tree . getSession ( ) . showErrorMessage ( th ) ; s_log . error ( "Error occured setting session catalog to " + catalog , th ) ; } } else { _tree . getSession ( ) . getApplication ( ) . showErrorDialog ( "Must select a single catalog" ) ; } / / IApplication app = getApplication ( ) ; / / CursorChanger cursorChg = new CursorChanger ( app . getMainFrame ( ) ) ; / / cursorChg . show ( ) ; / / try / / { / / new ShowNativeSQLCommand ( _session ) . execute ( ) ; / / } / / finally / / { / / cursorChg . restore ( ) ; / / } }
void test11 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void actionPerformed ( ActionEvent evt ) { IDatabaseObjectInfo [ ] catalogs = _tree . getSelectedDatabaseObjects ( ) ; if ( catalogs . length = = 1 ) { String catalog = catalogs [ 0 ] . getSimpleName ( ) ; try { new SetDefaultCatalogCommand ( _tree . getSession ( ) , catalog ) . execute ( ) ; } catch ( Throwable th ) { _tree . getSession ( ) . showErrorMessage ( th ) ; s_log . error ( "Error occured setting session catalog to " + catalog , th ) ; } } else { _tree . getSession ( ) . getApplication ( ) . showErrorDialog ( "Must select a single catalog" ) ; } / / IApplication app = getApplication ( ) ; / / CursorChanger cursorChg = new CursorChanger ( app . getMainFrame ( ) ) ; / / cursorChg . show ( ) ; / / try / / { / / new ShowNativeSQLCommand ( _session ) . execute ( ) ; / / } / / finally / / { / / cursorChg . restore ( ) ; / / } }
void test12 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void actionPerformed ( ActionEvent evt ) { IDatabaseObjectInfo [ ] catalogs = _tree . getSelectedDatabaseObjects ( ) ; if ( catalogs . length = = 1 ) { String catalog = catalogs [ 0 ] . getSimpleName ( ) ; try { new SetDefaultCatalogCommand ( _tree . getSession ( ) , catalog ) . execute ( ) ; } catch ( Throwable th ) { _tree . getSession ( ) . showErrorMessage ( th ) ; s_log . error ( "Error occured setting session catalog to " + catalog , th ) ; } } else { _tree . getSession ( ) . getApplication ( ) . showErrorDialog ( "Must select a single catalog" ) ; } / / IApplication app = getApplication ( ) ; / / CursorChanger cursorChg = new CursorChanger ( app . getMainFrame ( ) ) ; / / cursorChg . show ( ) ; / / try / / { / / new ShowNativeSQLCommand ( _session ) . execute ( ) ; / / } / / finally / / { / / cursorChg . restore ( ) ; / / } }
void test13 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void actionPerformed ( ActionEvent evt ) { IDatabaseObjectInfo [ ] catalogs = _tree . getSelectedDatabaseObjects ( ) ; if ( catalogs . length = = 1 ) { String catalog = catalogs [ 0 ] . getSimpleName ( ) ; try { new SetDefaultCatalogCommand ( _tree . getSession ( ) , catalog ) . execute ( ) ; } catch ( Throwable th ) { _tree . getSession ( ) . showErrorMessage ( th ) ; s_log . error ( "Error occured setting session catalog to " + catalog , th ) ; } } else { _tree . getSession ( ) . getApplication ( ) . showErrorDialog ( "Must select a single catalog" ) ; } / / IApplication app = getApplication ( ) ; / / CursorChanger cursorChg = new CursorChanger ( app . getMainFrame ( ) ) ; / / cursorChg . show ( ) ; / / try / / { / / new ShowNativeSQLCommand ( _session ) . execute ( ) ; / / } / / finally / / { / / cursorChg . restore ( ) ; / / } }
void test14 ( ) throws Throwable { TextPopupMenu textPopupMenu0 = new TextPopupMenu ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void actionPerformed ( ActionEvent evt ) { IDatabaseObjectInfo [ ] catalogs = _tree . getSelectedDatabaseObjects ( ) ; if ( catalogs . length = = 1 ) { String catalog = catalogs [ 0 ] . getSimpleName ( ) ; try { new SetDefaultCatalogCommand ( _tree . getSession ( ) , catalog ) . execute ( ) ; } catch ( Throwable th ) { _tree . getSession ( ) . showErrorMessage ( th ) ; s_log . error ( "Error occured setting session catalog to " + catalog , th ) ; } } else { _tree . getSession ( ) . getApplication ( ) . showErrorDialog ( "Must select a single catalog" ) ; } / / IApplication app = getApplication ( ) ; / / CursorChanger cursorChg = new CursorChanger ( app . getMainFrame ( ) ) ; / / cursorChg . show ( ) ; / / try / / { / / new ShowNativeSQLCommand ( _session ) . execute ( ) ; / / } / / finally / / { / / cursorChg . restore ( ) ; / / } }
void test0 ( ) throws Throwable { OutputLabel outputLabel0 = new OutputLabel ( "` ! ! av ( FZ3t + c" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getToolTipText ( MouseEvent event ) { JButton button = getButtonAt ( event . getX ( ) ) ; if ( null = = button ) { return super . getToolTipText ( event ) ; } else { return button . getToolTipText ( ) ; } }
void test1 ( ) throws Throwable { OutputLabel outputLabel0 = new OutputLabel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getToolTipText ( MouseEvent event ) { JButton button = getButtonAt ( event . getX ( ) ) ; if ( null = = button ) { return super . getToolTipText ( event ) ; } else { return button . getToolTipText ( ) ; } }
void test4 ( ) throws Throwable { Dialogs dialogs0 = new Dialogs ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { MultipleLineLabel multipleLineLabel0 = new MultipleLineLabel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test2 ( ) throws Throwable { DefaultDataModelImplementationDetails defaultDataModelImplementationDetails0 = new DefaultDataModelImplementationDetails ( ) ; DataSetViewerTablePanel dataSetViewerTablePanel0 = new DataSetViewerTablePanel ( ) ; Object [ ] objectArray0 = new Object [ 1 ] ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( objectArray0 , 0 ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 ) ; TablePopupMenu tablePopupMenu0 = new TablePopupMenu ( ( IDataSetUpdateableModel ) null , dataSetViewerTablePanel0 , jTable0 , ( IDataModelImplementationDetails ) defaultDataModelImplementationDetails0 ) ; tablePopupMenu0 . setTable ( jTable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { FontInfoBeanInfo fontInfoBeanInfo0 = new FontInfoBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = fontInfoBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { ModifiedDefaultListCellRenderer modifiedDefaultListCellRenderer0 = new ModifiedDefaultListCellRenderer ( ) ; JList jList0 = new JList ( ) ; ModifiedDefaultListCellRenderer modifiedDefaultListCellRenderer1 = ( ModifiedDefaultListCellRenderer ) modifiedDefaultListCellRenderer0 . getListCellRendererComponent ( jList0 , ( Object ) "java . awt . Point [ x = 1547 , y = 1547 ] " , 886 , true , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Component getListCellRendererComponent ( JList list , Object value , int index , boolean isSelected , boolean cellHasFocus ) { super . getListCellRendererComponent ( list , value , index , isSelected , cellHasFocus ) ; ISQLDriver drv = ( ISQLDriver ) value ; if ( drv = = null | | ! drv . isJDBCDriverClassLoaded ( ) ) { setIcon ( FAIL_ICON ) ; } else { setIcon ( OK_ICON ) ; } return this ; }
void test0 ( ) throws Throwable { ClassPathListModel classPathListModel0 = new ClassPathListModel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test0 ( ) throws Throwable { ChooserPreviewer chooserPreviewer0 = new ChooserPreviewer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { ChooserPreviewer chooserPreviewer0 = new ChooserPreviewer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { ChooserPreviewer chooserPreviewer0 = new ChooserPreviewer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { ChooserPreviewer chooserPreviewer0 = new ChooserPreviewer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { JInternalFrame jInternalFrame0 = new JInternalFrame ( "" , false ) ; GUIUtils . moveToFront ( jInternalFrame0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isVisible ( ) ; / * * * Named with underline to avoid being automatically implemented by JInternalFrame . moveToFront ( ) in InternalFrameDelegate * / void _moveToFront ( ) ; void setDefaultCloseOperation ( int operation ) ; int getDefaultCloseOperation ( ) ; Container getContentPane ( ) ; void pack ( ) ; String getTitle ( ) ; void makeToolWindow ( boolean isToolWindow ) ; void _dispose ( ) ; void _setTitle ( String title ) ; void _updateUI ( ) ; void _setVisible ( boolean aFlag ) ; void _addNotify ( ) ; void centerWithinDesktop ( ) ; Container getAwtContainer ( ) ; void setContentPane ( JPanel contentPane ) ; void showOk ( String msg ) ; Dimension getSize ( ) ; void setSize ( Dimension size ) ; void addFocusListener ( FocusListener focusListener ) ; void removeFocusListener ( FocusListener focusListener ) ; void addVetoableChangeListener ( VetoableChangeListener vetoableChangeListener ) ; void removeVetoableChangeListener ( VetoableChangeListener vetoableChangeListener ) ; / * * * * @return Will be null when tabbed mode is used . * / JInternalFrame getInternalFrame ( ) ; void setBounds ( Rectangle rectangle ) ; Rectangle getBounds ( ) ; void setSelected ( boolean b ) throws PropertyVetoException ; void setLayer ( Integer layer ) ; void putClientProperty ( Object key , Object prop ) ; Object getClientProperty ( Object key ) ; void fireWidgetClosing ( ) ; void fireWidgetClosed ( ) ; void validate ( ) ; void setFrameIcon ( Icon icon ) ; void toFront ( ) ; void requestFocus ( ) ; void setMaximum ( boolean b ) throws PropertyVetoException ; void setBorder ( Border border ) ; void setPreferredSize ( Dimension dimension ) ; boolean isToolWindow ( ) ; boolean isClosed ( ) ; boolean isIcon ( ) ; }
void test3 ( ) throws Throwable { GUIUtils gUIUtils0 = new GUIUtils ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test4 ( ) throws Throwable { JFrame jFrame0 = GUIUtils . getMainFrame ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" MainFrame getMainFrame ( ) ; / * * * Return the thread pool for this app . * * @return the thread pool for this app . * / TaskThreadPool getThreadPool ( ) ; / * * * Return the collection of < TT > FontInfo < / TT > objects for this app . * * @return the collection of < TT > FontInfo < / TT > objects for this app . * / FontInfoStore getFontInfoStore ( ) ; / * * * Return the factory object used to create the SQL entry panel . * * @return the factory object used to create the SQL entry panel . * / ISQLEntryPanelFactory getSQLEntryPanelFactory ( ) ; / * * * Retrieve the application level SQL History object . * * @return the application level SQL History object . * / SQLHistory getSQLHistory ( ) ; / * * * Set the factory object used to create the SQL entry panel . * * @param factory the factory object used to create the SQL entry panel . * / void setSQLEntryPanelFactory ( ISQLEntryPanelFactory factory ) ; / * * * Add a hierarchical menu to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param menu The menu that will be added . * / void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test6 ( ) throws Throwable { JInternalFrame jInternalFrame0 = new JInternalFrame ( "" , false ) ; GUIUtils . centerWithinDesktop ( jInternalFrame0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isVisible ( ) ; / * * * Named with underline to avoid being automatically implemented by JInternalFrame . moveToFront ( ) in InternalFrameDelegate * / void _moveToFront ( ) ; void setDefaultCloseOperation ( int operation ) ; int getDefaultCloseOperation ( ) ; Container getContentPane ( ) ; void pack ( ) ; String getTitle ( ) ; void makeToolWindow ( boolean isToolWindow ) ; void _dispose ( ) ; void _setTitle ( String title ) ; void _updateUI ( ) ; void _setVisible ( boolean aFlag ) ; void _addNotify ( ) ; void centerWithinDesktop ( ) ; Container getAwtContainer ( ) ; void setContentPane ( JPanel contentPane ) ; void showOk ( String msg ) ; Dimension getSize ( ) ; void setSize ( Dimension size ) ; void addFocusListener ( FocusListener focusListener ) ; void removeFocusListener ( FocusListener focusListener ) ; void addVetoableChangeListener ( VetoableChangeListener vetoableChangeListener ) ; void removeVetoableChangeListener ( VetoableChangeListener vetoableChangeListener ) ; / * * * * @return Will be null when tabbed mode is used . * / JInternalFrame getInternalFrame ( ) ; void setBounds ( Rectangle rectangle ) ; Rectangle getBounds ( ) ; void setSelected ( boolean b ) throws PropertyVetoException ; void setLayer ( Integer layer ) ; void putClientProperty ( Object key , Object prop ) ; Object getClientProperty ( Object key ) ; void fireWidgetClosing ( ) ; void fireWidgetClosed ( ) ; void validate ( ) ; void setFrameIcon ( Icon icon ) ; void toFront ( ) ; void requestFocus ( ) ; void setMaximum ( boolean b ) throws PropertyVetoException ; void setBorder ( Border border ) ; void setPreferredSize ( Dimension dimension ) ; boolean isToolWindow ( ) ; boolean isClosed ( ) ; boolean isIcon ( ) ; }
void test11 ( ) throws Throwable { JInternalFrame jInternalFrame0 = new JInternalFrame ( "\"#mV : #RReauLwVo" , true ) ; boolean boolean0 = GUIUtils . isToolWindow ( jInternalFrame0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isToolWindow ( ) { return _isToolWindow ; }
void test13 ( ) throws Throwable { JInternalFrame jInternalFrame0 = new JInternalFrame ( "\"#mV : #RReauLwVo" , true ) ; GUIUtils . makeToolWindow ( jInternalFrame0 , false ) ; boolean boolean0 = GUIUtils . isToolWindow ( jInternalFrame0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isToolWindow ( ) { return _isToolWindow ; }
void test14 ( ) throws Throwable { JInternalFrame jInternalFrame0 = new JInternalFrame ( "\"#mV : #RReauLwVo" , true ) ; GUIUtils . makeToolWindow ( jInternalFrame0 , true ) ; boolean boolean0 = GUIUtils . isToolWindow ( jInternalFrame0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isToolWindow ( ) { return _isToolWindow ; }
void test20 ( ) throws Throwable { DefaultListCellRenderer defaultListCellRenderer0 = new DefaultListCellRenderer ( ) ; DefaultFormatterFactory defaultFormatterFactory0 = new DefaultFormatterFactory ( ) ; JFormattedTextField jFormattedTextField0 = new JFormattedTextField ( ( JFormattedTextField . AbstractFormatterFactory ) defaultFormatterFactory0 ) ; JFormattedTextField jFormattedTextField1 = ( JFormattedTextField ) defaultListCellRenderer0 . add ( "\"\n" , ( Component ) jFormattedTextField0 ) ; boolean boolean0 = GUIUtils . isWithinParent ( ( Component ) jFormattedTextField1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isWithinParent ( Component wind ) { if ( wind = = null ) { throw new IllegalArgumentException ( "Null Component passed" ) ; } Rectangle windowBounds = wind . getBounds ( ) ; Component parent = wind . getParent ( ) ; Rectangle parentRect = null ; if ( parent ! = null ) { parentRect = new Rectangle ( parent . getSize ( ) ) ; } else { / / parentRect = new Rectangle ( Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ) ; parentRect = getScreenBoundsFor ( windowBounds ) ; } / / if ( windowBounds . x > ( parentRect . width - 20 ) / / | | windowBounds . y > ( parentRect . height - 20 ) / / | | ( windowBounds . x + windowBounds . width ) < 20 / / | | ( windowBounds . y + windowBounds . height ) < 20 ) / / { / / return false ; / / } if ( windowBounds . x < ( parentRect . x - 20 ) | | windowBounds . y < ( parentRect . y - 20 ) ) { return false ; } return true ; }
void test22 ( ) throws Throwable { String string0 = GUIUtils . getWrappedLine ( "~B ) r : H ( " , 376 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWrappedLine ( String line , int lineLength ) { if ( line . length ( ) < = lineLength ) { return line ; } StringBuffer result = new StringBuffer ( ) ; char [ ] lineChars = line . toCharArray ( ) ; int lastBreakCharIdx = - 1 ; ArrayList < Integer > breakPoints = new ArrayList < Integer > ( ) ; / / look for places to break the string for ( int i = 0 ; i < lineChars . length ; i + + ) { char curr = lineChars [ i ] ; if ( curr = = ' ' | | curr = = ' , ' ) { lastBreakCharIdx = i ; } if ( i > 0 & & ( i % lineLength = = 0 ) & & lastBreakCharIdx ! = - 1 ) { breakPoints . add ( Integer . valueOf ( lastBreakCharIdx ) ) ; } } if ( lastBreakCharIdx ! = lineChars . length ) { breakPoints . add ( Integer . valueOf ( lineChars . length ) ) ; } int lastBreakPointIdx = 0 ; for ( Iterator < Integer > iter = breakPoints . iterator ( ) ; iter . hasNext ( ) ; ) { int breakPointIdx = ( iter . next ( ) ) . intValue ( ) + 1 ; if ( breakPointIdx > line . length ( ) ) { breakPointIdx = line . length ( ) ; } String part = line . substring ( lastBreakPointIdx , breakPointIdx ) ; result . append ( part . trim ( ) ) ; if ( ! part . trim ( ) . endsWith ( "\\n" ) ) { result . append ( "\n" ) ; } lastBreakPointIdx = breakPointIdx ; } return result . toString ( ) ; }
void test23 ( ) throws Throwable { String string0 = GUIUtils . getWrappedLine ( " , PR - R^ ] CEbU`P" , ( - 6 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWrappedLine ( String line , int lineLength ) { if ( line . length ( ) < = lineLength ) { return line ; } StringBuffer result = new StringBuffer ( ) ; char [ ] lineChars = line . toCharArray ( ) ; int lastBreakCharIdx = - 1 ; ArrayList < Integer > breakPoints = new ArrayList < Integer > ( ) ; / / look for places to break the string for ( int i = 0 ; i < lineChars . length ; i + + ) { char curr = lineChars [ i ] ; if ( curr = = ' ' | | curr = = ' , ' ) { lastBreakCharIdx = i ; } if ( i > 0 & & ( i % lineLength = = 0 ) & & lastBreakCharIdx ! = - 1 ) { breakPoints . add ( Integer . valueOf ( lastBreakCharIdx ) ) ; } } if ( lastBreakCharIdx ! = lineChars . length ) { breakPoints . add ( Integer . valueOf ( lineChars . length ) ) ; } int lastBreakPointIdx = 0 ; for ( Iterator < Integer > iter = breakPoints . iterator ( ) ; iter . hasNext ( ) ; ) { int breakPointIdx = ( iter . next ( ) ) . intValue ( ) + 1 ; if ( breakPointIdx > line . length ( ) ) { breakPointIdx = line . length ( ) ; } String part = line . substring ( lastBreakPointIdx , breakPointIdx ) ; result . append ( part . trim ( ) ) ; if ( ! part . trim ( ) . endsWith ( "\\n" ) ) { result . append ( "\n" ) ; } lastBreakPointIdx = breakPointIdx ; } return result . toString ( ) ; }
void test24 ( ) throws Throwable { String string0 = GUIUtils . getWrappedLine ( "~B ) r : H ( " , ( - 305 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWrappedLine ( String line , int lineLength ) { if ( line . length ( ) < = lineLength ) { return line ; } StringBuffer result = new StringBuffer ( ) ; char [ ] lineChars = line . toCharArray ( ) ; int lastBreakCharIdx = - 1 ; ArrayList < Integer > breakPoints = new ArrayList < Integer > ( ) ; / / look for places to break the string for ( int i = 0 ; i < lineChars . length ; i + + ) { char curr = lineChars [ i ] ; if ( curr = = ' ' | | curr = = ' , ' ) { lastBreakCharIdx = i ; } if ( i > 0 & & ( i % lineLength = = 0 ) & & lastBreakCharIdx ! = - 1 ) { breakPoints . add ( Integer . valueOf ( lastBreakCharIdx ) ) ; } } if ( lastBreakCharIdx ! = lineChars . length ) { breakPoints . add ( Integer . valueOf ( lineChars . length ) ) ; } int lastBreakPointIdx = 0 ; for ( Iterator < Integer > iter = breakPoints . iterator ( ) ; iter . hasNext ( ) ; ) { int breakPointIdx = ( iter . next ( ) ) . intValue ( ) + 1 ; if ( breakPointIdx > line . length ( ) ) { breakPointIdx = line . length ( ) ; } String part = line . substring ( lastBreakPointIdx , breakPointIdx ) ; result . append ( part . trim ( ) ) ; if ( ! part . trim ( ) . endsWith ( "\\n" ) ) { result . append ( "\n" ) ; } lastBreakPointIdx = breakPointIdx ; } return result . toString ( ) ; }
void test25 ( ) throws Throwable { String string0 = GUIUtils . getWrappedLine ( "Q~YK" , ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWrappedLine ( String line , int lineLength ) { if ( line . length ( ) < = lineLength ) { return line ; } StringBuffer result = new StringBuffer ( ) ; char [ ] lineChars = line . toCharArray ( ) ; int lastBreakCharIdx = - 1 ; ArrayList < Integer > breakPoints = new ArrayList < Integer > ( ) ; / / look for places to break the string for ( int i = 0 ; i < lineChars . length ; i + + ) { char curr = lineChars [ i ] ; if ( curr = = ' ' | | curr = = ' , ' ) { lastBreakCharIdx = i ; } if ( i > 0 & & ( i % lineLength = = 0 ) & & lastBreakCharIdx ! = - 1 ) { breakPoints . add ( Integer . valueOf ( lastBreakCharIdx ) ) ; } } if ( lastBreakCharIdx ! = lineChars . length ) { breakPoints . add ( Integer . valueOf ( lineChars . length ) ) ; } int lastBreakPointIdx = 0 ; for ( Iterator < Integer > iter = breakPoints . iterator ( ) ; iter . hasNext ( ) ; ) { int breakPointIdx = ( iter . next ( ) ) . intValue ( ) + 1 ; if ( breakPointIdx > line . length ( ) ) { breakPointIdx = line . length ( ) ; } String part = line . substring ( lastBreakPointIdx , breakPointIdx ) ; result . append ( part . trim ( ) ) ; if ( ! part . trim ( ) . endsWith ( "\\n" ) ) { result . append ( "\n" ) ; } lastBreakPointIdx = breakPointIdx ; } return result . toString ( ) ; }
void test0 ( ) throws Throwable { DirectoryListComboBox directoryListComboBox0 = new DirectoryListComboBox ( ) ; directoryListComboBox0 . load ( ( File ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void load ( IApplication app ) throws PluginException ; / * * * Called on application startup after application started . * / void initialize ( ) throws PluginException ; / * * * Called when app shutdown . * TODO : Put throws clause back in * / void unload ( ) ; / / throws PluginException ; / * * * Returns the name by which this plugin is uniquely identified . * * @return the name by which this plugin is uniquely identified . * / String getInternalName ( ) ; / * * * Returns the descriptive name for this plugin . * * @return the descriptive name for this plugin . * / String getDescriptiveName ( ) ; / * * * Returns the authors name . * * @return the authors name . * / String getAuthor ( ) ; / * * * Returns a comma separated list of other contributors . * * @return Contributors names . * / String getContributors ( ) ; / * * * Returns the home page for this plugin . * * @return the home page for this plugin . * / String getWebSite ( ) ; / * * * Returns the current version of this plugin . * * @return the current version of this plugin . * / String getVersion ( ) ; / * * * Returns the name of the Help file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the Help file name or < TT > null < / TT > if plugin doesn't have * a help file . * / String getHelpFileName ( ) ; / * * * Returns the name of the change log for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the changelog file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getChangeLogFileName ( ) ; / * * * Returns the name of the licence file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the licence file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getLicenceFileName ( ) ; / * * * Create panels for the Global Preferences dialog . * * @return Array of < TT > IGlobalPreferencesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the Global Preferences Dialog . * / IGlobalPreferencesPanel [ ] getGlobalPreferencePanels ( ) ; / * * * Creates Alias Prefs Controllers for this Plugin . * / IAliasPropertiesPanelController [ ] getAliasPropertiesPanelControllers ( SQLAlias alias ) ; / * * * Called when an Alias is copied . Should be overridden by Plugins * that work with Alias properties . * / void aliasCopied ( SQLAlias source , SQLAlias target ) ; / * * * Called when an Alias is removed . Should be overridden by Plugins * that work with Alias properties . * / void aliasRemoved ( SQLAlias alias ) ; / * * * Create panels for the New Session Properties dialog . * * @return Array of < TT > INewSessionPropertiesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the New Session Properties Dialog . * / INewSessionPropertiesPanel [ ] getNewSessionPropertiesPanels ( ) ; / * * * Return the folder with the Squirrel application folder * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; squirrel_app & gt ; / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins application folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginAppSettingsFolder ( ) throws IOException , IllegalStateException ; / * * * Return the folder with the users home directory * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; user_home & gt ; / . squirrel - sql / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins user folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginUserSettingsFolder ( ) throws IllegalStateException , IOException ; / * * * Allows a plugin to provide services to other plugins . * @see PluginManager . bindExternalPluginService ( ) ; * / Object getExternalService ( ) ; / * * * Returns the absolute path to the plugin jar file . * * @return the absolute path to the plugin jar file . * * @throws IllegalStateException if this plugin doesn't have a valid internal name . * / String getPluginJarFilePath ( ) throws IllegalStateException ; / * * * @param applicationFiles the applicationFiles to set * / void setApplicationFiles ( ApplicationFileWrappers applicationFiles ) ; / * * * @param fileWrapperFactory the fileWrapperFactory to set * / void setFileWrapperFactory ( FileWrapperFactory fileWrapperFactory ) ; }
void test1 ( ) throws Throwable { DirectoryListComboBox directoryListComboBox0 = new DirectoryListComboBox ( ) ; File file0 = new File ( "" , "" ) ; directoryListComboBox0 . load ( file0 , ( FilenameFilter ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { DirectoryListComboBox directoryListComboBox0 = new DirectoryListComboBox ( ) ; File file0 = new File ( "1 & : 7R'Eg ) 8ZM" ) ; FilesystemFilter filesystemFilter0 = new FilesystemFilter ( "1 & : 7R'Eg ) 8ZM" , "1 & : 7R'Eg ) 8ZM" , false ) ; directoryListComboBox0 . load ( file0 , ( FilenameFilter ) filesystemFilter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void load ( IApplication app ) throws PluginException ; / * * * Called on application startup after application started . * / void initialize ( ) throws PluginException ; / * * * Called when app shutdown . * TODO : Put throws clause back in * / void unload ( ) ; / / throws PluginException ; / * * * Returns the name by which this plugin is uniquely identified . * * @return the name by which this plugin is uniquely identified . * / String getInternalName ( ) ; / * * * Returns the descriptive name for this plugin . * * @return the descriptive name for this plugin . * / String getDescriptiveName ( ) ; / * * * Returns the authors name . * * @return the authors name . * / String getAuthor ( ) ; / * * * Returns a comma separated list of other contributors . * * @return Contributors names . * / String getContributors ( ) ; / * * * Returns the home page for this plugin . * * @return the home page for this plugin . * / String getWebSite ( ) ; / * * * Returns the current version of this plugin . * * @return the current version of this plugin . * / String getVersion ( ) ; / * * * Returns the name of the Help file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the Help file name or < TT > null < / TT > if plugin doesn't have * a help file . * / String getHelpFileName ( ) ; / * * * Returns the name of the change log for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the changelog file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getChangeLogFileName ( ) ; / * * * Returns the name of the licence file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the licence file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getLicenceFileName ( ) ; / * * * Create panels for the Global Preferences dialog . * * @return Array of < TT > IGlobalPreferencesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the Global Preferences Dialog . * / IGlobalPreferencesPanel [ ] getGlobalPreferencePanels ( ) ; / * * * Creates Alias Prefs Controllers for this Plugin . * / IAliasPropertiesPanelController [ ] getAliasPropertiesPanelControllers ( SQLAlias alias ) ; / * * * Called when an Alias is copied . Should be overridden by Plugins * that work with Alias properties . * / void aliasCopied ( SQLAlias source , SQLAlias target ) ; / * * * Called when an Alias is removed . Should be overridden by Plugins * that work with Alias properties . * / void aliasRemoved ( SQLAlias alias ) ; / * * * Create panels for the New Session Properties dialog . * * @return Array of < TT > INewSessionPropertiesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the New Session Properties Dialog . * / INewSessionPropertiesPanel [ ] getNewSessionPropertiesPanels ( ) ; / * * * Return the folder with the Squirrel application folder * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; squirrel_app & gt ; / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins application folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginAppSettingsFolder ( ) throws IOException , IllegalStateException ; / * * * Return the folder with the users home directory * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; user_home & gt ; / . squirrel - sql / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins user folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginUserSettingsFolder ( ) throws IllegalStateException , IOException ; / * * * Allows a plugin to provide services to other plugins . * @see PluginManager . bindExternalPluginService ( ) ; * / Object getExternalService ( ) ; / * * * Returns the absolute path to the plugin jar file . * * @return the absolute path to the plugin jar file . * * @throws IllegalStateException if this plugin doesn't have a valid internal name . * / String getPluginJarFilePath ( ) throws IllegalStateException ; / * * * @param applicationFiles the applicationFiles to set * / void setApplicationFiles ( ApplicationFileWrappers applicationFiles ) ; / * * * @param fileWrapperFactory the fileWrapperFactory to set * / void setFileWrapperFactory ( FileWrapperFactory fileWrapperFactory ) ; }
void test3 ( ) throws Throwable { DirectoryListComboBox directoryListComboBox0 = new DirectoryListComboBox ( ) ; File file0 = new File ( "" , "" ) ; FilesystemFilter filesystemFilter0 = new FilesystemFilter ( "" , "" , false ) ; directoryListComboBox0 . load ( file0 , ( FilenameFilter ) filesystemFilter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void load ( IApplication app ) throws PluginException ; / * * * Called on application startup after application started . * / void initialize ( ) throws PluginException ; / * * * Called when app shutdown . * TODO : Put throws clause back in * / void unload ( ) ; / / throws PluginException ; / * * * Returns the name by which this plugin is uniquely identified . * * @return the name by which this plugin is uniquely identified . * / String getInternalName ( ) ; / * * * Returns the descriptive name for this plugin . * * @return the descriptive name for this plugin . * / String getDescriptiveName ( ) ; / * * * Returns the authors name . * * @return the authors name . * / String getAuthor ( ) ; / * * * Returns a comma separated list of other contributors . * * @return Contributors names . * / String getContributors ( ) ; / * * * Returns the home page for this plugin . * * @return the home page for this plugin . * / String getWebSite ( ) ; / * * * Returns the current version of this plugin . * * @return the current version of this plugin . * / String getVersion ( ) ; / * * * Returns the name of the Help file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the Help file name or < TT > null < / TT > if plugin doesn't have * a help file . * / String getHelpFileName ( ) ; / * * * Returns the name of the change log for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the changelog file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getChangeLogFileName ( ) ; / * * * Returns the name of the licence file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the licence file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getLicenceFileName ( ) ; / * * * Create panels for the Global Preferences dialog . * * @return Array of < TT > IGlobalPreferencesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the Global Preferences Dialog . * / IGlobalPreferencesPanel [ ] getGlobalPreferencePanels ( ) ; / * * * Creates Alias Prefs Controllers for this Plugin . * / IAliasPropertiesPanelController [ ] getAliasPropertiesPanelControllers ( SQLAlias alias ) ; / * * * Called when an Alias is copied . Should be overridden by Plugins * that work with Alias properties . * / void aliasCopied ( SQLAlias source , SQLAlias target ) ; / * * * Called when an Alias is removed . Should be overridden by Plugins * that work with Alias properties . * / void aliasRemoved ( SQLAlias alias ) ; / * * * Create panels for the New Session Properties dialog . * * @return Array of < TT > INewSessionPropertiesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the New Session Properties Dialog . * / INewSessionPropertiesPanel [ ] getNewSessionPropertiesPanels ( ) ; / * * * Return the folder with the Squirrel application folder * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; squirrel_app & gt ; / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins application folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginAppSettingsFolder ( ) throws IOException , IllegalStateException ; / * * * Return the folder with the users home directory * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; user_home & gt ; / . squirrel - sql / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins user folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginUserSettingsFolder ( ) throws IllegalStateException , IOException ; / * * * Allows a plugin to provide services to other plugins . * @see PluginManager . bindExternalPluginService ( ) ; * / Object getExternalService ( ) ; / * * * Returns the absolute path to the plugin jar file . * * @return the absolute path to the plugin jar file . * * @throws IllegalStateException if this plugin doesn't have a valid internal name . * / String getPluginJarFilePath ( ) throws IllegalStateException ; / * * * @param applicationFiles the applicationFiles to set * / void setApplicationFiles ( ApplicationFileWrappers applicationFiles ) ; / * * * @param fileWrapperFactory the fileWrapperFactory to set * / void setFileWrapperFactory ( FileWrapperFactory fileWrapperFactory ) ; }
void test0 ( ) throws Throwable { SortedComboBoxModel sortedComboBoxModel0 = new SortedComboBoxModel ( ) ; sortedComboBoxModel0 . insertElementAt ( 0 , ( Object ) "left" ) ; int int0 = sortedComboBoxModel0 . getIndexInList ( ( Object ) "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test1 ( ) throws Throwable { SortedComboBoxModel sortedComboBoxModel0 = new SortedComboBoxModel ( ) ; sortedComboBoxModel0 . insertElementAt ( 0 , ( Object ) "left" ) ; sortedComboBoxModel0 . insertElementAt ( ( - 1155 ) , ( Object ) "optionType" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test0 ( ) throws Throwable { WindowState windowState0 = new WindowState ( ( Window ) null ) ; windowState0 . aboutToBeWritten ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isVisible ( ) ; / * * * Named with underline to avoid being automatically implemented by JInternalFrame . moveToFront ( ) in InternalFrameDelegate * / void _moveToFront ( ) ; void setDefaultCloseOperation ( int operation ) ; int getDefaultCloseOperation ( ) ; Container getContentPane ( ) ; void pack ( ) ; String getTitle ( ) ; void makeToolWindow ( boolean isToolWindow ) ; void _dispose ( ) ; void _setTitle ( String title ) ; void _updateUI ( ) ; void _setVisible ( boolean aFlag ) ; void _addNotify ( ) ; void centerWithinDesktop ( ) ; Container getAwtContainer ( ) ; void setContentPane ( JPanel contentPane ) ; void showOk ( String msg ) ; Dimension getSize ( ) ; void setSize ( Dimension size ) ; void addFocusListener ( FocusListener focusListener ) ; void removeFocusListener ( FocusListener focusListener ) ; void addVetoableChangeListener ( VetoableChangeListener vetoableChangeListener ) ; void removeVetoableChangeListener ( VetoableChangeListener vetoableChangeListener ) ; / * * * * @return Will be null when tabbed mode is used . * / JInternalFrame getInternalFrame ( ) ; void setBounds ( Rectangle rectangle ) ; Rectangle getBounds ( ) ; void setSelected ( boolean b ) throws PropertyVetoException ; void setLayer ( Integer layer ) ; void putClientProperty ( Object key , Object prop ) ; Object getClientProperty ( Object key ) ; void fireWidgetClosing ( ) ; void fireWidgetClosed ( ) ; void validate ( ) ; void setFrameIcon ( Icon icon ) ; void toFront ( ) ; void requestFocus ( ) ; void setMaximum ( boolean b ) throws PropertyVetoException ; void setBorder ( Border border ) ; void setPreferredSize ( Dimension dimension ) ; boolean isToolWindow ( ) ; boolean isClosed ( ) ; boolean isIcon ( ) ; }
void test1 ( ) throws Throwable { WindowState windowState0 = new WindowState ( ) ; windowState0 . copyFrom ( windowState0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFrameExtendedState ( ) { refresh ( ) ; return _frameExtendedState ; }
void test2 ( ) throws Throwable { WindowState windowState0 = new WindowState ( ( Frame ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFrameExtendedState ( ) { refresh ( ) ; return _frameExtendedState ; }
void test4 ( ) throws Throwable { WindowState windowState0 = new WindowState ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isVisible ( ) ; / * * * Named with underline to avoid being automatically implemented by JInternalFrame . moveToFront ( ) in InternalFrameDelegate * / void _moveToFront ( ) ; void setDefaultCloseOperation ( int operation ) ; int getDefaultCloseOperation ( ) ; Container getContentPane ( ) ; void pack ( ) ; String getTitle ( ) ; void makeToolWindow ( boolean isToolWindow ) ; void _dispose ( ) ; void _setTitle ( String title ) ; void _updateUI ( ) ; void _setVisible ( boolean aFlag ) ; void _addNotify ( ) ; void centerWithinDesktop ( ) ; Container getAwtContainer ( ) ; void setContentPane ( JPanel contentPane ) ; void showOk ( String msg ) ; Dimension getSize ( ) ; void setSize ( Dimension size ) ; void addFocusListener ( FocusListener focusListener ) ; void removeFocusListener ( FocusListener focusListener ) ; void addVetoableChangeListener ( VetoableChangeListener vetoableChangeListener ) ; void removeVetoableChangeListener ( VetoableChangeListener vetoableChangeListener ) ; / * * * * @return Will be null when tabbed mode is used . * / JInternalFrame getInternalFrame ( ) ; void setBounds ( Rectangle rectangle ) ; Rectangle getBounds ( ) ; void setSelected ( boolean b ) throws PropertyVetoException ; void setLayer ( Integer layer ) ; void putClientProperty ( Object key , Object prop ) ; Object getClientProperty ( Object key ) ; void fireWidgetClosing ( ) ; void fireWidgetClosed ( ) ; void validate ( ) ; void setFrameIcon ( Icon icon ) ; void toFront ( ) ; void requestFocus ( ) ; void setMaximum ( boolean b ) throws PropertyVetoException ; void setBorder ( Border border ) ; void setPreferredSize ( Dimension dimension ) ; boolean isToolWindow ( ) ; boolean isClosed ( ) ; boolean isIcon ( ) ; }
void test0 ( ) throws Throwable { DefaultFileListBoxModel defaultFileListBoxModel0 = new DefaultFileListBoxModel ( ) ; FileListBox fileListBox0 = new FileListBox ( ( IFileListBoxModel ) defaultFileListBoxModel0 ) ; File file0 = fileListBox0 . getSelectedFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" File getSelectedFile ( ) { return ( File ) getSelectedValue ( ) ; }
void test1 ( ) throws Throwable { FileListBox fileListBox0 = new FileListBox ( ) ; ClassPathListModel classPathListModel0 = ( ClassPathListModel ) fileListBox0 . getTypedModel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test1 ( ) throws Throwable { SQLCatalogsComboBox sQLCatalogsComboBox0 = new SQLCatalogsComboBox ( ) ; String [ ] stringArray0 = new String [ 9 ] ; stringArray0 [ 3 ] = "Xt0Ym ] U1 > L#" ; sQLCatalogsComboBox0 . setCatalogs ( stringArray0 , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { SQLCatalogsComboBox sQLCatalogsComboBox0 = new SQLCatalogsComboBox ( ) ; String [ ] stringArray0 = new String [ 1 ] ; sQLCatalogsComboBox0 . setCatalogs ( stringArray0 , "reshore" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSelectedCatalog ( ) { return ( String ) _catalogsCmb . getSelectedItem ( ) ; }
void test3 ( ) throws Throwable { SQLCatalogsComboBox sQLCatalogsComboBox0 = new SQLCatalogsComboBox ( ) ; String [ ] stringArray0 = new String [ 9 ] ; stringArray0 [ 6 ] = "" ; sQLCatalogsComboBox0 . setCatalogs ( stringArray0 , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test4 ( ) throws Throwable { SQLCatalogsComboBox sQLCatalogsComboBox0 = new SQLCatalogsComboBox ( ) ; sQLCatalogsComboBox0 . setSelectedCatalog ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setSelectedCatalog ( String selectedCatalog ) { if ( selectedCatalog ! = null ) { getModel ( ) . setSelectedItem ( selectedCatalog ) ; } }
void test5 ( ) throws Throwable { SQLCatalogsComboBox sQLCatalogsComboBox0 = new SQLCatalogsComboBox ( ) ; sQLCatalogsComboBox0 . setSelectedItem ( ( Object ) "FormattedTextFieldUI" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setSelectedItem ( Object object ) { _selectedObject = object ; fireContentsChanged ( this , - 1 , - 1 ) ; }
void test0 ( ) throws Throwable { TimePanel timePanel0 = new TimePanel ( ) ; ActionEvent actionEvent0 = new ActionEvent ( ( Object ) timePanel0 , 212 , ( String ) null ) ; timePanel0 . actionPerformed ( actionEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { TimePanel timePanel0 = new TimePanel ( ) ; timePanel0 . addNotify ( ) ; timePanel0 . removeNotify ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void removeNotify ( ) { super . removeNotify ( ) ; if ( _propsListener ! = null ) { _session . getProperties ( ) . removePropertyChangeListener ( _propsListener ) ; _propsListener = null ; } }
void test2 ( ) throws Throwable { TimePanel timePanel0 = new TimePanel ( ) ; timePanel0 . removeNotify ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void removeNotify ( ) { super . removeNotify ( ) ; if ( _propsListener ! = null ) { _session . getProperties ( ) . removePropertyChangeListener ( _propsListener ) ; _propsListener = null ; } }
void test3 ( ) throws Throwable { TimePanel timePanel0 = new TimePanel ( ) ; Dimension dimension0 = timePanel0 . getPreferredSize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test4 ( ) throws Throwable { TimePanel timePanel0 = new TimePanel ( ) ; JDesktopPane jDesktopPane0 = new JDesktopPane ( ) ; Insets insets0 = jDesktopPane0 . getInsets ( ( Insets ) null ) ; Color color0 = Color . YELLOW ; MatteBorder matteBorder0 = new MatteBorder ( insets0 , color0 ) ; timePanel0 . setBorder ( ( Border ) matteBorder0 ) ; Dimension dimension0 = timePanel0 . getPreferredSize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { CascadeInternalFramePositioner cascadeInternalFramePositioner0 = new CascadeInternalFramePositioner ( ) ; JOptionPane jOptionPane0 = new JOptionPane ( ) ; Object [ ] objectArray0 = new Object [ 10 ] ; JComboBox jComboBox0 = new JComboBox ( objectArray0 ) ; JOptionPane jOptionPane1 = ( JOptionPane ) jComboBox0 . add ( ( Component ) jOptionPane0 ) ; JInternalFrame jInternalFrame0 = jOptionPane0 . createInternalFrame ( ( Component ) jOptionPane1 , "" ) ; jInternalFrame0 . dispose ( ) ; cascadeInternalFramePositioner0 . positionInternalFrame ( jInternalFrame0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getX ( ) { return _x ; }
void test2 ( ) throws Throwable { CascadeInternalFramePositioner cascadeInternalFramePositioner0 = new CascadeInternalFramePositioner ( ) ; JOptionPane jOptionPane0 = new JOptionPane ( ) ; Object [ ] objectArray0 = new Object [ 10 ] ; JComboBox jComboBox0 = new JComboBox ( objectArray0 ) ; JOptionPane jOptionPane1 = ( JOptionPane ) jComboBox0 . add ( ( Component ) jOptionPane0 ) ; JInternalFrame jInternalFrame0 = jOptionPane0 . createInternalFrame ( ( Component ) jOptionPane1 , "" ) ; cascadeInternalFramePositioner0 . positionInternalFrame ( jInternalFrame0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getX ( ) { return _x ; }
void test3 ( ) throws Throwable { CascadeInternalFramePositioner cascadeInternalFramePositioner0 = new CascadeInternalFramePositioner ( ) ; JOptionPane jOptionPane0 = new JOptionPane ( ) ; Object [ ] objectArray0 = new Object [ 10 ] ; JComboBox jComboBox0 = new JComboBox ( objectArray0 ) ; JOptionPane jOptionPane1 = ( JOptionPane ) jComboBox0 . add ( ( Component ) jOptionPane0 ) ; JInternalFrame jInternalFrame0 = jOptionPane0 . createInternalFrame ( ( Component ) jOptionPane1 , "" ) ; JButton jButton0 = new JButton ( ) ; Rectangle rectangle0 = jButton0 . getVisibleRect ( ) ; jInternalFrame0 . setBounds ( rectangle0 ) ; cascadeInternalFramePositioner0 . positionInternalFrame ( jInternalFrame0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getX ( ) { return _x ; }
void test4 ( ) throws Throwable { CascadeInternalFramePositioner cascadeInternalFramePositioner0 = new CascadeInternalFramePositioner ( ) ; JOptionPane jOptionPane0 = new JOptionPane ( ) ; Object [ ] objectArray0 = new Object [ 10 ] ; JComboBox jComboBox0 = new JComboBox ( objectArray0 ) ; JOptionPane jOptionPane1 = ( JOptionPane ) jComboBox0 . add ( ( Component ) jOptionPane0 ) ; JInternalFrame jInternalFrame0 = jOptionPane0 . createInternalFrame ( ( Component ) jOptionPane1 , "" ) ; JRadioButton jRadioButton0 = new JRadioButton ( ) ; Rectangle rectangle0 = jRadioButton0 . getVisibleRect ( ) ; rectangle0 . width = ( - 8 ) ; jInternalFrame0 . setBounds ( rectangle0 ) ; cascadeInternalFramePositioner0 . positionInternalFrame ( jInternalFrame0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getY ( ) { return _y ; }
void test5 ( ) throws Throwable { CascadeInternalFramePositioner cascadeInternalFramePositioner0 = new CascadeInternalFramePositioner ( ) ; JInternalFrame jInternalFrame0 = new JInternalFrame ( ) ; jInternalFrame0 . setIcon ( true ) ; cascadeInternalFramePositioner0 . positionInternalFrame ( jInternalFrame0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getX ( ) { return _x ; }
void test0 ( ) throws Throwable { DefaultEditorKit . CopyAction defaultEditorKit_CopyAction0 = new DefaultEditorKit . CopyAction ( ) ; JRadioButton jRadioButton0 = new JRadioButton ( ( Action ) defaultEditorKit_CopyAction0 ) ; ToggleComponentHolder toggleComponentHolder0 = new ToggleComponentHolder ( ) ; toggleComponentHolder0 . addToggleableComponent ( ( AbstractButton ) jRadioButton0 ) ; toggleComponentHolder0 . setSelected ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSelected ( ) { return _isSelected ; }
void test1 ( ) throws Throwable { DefaultEditorKit . CopyAction defaultEditorKit_CopyAction0 = new DefaultEditorKit . CopyAction ( ) ; JRadioButton jRadioButton0 = new JRadioButton ( ( Action ) defaultEditorKit_CopyAction0 ) ; ToggleComponentHolder toggleComponentHolder0 = new ToggleComponentHolder ( ) ; toggleComponentHolder0 . addToggleableComponent ( ( AbstractButton ) jRadioButton0 ) ; toggleComponentHolder0 . addToggleableComponent ( ( AbstractButton ) jRadioButton0 ) ; jRadioButton0 . doClick ( 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSelected ( ) { return _isSelected ; }
void test2 ( ) throws Throwable { ToggleComponentHolder toggleComponentHolder0 = new ToggleComponentHolder ( ) ; boolean boolean0 = toggleComponentHolder0 . isSelected ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSelected ( ) { return _isSelected ; }
void test0 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; CursorChanger cursorChanger0 = new CursorChanger ( ( Component ) jTable0 ) ; cursorChanger0 . restore ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void restore ( ) { _comp . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; }
void test1 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; CursorChanger cursorChanger0 = new CursorChanger ( ( Component ) jTable0 ) ; cursorChanger0 . show ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void show ( Component invoker , int x , int y ) { super . show ( invoker , x , y ) ; }
void test0 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test1 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setFont ( Font font ) { _comp . setFont ( font ) ; }
void test2 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test3 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test4 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test5 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test6 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test7 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test8 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addJComponent ( JComponent comp ) { if ( comp = = null ) { throw new IllegalArgumentException ( "JComponent = = null" ) ; } comp . setBorder ( createComponentBorder ( ) ) ; if ( _font ! = null ) { comp . setFont ( _font ) ; updateSubcomponentsFont ( comp ) ; } super . add ( comp , _gbc ) ; }
void test9 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test10 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test11 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test12 ( ) throws Throwable { StatusBar statusBar0 = new StatusBar ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test0 ( ) throws Throwable { WindowStateBeanInfo windowStateBeanInfo0 = new WindowStateBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = windowStateBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test1 ( ) throws Throwable { DefaultFileListBoxModel defaultFileListBoxModel0 = new DefaultFileListBoxModel ( ) ; File file0 = new File ( " & 15 < L XPDQG8" , " & 15 < L XPDQG8" ) ; defaultFileListBoxModel0 . insertFileAt ( file0 , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test2 ( ) throws Throwable { DefaultFileListBoxModel defaultFileListBoxModel0 = new DefaultFileListBoxModel ( ) ; File file0 = new File ( "" ) ; defaultFileListBoxModel0 . addFile ( file0 ) ; defaultFileListBoxModel0 . getFileNames ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test3 ( ) throws Throwable { DefaultFileListBoxModel defaultFileListBoxModel0 = new DefaultFileListBoxModel ( ) ; String [ ] stringArray0 = defaultFileListBoxModel0 . getFileNames ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getFileNames ( ) ; / * * * Return the File at the passed index . * * @param idx Index to return File for . * * @return The File at < TT > idx < / TT > . * * @throws ArrayInexOutOfBoundsException * Thrown if < TT > idx < / TT > < 0 or > = < TT > getSize ( ) < / TT > . * / File getFile ( int idx ) ; }
void test0 ( ) throws Throwable { BeanPropertyTable beanPropertyTable0 = new BeanPropertyTable ( ( Object ) null ) ; beanPropertyTable0 . setBean ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setBean ( Object bean ) throws BaseException { _model . setBean ( bean ) ; }
void test1 ( ) throws Throwable { BeanPropertyTable beanPropertyTable0 = new BeanPropertyTable ( ( Object ) "LabelUI" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test2 ( ) throws Throwable { BeanPropertyTable beanPropertyTable0 = new BeanPropertyTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test0 ( ) throws Throwable { JMenuItem jMenuItem0 = new JMenuItem ( "nested - " , ( Icon ) null ) ; RectangleSelectionHandler rectangleSelectionHandler0 = new RectangleSelectionHandler ( ( JComponent ) jMenuItem0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RectangleSelectionHandler ( JComponent comp ) { setComponent ( comp ) ; }
void test0 ( ) throws Throwable { PropertyPanel propertyPanel0 = new PropertyPanel ( ) ; DefaultTableCellRenderer defaultTableCellRenderer0 = new DefaultTableCellRenderer ( ) ; propertyPanel0 . add ( ( JLabel ) defaultTableCellRenderer0 , ( Component ) defaultTableCellRenderer0 ) ; propertyPanel0 . add ( ( JLabel ) defaultTableCellRenderer0 , ( Component ) defaultTableCellRenderer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { PropertyPanel propertyPanel0 = new PropertyPanel ( ) ; JRadioButtonMenuItem jRadioButtonMenuItem0 = new JRadioButtonMenuItem ( "Z# < . N / / #" , ( Icon ) null , false ) ; propertyPanel0 . add ( ( Component ) jRadioButtonMenuItem0 , ( Component ) jRadioButtonMenuItem0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { PropertyPanel propertyPanel0 = new PropertyPanel ( ) ; JLayeredPane jLayeredPane0 = new JLayeredPane ( ) ; propertyPanel0 . add ( ( Component ) jLayeredPane0 , ( Component ) jLayeredPane0 , ( Component ) jLayeredPane0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { ToolBar toolBar0 = new ToolBar ( 0 ) ; StyledEditorKit . UnderlineAction styledEditorKit_UnderlineAction0 = new StyledEditorKit . UnderlineAction ( ) ; JCheckBox jCheckBox0 = new JCheckBox ( ( Icon ) null ) ; toolBar0 . add ( ( Action ) styledEditorKit_UnderlineAction0 , ( AbstractButton ) jCheckBox0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void add ( Action action ) { if ( action = = null ) { throw new IllegalArgumentException ( "Action = = null" ) ; } _actionColl . put ( action . getClass ( ) . getName ( ) , action ) ; }
void test1 ( ) throws Throwable { ToolBar toolBar0 = new ToolBar ( 0 ) ; toolBar0 . setUseRolloverButtons ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setUseRolloverButtons ( boolean value ) { putClientProperty ( "JToolBar . isRollover" , value ? Boolean . TRUE : Boolean . FALSE ) ; }
void test2 ( ) throws Throwable { ToolBar toolBar0 = new ToolBar ( ) ; toolBar0 . setUseRolloverButtons ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setUseRolloverButtons ( boolean value ) { putClientProperty ( "JToolBar . isRollover" , value ? Boolean . TRUE : Boolean . FALSE ) ; }
void test3 ( ) throws Throwable { ToolBar toolBar0 = new ToolBar ( ) ; toolBar0 . initialiseButton ( ( Action ) null , ( AbstractButton ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test4 ( ) throws Throwable { ToolBar toolBar0 = new ToolBar ( ) ; JButton jButton0 = toolBar0 . add ( ( Action ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void add ( Action action ) { if ( action = = null ) { throw new IllegalArgumentException ( "Action = = null" ) ; } _actionColl . put ( action . getClass ( ) . getName ( ) , action ) ; }
void test0 ( ) throws Throwable { ReadTypeCombo readTypeCombo0 = new ReadTypeCombo ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { JButton jButton0 = new JButton ( "5M5 { 4i . g" ) ; FontUIResource fontUIResource0 = ( FontUIResource ) jButton0 . getFont ( ) ; FontInfo fontInfo0 = new FontInfo ( ( Font ) fontUIResource0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; FontInfo fontInfo1 = ( FontInfo ) fontInfo0 . clone ( ) ; fontInfo0 . setIsBold ( true ) ; boolean boolean0 = fontInfo0 . equals ( ( Object ) fontInfo1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int generateStyle ( ) { int style = 0 ; if ( ! _isBold & & ! _isItalic ) { style = Font . PLAIN ; } else { if ( _isBold ) { style | = Font . BOLD ; } if ( _isItalic ) { style | = Font . ITALIC ; } } return style ; }
void test2 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; fontInfo0 . setIsBold ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { JButton jButton0 = new JButton ( "5M5 { 4i . g" ) ; FontUIResource fontUIResource0 = ( FontUIResource ) jButton0 . getFont ( ) ; FontInfo fontInfo0 = new FontInfo ( ( Font ) fontUIResource0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test4 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; fontInfo0 . isItalic ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test6 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; fontInfo0 . setFamily ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test8 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; boolean boolean0 = fontInfo0 . doesFontMatch ( ( Font ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test9 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; Object [ ] [ ] objectArray0 = new Object [ 25 ] [ 3 ] ; Object [ ] objectArray1 = new Object [ 1 ] ; objectArray1 [ 0 ] = ( Object ) fontInfo0 ; JTable jTable0 = new JTable ( objectArray0 , objectArray1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test10 ( ) throws Throwable { JMenuItem jMenuItem0 = new JMenuItem ( ( Icon ) null ) ; FontUIResource fontUIResource0 = ( FontUIResource ) jMenuItem0 . getFont ( ) ; FontInfo fontInfo0 = new FontInfo ( ( Font ) fontUIResource0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean doesFontMatch ( Font font ) { if ( font = = null ) { return false ; } return font . getFamily ( ) . equals ( _familyName ) & & font . getSize ( ) = = getSize ( ) & & font . getStyle ( ) = = generateStyle ( ) ; }
void test11 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; Font font0 = fontInfo0 . createFont ( ) ; fontInfo0 . setIsItalic ( true ) ; boolean boolean0 = fontInfo0 . doesFontMatch ( font0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isItalic ( ) { return _isItalic ; }
void test12 ( ) throws Throwable { JMenuItem jMenuItem0 = new JMenuItem ( ( Icon ) null ) ; FontUIResource fontUIResource0 = ( FontUIResource ) jMenuItem0 . getFont ( ) ; FontInfo fontInfo0 = new FontInfo ( ( Font ) fontUIResource0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean doesFontMatch ( Font font ) { if ( font = = null ) { return false ; } return font . getFamily ( ) . equals ( _familyName ) & & font . getSize ( ) = = getSize ( ) & & font . getStyle ( ) = = generateStyle ( ) ; }
void test13 ( ) throws Throwable { JMenuItem jMenuItem0 = new JMenuItem ( ( Icon ) null ) ; FontUIResource fontUIResource0 = ( FontUIResource ) jMenuItem0 . getFont ( ) ; FontInfo fontInfo0 = new FontInfo ( ( Font ) fontUIResource0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test14 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; fontInfo0 . setIsItalic ( true ) ; String string0 = fontInfo0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int generateStyle ( ) { int style = 0 ; if ( ! _isBold & & ! _isItalic ) { style = Font . PLAIN ; } else { if ( _isBold ) { style | = Font . BOLD ; } if ( _isItalic ) { style | = Font . ITALIC ; } } return style ; }
void test15 ( ) throws Throwable { JButton jButton0 = new JButton ( "5M5 { 4i . g" ) ; FontUIResource fontUIResource0 = ( FontUIResource ) jButton0 . getFont ( ) ; FontInfo fontInfo0 = new FontInfo ( ( Font ) fontUIResource0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test16 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; fontInfo0 . setIsItalic ( true ) ; int int0 = fontInfo0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int generateStyle ( ) { int style = 0 ; if ( ! _isBold & & ! _isItalic ) { style = Font . PLAIN ; } else { if ( _isBold ) { style | = Font . BOLD ; } if ( _isItalic ) { style | = Font . ITALIC ; } } return style ; }
void test17 ( ) throws Throwable { JButton jButton0 = new JButton ( "5M5 { 4i . g" ) ; FontUIResource fontUIResource0 = ( FontUIResource ) jButton0 . getFont ( ) ; FontInfo fontInfo0 = new FontInfo ( ( Font ) fontUIResource0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test18 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; boolean boolean0 = fontInfo0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test19 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; Object [ ] objectArray0 = new Object [ 8 ] ; StyleConstants styleConstants0 = ( StyleConstants ) AttributeSet . ResolveAttribute ; objectArray0 [ 0 ] = ( Object ) styleConstants0 ; boolean boolean0 = fontInfo0 . equals ( objectArray0 [ 0 ] ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test20 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; FontInfo fontInfo1 = ( FontInfo ) fontInfo0 . clone ( ) ; fontInfo0 . setFamily ( "Monospaced , 12" ) ; boolean boolean0 = fontInfo0 . equals ( ( Object ) fontInfo1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test21 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; fontInfo0 . setIsItalic ( true ) ; FontInfo fontInfo1 = new FontInfo ( ) ; FontInfo fontInfo2 = ( FontInfo ) fontInfo1 . clone ( ) ; boolean boolean0 = fontInfo0 . equals ( ( Object ) fontInfo2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int generateStyle ( ) { int style = 0 ; if ( ! _isBold & & ! _isItalic ) { style = Font . PLAIN ; } else { if ( _isBold ) { style | = Font . BOLD ; } if ( _isItalic ) { style | = Font . ITALIC ; } } return style ; }
void test22 ( ) throws Throwable { FontInfo fontInfo0 = new FontInfo ( ) ; FontInfo fontInfo1 = new FontInfo ( ) ; fontInfo1 . setSize ( ( - 19 ) ) ; FontInfo fontInfo2 = ( FontInfo ) fontInfo1 . clone ( ) ; boolean boolean0 = fontInfo0 . equals ( ( Object ) fontInfo2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSize ( ) { return _dataModel . getSize ( ) ; }
void test0 ( ) throws Throwable { BeanPropertyTableModel beanPropertyTableModel0 = new BeanPropertyTableModel ( ) ; beanPropertyTableModel0 . setValueColumnName ( "Q46i & G * { gz & A%pY8o%M" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test1 ( ) throws Throwable { BeanPropertyTableModel beanPropertyTableModel0 = new BeanPropertyTableModel ( ) ; beanPropertyTableModel0 . setNameColumnName ( "Q46i & G * { gz & A%pY8o%M" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test2 ( ) throws Throwable { BeanPropertyTableModel beanPropertyTableModel0 = new BeanPropertyTableModel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test3 ( ) throws Throwable { BeanPropertyTableModel beanPropertyTableModel0 = new BeanPropertyTableModel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test1 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; TableExportCsvCommand tableExportCsvCommand0 = new TableExportCsvCommand ( jTable0 ) ; boolean boolean0 = tableExportCsvCommand0 . checkMissingData ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean checkMissingData ( String sepChar ) { return false ; }
void test0 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . FIREBIRD ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "Null 'categoryKeys' argument . " , "Null 'categoryKeys' argument . " , "Null 'categoryKeys' argument . " , ( - 7 ) , "Null 'categoryKeys' argument . " , false , ( - 7 ) , 0 , ( - 7 ) , false , false , false , dialectType0 ) ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . UPDATE ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) "java . awt . CheckboxGroup [ selectedCheckbox = null ] " , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test1 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 851 , "oC } o5 * cLV { ; IL" ) ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . UPDATE ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) null , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test2 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . UPDATE ; String string0 = tableCopySqlPartCommandBase0 . getData ( ( ColumnDisplayDefinition ) null , ( Object ) " = java . awt . CheckboxGroup [ selectedCheckbox = null ] " , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test3 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . MCKOI ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 5 , "n" , "n" , "n" , 5 , "n" , false , 5 , 5 , 5 , false , false , false , dialectType0 ) ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . UPDATE ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) "SmallIcon" , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test4 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . INFORMIX ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 93 , "Ikx5QDg ! PJ#Yk" , "Ikx5QDg ! PJ#Yk" , "Ikx5QDg ! PJ#Yk" , 4 , "Ikx5QDg ! PJ#Yk" , true , 93 , 93 , 93 , false , false , true , dialectType0 ) ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . WHERE ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) tableCopySqlPartCommandBase0 , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test5 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . H2 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 3 , "Ikx5QDg ! PJ#Yk" , "Ikx5QDg ! PJ#Yk" , "Ikx5QDg ! PJ#Yk" , 3 , "Ikx5QDg ! PJ#Yk" , false , 3 , 3 , 3 , false , false , false , dialectType0 ) ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . UPDATE ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) "United Kingdom" , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test6 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . PROGRESS ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 7 , "" , "" , "" , 8 , "" , true , 7 , 7 , 8 , true , true , true , dialectType0 ) ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . IN ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) "ShortDescription" , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test7 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . PROGRESS ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . IN ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 7 , "ShortDescription" , "ShortDescription" , "ShortDescription" , 2 , "ShortDescription" , true , 7 , 7 , 7 , true , true , true , dialectType0 ) ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) "job - state - reason" , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test8 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . INGRES ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 6 ) , "aW" , "aW" , "aW" , ( - 6 ) , "aW" , true , ( - 6 ) , ( - 6 ) , ( - 6 ) , true , true , true , dialectType0 ) ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . IN ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) "ActionCommandKey" , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test9 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . H2 ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . UPDATE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 3 , "Ikx5QDg ! PJ#Yk" , "Ikx5QDg ! PJ#Yk" , "Ikx5QDg ! PJ#Yk" , 92 , "Ikx5QDg ! PJ#Yk" , false , 3 , 3 , 3 , false , false , false , dialectType0 ) ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) " = United Kingdom" , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test10 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . PROGRESS ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . IN ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 7 , "" , "" , "" , 7 , "" , true , 7 , 7 , 7 , true , true , true , dialectType0 ) ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) "job - state - reason" , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test11 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1743 ) , "IkxQDgPJ#Yk" , "IkxQDgPJ#Yk" , "IkxQDgPJ#Yk" , 91 , "IkxQDgPJ#Yk" , false , ( - 1743 ) , 91 , ( - 1743 ) , false , false , false , dialectType0 ) ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . UPDATE ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) "AcceleratorKey" , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test12 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1743 ) , "IkxQDgPJ#Yk" , "IkxQDgPJ#Yk" , "IkxQDgPJ#Yk" , 91 , "IkxQDgPJ#Yk" , false , ( - 1743 ) , 91 , ( - 1743 ) , false , false , false , dialectType0 ) ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . UPDATE ; Date date0 = new Date ( ( long ) 91 ) ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) date0 , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test13 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . INFORMIX ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . WHERE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1743 ) , "Ikx5QDg ! PJ#Yk" , "Ikx5QDg ! PJ#Yk" , "Ikx5QDg ! PJ#Yk" , 93 , "Ikx5QDg ! PJ#Yk" , false , ( - 1743 ) , 93 , 93 , false , false , false , dialectType0 ) ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) "ActionCommandKey" , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test14 ( ) throws Throwable { TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; DialectType dialectType0 = DialectType . PROGRESS ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 7 , "" , "" , "" , 8 , "" , true , 7 , 7 , 8 , true , true , true , dialectType0 ) ; TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . IN ; String string0 = tableCopySqlPartCommandBase0 . getData ( columnDisplayDefinition0 , ( Object ) null , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test15 ( ) throws Throwable { TableCopySqlPartCommandBase . StatType tableCopySqlPartCommandBase_StatType0 = TableCopySqlPartCommandBase . StatType . WHERE ; TableCopySqlPartCommandBase tableCopySqlPartCommandBase0 = new TableCopySqlPartCommandBase ( ) ; String string0 = tableCopySqlPartCommandBase0 . getData ( ( ColumnDisplayDefinition ) null , ( Object ) null , tableCopySqlPartCommandBase_StatType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test0 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; CopyWikiTableAction copyWikiTableAction0 = new CopyWikiTableAction ( "3 ! h\"sCtpw ) , cRM2Xc" , ( IWikiTableConfiguration ) genericWikiTableConfigurationBean0 , ( ITableActionCallback ) null ) ; Frame frame0 = copyWikiTableAction0 . getParentFrame ( ( ActionEvent ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Frame getParentFrame ( ActionEvent evt ) { Frame parent = null ; if ( evt ! = null ) { Object src = evt . getSource ( ) ; if ( src instanceof Component ) { Component comp = ( Component ) src ; while ( comp ! = null & & parent = = null ) { if ( comp instanceof Frame ) { parent = ( Frame ) comp ; } else if ( comp instanceof JPopupMenu ) { comp = ( ( JPopupMenu ) comp ) . getInvoker ( ) ; } else { comp = comp . getParent ( ) ; } } } } return parent ; }
void test1 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; CopyWikiTableAction copyWikiTableAction0 = new CopyWikiTableAction ( "3 ! h\"sCtpw ) , cRM2Xc" , ( IWikiTableConfiguration ) genericWikiTableConfigurationBean0 , ( ITableActionCallback ) null ) ; ActionEvent actionEvent0 = new ActionEvent ( ( Object ) "LongDescription" , 37 , "LongDescription" ) ; Frame frame0 = copyWikiTableAction0 . getParentFrame ( actionEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Frame getParentFrame ( ActionEvent evt ) { Frame parent = null ; if ( evt ! = null ) { Object src = evt . getSource ( ) ; if ( src instanceof Component ) { Component comp = ( Component ) src ; while ( comp ! = null & & parent = = null ) { if ( comp instanceof Frame ) { parent = ( Frame ) comp ; } else if ( comp instanceof JPopupMenu ) { comp = ( ( JPopupMenu ) comp ) . getInvoker ( ) ; } else { comp = comp . getParent ( ) ; } } } } return parent ; }
void test2 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; CopyWikiTableAction copyWikiTableAction0 = new CopyWikiTableAction ( " * g = w' ? y@o_# * MQr = M" , ( IWikiTableConfiguration ) genericWikiTableConfigurationBean0 , ( ITableActionCallback ) null ) ; DefaultTableCellRenderer defaultTableCellRenderer0 = new DefaultTableCellRenderer ( ) ; JToolTip jToolTip0 = defaultTableCellRenderer0 . createToolTip ( ) ; ActionEvent actionEvent0 = new ActionEvent ( ( Object ) jToolTip0 , 19 , " * g = w' ? y@o_# * MQr = M" , ( long ) 19 , 19 ) ; JMenu jMenu0 = new JMenu ( ) ; JPopupMenu jPopupMenu0 = jMenu0 . getPopupMenu ( ) ; actionEvent0 . setSource ( ( Object ) jPopupMenu0 ) ; Frame frame0 = copyWikiTableAction0 . getParentFrame ( actionEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Frame getParentFrame ( ActionEvent evt ) { Frame parent = null ; if ( evt ! = null ) { Object src = evt . getSource ( ) ; if ( src instanceof Component ) { Component comp = ( Component ) src ; while ( comp ! = null & & parent = = null ) { if ( comp instanceof Frame ) { parent = ( Frame ) comp ; } else if ( comp instanceof JPopupMenu ) { comp = ( ( JPopupMenu ) comp ) . getInvoker ( ) ; } else { comp = comp . getParent ( ) ; } } } } return parent ; }
void test0 ( ) throws Throwable { DialectType dialectType0 = DialectType . ORACLE ; ResultSetExportCommand resultSetExportCommand0 = new ResultSetExportCommand ( ( Statement ) null , "Null 'group' argmnt . " , dialectType0 , ( ProgressAbortFactoryCallback ) null ) ; boolean boolean0 = resultSetExportCommand0 . checkMissingData ( "Null 'group' argmnt . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean checkMissingData ( String sepChar ) { return false ; }
void test3 ( ) throws Throwable { DialectType dialectType0 = DialectType . ORACLE ; ResultSetExportCommand resultSetExportCommand0 = new ResultSetExportCommand ( ( Statement ) null , "Null 'group' argmnt . " , dialectType0 , ( ProgressAbortFactoryCallback ) null ) ; String string0 = resultSetExportCommand0 . getSql ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSql ( ) { return sql ; }
void test0 ( ) throws Throwable { TableExportCsvDlg . LineSeparator tableExportCsvDlg_LineSeparator0 = TableExportCsvDlg . LineSeparator . CRLF ; String string0 = tableExportCsvDlg_LineSeparator0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { TableExportCsvDlg . LineSeparator tableExportCsvDlg_LineSeparator0 = TableExportCsvDlg . LineSeparator . DEFAULT ; String string0 = tableExportCsvDlg_LineSeparator0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { TableExportCsvDlg . LineSeparator tableExportCsvDlg_LineSeparator0 = TableExportCsvDlg . LineSeparator . LF ; String string0 = tableExportCsvDlg_LineSeparator0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { TimeTableXYDataset timeTableXYDataset0 = new TimeTableXYDataset ( ) ; XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ( TableXYDataset ) timeTableXYDataset0 ) ; JTable jTable0 = new JTable ( ( TableModel ) xYDatasetTableModel0 ) ; TableSelectAllCellsCommand tableSelectAllCellsCommand0 = new TableSelectAllCellsCommand ( jTable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void execute ( ) { ISession session = _panel . getSession ( ) ; Connection conn = session . getSQLConnection ( ) . getConnection ( ) ; try { String sql = conn . nativeSQL ( _panel . getSQLScriptToBeExecuted ( ) ) ; if ( sql . length ( ) > 0 ) { _panel . appendSQLScript ( "\n" + sql , true ) ; } } catch ( SQLException ex ) { session . showErrorMessage ( ex ) ; } }
void test0 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; TableExportCsvCommand tableExportCsvCommand0 = new TableExportCsvCommand ( jTable0 ) ; tableExportCsvCommand0 . createProgressController ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getWrittenRows ( ) { return writtenRows ; }
void test2 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; TableExportCsvCommand tableExportCsvCommand0 = new TableExportCsvCommand ( jTable0 ) ; tableExportCsvCommand0 . getProgressController ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getWrittenRows ( ) { return writtenRows ; }
void test3 ( ) throws Throwable { TableExportCsvCommand tableExportCsvCommand0 = new TableExportCsvCommand ( ( JTable ) null ) ; long long0 = tableExportCsvCommand0 . getWrittenRows ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getWrittenRows ( ) { return writtenRows ; }
void test4 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; TableExportCsvCommand tableExportCsvCommand0 = new TableExportCsvCommand ( jTable0 ) ; tableExportCsvCommand0 . setProgressController ( ( ProgressAbortCallback ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getWrittenRows ( ) { return writtenRows ; }
void test5 ( ) throws Throwable { TableExportCsvCommand tableExportCsvCommand0 = new TableExportCsvCommand ( ( JTable ) null ) ; tableExportCsvCommand0 . getTargetFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getWrittenRows ( ) { return writtenRows ; }
void test6 ( ) throws Throwable { TableExportCsvCommand tableExportCsvCommand0 = new TableExportCsvCommand ( ( JTable ) null ) ; tableExportCsvCommand0 . progress ( "\"yBL5^u" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long getWrittenRows ( ) { return writtenRows ; }
void test0 ( ) throws Throwable { ExportFileContainer exportFileContainer0 = ExportFileContainer . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void add ( Action action ) { if ( action = = null ) { throw new IllegalArgumentException ( "Action = = null" ) ; } _actionColl . put ( action . getClass ( ) . getName ( ) , action ) ; }
void test1 ( ) throws Throwable { ExportFileContainer exportFileContainer0 = ExportFileContainer . getInstance ( ) ; File file0 = new File ( "" , "" ) ; boolean boolean0 = exportFileContainer0 . remove ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void remove ( Component comp ) { if ( comp ! = null ) { comp . removeComponentListener ( _listener ) ; super . remove ( comp ) ; } revalidate ( ) ; repaint ( ) ; }
void test0 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( 1 , 1 ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 ) ; TableSelectEntireRowsCommand tableSelectEntireRowsCommand0 = new TableSelectEntireRowsCommand ( jTable0 ) ; tableSelectEntireRowsCommand0 . execute ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TableColumnInfo getSelectedColumn ( ) { return ( TableColumnInfo ) getSelectedItem ( ) ; }
void test1 ( ) throws Throwable { JTable jTable0 = new JTable ( 104 , 104 ) ; TableSelectEntireRowsCommand tableSelectEntireRowsCommand0 = new TableSelectEntireRowsCommand ( jTable0 ) ; JTable jTable1 = tableSelectEntireRowsCommand0 . getTable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLSchema . Table getTable ( String catalog , String schema , String name ) { if ( _session . getSchemaInfo ( ) . isTable ( name ) ) { String key = getKey ( catalog , schema , name ) ; SQLSchema . Table ret = _tableCache . get ( key ) ; if ( null = = ret ) { ret = new SQLSchema . Table ( catalog , schema , name , _dmd ) ; _tableCache . put ( key , ret ) ; } return ret ; } return null ; }
void test0 ( ) throws Throwable { JTable jTable0 = new JTable ( 50 , 50 ) ; JTableExportData jTableExportData0 = new JTableExportData ( jTable0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasNext ( ) { return false ; }
void test1 ( ) throws Throwable { JTable jTable0 = new JTable ( 50 , 50 ) ; jTable0 . selectAll ( ) ; JTableExportData jTableExportData0 = new JTableExportData ( jTable0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTableExportData ( JTable table , boolean complete ) { this . table = table ; nbrSelRows = table . getSelectedRowCount ( ) ; if ( 0 = = nbrSelRows | | complete ) { nbrSelRows = table . getRowCount ( ) ; } nbrSelCols = table . getSelectedColumnCount ( ) ; if ( 0 = = nbrSelCols | | complete ) { nbrSelCols = table . getColumnCount ( ) ; } selRows = table . getSelectedRows ( ) ; if ( 0 = = selRows . length | | complete ) { selRows = new int [ nbrSelRows ] ; for ( int i = 0 ; i < selRows . length ; i + + ) { selRows [ i ] = i ; } } selCols = table . getSelectedColumns ( ) ; if ( 0 = = selCols . length | | complete ) { selCols = new int [ nbrSelCols ] ; for ( int i = 0 ; i < selCols . length ; i + + ) { selCols [ i ] = i ; } } }
void test2 ( ) throws Throwable { JTable jTable0 = new JTable ( 50 , 50 ) ; jTable0 . selectAll ( ) ; JTableExportData jTableExportData0 = new JTableExportData ( jTable0 , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTableExportData ( JTable table , boolean complete ) { this . table = table ; nbrSelRows = table . getSelectedRowCount ( ) ; if ( 0 = = nbrSelRows | | complete ) { nbrSelRows = table . getRowCount ( ) ; } nbrSelCols = table . getSelectedColumnCount ( ) ; if ( 0 = = nbrSelCols | | complete ) { nbrSelCols = table . getColumnCount ( ) ; } selRows = table . getSelectedRows ( ) ; if ( 0 = = selRows . length | | complete ) { selRows = new int [ nbrSelRows ] ; for ( int i = 0 ; i < selRows . length ; i + + ) { selRows [ i ] = i ; } } selCols = table . getSelectedColumns ( ) ; if ( 0 = = selCols . length | | complete ) { selCols = new int [ nbrSelCols ] ; for ( int i = 0 ; i < selCols . length ; i + + ) { selCols [ i ] = i ; } } }
void test3 ( ) throws Throwable { JTable jTable0 = new JTable ( 50 , 50 ) ; JTableExportData jTableExportData0 = new JTableExportData ( jTable0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasNext ( ) { return false ; }
void test0 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 572 ) , "JS : G - qeG ( qO7" , "JS : G - qeG ( qO7" , "JS : G - qeG ( qO7" , 999 , "JS : G - qeG ( qO7" , false , ( - 1 ) , ( - 1 ) , ( - 1 ) , true , false , false , dialectType0 ) ; ExportDataColumn exportDataColumn0 = new ExportDataColumn ( columnDisplayDefinition0 , ( Object ) "caret - begin - line" , 999 , 999 ) ; ColumnDisplayDefinition columnDisplayDefinition1 = exportDataColumn0 . getColumnDisplayDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowIndex ( ) ; }
void test1 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 572 ) , "JS : G - qeG ( qO7" , "JS : G - qeG ( qO7" , "JS : G - qeG ( qO7" , 999 , "JS : G - qeG ( qO7" , false , ( - 1 ) , ( - 1 ) , ( - 1 ) , true , false , false , dialectType0 ) ; ExportDataColumn exportDataColumn0 = new ExportDataColumn ( columnDisplayDefinition0 , ( Object ) "caret - begin - line" , 999 , 999 ) ; int int0 = exportDataColumn0 . getColumnIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowIndex ( ) ; }
void test2 ( ) throws Throwable { ExportDataColumn exportDataColumn0 = new ExportDataColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnIndex ( ) { return _colIx ; }
void test3 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 572 ) , "JS : G - qeG ( qO7" , "JS : G - qeG ( qO7" , "JS : G - qeG ( qO7" , 999 , "JS : G - qeG ( qO7" , false , ( - 1 ) , ( - 1 ) , ( - 1 ) , true , false , false , dialectType0 ) ; ExportDataColumn exportDataColumn0 = new ExportDataColumn ( columnDisplayDefinition0 , ( Object ) "caret - begin - line" , 999 , 999 ) ; String string0 = ( String ) exportDataColumn0 . getObject ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowIndex ( ) ; }
void test4 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 572 ) , "JS : G - qeG ( qO7" , "JS : G - qeG ( qO7" , "JS : G - qeG ( qO7" , 999 , "JS : G - qeG ( qO7" , false , ( - 1 ) , ( - 1 ) , ( - 1 ) , true , false , false , dialectType0 ) ; ExportDataColumn exportDataColumn0 = new ExportDataColumn ( columnDisplayDefinition0 , ( Object ) "caret - begin - line" , 999 , 999 ) ; int int0 = exportDataColumn0 . getRowIndex ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnIndex ( ) { return _colIx ; }
void test0 ( ) throws Throwable { Vector < IExportDataCell > vector0 = new Vector < IExportDataCell > ( ) ; ExportDataRow exportDataRow0 = new ExportDataRow ( ( List < IExportDataCell > ) vector0 , 621 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowIndex ( ) ; }
void test1 ( ) throws Throwable { Vector < IExportDataCell > vector0 = new Vector < IExportDataCell > ( ) ; ExportDataRow exportDataRow0 = new ExportDataRow ( ( List < IExportDataCell > ) vector0 , 621 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowIndex ( ) ; }
void test0 ( ) throws Throwable { DataExportExcelWriter dataExportExcelWriter0 = new DataExportExcelWriter ( ( File ) null , ( TableExportCsvController ) null , true , ( ProgressAbortCallback ) null ) ; dataExportExcelWriter0 . setCtrl ( ( TableExportCsvController ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeHeaders ( ) { return includeHeaders ; }
void test1 ( ) throws Throwable { File file0 = new File ( "vJW - d [ U$1Cu ! 5" , "vJW - d [ U$1Cu ! 5" ) ; DataExportXMLWriter dataExportXMLWriter0 = new DataExportXMLWriter ( file0 , ( TableExportCsvController ) null , false , ( ProgressAbortCallback ) null ) ; dataExportXMLWriter0 . setFile ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeHeaders ( ) { return includeHeaders ; }
void test2 ( ) throws Throwable { File file0 = new File ( ( File ) null , "Category option \"" ) ; DataExportCSVWriter dataExportCSVWriter0 = new DataExportCSVWriter ( file0 , ( TableExportCsvController ) null , false , ( ProgressAbortCallback ) null ) ; boolean boolean0 = dataExportCSVWriter0 . isIncludeHeaders ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeHeaders ( ) { return includeHeaders ; }
void test3 ( ) throws Throwable { File file0 = new File ( ( File ) null , "Category option \"" ) ; DataExportCSVWriter dataExportCSVWriter0 = new DataExportCSVWriter ( file0 , ( TableExportCsvController ) null , false , ( ProgressAbortCallback ) null ) ; dataExportCSVWriter0 . getCtrl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeHeaders ( ) { return includeHeaders ; }
void test4 ( ) throws Throwable { File file0 = new File ( "open" ) ; DataExportXMLWriter dataExportXMLWriter0 = new DataExportXMLWriter ( file0 , ( TableExportCsvController ) null , true , ( ProgressAbortCallback ) null ) ; dataExportXMLWriter0 . setIncludeHeaders ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeHeaders ( ) { return includeHeaders ; }
void test2 ( ) throws Throwable { DataExportCSVWriter dataExportCSVWriter0 = new DataExportCSVWriter ( ( File ) null , ( TableExportCsvController ) null , false , ( ProgressAbortCallback ) null ) ; dataExportCSVWriter0 . beforeRow ( ( - 407 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isIncludeHeaders ( ) { return includeHeaders ; }
void test7 ( ) throws Throwable { DataExportCSVWriter dataExportCSVWriter0 = new DataExportCSVWriter ( ( File ) null , ( TableExportCsvController ) null , false , ( ProgressAbortCallback ) null ) ; ExportDataColumn exportDataColumn0 = new ExportDataColumn ( ( ColumnDisplayDefinition ) null , ( Object ) "application / x - java - jvm - local - objectref" , ( - 407 ) , ( - 407 ) ) ; String string0 = dataExportCSVWriter0 . getDataCSV ( "R" , ( IExportDataCell ) exportDataColumn0 , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDataCSV ( String sepChar , IExportDataCell cellObj , boolean useGlobalFormatting ) { if ( cellObj . getObject ( ) = = null ) { return "" ; } String value ; if ( cellObj . getColumnDisplayDefinition ( ) ! = null & & useGlobalFormatting ) { value = CellComponentFactory . renderObject ( cellObj . getObject ( ) , cellObj . getColumnDisplayDefinition ( ) ) ; } else { value = cellObj . getObject ( ) . toString ( ) ; } return getDataCSV ( sepChar , value ) ; }
void test8 ( ) throws Throwable { DataExportCSVWriter dataExportCSVWriter0 = new DataExportCSVWriter ( ( File ) null , ( TableExportCsvController ) null , false , ( ProgressAbortCallback ) null ) ; ExportDataColumn exportDataColumn0 = new ExportDataColumn ( ) ; String string0 = dataExportCSVWriter0 . getDataCSV ( "R" , ( IExportDataCell ) exportDataColumn0 , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDataCSV ( String sepChar , IExportDataCell cellObj , boolean useGlobalFormatting ) { if ( cellObj . getObject ( ) = = null ) { return "" ; } String value ; if ( cellObj . getColumnDisplayDefinition ( ) ! = null & & useGlobalFormatting ) { value = CellComponentFactory . renderObject ( cellObj . getObject ( ) , cellObj . getColumnDisplayDefinition ( ) ) ; } else { value = cellObj . getObject ( ) . toString ( ) ; } return getDataCSV ( sepChar , value ) ; }
void test9 ( ) throws Throwable { File file0 = new File ( "No resource found for key " , "No resource found for key " ) ; DataExportCSVWriter dataExportCSVWriter0 = new DataExportCSVWriter ( file0 , ( TableExportCsvController ) null , false , ( ProgressAbortCallback ) null ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1086 , "No resource found for key " ) ; ExportDataColumn exportDataColumn0 = new ExportDataColumn ( columnDisplayDefinition0 , ( Object ) "No resource found for key" , 1086 , 1086 ) ; String string0 = dataExportCSVWriter0 . getDataCSV ( "No resource found for key" , ( IExportDataCell ) exportDataColumn0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDataCSV ( String sepChar , IExportDataCell cellObj , boolean useGlobalFormatting ) { if ( cellObj . getObject ( ) = = null ) { return "" ; } String value ; if ( cellObj . getColumnDisplayDefinition ( ) ! = null & & useGlobalFormatting ) { value = CellComponentFactory . renderObject ( cellObj . getObject ( ) , cellObj . getColumnDisplayDefinition ( ) ) ; } else { value = cellObj . getObject ( ) . toString ( ) ; } return getDataCSV ( sepChar , value ) ; }
void test10 ( ) throws Throwable { File file0 = new File ( "No resource found for key " , "No resource found for key" ) ; DataExportCSVWriter dataExportCSVWriter0 = new DataExportCSVWriter ( file0 , ( TableExportCsvController ) null , false , ( ProgressAbortCallback ) null ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 15 ) , "No resource found for key " ) ; ExportDataColumn exportDataColumn0 = new ExportDataColumn ( columnDisplayDefinition0 , ( Object ) "No resource found for key" , ( - 15 ) , ( - 15 ) ) ; String string0 = dataExportCSVWriter0 . getDataCSV ( "No resource found for key" , ( IExportDataCell ) exportDataColumn0 , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDataCSV ( String sepChar , IExportDataCell cellObj , boolean useGlobalFormatting ) { if ( cellObj . getObject ( ) = = null ) { return "" ; } String value ; if ( cellObj . getColumnDisplayDefinition ( ) ! = null & & useGlobalFormatting ) { value = CellComponentFactory . renderObject ( cellObj . getObject ( ) , cellObj . getColumnDisplayDefinition ( ) ) ; } else { value = cellObj . getObject ( ) . toString ( ) ; } return getDataCSV ( sepChar , value ) ; }
void test11 ( ) throws Throwable { String string0 = DataExportCSVWriter . getDataCSV ( "\"ad7\"\"\"\"k%o\"" , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDataCSV ( String sepChar , IExportDataCell cellObj , boolean useGlobalFormatting ) { if ( cellObj . getObject ( ) = = null ) { return "" ; } String value ; if ( cellObj . getColumnDisplayDefinition ( ) ! = null & & useGlobalFormatting ) { value = CellComponentFactory . renderObject ( cellObj . getObject ( ) , cellObj . getColumnDisplayDefinition ( ) ) ; } else { value = cellObj . getObject ( ) . toString ( ) ; } return getDataCSV ( sepChar , value ) ; }
void test12 ( ) throws Throwable { String string0 = DataExportCSVWriter . getDataCSV ( "ad7\"\"k%o" , "\"ad7\"\"\"\"k%o\"" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDataCSV ( String sepChar , IExportDataCell cellObj , boolean useGlobalFormatting ) { if ( cellObj . getObject ( ) = = null ) { return "" ; } String value ; if ( cellObj . getColumnDisplayDefinition ( ) ! = null & & useGlobalFormatting ) { value = CellComponentFactory . renderObject ( cellObj . getObject ( ) , cellObj . getColumnDisplayDefinition ( ) ) ; } else { value = cellObj . getObject ( ) . toString ( ) ; } return getDataCSV ( sepChar , value ) ; }
void test0 ( ) throws Throwable { LinkedList < IWikiTableConfiguration > linkedList0 = new LinkedList < IWikiTableConfiguration > ( ) ; WikiTableConfigurationStorage wikiTableConfigurationStorage0 = new WikiTableConfigurationStorage ( ( List < IWikiTableConfiguration > ) linkedList0 ) ; List < IWikiTableConfiguration > list0 = wikiTableConfigurationStorage0 . configurationsAsList ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test2 ( ) throws Throwable { WikiTableConfigurationStorage wikiTableConfigurationStorage0 = new WikiTableConfigurationStorage ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" WikiTableConfigurationStorage ( ) { super ( ) ; }
void test3 ( ) throws Throwable { WikiTableConfigurationStorage wikiTableConfigurationStorage0 = new WikiTableConfigurationStorage ( ( List < IWikiTableConfiguration > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" WikiTableConfigurationStorage ( ) { super ( ) ; }
void test0 ( ) throws Throwable { CopyWikiTableAction copyWikiTableAction0 = new CopyWikiTableAction ( "e\"c\" } { 3~NtDqt" , ( IWikiTableConfiguration ) null , ( ITableActionCallback ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEnabled ( ) { return enabled ; }
void test0 ( ) throws Throwable { GenericWikiTableTransformer genericWikiTableTransformer0 = new GenericWikiTableTransformer ( ) ; StringBuilder stringBuilder0 = new StringBuilder ( "" ) ; genericWikiTableTransformer0 . appendWithReplacement ( stringBuilder0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { GenericWikiTableTransformer genericWikiTableTransformer0 = new GenericWikiTableTransformer ( ) ; IWikiTableConfiguration iWikiTableConfiguration0 = genericWikiTableTransformer0 . getConfiguration ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IWikiTableConfiguration getConfiguration ( ) { return configuration ; }
void test3 ( ) throws Throwable { GenericWikiTableTransformer genericWikiTableTransformer0 = new GenericWikiTableTransformer ( ) ; JTable jTable0 = new JTable ( ) ; String string0 = genericWikiTableTransformer0 . transform ( jTable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String transform ( ApplicationFiles appFiles ) { return convertAliases_2_2_to_2_3 ( appFiles ) ; }
void test0 ( ) throws Throwable { WikiTableConfigurationFactory wikiTableConfigurationFactory0 = new WikiTableConfigurationFactory ( ) ; LinkedList < IWikiTableConfiguration > linkedList0 = new LinkedList < IWikiTableConfiguration > ( ) ; GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; genericWikiTableConfigurationBean0 . setName ( "8 { i & PWLr1Ejv\"l Q" ) ; linkedList0 . add ( ( IWikiTableConfiguration ) genericWikiTableConfigurationBean0 ) ; wikiTableConfigurationFactory0 . setUserSpecificConfigurations ( ( List < IWikiTableConfiguration > ) linkedList0 ) ; wikiTableConfigurationFactory0 . setBuildInConfigurations ( ( List < IWikiTableConfiguration > ) linkedList0 ) ; List < IWikiTableConfiguration > list0 = wikiTableConfigurationFactory0 . getConfigurations ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test1 ( ) throws Throwable { WikiTableConfigurationFactory wikiTableConfigurationFactory0 = ( WikiTableConfigurationFactory ) WikiTableConfigurationFactory . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ApplicationArguments getInstance ( ) { if ( s_instance = = null ) { try { s_instance = new ApplicationArguments ( new String [ ] { } ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } } return s_instance ; }
void test2 ( ) throws Throwable { WikiTableConfigurationFactory wikiTableConfigurationFactory0 = new WikiTableConfigurationFactory ( ) ; LinkedList < IWikiTableConfiguration > linkedList0 = new LinkedList < IWikiTableConfiguration > ( ) ; wikiTableConfigurationFactory0 . replaceBuilInConfiguration ( ( List < IWikiTableConfiguration > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test7 ( ) throws Throwable { WikiTableConfigurationFactory wikiTableConfigurationFactory0 = new WikiTableConfigurationFactory ( ) ; LinkedList < IWikiTableConfiguration > linkedList0 = new LinkedList < IWikiTableConfiguration > ( ) ; wikiTableConfigurationFactory0 . replaceUserSpecificConfigurations ( ( List < IWikiTableConfiguration > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test8 ( ) throws Throwable { LinkedList < IWikiTableConfiguration > linkedList0 = new LinkedList < IWikiTableConfiguration > ( ) ; GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; linkedList0 . add ( ( IWikiTableConfiguration ) genericWikiTableConfigurationBean0 ) ; List < IWikiTableConfiguration > list0 = WikiTableConfigurationFactory . merge ( ( List < IWikiTableConfiguration > ) linkedList0 , ( List < IWikiTableConfiguration > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test0 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDataCell ( ) { return dataCell ; }
void test3 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IWikiTableConfiguration copyAsUserSpecific ( ) { return new GenericWikiTableConfigurationBean ( this ) ; }
void test4 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object clone ( ) throws CloneNotSupportedException { return super . clone ( ) ; }
void test5 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setDataCell ( String dataCell ) { checkReadOnly ( ) ; if ( StringUtils . contains ( dataCell , VALUE_PLACEHOLDER ) = = false ) { throw new IllegalArgumentException ( s_stringMgr . getString ( "GenericWikiTableConfigurationBean . dataCellErrorValueVariableMissing" ) ) ; / / $NON - NLS - 1$ } this . dataCell = dataCell ; }
void test6 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setNoWikiTag ( String escapeSequence ) { checkReadOnly ( ) ; if ( StringUtils . contains ( escapeSequence , VALUE_PLACEHOLDER ) = = false ) { throw new IllegalArgumentException ( s_stringMgr . getString ( "GenericWikiTableConfigurationBean . noWikiErrorValueVariableMissing" ) ) ; / / $NON - NLS - 1$ } this . noWikiTag = escapeSequence ; }
void test7 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test8 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEnabled ( ) { return enabled ; }
void test9 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test10 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHeaderCell ( ) { return headerCell ; }
void test11 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test12 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEnabled ( ) { return enabled ; }
void test13 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHeaderCell ( ) { return headerCell ; }
void test14 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEnabled ( ) { return enabled ; }
void test15 ( ) throws Throwable { GenericWikiTableConfigurationBean genericWikiTableConfigurationBean0 = new GenericWikiTableConfigurationBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { CopyWikiTableActionFactory copyWikiTableActionFactory0 = new CopyWikiTableActionFactory ( ) ; JMenuItem jMenuItem0 = copyWikiTableActionFactory0 . createMenueItem ( ( ITableActionCallback ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEnabled ( ) { return enabled ; }
void test2 ( ) throws Throwable { CopyWikiTableActionFactory copyWikiTableActionFactory0 = ( CopyWikiTableActionFactory ) CopyWikiTableActionFactory . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ApplicationArguments getInstance ( ) { if ( s_instance = = null ) { try { s_instance = new ApplicationArguments ( new String [ ] { } ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } } return s_instance ; }
void test2 ( ) throws Throwable { DefaultTreeCellRenderer defaultTreeCellRenderer0 = new DefaultTreeCellRenderer ( ) ; Color color0 = defaultTreeCellRenderer0 . getTextSelectionColor ( ) ; LineBorder lineBorder0 = new LineBorder ( color0 ) ; DebugBorder debugBorder0 = new DebugBorder ( ( Border ) lineBorder0 ) ; LineBorder lineBorder1 = ( LineBorder ) debugBorder0 . getDelegate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ITabDelegate getDelegate ( ) { return _delegate ; }
void test3 ( ) throws Throwable { Action action0 = TransferHandler . getPasteAction ( ) ; JMenuItem jMenuItem0 = new JMenuItem ( action0 ) ; MetalBorders . MenuItemBorder metalBorders_MenuItemBorder0 = ( MetalBorders . MenuItemBorder ) jMenuItem0 . getBorder ( ) ; DebugBorder debugBorder0 = new DebugBorder ( ( Border ) metalBorders_MenuItemBorder0 ) ; boolean boolean0 = debugBorder0 . isBorderOpaque ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isBorderOpaque ( ) { return b . isBorderOpaque ( ) ; }
void test2 ( ) throws Throwable { DebugEventListener debugEventListener0 = new DebugEventListener ( ) ; ActionEvent actionEvent0 = new ActionEvent ( ( Object ) "First" , ( - 1582 ) , "First" ) ; debugEventListener0 . eventDispatched ( ( AWTEvent ) actionEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { DebugEventListener debugEventListener0 = new DebugEventListener ( ) ; JButton jButton0 = new JButton ( "t~o4 : @n | ] ( " ) ; KeyEvent keyEvent0 = new KeyEvent ( ( Component ) jButton0 , 506 , ( long ) 506 , 0 , 0 , 'U' ) ; debugEventListener0 . eventDispatched ( ( AWTEvent ) keyEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void eventDispatched ( AWTEvent event ) { Object o = event . getSource ( ) ; if ( o instanceof JComponent & & o ! = null ) { JComponent source = ( JComponent ) o ; switch ( event . getID ( ) ) { case MouseEvent . MOUSE_DRAGGED : printDebugInfo ( source , event ) ; break ; case MouseEvent . MOUSE_ENTERED : printDebugInfo ( source , event ) ; setToolTipText ( source , event ) ; setBorder ( source , event ) ; break ; case MouseEvent . MOUSE_EXITED : printDebugInfo ( source , event ) ; setBorder ( source , event ) ; break ; } } }
void test4 ( ) throws Throwable { DebugEventListener debugEventListener0 = new DebugEventListener ( ) ; JButton jButton0 = new JButton ( "t~o4 : @n | ] ( " ) ; ContainerEvent containerEvent0 = new ContainerEvent ( ( Component ) jButton0 , 504 , ( Component ) jButton0 ) ; debugEventListener0 . eventDispatched ( ( AWTEvent ) containerEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getToolTipText ( MouseEvent event ) { JButton button = getButtonAt ( event . getX ( ) ) ; if ( null = = button ) { return super . getToolTipText ( event ) ; } else { return button . getToolTipText ( ) ; } }
void test5 ( ) throws Throwable { DebugEventListener debugEventListener0 = new DebugEventListener ( ) ; JButton jButton0 = new JButton ( "t~ow : @n | ] ( " ) ; ContainerEvent containerEvent0 = new ContainerEvent ( ( Component ) jButton0 , 505 , ( Component ) jButton0 ) ; debugEventListener0 . eventDispatched ( ( AWTEvent ) containerEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getID ( ) { return _id ; }
void test6 ( ) throws Throwable { DebugEventListener debugEventListener0 = new DebugEventListener ( ) ; JButton jButton0 = new JButton ( "t~o4 : @n | ] ( " ) ; ContainerEvent containerEvent0 = new ContainerEvent ( ( Component ) jButton0 , 0 , ( Component ) jButton0 ) ; debugEventListener0 . eventDispatched ( ( AWTEvent ) containerEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getID ( ) { return _id ; }
void test1 ( ) throws Throwable { XMLObjectCache < IHasIdentifier > xMLObjectCache0 = new XMLObjectCache < IHasIdentifier > ( ) ; Class < IHasIdentifier > [ ] classArray0 = xMLObjectCache0 . getAllClasses ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Class < E > [ ] getAllClasses ( ) { return _cache . getAllClasses ( ) ; }
void test3 ( ) throws Throwable { XMLObjectCache < IHasIdentifier > xMLObjectCache0 = new XMLObjectCache < IHasIdentifier > ( ) ; Class < ? > class0 = DropTargetEvent . class ; DatabaseObjectType databaseObjectType0 = DatabaseObjectType . TRIGGER_TYPE_DBO ; IntegerIdentifier integerIdentifier0 = ( IntegerIdentifier ) databaseObjectType0 . getIdentifier ( ) ; IHasIdentifier iHasIdentifier0 = xMLObjectCache0 . get ( class0 , ( IIdentifier ) integerIdentifier0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test4 ( ) throws Throwable { XMLObjectCache < IHasIdentifier > xMLObjectCache0 = new XMLObjectCache < IHasIdentifier > ( ) ; Class < ? > class0 = DropTargetEvent . class ; UidIdentifier uidIdentifier0 = new UidIdentifier ( ) ; xMLObjectCache0 . remove ( class0 , ( IIdentifier ) uidIdentifier0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test5 ( ) throws Throwable { XMLObjectCache < IHasIdentifier > xMLObjectCache0 = new XMLObjectCache < IHasIdentifier > ( ) ; char [ ] charArray0 = new char [ 1 ] ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 , 0 , 0 ) ; PushbackReader pushbackReader0 = new PushbackReader ( ( Reader ) charArrayReader0 , ( int ) ' ] ' ) ; xMLObjectCache0 . load ( ( Reader ) pushbackReader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void load ( IApplication app ) throws PluginException ; / * * * Called on application startup after application started . * / void initialize ( ) throws PluginException ; / * * * Called when app shutdown . * TODO : Put throws clause back in * / void unload ( ) ; / / throws PluginException ; / * * * Returns the name by which this plugin is uniquely identified . * * @return the name by which this plugin is uniquely identified . * / String getInternalName ( ) ; / * * * Returns the descriptive name for this plugin . * * @return the descriptive name for this plugin . * / String getDescriptiveName ( ) ; / * * * Returns the authors name . * * @return the authors name . * / String getAuthor ( ) ; / * * * Returns a comma separated list of other contributors . * * @return Contributors names . * / String getContributors ( ) ; / * * * Returns the home page for this plugin . * * @return the home page for this plugin . * / String getWebSite ( ) ; / * * * Returns the current version of this plugin . * * @return the current version of this plugin . * / String getVersion ( ) ; / * * * Returns the name of the Help file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the Help file name or < TT > null < / TT > if plugin doesn't have * a help file . * / String getHelpFileName ( ) ; / * * * Returns the name of the change log for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the changelog file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getChangeLogFileName ( ) ; / * * * Returns the name of the licence file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the licence file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getLicenceFileName ( ) ; / * * * Create panels for the Global Preferences dialog . * * @return Array of < TT > IGlobalPreferencesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the Global Preferences Dialog . * / IGlobalPreferencesPanel [ ] getGlobalPreferencePanels ( ) ; / * * * Creates Alias Prefs Controllers for this Plugin . * / IAliasPropertiesPanelController [ ] getAliasPropertiesPanelControllers ( SQLAlias alias ) ; / * * * Called when an Alias is copied . Should be overridden by Plugins * that work with Alias properties . * / void aliasCopied ( SQLAlias source , SQLAlias target ) ; / * * * Called when an Alias is removed . Should be overridden by Plugins * that work with Alias properties . * / void aliasRemoved ( SQLAlias alias ) ; / * * * Create panels for the New Session Properties dialog . * * @return Array of < TT > INewSessionPropertiesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the New Session Properties Dialog . * / INewSessionPropertiesPanel [ ] getNewSessionPropertiesPanels ( ) ; / * * * Return the folder with the Squirrel application folder * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; squirrel_app & gt ; / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins application folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginAppSettingsFolder ( ) throws IOException , IllegalStateException ; / * * * Return the folder with the users home directory * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; user_home & gt ; / . squirrel - sql / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins user folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginUserSettingsFolder ( ) throws IllegalStateException , IOException ; / * * * Allows a plugin to provide services to other plugins . * @see PluginManager . bindExternalPluginService ( ) ; * / Object getExternalService ( ) ; / * * * Returns the absolute path to the plugin jar file . * * @return the absolute path to the plugin jar file . * * @throws IllegalStateException if this plugin doesn't have a valid internal name . * / String getPluginJarFilePath ( ) throws IllegalStateException ; / * * * @param applicationFiles the applicationFiles to set * / void setApplicationFiles ( ApplicationFileWrappers applicationFiles ) ; / * * * @param fileWrapperFactory the fileWrapperFactory to set * / void setFileWrapperFactory ( FileWrapperFactory fileWrapperFactory ) ; }
void test0 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { try { JInternalFrame jInternalFrame0 = new JInternalFrame ( "%d - tN \"LS_7 < 'Uc" , true ) ; WindowState windowState0 = new WindowState ( jInternalFrame0 ) ; XMLBeanWriter xMLBeanWriter0 = new XMLBeanWriter ( ( Object ) windowState0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test2 ( ) throws Throwable { XMLBeanWriter xMLBeanWriter0 = new XMLBeanWriter ( ) ; xMLBeanWriter0 . addToRoot ( ( Object ) xMLBeanWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAsString ( ) throws IOException { StringWriter sw = new StringWriter ( ) ; BufferedWriter bw = new BufferedWriter ( sw ) ; new XMLWriter ( bw ) . write ( _rootElement , true ) ; bw . flush ( ) ; sw . flush ( ) ; bw . close ( ) ; sw . close ( ) ; return sw . toString ( ) ; }
void test6 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; XMLBeanWriter xMLBeanWriter0 = new XMLBeanWriter ( ( Object ) defaultTableModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAsString ( ) throws IOException { StringWriter sw = new StringWriter ( ) ; BufferedWriter bw = new BufferedWriter ( sw ) ; new XMLWriter ( bw ) . write ( _rootElement , true ) ; bw . flush ( ) ; sw . flush ( ) ; bw . close ( ) ; sw . close ( ) ; return sw . toString ( ) ; }
void test0 ( ) throws Throwable { JTextField jTextField0 = new JTextField ( " > " ) ; TextComponentProvider textComponentProvider0 = new TextComponentProvider ( ( JTextComponent ) jTextField0 , false ) ; JTextField jTextField1 = ( JTextField ) textComponentProvider0 . getEditor ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editorEqualsFilter ( ) { return null = = _txtFilter ; }
void test1 ( ) throws Throwable { JTextField jTextField0 = new JTextField ( "" ) ; TextComponentProvider textComponentProvider0 = new TextComponentProvider ( ( JTextComponent ) jTextField0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editorEqualsFilter ( ) { return null = = _txtFilter ; }
void test2 ( ) throws Throwable { JTextArea jTextArea0 = new JTextArea ( "SZ ? 5_ { F ] V + TFHa + ? l\" * " ) ; TextComponentProvider textComponentProvider0 = new TextComponentProvider ( ( JTextComponent ) jTextArea0 , false ) ; JTextArea jTextArea1 = ( JTextArea ) textComponentProvider0 . getFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editorEqualsFilter ( ) { return null = = _txtFilter ; }
void test3 ( ) throws Throwable { JTextField jTextField0 = new JTextField ( " > " ) ; TextComponentProvider textComponentProvider0 = new TextComponentProvider ( ( JTextComponent ) jTextField0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test4 ( ) throws Throwable { JTextArea jTextArea0 = new JTextArea ( "SZ ? 5_ { F ] V + TFHa + ? l\" * " ) ; TextComponentProvider textComponentProvider0 = new TextComponentProvider ( ( JTextComponent ) jTextArea0 , false ) ; boolean boolean0 = textComponentProvider0 . editorEqualsFilter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean editorEqualsFilter ( ) { return null = = _txtFilter ; }
void test0 ( ) throws Throwable { CompletionInfo [ ] completionInfoArray0 = new CompletionInfo [ 10 ] ; CompletionCandidates completionCandidates0 = new CompletionCandidates ( completionInfoArray0 , 558 , "Npb# ) @T" ) ; CompletionInfo [ ] completionInfoArray1 = completionCandidates0 . getCandidates ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getReplacementStart ( ) { return _replacementStart ; }
void test1 ( ) throws Throwable { CompletionInfo [ ] completionInfoArray0 = new CompletionInfo [ 10 ] ; CompletionCandidates completionCandidates0 = new CompletionCandidates ( completionInfoArray0 , 558 , "Npb# ) @T" ) ; String string0 = completionCandidates0 . getStringToReplace ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getReplacementStart ( ) { return _replacementStart ; }
void test2 ( ) throws Throwable { CompletionInfo [ ] completionInfoArray0 = new CompletionInfo [ 10 ] ; CompletionCandidates completionCandidates0 = new CompletionCandidates ( completionInfoArray0 , 558 , "Npb# ) @T" ) ; int int0 = completionCandidates0 . getReplacementStart ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getReplacementStart ( ) { return _replacementStart ; }
void test3 ( ) throws Throwable { CompletionInfo [ ] completionInfoArray0 = new CompletionInfo [ 3 ] ; Action action0 = TransferHandler . getPasteAction ( ) ; ToolsPopupCompletionInfo toolsPopupCompletionInfo0 = new ToolsPopupCompletionInfo ( ( String ) null , action0 ) ; completionInfoArray0 [ 0 ] = ( CompletionInfo ) toolsPopupCompletionInfo0 ; completionInfoArray0 [ 1 ] = ( CompletionInfo ) toolsPopupCompletionInfo0 ; completionInfoArray0 [ 2 ] = ( CompletionInfo ) toolsPopupCompletionInfo0 ; CompletionCandidates completionCandidates0 = new CompletionCandidates ( completionInfoArray0 ) ; String string0 = completionCandidates0 . getAllCandidatesPrefix ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAllCandidatesPrefix ( boolean caseSensitive ) { if ( 0 = = _candidates . length ) { return "" ; } String prefix = null ; for ( CompletionInfo _candidate : _candidates ) { String completionString = _candidate . getCompletionString ( ) ; if ( null = = prefix ) { prefix = completionString ; } else { int ix ; int minLen = Math . min ( prefix . length ( ) , completionString . length ( ) ) ; prefix = prefix . substring ( 0 , minLen ) ; for ( ix = 0 ; ix < minLen ; + + ix ) { if ( getCharAt ( prefix , ix , caseSensitive ) ! = getCharAt ( completionString , ix , caseSensitive ) ) { prefix = prefix . substring ( 0 , ix ) ; break ; } } } } return prefix ; }
void test0 ( ) throws Throwable { CamelCaseMatcher camelCaseMatcher0 = new CamelCaseMatcher ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { boolean boolean0 = CamelCaseMatcher . matchesCamelCase ( "sF * e & | Y" , "sF * e & | Y" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matchesCamelCase ( String testString , String dbObjectName ) { int [ ] bufTest = new int [ ] { 0 } ; int [ ] bufComp = new int [ ] { 0 } ; String nextCamelCaseSubstring = getNextCamelCaseSubstring ( testString , bufTest ) ; if ( null = = nextCamelCaseSubstring ) { return false ; } String dbObjCamelCaseSubstring = getNextCamelCaseSubstring ( dbObjectName , bufComp ) ; while ( null ! = dbObjCamelCaseSubstring & & dbObjCamelCaseSubstring . startsWith ( nextCamelCaseSubstring ) ) { nextCamelCaseSubstring = getNextCamelCaseSubstring ( testString , bufTest ) ; if ( null = = nextCamelCaseSubstring ) { return true ; } dbObjCamelCaseSubstring = getNextCamelCaseSubstring ( dbObjectName , bufComp ) ; } return false ; }
void test2 ( ) throws Throwable { boolean boolean0 = CamelCaseMatcher . matchesCamelCase ( "" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matchesCamelCase ( String testString , String dbObjectName ) { int [ ] bufTest = new int [ ] { 0 } ; int [ ] bufComp = new int [ ] { 0 } ; String nextCamelCaseSubstring = getNextCamelCaseSubstring ( testString , bufTest ) ; if ( null = = nextCamelCaseSubstring ) { return false ; } String dbObjCamelCaseSubstring = getNextCamelCaseSubstring ( dbObjectName , bufComp ) ; while ( null ! = dbObjCamelCaseSubstring & & dbObjCamelCaseSubstring . startsWith ( nextCamelCaseSubstring ) ) { nextCamelCaseSubstring = getNextCamelCaseSubstring ( testString , bufTest ) ; if ( null = = nextCamelCaseSubstring ) { return true ; } dbObjCamelCaseSubstring = getNextCamelCaseSubstring ( dbObjectName , bufComp ) ; } return false ; }
void test3 ( ) throws Throwable { boolean boolean0 = CamelCaseMatcher . matchesCamelCase ( "sF * e & | Y" , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matchesCamelCase ( String testString , String dbObjectName ) { int [ ] bufTest = new int [ ] { 0 } ; int [ ] bufComp = new int [ ] { 0 } ; String nextCamelCaseSubstring = getNextCamelCaseSubstring ( testString , bufTest ) ; if ( null = = nextCamelCaseSubstring ) { return false ; } String dbObjCamelCaseSubstring = getNextCamelCaseSubstring ( dbObjectName , bufComp ) ; while ( null ! = dbObjCamelCaseSubstring & & dbObjCamelCaseSubstring . startsWith ( nextCamelCaseSubstring ) ) { nextCamelCaseSubstring = getNextCamelCaseSubstring ( testString , bufTest ) ; if ( null = = nextCamelCaseSubstring ) { return true ; } dbObjCamelCaseSubstring = getNextCamelCaseSubstring ( dbObjectName , bufComp ) ; } return false ; }
void test4 ( ) throws Throwable { boolean boolean0 = CamelCaseMatcher . matchesCamelCase ( "sF * e & | Y" , "Rw`AM * wW_p , I" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matchesCamelCase ( String testString , String dbObjectName ) { int [ ] bufTest = new int [ ] { 0 } ; int [ ] bufComp = new int [ ] { 0 } ; String nextCamelCaseSubstring = getNextCamelCaseSubstring ( testString , bufTest ) ; if ( null = = nextCamelCaseSubstring ) { return false ; } String dbObjCamelCaseSubstring = getNextCamelCaseSubstring ( dbObjectName , bufComp ) ; while ( null ! = dbObjCamelCaseSubstring & & dbObjCamelCaseSubstring . startsWith ( nextCamelCaseSubstring ) ) { nextCamelCaseSubstring = getNextCamelCaseSubstring ( testString , bufTest ) ; if ( null = = nextCamelCaseSubstring ) { return true ; } dbObjCamelCaseSubstring = getNextCamelCaseSubstring ( dbObjectName , bufComp ) ; } return false ; }
void test0 ( ) throws Throwable { Action action0 = TransferHandler . getCutAction ( ) ; ToolsPopupCompletionInfo toolsPopupCompletionInfo0 = new ToolsPopupCompletionInfo ( "dc#0TMEJ - U8 : r { J ( `" , action0 ) ; boolean boolean0 = toolsPopupCompletionInfo0 . matchesCompletionString ( "NULL IAPPLICATION PASSEDNULL IAPPLICATION PASSEDNULL IAPPLICATON PASSEDNULL IAPPLICATION PASSED" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matchesCompletionString ( String testString ) { initCache ( ) ; return _upperCaseCompletionString . equals ( testString . toUpperCase ( ) ) ; }
void test1 ( ) throws Throwable { Action action0 = TransferHandler . getCutAction ( ) ; ToolsPopupCompletionInfo toolsPopupCompletionInfo0 = new ToolsPopupCompletionInfo ( "dc#0TMEJ - U8 : r { J ( `" , action0 ) ; boolean boolean0 = toolsPopupCompletionInfo0 . hasColumns ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasColumns ( ) { return false ; }
void test2 ( ) throws Throwable { Action action0 = TransferHandler . getCutAction ( ) ; ToolsPopupCompletionInfo toolsPopupCompletionInfo0 = new ToolsPopupCompletionInfo ( "dc#0TMEJ - U8 : r { J ( `" , action0 ) ; int int0 = toolsPopupCompletionInfo0 . compareTo ( ( CompletionInfo ) toolsPopupCompletionInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compareTo ( CaseInsensitiveString anotherString ) { int len1 = count ; int len2 = anotherString . count ; int n = Math . min ( len1 , len2 ) ; char v1 [ ] = value ; char v2 [ ] = anotherString . value ; int i = offset ; int j = anotherString . offset ; if ( i = = j ) { int k = i ; int lim = n + i ; while ( k < lim ) { char c1 = v1 [ k ] ; char c2 = v2 [ k ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } k + + ; } } else { while ( n - - ! = 0 ) { char c1 = v1 [ i + + ] ; char c2 = v2 [ j + + ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } } } return len1 - len2 ; }
void test3 ( ) throws Throwable { Action action0 = TransferHandler . getCutAction ( ) ; ToolsPopupCompletionInfo toolsPopupCompletionInfo0 = new ToolsPopupCompletionInfo ( "NULL IAPPLICATION PASSEDNULL IAPPLICATION PASSEDNULL IAPPLICATON PASSEDNULL IAPPLICATION PASSED" , action0 ) ; boolean boolean0 = toolsPopupCompletionInfo0 . matchesCompletionStringStart ( "dc#0TMEJ - U8 : r { J ( `" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matchesCompletionStringStart ( String testString , boolean matchCamelCase ) { initCache ( ) ; return _upperCaseCompletionString . startsWith ( testString . toUpperCase ( ) ) | | ( matchCamelCase & & matchesCamelCase ( testString ) ) ; }
void test4 ( ) throws Throwable { Action action0 = TransferHandler . getCutAction ( ) ; ToolsPopupCompletionInfo toolsPopupCompletionInfo0 = new ToolsPopupCompletionInfo ( "dc#0TMEJ - U8 : r { J ( `" , action0 ) ; boolean boolean0 = toolsPopupCompletionInfo0 . matchesCompletionStringStart ( "dc#0TMEJ - U8 : r { J ( `" , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matchesCompletionStringStart ( String testString , boolean matchCamelCase ) { initCache ( ) ; return _upperCaseCompletionString . startsWith ( testString . toUpperCase ( ) ) | | ( matchCamelCase & & matchesCamelCase ( testString ) ) ; }
void test5 ( ) throws Throwable { Action action0 = TransferHandler . getCutAction ( ) ; ToolsPopupCompletionInfo toolsPopupCompletionInfo0 = new ToolsPopupCompletionInfo ( "dc#0TMEJ - U8 : r { J ( `" , action0 ) ; boolean boolean0 = toolsPopupCompletionInfo0 . matchesCompletionStringStart ( "NULL IAPPLICATION PASSEDNULL IAPPLICATION PASSEDNULL IAPPLICATON PASSEDNULL IAPPLICATION PASSED" , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean matchesCompletionStringStart ( String testString , boolean matchCamelCase ) { initCache ( ) ; return _upperCaseCompletionString . startsWith ( testString . toUpperCase ( ) ) | | ( matchCamelCase & & matchesCamelCase ( testString ) ) ; }
void test0 ( ) throws Throwable { JTextField jTextField0 = new JTextField ( 210 ) ; ToolsPopupCompletorModel toolsPopupCompletorModel0 = new ToolsPopupCompletorModel ( ) ; JCheckBox jCheckBox0 = new JCheckBox ( ( Icon ) null ) ; Color color0 = jCheckBox0 . getForeground ( ) ; Completor completor0 = new Completor ( ( JTextComponent ) jTextField0 , ( ICompletorModel ) toolsPopupCompletorModel0 , ( CompletorListener ) null , color0 , false ) ; completor0 . disposePopup ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTextTillCarret ( ) { try { if ( _txtComp . editorEqualsFilter ( ) ) { return _txtComp . getEditor ( ) . getText ( 0 , _txtComp . getFilter ( ) . getCaretPosition ( ) ) ; } else { return _txtComp . getFilter ( ) . getText ( ) ; } } catch ( BadLocationException e ) { throw new RuntimeException ( e ) ; } }
void test1 ( ) throws Throwable { JTextField jTextField0 = new JTextField ( 189 ) ; ToolsPopupCompletorModel toolsPopupCompletorModel0 = new ToolsPopupCompletorModel ( ) ; JCheckBox jCheckBox0 = new JCheckBox ( ( Icon ) null ) ; Color color0 = jCheckBox0 . getForeground ( ) ; Completor completor0 = new Completor ( ( JTextComponent ) jTextField0 , ( ICompletorModel ) toolsPopupCompletorModel0 , ( CompletorListener ) null , color0 , true ) ; completor0 . show ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTextTillCarret ( ) { try { if ( _txtComp . editorEqualsFilter ( ) ) { return _txtComp . getEditor ( ) . getText ( 0 , _txtComp . getFilter ( ) . getCaretPosition ( ) ) ; } else { return _txtComp . getFilter ( ) . getText ( ) ; } } catch ( BadLocationException e ) { throw new RuntimeException ( e ) ; } }
void test0 ( ) throws Throwable { JInternalFrame jInternalFrame0 = new JInternalFrame ( "" , true , true , true ) ; PopupManager popupManager0 = new PopupManager ( ( JComponent ) jInternalFrame0 ) ; JScrollBar jScrollBar0 = new JScrollBar ( 0 ) ; Line2D . Float line2D_Float0 = new Line2D . Float ( ) ; Rectangle rectangle0 = line2D_Float0 . getBounds ( ) ; PopupManager . Placement popupManager_Placement0 = PopupManager . AbovePreferred ; popupManager0 . install ( ( JComponent ) jScrollBar0 , rectangle0 , popupManager_Placement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getHeight ( ) ; }
void test1 ( ) throws Throwable { PopupManager . Placement popupManager_Placement0 = PopupManager . Largest ; String string0 = popupManager_Placement0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { PopupManager . Placement popupManager_Placement0 = PopupManager . Largest ; JInternalFrame jInternalFrame0 = new JInternalFrame ( "" , true , true , true ) ; PopupManager popupManager0 = new PopupManager ( ( JComponent ) jInternalFrame0 ) ; JScrollBar jScrollBar0 = new JScrollBar ( 0 ) ; Line2D . Float line2D_Float0 = new Line2D . Float ( ) ; Rectangle rectangle0 = line2D_Float0 . getBounds ( ) ; popupManager0 . install ( ( JComponent ) jScrollBar0 , rectangle0 , popupManager_Placement0 ) ; popupManager0 . install ( ( JComponent ) jScrollBar0 , rectangle0 , popupManager_Placement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { JTable jTable0 = new JTable ( 0 , 0 ) ; JScrollPane jScrollPane0 = new JScrollPane ( ( Component ) jTable0 ) ; JToolTip jToolTip0 = jScrollPane0 . createToolTip ( ) ; Rectangle rectangle0 = jToolTip0 . getVisibleRect ( ) ; PopupManager . Placement popupManager_Placement0 = PopupManager . Below ; Rectangle rectangle1 = PopupManager . computeBounds ( ( JComponent ) jToolTip0 , ( JComponent ) jTable0 , rectangle0 , popupManager_Placement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test5 ( ) throws Throwable { PopupManager . Placement popupManager_Placement0 = PopupManager . Largest ; JCheckBox jCheckBox0 = new JCheckBox ( ) ; JToolTip jToolTip0 = jCheckBox0 . createToolTip ( ) ; CellRendererPane cellRendererPane0 = new CellRendererPane ( ) ; Rectangle rectangle0 = cellRendererPane0 . getBounds ( ) ; Rectangle rectangle1 = PopupManager . computeBounds ( ( JComponent ) jToolTip0 , ( - 1754 ) , 726 , rectangle0 , popupManager_Placement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getHeight ( ) ; }
void test6 ( ) throws Throwable { JRadioButtonMenuItem jRadioButtonMenuItem0 = new JRadioButtonMenuItem ( ( Action ) null ) ; JInternalFrame jInternalFrame0 = new JInternalFrame ( ) ; JInternalFrame . JDesktopIcon jInternalFrame_JDesktopIcon0 = jInternalFrame0 . getDesktopIcon ( ) ; Rectangle rectangle0 = jInternalFrame_JDesktopIcon0 . getVisibleRect ( ) ; PopupManager . Placement popupManager_Placement0 = PopupManager . AbovePreferred ; Rectangle rectangle1 = PopupManager . computeBounds ( ( JComponent ) jRadioButtonMenuItem0 , ( JComponent ) jRadioButtonMenuItem0 , rectangle0 , popupManager_Placement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Rectangle computeBounds ( JComponent popup , JComponent view , Rectangle cursorBounds , Placement placement ) { Rectangle ret ; Component viewParent = view . getParent ( ) ; if ( viewParent instanceof JViewport ) { Rectangle viewBounds = ( ( JViewport ) viewParent ) . getViewRect ( ) ; Rectangle translatedCursorBounds = ( Rectangle ) cursorBounds . clone ( ) ; translatedCursorBounds . translate ( - viewBounds . x , - viewBounds . y ) ; ret = computeBounds ( popup , viewBounds . width , viewBounds . height , translatedCursorBounds , placement ) ; if ( ret ! = null ) { / / valid bounds ret . translate ( viewBounds . x , viewBounds . y ) ; } } else { / / not in scroll pane ret = computeBounds ( popup , view . getWidth ( ) , view . getHeight ( ) , cursorBounds , placement ) ; } return ret ; }
void test7 ( ) throws Throwable { JSlider jSlider0 = new JSlider ( ) ; SpinnerDateModel spinnerDateModel0 = new SpinnerDateModel ( ) ; JSpinner jSpinner0 = new JSpinner ( ( SpinnerModel ) spinnerDateModel0 ) ; JSpinner . DefaultEditor jSpinner_DefaultEditor0 = new JSpinner . DefaultEditor ( jSpinner0 ) ; Rectangle rectangle0 = jSpinner_DefaultEditor0 . getVisibleRect ( ) ; PopupManager . Placement popupManager_Placement0 = PopupManager . BelowPreferred ; Rectangle rectangle1 = PopupManager . computeBounds ( ( JComponent ) jSlider0 , 1970 , 1970 , rectangle0 , popupManager_Placement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getHeight ( ) ; }
void test8 ( ) throws Throwable { JSpinner jSpinner0 = new JSpinner ( ) ; Rectangle2D . Float rectangle2D_Float0 = new Rectangle2D . Float ( ( - 1811 . 1368F ) , ( - 1811 . 1368F ) , ( - 1811 . 1368F ) , ( - 1811 . 1368F ) ) ; Rectangle rectangle0 = rectangle2D_Float0 . getBounds ( ) ; PopupManager . Placement popupManager_Placement0 = PopupManager . BelowPreferred ; Rectangle rectangle1 = PopupManager . computeBounds ( ( JComponent ) jSpinner0 , 0 , 0 , rectangle0 , popupManager_Placement0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Rectangle computeBounds ( JComponent popup , JComponent view , Rectangle cursorBounds , Placement placement ) { Rectangle ret ; Component viewParent = view . getParent ( ) ; if ( viewParent instanceof JViewport ) { Rectangle viewBounds = ( ( JViewport ) viewParent ) . getViewRect ( ) ; Rectangle translatedCursorBounds = ( Rectangle ) cursorBounds . clone ( ) ; translatedCursorBounds . translate ( - viewBounds . x , - viewBounds . y ) ; ret = computeBounds ( popup , viewBounds . width , viewBounds . height , translatedCursorBounds , placement ) ; if ( ret ! = null ) { / / valid bounds ret . translate ( viewBounds . x , viewBounds . y ) ; } } else { / / not in scroll pane ret = computeBounds ( popup , view . getWidth ( ) , view . getHeight ( ) , cursorBounds , placement ) ; } return ret ; }
void test0 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( "'" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test1 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( "" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test2 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( "q . eSD" , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getReplacementStart ( ) { return _replacementStart ; }
void test3 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( " . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getToken ( int index ) { return _tokens . get ( index ) ; }
void test4 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( "'" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test5 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( " . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getReplacementStart ( ) { return _replacementStart ; }
void test6 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( "'" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test7 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( "'" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test8 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( "" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test9 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( "q . eSD" , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringToReplace ( ) { return _stringToReplace ; }
void test10 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( "q . eSD" , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringToReplace ( ) { return _stringToReplace ; }
void test11 ( ) throws Throwable { CompletionParser completionParser0 = new CompletionParser ( "q . eSD . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getReplacementStart ( ) { return _replacementStart ; }
void test0 ( ) throws Throwable { CompletionUtils completionUtils0 = new CompletionUtils ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { String string0 = CompletionUtils . getStringToParse ( " . / K" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringToParse ( String textTillCaret ) { int lastIndexOfLineFeed = textTillCaret . lastIndexOf ( '\n' ) ; String lineTillCaret ; if ( - 1 = = lastIndexOfLineFeed ) { lineTillCaret = textTillCaret ; } else { lineTillCaret = textTillCaret . substring ( lastIndexOfLineFeed ) ; } String beginning = "" ; if ( 0 ! = lineTillCaret . trim ( ) . length ( ) & & ! Character . isWhitespace ( lineTillCaret . charAt ( lineTillCaret . length ( ) - 1 ) ) ) { String trimmedLineTillCaret = lineTillCaret . trim ( ) ; int lastSeparatorIndex = getLastSeparatorIndex ( trimmedLineTillCaret ) ; if ( - 1 = = lastSeparatorIndex ) { beginning = trimmedLineTillCaret ; } else { beginning = trimmedLineTillCaret . substring ( lastSeparatorIndex + 1 , trimmedLineTillCaret . length ( ) ) ; } } return beginning ; }
void test2 ( ) throws Throwable { String string0 = CompletionUtils . getStringToParse ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringToParse ( String textTillCaret ) { int lastIndexOfLineFeed = textTillCaret . lastIndexOf ( '\n' ) ; String lineTillCaret ; if ( - 1 = = lastIndexOfLineFeed ) { lineTillCaret = textTillCaret ; } else { lineTillCaret = textTillCaret . substring ( lastIndexOfLineFeed ) ; } String beginning = "" ; if ( 0 ! = lineTillCaret . trim ( ) . length ( ) & & ! Character . isWhitespace ( lineTillCaret . charAt ( lineTillCaret . length ( ) - 1 ) ) ) { String trimmedLineTillCaret = lineTillCaret . trim ( ) ; int lastSeparatorIndex = getLastSeparatorIndex ( trimmedLineTillCaret ) ; if ( - 1 = = lastSeparatorIndex ) { beginning = trimmedLineTillCaret ; } else { beginning = trimmedLineTillCaret . substring ( lastSeparatorIndex + 1 , trimmedLineTillCaret . length ( ) ) ; } } return beginning ; }
void test3 ( ) throws Throwable { String string0 = CompletionUtils . getStringToParse ( "tlDx^3dK . 0 " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringToParse ( String textTillCaret ) { int lastIndexOfLineFeed = textTillCaret . lastIndexOf ( '\n' ) ; String lineTillCaret ; if ( - 1 = = lastIndexOfLineFeed ) { lineTillCaret = textTillCaret ; } else { lineTillCaret = textTillCaret . substring ( lastIndexOfLineFeed ) ; } String beginning = "" ; if ( 0 ! = lineTillCaret . trim ( ) . length ( ) & & ! Character . isWhitespace ( lineTillCaret . charAt ( lineTillCaret . length ( ) - 1 ) ) ) { String trimmedLineTillCaret = lineTillCaret . trim ( ) ; int lastSeparatorIndex = getLastSeparatorIndex ( trimmedLineTillCaret ) ; if ( - 1 = = lastSeparatorIndex ) { beginning = trimmedLineTillCaret ; } else { beginning = trimmedLineTillCaret . substring ( lastSeparatorIndex + 1 , trimmedLineTillCaret . length ( ) ) ; } } return beginning ; }
void test4 ( ) throws Throwable { String string0 = CompletionUtils . getStringToParse ( "yh < f = qt" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getStringToParse ( String textTillCaret ) { int lastIndexOfLineFeed = textTillCaret . lastIndexOf ( '\n' ) ; String lineTillCaret ; if ( - 1 = = lastIndexOfLineFeed ) { lineTillCaret = textTillCaret ; } else { lineTillCaret = textTillCaret . substring ( lastIndexOfLineFeed ) ; } String beginning = "" ; if ( 0 ! = lineTillCaret . trim ( ) . length ( ) & & ! Character . isWhitespace ( lineTillCaret . charAt ( lineTillCaret . length ( ) - 1 ) ) ) { String trimmedLineTillCaret = lineTillCaret . trim ( ) ; int lastSeparatorIndex = getLastSeparatorIndex ( trimmedLineTillCaret ) ; if ( - 1 = = lastSeparatorIndex ) { beginning = trimmedLineTillCaret ; } else { beginning = trimmedLineTillCaret . substring ( lastSeparatorIndex + 1 , trimmedLineTillCaret . length ( ) ) ; } } return beginning ; }
void test5 ( ) throws Throwable { int int0 = CompletionUtils . getStringToParsePosition ( " . / K" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStringToParsePosition ( String textTillCaret ) { int lastIndexOfLineFeed = textTillCaret . lastIndexOf ( '\n' ) ; String lineTillCaret ; if ( - 1 = = lastIndexOfLineFeed ) { lineTillCaret = textTillCaret ; } else { lineTillCaret = textTillCaret . substring ( lastIndexOfLineFeed ) ; } int pos = lastIndexOfLineFeed + 1 ; if ( 0 ! = lineTillCaret . length ( ) & & ! Character . isWhitespace ( lineTillCaret . charAt ( lineTillCaret . length ( ) - 1 ) ) ) { int lastSeparatorIndex = getLastSeparatorIndex ( lineTillCaret ) ; if ( - 1 ! = lastSeparatorIndex ) { pos + = lastSeparatorIndex ; } } return pos ; }
void test6 ( ) throws Throwable { int int0 = CompletionUtils . getStringToParsePosition ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStringToParsePosition ( String textTillCaret ) { int lastIndexOfLineFeed = textTillCaret . lastIndexOf ( '\n' ) ; String lineTillCaret ; if ( - 1 = = lastIndexOfLineFeed ) { lineTillCaret = textTillCaret ; } else { lineTillCaret = textTillCaret . substring ( lastIndexOfLineFeed ) ; } int pos = lastIndexOfLineFeed + 1 ; if ( 0 ! = lineTillCaret . length ( ) & & ! Character . isWhitespace ( lineTillCaret . charAt ( lineTillCaret . length ( ) - 1 ) ) ) { int lastSeparatorIndex = getLastSeparatorIndex ( lineTillCaret ) ; if ( - 1 ! = lastSeparatorIndex ) { pos + = lastSeparatorIndex ; } } return pos ; }
void test7 ( ) throws Throwable { int int0 = CompletionUtils . getStringToParsePosition ( "tlDx^3dK . 0 " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStringToParsePosition ( String textTillCaret ) { int lastIndexOfLineFeed = textTillCaret . lastIndexOf ( '\n' ) ; String lineTillCaret ; if ( - 1 = = lastIndexOfLineFeed ) { lineTillCaret = textTillCaret ; } else { lineTillCaret = textTillCaret . substring ( lastIndexOfLineFeed ) ; } int pos = lastIndexOfLineFeed + 1 ; if ( 0 ! = lineTillCaret . length ( ) & & ! Character . isWhitespace ( lineTillCaret . charAt ( lineTillCaret . length ( ) - 1 ) ) ) { int lastSeparatorIndex = getLastSeparatorIndex ( lineTillCaret ) ; if ( - 1 ! = lastSeparatorIndex ) { pos + = lastSeparatorIndex ; } } return pos ; }
void test8 ( ) throws Throwable { int int0 = CompletionUtils . getStringToParsePosition ( "yh < f = qt" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStringToParsePosition ( String textTillCaret ) { int lastIndexOfLineFeed = textTillCaret . lastIndexOf ( '\n' ) ; String lineTillCaret ; if ( - 1 = = lastIndexOfLineFeed ) { lineTillCaret = textTillCaret ; } else { lineTillCaret = textTillCaret . substring ( lastIndexOfLineFeed ) ; } int pos = lastIndexOfLineFeed + 1 ; if ( 0 ! = lineTillCaret . length ( ) & & ! Character . isWhitespace ( lineTillCaret . charAt ( lineTillCaret . length ( ) - 1 ) ) ) { int lastSeparatorIndex = getLastSeparatorIndex ( lineTillCaret ) ; if ( - 1 ! = lastSeparatorIndex ) { pos + = lastSeparatorIndex ; } } return pos ; }
void test0 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 1 ] ; ObjectArrayDataSet objectArrayDataSet0 = new ObjectArrayDataSet ( objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test2 ( ) throws Throwable { Object [ ] [ ] objectArray0 = new Object [ 4 ] [ 1 ] ; objectArray0 [ 0 ] = ( Object [ ] ) null ; ObjectArrayDataSet objectArrayDataSet0 = new ObjectArrayDataSet ( objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test3 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 1 ] ; ObjectArrayDataSet objectArrayDataSet0 = new ObjectArrayDataSet ( objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test4 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 1 ] ; ObjectArrayDataSet objectArrayDataSet0 = new ObjectArrayDataSet ( objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test5 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 1 ] ; ObjectArrayDataSet objectArrayDataSet0 = new ObjectArrayDataSet ( objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test6 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 3 ] ; ObjectArrayDataSet objectArrayDataSet0 = new ObjectArrayDataSet ( objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test0 ( ) throws Throwable { DataSetListModel dataSetListModel0 = new DataSetListModel ( ) ; dataSetListModel0 . removeListener ( ( IDataSetModelListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowHeadings ( ) { return _showHeadings ; }
void test1 ( ) throws Throwable { DataSetListModel dataSetListModel0 = new DataSetListModel ( ) ; int int0 = dataSetListModel0 . getRowCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test3 ( ) throws Throwable { DataSetListModel dataSetListModel0 = new DataSetListModel ( ) ; dataSetListModel0 . clear ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowHeadings ( ) { return _showHeadings ; }
void test4 ( ) throws Throwable { DataSetListModel dataSetListModel0 = new DataSetListModel ( ) ; dataSetListModel0 . allRowsAdded ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowHeadings ( ) { return _showHeadings ; }
void test5 ( ) throws Throwable { DataSetListModel dataSetListModel0 = new DataSetListModel ( ) ; ColumnDisplayDefinition [ ] columnDisplayDefinitionArray0 = dataSetListModel0 . getColumnDefinitions ( ) ; dataSetListModel0 . addRow ( ( Object [ ] ) columnDisplayDefinitionArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test7 ( ) throws Throwable { DataSetListModel dataSetListModel0 = new DataSetListModel ( ) ; dataSetListModel0 . addListener ( ( IDataSetModelListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowHeadings ( ) { return _showHeadings ; }
void test8 ( ) throws Throwable { DataSetListModel dataSetListModel0 = new DataSetListModel ( ) ; Component component0 = dataSetListModel0 . getComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JComponent getComponent ( ) { checkInit ( ) ; return _component ; }
void test9 ( ) throws Throwable { DataSetListModel dataSetListModel0 = new DataSetListModel ( ) ; dataSetListModel0 . moveToTop ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test0 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1344 ) , "margin" ) ; PopupEditableIOPanel popupEditableIOPanel0 = new PopupEditableIOPanel ( columnDisplayDefinition0 , ( Object ) "caret - begin - line" , true ) ; popupEditableIOPanel0 . addNotify ( ) ; popupEditableIOPanel0 . addNotify ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addNotify ( ) { super . addNotify ( ) ; if ( _propsListener = = null ) { _propsListener = new PropertyChangeListener ( ) { void propertyChange ( PropertyChangeEvent evt ) { propertiesHaveChanged ( evt ) ; } } ; _session . getProperties ( ) . addPropertyChangeListener ( _propsListener ) ; } }
void test1 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 691 , "popupeditableIoPanel . commandReturnNot0" , "popupeditableIoPanel . commandReturnNot0" , "popupeditableIoPanel . commandReturnNot0" , 691 , "popupeditableIoPanel . commandReturnNot0" , false , 691 , 691 , 691 , false , false , false , dialectType0 ) ; PopupEditableIOPanel popupEditableIOPanel0 = new PopupEditableIOPanel ( columnDisplayDefinition0 , ( Object ) "margin" , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long length ( ) { return _wrappedFile . length ( ) ; }
void test2 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 691 , "popupeditableIoPanel . commandReturnNot0" , "popupeditableIoPanel . commandReturnNot0" , "popupeditableIoPanel . commandReturnNot0" , 691 , "popupeditableIoPanel . commandReturnNot0" , false , 691 , 691 , 691 , false , false , false , dialectType0 ) ; PopupEditableIOPanel popupEditableIOPanel0 = new PopupEditableIOPanel ( columnDisplayDefinition0 , ( Object ) "margin" , false ) ; popupEditableIOPanel0 . requestFocus ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getHeight ( ) ; }
void test4 ( ) throws Throwable { DialectType dialectType0 = DialectType . DAFFODIL ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 995 ) , "sP | 8h - o ? " , "sP | 8h - o ? " , "sP | 8h - o ? " , ( - 5 ) , "sP | 8h - o ? " , true , ( - 995 ) , ( - 5 ) , ( - 995 ) , true , true , true , dialectType0 ) ; PopupEditableIOPanel popupEditableIOPanel0 = new PopupEditableIOPanel ( columnDisplayDefinition0 , ( Object ) "margin" , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PopupEditableIOPanel ( ColumnDisplayDefinition colDef , Object value , boolean isEditable ) { originalValue = value ; / / save for possible future use _popupMenu = new TextPopupMenu ( ) ; _colDef = colDef ; _ta = CellComponentFactory . getJTextArea ( colDef , value ) ; if ( isEditable ) { _ta . setEditable ( true ) ; _ta . setBackground ( Color . yellow ) ; / / tell user it is editable } else { _ta . setEditable ( false ) ; } _ta . setLineWrap ( true ) ; _ta . setWrapStyleWord ( true ) ; setLayout ( new BorderLayout ( ) ) ; / / add a panel containing binary data editing options , if needed JPanel displayPanel = new JPanel ( ) ; displayPanel . setLayout ( new BorderLayout ( ) ) ; scrollPane = new JScrollPane ( _ta ) ; / * * TODO : When 1 . 4 is the earliest version supported , include * the following line here : * scrollPane . setWheelScrollingEnabled ( true ) ; * The scroll - wheel function is important for ease of use , but the * setWheelScrollingEnabled function is not available in java 1 . 3 . * / displayPanel . add ( scrollPane , BorderLayout . CENTER ) ; if ( CellComponentFactory . useBinaryEditingPanel ( colDef ) ) { / / this is a binary field , so allow for multiple viewing options String [ ] radixListData = { "Hex" , "Decimal" , "Octal" , "Binary" } ; radixList = new JComboBox ( radixListData ) ; radixList . addActionListener ( optionActionListener ) ; previousRadixListItem = "Hex" ; showAscii = new JCheckBox ( ) ; previousShowAscii = false ; showAscii . addActionListener ( optionActionListener ) ; JPanel displayControlsPanel = new JPanel ( ) ; / / use default sequential layout / / i18n [ popupeditableIoPanel . numberBase = Number Base : ] displayControlsPanel . add ( new JLabel ( s_stringMgr . getString ( "popupeditableIoPanel . numberBase" ) ) ) ; displayControlsPanel . add ( radixList ) ; displayControlsPanel . add ( new JLabel ( " " ) ) ; / / add some space displayControlsPanel . add ( showAscii ) ; / / i18n [ popupeditableIoPanel . showAscii = Show ASCII as chars ] displayControlsPanel . add ( new JLabel ( s_stringMgr . getString ( "popupeditableIoPanel . showAscii" ) ) ) ; displayPanel . add ( displayControlsPanel , BorderLayout . SOUTH ) ; } add ( displayPanel , BorderLayout . CENTER ) ; / / add controls for file handling , but only if DataType / / can do File operations if ( CellComponentFactory . canDoFileIO ( colDef ) ) { / / yes it can , so add controls add ( exportImportPanel ( isEditable ) , BorderLayout . SOUTH ) ; } _popupMenu . add ( new LineWrapAction ( ) ) ; _popupMenu . add ( new WordWrapAction ( ) ) ; _popupMenu . add ( new XMLReformatAction ( ) ) ; _popupMenu . setTextComponent ( _ta ) ; }
void test5 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 691 , "popupeditableIoPanel . commandReturnNot0" , "popupeditableIoPanel . commandReturnNot0" , "popupeditableIoPanel . commandReturnNot0" , 691 , "popupeditableIoPanel . commandReturnNot0" , false , 691 , 691 , 691 , false , false , false , dialectType0 ) ; PopupEditableIOPanel popupEditableIOPanel0 = new PopupEditableIOPanel ( columnDisplayDefinition0 , ( Object ) "margin" , false ) ; popupEditableIOPanel0 . removeNotify ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void removeNotify ( ) { super . removeNotify ( ) ; if ( _propsListener ! = null ) { _session . getProperties ( ) . removePropertyChangeListener ( _propsListener ) ; _propsListener = null ; } }
void test6 ( ) throws Throwable { DialectType dialectType0 = DialectType . MSSQL ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 666 , " = a } S_T1 > 6 < ; " , " = a } S_T1 > 6 < ; " , " = a } S_T1 > 6 < ; " , 666 , " = a } S_T1 > 6 < ; " , false , 666 , 666 , 666 , false , false , false , dialectType0 ) ; PopupEditableIOPanel popupEditableIOPanel0 = new PopupEditableIOPanel ( columnDisplayDefinition0 , ( Object ) null , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test7 ( ) throws Throwable { DialectType dialectType0 = DialectType . AXION ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 691 , "" , "" , "" , 691 , "" , false , 691 , 691 , 691 , false , false , false , dialectType0 ) ; PopupEditableIOPanel popupEditableIOPanel0 = new PopupEditableIOPanel ( columnDisplayDefinition0 , ( Object ) "" , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long length ( ) { return _wrappedFile . length ( ) ; }
void test0 ( ) throws Throwable { ColumnDisplayDefinition [ ] columnDisplayDefinitionArray0 = new ColumnDisplayDefinition [ 1 ] ; DataSetDefinition dataSetDefinition0 = new DataSetDefinition ( columnDisplayDefinitionArray0 ) ; ColumnDisplayDefinition [ ] columnDisplayDefinitionArray1 = dataSetDefinition0 . getColumnDefinitions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ColumnDisplayDefinition [ ] getColumnDefinitions ( ) { return _columnDefs ; }
void test1 ( ) throws Throwable { DataSetDefinition dataSetDefinition0 = new DataSetDefinition ( ( ColumnDisplayDefinition [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataSetDefinition ( ColumnDisplayDefinition [ ] columnDefs ) { super ( ) ; _columnDefs = columnDefs ! = null ? columnDefs : new ColumnDisplayDefinition [ 0 ] ; }
void test0 ( ) throws Throwable { DialectType dialectType0 = DialectType . INGRES ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1366 , " ) < = upper ( " , " ) < = upper ( " , " ) < = upper ( " , 0 , " ) < = upper ( " , true , ( - 447 ) , 0 , ( - 1661 ) , true , true , true , dialectType0 ) ; PropertyDescriptor propertyDescriptor0 = new PropertyDescriptor ( " ) < = upper ( " , ( Method ) null , ( Method ) null ) ; BeanPorpertyColumnDisplayDefinition beanPorpertyColumnDisplayDefinition0 = new BeanPorpertyColumnDisplayDefinition ( columnDisplayDefinition0 , propertyDescriptor0 ) ; PropertyDescriptor propertyDescriptor1 = beanPorpertyColumnDisplayDefinition0 . getPropDesc ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isHidden ( ) { return _wrappedFile . isHidden ( ) ; }
void test1 ( ) throws Throwable { DialectType dialectType0 = DialectType . INGRES ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1366 , " ) < = upper ( " , " ) < = upper ( " , " ) < = upper ( " , 0 , " ) < = upper ( " , true , ( - 447 ) , 0 , ( - 1661 ) , true , true , true , dialectType0 ) ; PropertyDescriptor propertyDescriptor0 = new PropertyDescriptor ( " ) < = upper ( " , ( Method ) null , ( Method ) null ) ; BeanPorpertyColumnDisplayDefinition beanPorpertyColumnDisplayDefinition0 = new BeanPorpertyColumnDisplayDefinition ( columnDisplayDefinition0 , propertyDescriptor0 ) ; BeanPorpertyColumnDisplayDefinition [ ] beanPorpertyColumnDisplayDefinitionArray0 = new BeanPorpertyColumnDisplayDefinition [ 6 ] ; beanPorpertyColumnDisplayDefinitionArray0 [ 0 ] = beanPorpertyColumnDisplayDefinition0 ; beanPorpertyColumnDisplayDefinitionArray0 [ 1 ] = beanPorpertyColumnDisplayDefinition0 ; beanPorpertyColumnDisplayDefinitionArray0 [ 2 ] = beanPorpertyColumnDisplayDefinition0 ; beanPorpertyColumnDisplayDefinitionArray0 [ 3 ] = beanPorpertyColumnDisplayDefinition0 ; beanPorpertyColumnDisplayDefinitionArray0 [ 4 ] = beanPorpertyColumnDisplayDefinition0 ; beanPorpertyColumnDisplayDefinitionArray0 [ 5 ] = beanPorpertyColumnDisplayDefinitionArray0 [ 3 ] ; ColumnDisplayDefinition [ ] columnDisplayDefinitionArray0 = BeanPorpertyColumnDisplayDefinition . getColDefs ( beanPorpertyColumnDisplayDefinitionArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ColumnDisplayDefinition [ ] getColDefs ( BeanPorpertyColumnDisplayDefinition [ ] beanPorpertyColumnDisplayDefinitions ) { ColumnDisplayDefinition [ ] ret = new ColumnDisplayDefinition [ beanPorpertyColumnDisplayDefinitions . length ] ; for ( int i = 0 ; i < beanPorpertyColumnDisplayDefinitions . length ; i + + ) { ret [ i ] = beanPorpertyColumnDisplayDefinitions [ i ] . getColDef ( ) ; } return ret ; }
void test0 ( ) throws Throwable { DataSetViewerEditableTablePanel dataSetViewerEditableTablePanel0 = new DataSetViewerEditableTablePanel ( ) ; boolean boolean0 = dataSetViewerEditableTablePanel0 . isTableEditable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTableEditable ( ) { return false ; }
void test3 ( ) throws Throwable { DataSetViewerEditableTablePanel dataSetViewerEditableTablePanel0 = new DataSetViewerEditableTablePanel ( ) ; boolean boolean0 = dataSetViewerEditableTablePanel0 . isColumnEditable ( ( - 42 ) , ( Object ) "SORTED" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isColumnEditable ( int col , Object originalValue ) { return false ; }
void test4 ( ) throws Throwable { DataSetViewerEditableTablePanel dataSetViewerEditableTablePanel0 = new DataSetViewerEditableTablePanel ( ) ; JTable jTable0 = new JTable ( ) ; dataSetViewerEditableTablePanel0 . setCellEditors ( jTable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setCellEditors ( JTable table ) { }
void test7 ( ) throws Throwable { DataSetViewerEditableTablePanel dataSetViewerEditableTablePanel0 = new DataSetViewerEditableTablePanel ( ) ; DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; dataSetViewerEditableTablePanel0 . setUpdateableModelReference ( ( IDataSetUpdateableModel ) dataSetUpdateableTableModelImpl0 ) ; int [ ] intArray0 = dataSetViewerEditableTablePanel0 . changeUnderlyingValueAt ( ( - 12 ) , ( - 12 ) , ( Object ) "ToolTipText" , ( Object ) "ToolTipText" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] changeUnderlyingValueAt ( int row , int col , Object newValue , Object oldValue ) { return new int [ 0 ] ; / / underlaying data cannot be changed }
void test0 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1245 ) , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCurrency ( ) { return _isCurrency ; }
void test1 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 23 ) , "%P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSigned ( ) { return _isSigned ; }
void test2 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , "dataType2tring . newine'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnSize ( ) { return _columnSize ; }
void test3 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 23 ) , "%P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAutoIncrement ( ) { return _isAutoIncrement ; }
void test4 ( ) throws Throwable { DialectType dialectType0 = DialectType . INFORMIX ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 91 , "4C = z [ CZ" , "4C = z [ CZ" , "4C = z [ CZ" , 91 , "4C = z [ CZ" , false , 765 , 91 , 91 , false , false , false , dialectType0 ) ; columnDisplayDefinition0 . isCurrency ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getScale ( ) { return _scale ; }
void test5 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 23 ) , "%P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnSize ( ) { return _columnSize ; }
void test6 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , "dataType2tring . newine'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAutoIncrement ( ) { return _isAutoIncrement ; }
void test7 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , "dataType2tring . newine'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNullable ( ) { return _nullable ; }
void test8 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 54 ) , " ] cannot be instantiated due to acHess restrictions" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLabel ( ) { return _label ; }
void test9 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , "dataType2tring . newine'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAutoIncrement ( ) { return _isAutoIncrement ; }
void test10 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , "dataType2tring . newine'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getScale ( ) { return _scale ; }
void test11 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , "dataType2tring . newine'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSigned ( ) { return _isSigned ; }
void test12 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 23 ) , "%P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAutoIncrement ( ) { return _isAutoIncrement ; }
void test13 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , "dataType2tring . newine'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getPrecision ( ) { return _precision ; }
void test14 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 54 ) , " ] cannot be instantiated due to acHess restrictions" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDisplayWidth ( ) { return _displayWidth ; }
void test15 ( ) throws Throwable { DialectType dialectType0 = DialectType . ORACLE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 7 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnSize ( ) { return _columnSize ; }
void test16 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 23 ) , "%P" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAutoIncrement ( ) { return _isAutoIncrement ; }
void test17 ( ) throws Throwable { DialectType dialectType0 = DialectType . INFORMIX ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 91 , "4C = z [ CZ" , "4C = z [ CZ" , "4C = z [ CZ" , 91 , "4C = z [ CZ" , false , 765 , 91 , 91 , false , false , false , dialectType0 ) ; columnDisplayDefinition0 . setIsAutoIncrement ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test18 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , "dataType2tring . newine'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNullable ( ) { return _nullable ; }
void test19 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 54 ) , " ] cannot be instantiated due to acHess restrictions" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCurrency ( ) { return _isCurrency ; }
void test20 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , "dataType2tring . newine'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getPrecision ( ) { return _precision ; }
void test21 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , "dataType2tring . newine'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLabel ( ) { return _label ; }
void test22 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , "dataType2tring . newine'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLabel ( ) { return _label ; }
void test23 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1245 ) , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDisplayWidth ( ) { return _displayWidth ; }
void test24 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 5 ) , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDisplayWidth ( ) { return _displayWidth ; }
void test1 ( ) throws Throwable { RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl ( ) ; ResultSetMetaDataDataSet resultSetMetaDataDataSet0 = new ResultSetMetaDataDataSet ( ( ResultSetMetaData ) rowSetMetaDataImpl0 ) ; int int0 = resultSetMetaDataDataSet0 . getColumnCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test2 ( ) throws Throwable { RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl ( ) ; rowSetMetaDataImpl0 . setColumnCount ( 1299 ) ; ResultSetMetaDataDataSet resultSetMetaDataDataSet0 = new ResultSetMetaDataDataSet ( ( ResultSetMetaData ) rowSetMetaDataImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean next ( IMessageHandler msgHandler ) throws DataSetException { return + + _curIx < _allRows . size ( ) ; }
void test3 ( ) throws Throwable { RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl ( ) ; ResultSetMetaDataDataSet resultSetMetaDataDataSet0 = new ResultSetMetaDataDataSet ( ( ResultSetMetaData ) rowSetMetaDataImpl0 ) ; DataSetDefinition dataSetDefinition0 = resultSetMetaDataDataSet0 . getDataSetDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataSetDefinition getDataSetDefinition ( ) throws DataSetException { return new DataSetDefinition ( _columnDisplayDefinitions ) ; }
void test4 ( ) throws Throwable { RowSetMetaDataImpl rowSetMetaDataImpl0 = new RowSetMetaDataImpl ( ) ; ResultSetMetaDataDataSet resultSetMetaDataDataSet0 = new ResultSetMetaDataDataSet ( ( ResultSetMetaData ) rowSetMetaDataImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean next ( IMessageHandler msgHandler ) throws DataSetException { return + + _curIx < _allRows . size ( ) ; }
void test0 ( ) throws Throwable { Properties properties0 = new Properties ( ) ; HashtableDataSet hashtableDataSet0 = new HashtableDataSet ( properties0 ) ; Hashtable < Integer , Map < String , String > > hashtable0 = new Hashtable < Integer , Map < String , String > > ( ) ; FilterDataSet filterDataSet0 = new FilterDataSet ( ( IDataSet ) hashtableDataSet0 , ( Map < Integer , Map < String , String > > ) hashtable0 ) ; DataSetDefinition dataSetDefinition0 = filterDataSet0 . getDataSetDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataSetDefinition getDataSetDefinition ( ) throws DataSetException { return new DataSetDefinition ( _columnDisplayDefinitions ) ; }
void test1 ( ) throws Throwable { Properties properties0 = new Properties ( ) ; HashtableDataSet hashtableDataSet0 = new HashtableDataSet ( properties0 ) ; Hashtable < Integer , Map < String , String > > hashtable0 = new Hashtable < Integer , Map < String , String > > ( ) ; FilterDataSet filterDataSet0 = new FilterDataSet ( ( IDataSet ) hashtableDataSet0 , ( Map < Integer , Map < String , String > > ) hashtable0 ) ; int int0 = filterDataSet0 . getColumnCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test2 ( ) throws Throwable { Properties properties0 = new Properties ( ) ; properties0 . put ( ( Object ) "delete - next" , ( Object ) "delete - next" ) ; HashtableDataSet hashtableDataSet0 = new HashtableDataSet ( properties0 ) ; Hashtable < Integer , Map < String , String > > hashtable0 = new Hashtable < Integer , Map < String , String > > ( ) ; FilterDataSet filterDataSet0 = new FilterDataSet ( ( IDataSet ) hashtableDataSet0 , ( Map < Integer , Map < String , String > > ) hashtable0 ) ; ListMessageHandler listMessageHandler0 = new ListMessageHandler ( ) ; filterDataSet0 . next ( ( IMessageHandler ) listMessageHandler0 ) ; String string0 = ( String ) filterDataSet0 . get ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test3 ( ) throws Throwable { Properties properties0 = new Properties ( ) ; HashtableDataSet hashtableDataSet0 = new HashtableDataSet ( properties0 ) ; Hashtable < Integer , Map < String , String > > hashtable0 = new Hashtable < Integer , Map < String , String > > ( ) ; FilterDataSet filterDataSet0 = new FilterDataSet ( ( IDataSet ) hashtableDataSet0 , ( Map < Integer , Map < String , String > > ) hashtable0 ) ; Object object0 = filterDataSet0 . get ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test4 ( ) throws Throwable { Properties properties0 = new Properties ( ) ; properties0 . put ( ( Object ) "delete - next" , ( Object ) "delete - next" ) ; HashtableDataSet hashtableDataSet0 = new HashtableDataSet ( properties0 ) ; Hashtable < Integer , Map < String , String > > hashtable0 = new Hashtable < Integer , Map < String , String > > ( ) ; FilterDataSet filterDataSet0 = new FilterDataSet ( ( IDataSet ) hashtableDataSet0 , ( Map < Integer , Map < String , String > > ) hashtable0 ) ; ListMessageHandler listMessageHandler0 = new ListMessageHandler ( ) ; HashMap < String , String > hashMap0 = new HashMap < String , String > ( ) ; hashtable0 . put ( ( Integer ) 0 , ( Map < String , String > ) hashMap0 ) ; filterDataSet0 . next ( ( IMessageHandler ) listMessageHandler0 ) ; String string0 = ( String ) filterDataSet0 . get ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test5 ( ) throws Throwable { Properties properties0 = new Properties ( ) ; properties0 . put ( ( Object ) "delete - next" , ( Object ) "delete - next" ) ; HashtableDataSet hashtableDataSet0 = new HashtableDataSet ( properties0 ) ; Hashtable < Integer , Map < String , String > > hashtable0 = new Hashtable < Integer , Map < String , String > > ( ) ; FilterDataSet filterDataSet0 = new FilterDataSet ( ( IDataSet ) hashtableDataSet0 , ( Map < Integer , Map < String , String > > ) hashtable0 ) ; ListMessageHandler listMessageHandler0 = new ListMessageHandler ( ) ; HashMap < String , String > hashMap0 = new HashMap < String , String > ( ) ; hashtable0 . put ( ( Integer ) 0 , ( Map < String , String > ) hashMap0 ) ; filterDataSet0 . next ( ( IMessageHandler ) listMessageHandler0 ) ; hashMap0 . put ( "delete - next" , "delete - next" ) ; String string0 = ( String ) filterDataSet0 . get ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test1 ( ) throws Throwable { DatabaseTypesDataSet databaseTypesDataSet0 = new DatabaseTypesDataSet ( ( ResultSet ) null ) ; DataSetDefinition dataSetDefinition0 = databaseTypesDataSet0 . getDataSetDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataSetDefinition getDataSetDefinition ( ) throws DataSetException { return new DataSetDefinition ( _columnDisplayDefinitions ) ; }
void test2 ( ) throws Throwable { int [ ] intArray0 = new int [ 1 ] ; DatabaseTypesDataSet databaseTypesDataSet0 = new DatabaseTypesDataSet ( ( ResultSet ) null , intArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test4 ( ) throws Throwable { DatabaseTypesDataSet databaseTypesDataSet0 = new DatabaseTypesDataSet ( ( ResultSet ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean next ( IMessageHandler msgHandler ) throws DataSetException { return + + _curIx < _allRows . size ( ) ; }
void test0 ( ) throws Throwable { ResultSetDataSet resultSetDataSet0 = new ResultSetDataSet ( ) ; int int0 = resultSetDataSet0 . getColumnCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test1 ( ) throws Throwable { ResultSetDataSet resultSetDataSet0 = new ResultSetDataSet ( ) ; int [ ] intArray0 = new int [ 1 ] ; DialectType dialectType0 = DialectType . ORACLE ; int int0 = resultSetDataSet0 . setResultSet ( ( ResultSet ) null , intArray0 , dialectType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test2 ( ) throws Throwable { ResultSetDataSet resultSetDataSet0 = new ResultSetDataSet ( ) ; List < Object [ ] > list0 = resultSetDataSet0 . getAllDataForReadOnly ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < Object [ ] > getAllDataForReadOnly ( ) { return _alData ; }
void test4 ( ) throws Throwable { ResultSetDataSet resultSetDataSet0 = new ResultSetDataSet ( ) ; DataSetDefinition dataSetDefinition0 = resultSetDataSet0 . getDataSetDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataSetDefinition getDataSetDefinition ( ) throws DataSetException { return new DataSetDefinition ( _columnDisplayDefinitions ) ; }
void test5 ( ) throws Throwable { ResultSetDataSet resultSetDataSet0 = new ResultSetDataSet ( ) ; DialectType dialectType0 = DialectType . DAFFODIL ; int int0 = resultSetDataSet0 . setResultSet ( ( ResultSet ) null , dialectType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test6 ( ) throws Throwable { ResultSetDataSet resultSetDataSet0 = new ResultSetDataSet ( ) ; resultSetDataSet0 . resetCursor ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test7 ( ) throws Throwable { ResultSetDataSet resultSetDataSet0 = new ResultSetDataSet ( ) ; DialectType dialectType0 = DialectType . NETEZZA ; int int0 = resultSetDataSet0 . setContentsTabResultSet ( ( ResultSet ) null , "jaU`TUw%vw { @ajH * z | " , dialectType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void removeRow ( String name ) { _props . removeDriverProperty ( name ) ; fireTableDataChanged ( ) ; }
void test9 ( ) throws Throwable { ResultSetDataSet resultSetDataSet0 = new ResultSetDataSet ( ) ; Object object0 = resultSetDataSet0 . get ( 8 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test10 ( ) throws Throwable { ResultSetDataSet resultSetDataSet0 = new ResultSetDataSet ( ) ; DialectType dialectType0 = DialectType . DAFFODIL ; int int0 = resultSetDataSet0 . setResultSet ( ( ResultSet ) null , dialectType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test11 ( ) throws Throwable { ResultSetDataSet resultSetDataSet0 = new ResultSetDataSet ( ) ; DialectType dialectType0 = DialectType . NETEZZA ; int int0 = resultSetDataSet0 . setContentsTabResultSet ( ( ResultSet ) null , "jaU`TUw%vw { @ajH * z | " , dialectType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test0 ( ) throws Throwable { DataSetListModel dataSetListModel0 = new DataSetListModel ( ) ; DataSetModelEvent dataSetModelEvent0 = new DataSetModelEvent ( ( IDataSetModel ) dataSetListModel0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataSetModelEvent ( IDataSetModel src ) throws IllegalArgumentException { super ( validateSource ( src ) ) ; _src = src ; }
void test0 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 1 ] ; objectArray0 [ 0 ] = ( Object ) 100 ; JavabeanArrayDataSet javabeanArrayDataSet0 = new JavabeanArrayDataSet ( objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test1 ( ) throws Throwable { Class < ? > class0 = Adjustable . class ; JavabeanArrayDataSet javabeanArrayDataSet0 = new JavabeanArrayDataSet ( class0 ) ; javabeanArrayDataSet0 . setColPos ( "8 , 8 ) sg" , 1025 ) ; javabeanArrayDataSet0 . initColsAndBeanInfo ( class0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test2 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 7 ] ; Object object0 = RenderingHints . VALUE_TEXT_ANTIALIAS_GASP ; objectArray0 [ 0 ] = object0 ; objectArray0 [ 1 ] = object0 ; objectArray0 [ 2 ] = objectArray0 [ 0 ] ; objectArray0 [ 3 ] = objectArray0 [ 2 ] ; objectArray0 [ 4 ] = objectArray0 [ 0 ] ; objectArray0 [ 5 ] = objectArray0 [ 3 ] ; objectArray0 [ 6 ] = objectArray0 [ 2 ] ; JavabeanArrayDataSet javabeanArrayDataSet0 = new JavabeanArrayDataSet ( objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test5 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 7 ] ; Object object0 = RenderingHints . VALUE_TEXT_ANTIALIAS_GASP ; objectArray0 [ 0 ] = object0 ; objectArray0 [ 1 ] = object0 ; objectArray0 [ 2 ] = objectArray0 [ 0 ] ; objectArray0 [ 3 ] = objectArray0 [ 2 ] ; objectArray0 [ 4 ] = objectArray0 [ 0 ] ; objectArray0 [ 5 ] = objectArray0 [ 3 ] ; objectArray0 [ 6 ] = objectArray0 [ 2 ] ; JavabeanArrayDataSet javabeanArrayDataSet0 = new JavabeanArrayDataSet ( objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test7 ( ) throws Throwable { Class < ? > class0 = Adjustable . class ; JavabeanArrayDataSet javabeanArrayDataSet0 = new JavabeanArrayDataSet ( class0 ) ; DataSetDefinition dataSetDefinition0 = javabeanArrayDataSet0 . getDataSetDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataSetDefinition getDataSetDefinition ( ) throws DataSetException { return new DataSetDefinition ( _columnDisplayDefinitions ) ; }
void test9 ( ) throws Throwable { Class < ? > class0 = JavabeanArrayDataSet . class ; JavabeanArrayDataSet javabeanArrayDataSet0 = new JavabeanArrayDataSet ( class0 ) ; NullMessageHandler nullMessageHandler0 = NullMessageHandler . getInstance ( ) ; boolean boolean0 = javabeanArrayDataSet0 . next ( ( IMessageHandler ) nullMessageHandler0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean next ( IMessageHandler msgHandler ) throws DataSetException { return + + _curIx < _allRows . size ( ) ; }
void test10 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 7 ] ; Object object0 = RenderingHints . VALUE_TEXT_ANTIALIAS_GASP ; objectArray0 [ 0 ] = object0 ; objectArray0 [ 1 ] = object0 ; objectArray0 [ 2 ] = objectArray0 [ 0 ] ; objectArray0 [ 3 ] = objectArray0 [ 2 ] ; objectArray0 [ 4 ] = objectArray0 [ 0 ] ; objectArray0 [ 5 ] = objectArray0 [ 3 ] ; objectArray0 [ 6 ] = objectArray0 [ 2 ] ; JavabeanArrayDataSet javabeanArrayDataSet0 = new JavabeanArrayDataSet ( objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test0 ( ) throws Throwable { RowNumberTableColumn rowNumberTableColumn0 = new RowNumberTableColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" RowNumberTableColumn ( ) { super ( ROW_NUMBER_MODEL_INDEX , 100 ) ; DefaultTableCellRenderer rend = new DefaultTableCellRenderer ( ) ; rend . setBackground ( Color . lightGray ) ; setCellRenderer ( rend ) ; setCellEditor ( new DefaultCellEditor ( new RestorableJTextField ( ) ) ) ; setHeaderValue ( ROW_NUMBER_HEADER ) ; setIdentifier ( ROW_NUMBER_COL_IDENTIFIER ) ; }
void test0 ( ) throws Throwable { Hashtable < String , String > hashtable0 = new Hashtable < String , String > ( ) ; HashtableDataSet hashtableDataSet0 = new HashtableDataSet ( hashtable0 ) ; DataSetDefinition dataSetDefinition0 = hashtableDataSet0 . getDataSetDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataSetDefinition getDataSetDefinition ( ) throws DataSetException { return new DataSetDefinition ( _columnDisplayDefinitions ) ; }
void test2 ( ) throws Throwable { Hashtable < String , String > hashtable0 = new Hashtable < String , String > ( ) ; hashtable0 . put ( "0 ? ez . 9wvmp > jEI" , "0 ? ez . 9wvmp > jEI" ) ; HashtableDataSet hashtableDataSet0 = new HashtableDataSet ( hashtable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test3 ( ) throws Throwable { Properties properties0 = new Properties ( ) ; properties0 . setProperty ( "" , "" ) ; HashtableDataSet hashtableDataSet0 = new HashtableDataSet ( properties0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean next ( IMessageHandler msgHandler ) throws DataSetException { return + + _curIx < _allRows . size ( ) ; }
void test4 ( ) throws Throwable { Hashtable < String , String > hashtable0 = new Hashtable < String , String > ( ) ; HashtableDataSet hashtableDataSet0 = new HashtableDataSet ( hashtable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean next ( IMessageHandler msgHandler ) throws DataSetException { return + + _curIx < _allRows . size ( ) ; }
void test0 ( ) throws Throwable { DataSetViewerPropertyPanel dataSetViewerPropertyPanel0 = new DataSetViewerPropertyPanel ( ) ; Object [ ] objectArray0 = new Object [ 1 ] ; objectArray0 [ 0 ] = ( Object ) dataSetViewerPropertyPanel0 ; JavabeanArrayDataSet javabeanArrayDataSet0 = new JavabeanArrayDataSet ( objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test1 ( ) throws Throwable { DataSetViewerPropertyPanel dataSetViewerPropertyPanel0 = new DataSetViewerPropertyPanel ( ) ; dataSetViewerPropertyPanel0 . moveToTop ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test2 ( ) throws Throwable { DataSetViewerPropertyPanel dataSetViewerPropertyPanel0 = new DataSetViewerPropertyPanel ( ) ; dataSetViewerPropertyPanel0 . clear ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test2 ( ) throws Throwable { DataSetViewerEditableTablePanel dataSetViewerEditableTablePanel0 = new DataSetViewerEditableTablePanel ( ) ; dataSetViewerEditableTablePanel0 . getUpdateableModel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IDataSetUpdateableModel getUpdateableModel ( ) { return _updateableModel ; }
void test5 ( ) throws Throwable { DataSetViewerTablePanel dataSetViewerTablePanel0 = new DataSetViewerTablePanel ( ) ; boolean boolean0 = dataSetViewerTablePanel0 . isColumnEditable ( 1148 , ( Object ) "LongDescription" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isColumnEditable ( int col , Object originalValue ) { return false ; }
void test8 ( ) throws Throwable { DataSetViewerEditableTablePanel dataSetViewerEditableTablePanel0 = new DataSetViewerEditableTablePanel ( ) ; JTable jTable0 = new JTable ( ) ; TableState tableState0 = new TableState ( jTable0 ) ; dataSetViewerEditableTablePanel0 . applyResultSortableTableState ( tableState0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void applyResultSortableTableState ( TableState sortableTableState ) { _resultSetOutput . applyResultSortableTableState ( sortableTableState ) ; }
void test9 ( ) throws Throwable { DataSetViewerTablePanel dataSetViewerTablePanel0 = new DataSetViewerTablePanel ( ) ; dataSetViewerTablePanel0 . deleteRows ( ( int [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String deleteRows ( Object [ ] [ ] rowData , ColumnDisplayDefinition [ ] colDefs ) { return _dataSetUpdateableTableModel . deleteRows ( rowData , colDefs ) ; }
void test12 ( ) throws Throwable { DataSetViewerTablePanel dataSetViewerTablePanel0 = new DataSetViewerTablePanel ( ) ; DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; Object [ ] [ ] objectArray0 = new Object [ 13 ] [ 6 ] ; Object [ ] objectArray1 = new Object [ 3 ] ; objectArray1 [ 0 ] = ( Object ) dataSetUpdateableTableModelImpl0 ; objectArray1 [ 1 ] = ( Object ) dataSetViewerTablePanel0 ; objectArray1 [ 2 ] = ( Object ) dataSetUpdateableTableModelImpl0 ; JTable jTable0 = new JTable ( objectArray0 , objectArray1 ) ; dataSetViewerTablePanel0 . setCellEditors ( jTable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setCellEditors ( JTable table ) { }
void test16 ( ) throws Throwable { DataSetViewerTablePanel dataSetViewerTablePanel0 = new DataSetViewerTablePanel ( ) ; DataSetUpdateableTableModelImpl dataSetUpdateableTableModelImpl0 = new DataSetUpdateableTableModelImpl ( ) ; dataSetViewerTablePanel0 . changeUnderlyingValueAt ( 0 , 0 , ( Object ) dataSetUpdateableTableModelImpl0 , ( Object ) dataSetUpdateableTableModelImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] changeUnderlyingValueAt ( int row , int col , Object newValue , Object oldValue ) { return new int [ 0 ] ; / / underlaying data cannot be changed }
void test17 ( ) throws Throwable { DataSetViewerEditableTablePanel dataSetViewerEditableTablePanel0 = new DataSetViewerEditableTablePanel ( ) ; dataSetViewerEditableTablePanel0 . getComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JComponent getComponent ( ) { checkInit ( ) ; return _component ; }
void test20 ( ) throws Throwable { DataSetViewerTablePanel dataSetViewerTablePanel0 = new DataSetViewerTablePanel ( ) ; dataSetViewerTablePanel0 . insertRow ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String insertRow ( Object [ ] values , ColumnDisplayDefinition [ ] colDefs ) { return _dataSetUpdateableTableModel . insertRow ( values , colDefs ) ; }
void test24 ( ) throws Throwable { DataSetViewerEditableTablePanel dataSetViewerEditableTablePanel0 = new DataSetViewerEditableTablePanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { PrinterJob printJob = PrinterJob . getPrinterJob ( ) ; printJob . setPrintable ( this ) ; if ( printJob . printDialog ( ) ) { try { printJob . print ( ) ; } catch ( PrinterException pe ) { s_log . error ( "Error printing" , pe ) ; } } }
void test0 ( ) throws Throwable { JavabeanDataSet javabeanDataSet0 = new JavabeanDataSet ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test2 ( ) throws Throwable { JavabeanDataSet javabeanDataSet0 = new JavabeanDataSet ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean next ( IMessageHandler msgHandler ) throws DataSetException { return + + _curIx < _allRows . size ( ) ; }
void test3 ( ) throws Throwable { JavabeanDataSet javabeanDataSet0 = new JavabeanDataSet ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test1 ( ) throws Throwable { DataSetScrollingPanel dataSetScrollingPanel0 = new DataSetScrollingPanel ( ) ; IDataSetViewer iDataSetViewer0 = dataSetScrollingPanel0 . getViewer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" HtmlViewerSheet getViewer ( MainFrame parent , URL url ) { if ( parent = = null ) { throw new IllegalArgumentException ( "MainFrame = = null" ) ; } if ( url = = null ) { throw new IllegalArgumentException ( "URL = = null" ) ; } HtmlViewerSheet viewer = _sheets . get ( url . toString ( ) ) ; if ( viewer = = null ) { viewer = new HtmlViewerSheet ( parent . getApplication ( ) , url . toString ( ) , url ) ; / / viewer . addInternalFrameListener ( _lis ) ; viewer . addWindowListener ( _lis ) ; viewer . setSize ( 600 , 400 ) ; / / parent . addInternalFrame ( viewer , true , null ) ; / / GUIUtils . centerWithinDesktop ( viewer ) ; GUIUtils . centerWithinParent ( viewer ) ; _sheets . put ( url . toString ( ) , viewer ) ; } return viewer ; }
void test2 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { DataSetScrollingPanel dataSetScrollingPanel0 = new DataSetScrollingPanel ( ) ; EmptyDataSet emptyDataSet0 = new EmptyDataSet ( ) ; dataSetScrollingPanel0 . load ( ( IDataSet ) emptyDataSet0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test3 ( ) throws Throwable { DataSetScrollingPanel dataSetScrollingPanel0 = new DataSetScrollingPanel ( ) ; dataSetScrollingPanel0 . clear ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void clear ( ) ; / * * * Return the current SQL script . * * @return Current SQL script . * / String getSqlString ( ) ; / * * * Return the current SQL script with control characters removed . * * @return Current SQL script . * / String getViewableSqlString ( ) ; / * * * Return the title for this tab . * / String getTitle ( ) ; / * * * Close this tab . * / void closeTab ( ) ; void returnToTabbedPane ( ) ; Component getOutputComponent ( ) ; void reRunSQL ( ) ; / * * * @see IHasIdentifier#getIdentifier ( ) * / IIdentifier getIdentifier ( ) ; TableState getResultSortableTableState ( ) ; }
void test1 ( ) throws Throwable { EmptyDataSet emptyDataSet0 = new EmptyDataSet ( ) ; int int0 = emptyDataSet0 . getColumnCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test2 ( ) throws Throwable { EmptyDataSet emptyDataSet0 = new EmptyDataSet ( ) ; DataSetDefinition dataSetDefinition0 = emptyDataSet0 . getDataSetDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataSetDefinition getDataSetDefinition ( ) throws DataSetException { return new DataSetDefinition ( _columnDisplayDefinitions ) ; }
void test3 ( ) throws Throwable { EmptyDataSet emptyDataSet0 = new EmptyDataSet ( ) ; ListMessageHandler listMessageHandler0 = new ListMessageHandler ( ) ; boolean boolean0 = emptyDataSet0 . next ( ( IMessageHandler ) listMessageHandler0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean next ( IMessageHandler msgHandler ) throws DataSetException { return + + _curIx < _allRows . size ( ) ; }
void test0 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { try { File file0 = new File ( "u" , "u" ) ; DataSetViewerTextFileDestination dataSetViewerTextFileDestination0 = new DataSetViewerTextFileDestination ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test1 ( ) throws Throwable { File file0 = new File ( "u" , "u" ) ; DataSetViewerTextFileDestination dataSetViewerTextFileDestination0 = new DataSetViewerTextFileDestination ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test2 ( ) throws Throwable { File file0 = new File ( "fc | yG_" ) ; DataSetViewerTextFileDestination dataSetViewerTextFileDestination0 = new DataSetViewerTextFileDestination ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test3 ( ) throws Throwable { File file0 = new File ( " / 1GjpD@" ) ; DataSetViewerTextFileDestination dataSetViewerTextFileDestination0 = new DataSetViewerTextFileDestination ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JComponent getComponent ( ) { checkInit ( ) ; return _component ; }
void test1 ( ) throws Throwable { CellImportExportInfoSaver cellImportExportInfoSaver0 = new CellImportExportInfoSaver ( ) ; CellImportExportInfo cellImportExportInfo0 = cellImportExportInfoSaver0 . get ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test2 ( ) throws Throwable { CellImportExportInfoSaver cellImportExportInfoSaver0 = CellImportExportInfoSaver . getInstance ( ) ; CellImportExportInfo cellImportExportInfo0 = new CellImportExportInfo ( "" , "" , "" ) ; cellImportExportInfoSaver0 . add ( cellImportExportInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTableColumnName ( ) { return _tableColumnName ; }
void test10 ( ) throws Throwable { CellImportExportInfoSaver cellImportExportInfoSaver0 = CellImportExportInfoSaver . getInstance ( ) ; CellImportExportInfo [ ] cellImportExportInfoArray0 = cellImportExportInfoSaver0 . getData ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLHistoryItem [ ] getData ( ) { SQLHistoryItem [ ] data = new SQLHistoryItem [ _history . size ( ) ] ; return _history . toArray ( data ) ; }
void test0 ( ) throws Throwable { JTableHeader jTableHeader0 = new JTableHeader ( ) ; TableCellRenderer tableCellRenderer0 = jTableHeader0 . getDefaultRenderer ( ) ; ExtTableColumn extTableColumn0 = new ExtTableColumn ( 0 , 0 , tableCellRenderer0 , ( TableCellEditor ) null ) ; ColumnDisplayDefinition columnDisplayDefinition0 = extTableColumn0 . getColumnDisplayDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ColumnDisplayDefinition getColumnDisplayDefinition ( ) { return _columnDefinition ; }
void test1 ( ) throws Throwable { JTableHeader jTableHeader0 = new JTableHeader ( ) ; TableCellRenderer tableCellRenderer0 = jTableHeader0 . getDefaultRenderer ( ) ; ExtTableColumn extTableColumn0 = new ExtTableColumn ( 0 , 0 , tableCellRenderer0 , ( TableCellEditor ) null ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 164 ) , "" ) ; extTableColumn0 . setColumnDisplayDefinition ( columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNullable ( ) { return _nullable ; }
void test0 ( ) throws Throwable { CellImportExportInfo cellImportExportInfo0 = new CellImportExportInfo ( ) ; cellImportExportInfo0 . setFileName ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTableColumnName ( ) { return _tableColumnName ; }
void test1 ( ) throws Throwable { CellImportExportInfo cellImportExportInfo0 = new CellImportExportInfo ( ) ; String string0 = cellImportExportInfo0 . getTableColumnName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTableColumnName ( ) { return _tableColumnName ; }
void test2 ( ) throws Throwable { CellImportExportInfo cellImportExportInfo0 = new CellImportExportInfo ( ) ; String string0 = cellImportExportInfo0 . getCommand ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCommand ( ) { if ( _dlg . chkExecCommand . isSelected ( ) ) { / / Copied from Java Doc Matcher . replaceAll : / / / / Note that backslashes ( \ ) and dollar signs ( $ ) in the replacement string / / may cause the results to be different than if it / / were being treated as a literal replacement string . / / Dollar signs may be treated as references to / / captured subsequences as described above , and / / backslashes are used to escape literal characters in the replacement string . return _dlg . txtCommand . getText ( ) . replaceAll ( "%file" , _dlg . txtFile . getText ( ) . replaceAll ( "\\\\" , "\\\\\\\\" ) ) ; } else { return null ; } }
void test3 ( ) throws Throwable { CellImportExportInfo cellImportExportInfo0 = new CellImportExportInfo ( ) ; cellImportExportInfo0 . setCommand ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFileName ( ) { return _fileName ; }
void test4 ( ) throws Throwable { CellImportExportInfo cellImportExportInfo0 = new CellImportExportInfo ( ) ; String string0 = cellImportExportInfo0 . getFileName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFileName ( ) { return _fileName ; }
void test5 ( ) throws Throwable { CellImportExportInfo cellImportExportInfo0 = new CellImportExportInfo ( ) ; cellImportExportInfo0 . setTableColumnName ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCommand ( ) { if ( _dlg . chkExecCommand . isSelected ( ) ) { / / Copied from Java Doc Matcher . replaceAll : / / / / Note that backslashes ( \ ) and dollar signs ( $ ) in the replacement string / / may cause the results to be different than if it / / were being treated as a literal replacement string . / / Dollar signs may be treated as references to / / captured subsequences as described above , and / / backslashes are used to escape literal characters in the replacement string . return _dlg . txtCommand . getText ( ) . replaceAll ( "%file" , _dlg . txtFile . getText ( ) . replaceAll ( "\\\\" , "\\\\\\\\" ) ) ; } else { return null ; } }
void test2 ( ) throws Throwable { DataSetViewerPropertyPanel dataSetViewerPropertyPanel0 = new DataSetViewerPropertyPanel ( ) ; dataSetViewerPropertyPanel0 . init ( ( IDataSetUpdateableModel ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowHeadings ( ) { return _showHeadings ; }
void test3 ( ) throws Throwable { DataSetViewerEditableTablePanel dataSetViewerEditableTablePanel0 = new DataSetViewerEditableTablePanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowHeadings ( ) { return _showHeadings ; }
void test4 ( ) throws Throwable { DataSetViewerEditableTablePanel dataSetViewerEditableTablePanel0 = new DataSetViewerEditableTablePanel ( ) ; dataSetViewerEditableTablePanel0 . setUpdateableModelReference ( ( IDataSetUpdateableModel ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowHeadings ( ) { return _showHeadings ; }
void test5 ( ) throws Throwable { DataSetViewerPropertyPanel dataSetViewerPropertyPanel0 = new DataSetViewerPropertyPanel ( ) ; dataSetViewerPropertyPanel0 . applyResultSortableTableState ( ( TableState ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowHeadings ( ) { return _showHeadings ; }
void test7 ( ) throws Throwable { DataSetViewerPropertyPanel dataSetViewerPropertyPanel0 = new DataSetViewerPropertyPanel ( ) ; EmptyDataSet emptyDataSet0 = new EmptyDataSet ( ) ; dataSetViewerPropertyPanel0 . show ( ( IDataSet ) emptyDataSet0 , ( IMessageHandler ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowHeadings ( ) { return _showHeadings ; }
void test8 ( ) throws Throwable { DataSetViewerPropertyPanel dataSetViewerPropertyPanel0 = new DataSetViewerPropertyPanel ( ) ; ResultSetDataSet resultSetDataSet0 = new ResultSetDataSet ( ) ; NullMessageHandler nullMessageHandler0 = NullMessageHandler . getInstance ( ) ; dataSetViewerPropertyPanel0 . show ( ( IDataSet ) resultSetDataSet0 , ( IMessageHandler ) nullMessageHandler0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getShowHeadings ( ) { return _showHeadings ; }
void test0 ( ) throws Throwable { DataSetViewerTextPanel dataSetViewerTextPanel0 = new DataSetViewerTextPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test1 ( ) throws Throwable { DataSetViewerTextPanel dataSetViewerTextPanel0 = new DataSetViewerTextPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test2 ( ) throws Throwable { DataSetViewerTextPanel dataSetViewerTextPanel0 = new DataSetViewerTextPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRowCount ( ) { return _dataScales . length ; }
void test0 ( ) throws Throwable { HashMap < MapDataSet , Object > hashMap0 = new HashMap < MapDataSet , Object > ( ) ; MapDataSet mapDataSet0 = new MapDataSet ( ( Map < ? , ? > ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test1 ( ) throws Throwable { HashMap < MapDataSet , Object > hashMap0 = new HashMap < MapDataSet , Object > ( ) ; MapDataSet mapDataSet0 = new MapDataSet ( ( Map < ? , ? > ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test3 ( ) throws Throwable { HashMap < MapDataSet , MapDataSet > hashMap0 = new HashMap < MapDataSet , MapDataSet > ( ) ; MapDataSet mapDataSet0 = new MapDataSet ( ( Map < ? , ? > ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test4 ( ) throws Throwable { HashMap < MapDataSet , String > hashMap0 = new HashMap < MapDataSet , String > ( ) ; MapDataSet mapDataSet0 = new MapDataSet ( ( Map < ? , ? > ) hashMap0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test0 ( ) throws Throwable { JTable jTable0 = new JTable ( 2011 , 2011 ) ; TableState tableState0 = new TableState ( jTable0 ) ; tableState0 . apply ( jTable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void apply ( JTable table ) { Runnable runnable = new Runnable ( ) { void run ( ) { doApply ( table ) ; } } ; SwingUtilities . invokeLater ( runnable ) ; }
void test1 ( ) throws Throwable { JTable jTable0 = new JTable ( 2011 , 2011 ) ; DefaultTableModel defaultTableModel0 = ( DefaultTableModel ) jTable0 . getModel ( ) ; SortableTableModel sortableTableModel0 = new SortableTableModel ( ( TableModel ) defaultTableModel0 ) ; DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel ( ) ; JTable jTable1 = new JTable ( ( TableModel ) sortableTableModel0 , ( TableColumnModel ) defaultTableColumnModel0 ) ; TableState tableState0 = new TableState ( jTable1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TableState ( JTable table ) { if ( table . getModel ( ) instanceof SortableTableModel ) { _applySorting = true ; _sortedColumn = ( ( SortableTableModel ) table . getModel ( ) ) . getSortedColumn ( ) ; _sortedAscending = ( ( SortableTableModel ) table . getModel ( ) ) . isSortedAscending ( ) ; } _selectedRow = table . getSelectedRow ( ) ; for ( int i = 0 ; i < table . getColumnModel ( ) . getColumnCount ( ) ; i + + ) { TableColumn column = table . getColumnModel ( ) . getColumn ( i ) ; _columnWidthsByModelIndex . put ( column . getModelIndex ( ) , column . getWidth ( ) ) ; _columnIndexByModelIndex . put ( column . getModelIndex ( ) , i ) ; } _visibleRect = table . getVisibleRect ( ) ; }
void test0 ( ) throws Throwable { JTable jTable0 = new JTable ( 490 , 490 ) ; DialectType dialectType0 = DialectType . DAFFODIL ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 490 , "Receiving events from a series that does not belong to this collection . " , "" , "" , 490 , "Receiving events from a series that does not belong to this collection . " , true , 490 , 490 , ( - 1692 ) , true , true , true , dialectType0 ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) dataTypeBoolean0 . getJTextArea ( ( Object ) "java . lang . Boolean" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test1 ( ) throws Throwable { JTable jTable0 = new JTable ( 732 , 732 ) ; DialectType dialectType0 = DialectType . H2 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 518 ) , "" , "" , "" , 1 , "" , false , 0 , 732 , 883 , false , true , false , dialectType0 ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeBoolean0 . getJTextField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test2 ( ) throws Throwable { JTable jTable0 = new JTable ( 490 , 490 ) ; DialectType dialectType0 = DialectType . DAFFODIL ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 490 , "Receiving events from a series that does not belong to this collection . " , "" , "" , 490 , "Receiving events from a series that does not belong to this collection . " , true , 490 , 490 , ( - 1692 ) , true , true , true , dialectType0 ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( jTable0 , columnDisplayDefinition0 ) ; String string0 = dataTypeBoolean0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test3 ( ) throws Throwable { JTable jTable0 = new JTable ( 732 , 732 ) ; DialectType dialectType0 = DialectType . MSSQL ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 732 , " < null > " , " < null > " , " < null > " , ( - 1470 ) , " < null > " , false , 0 , ( - 518 ) , 0 , false , false , false , dialectType0 ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBoolean0 . isEditableInCell ( ( Object ) "ToolTipText" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test4 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 , ( TableColumnModel ) null ) ; DialectType dialectType0 = DialectType . INGRES ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" , "" , "" , 0 , "" , true , 0 , 0 , 0 , true , true , true , dialectType0 ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBoolean0 . useBinaryEditingPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test5 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "dc : Y~" ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( ( JTable ) null , columnDisplayDefinition0 ) ; StringBuffer stringBuffer0 = new StringBuffer ( 0 ) ; Boolean boolean0 = ( Boolean ) dataTypeBoolean0 . validateAndConvert ( "dc : Y~" , ( Object ) "contentAreaFilled" , stringBuffer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test6 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "dc : Y~" ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBoolean0 . canDoFileIO ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test7 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "dc : Y~" ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( ( JTable ) null , columnDisplayDefinition0 ) ; StringBuffer stringBuffer0 = new StringBuffer ( 0 ) ; Boolean boolean0 = ( Boolean ) dataTypeBoolean0 . validateAndConvert ( "dc : Y~" , ( Object ) "contentAreaFilled" , stringBuffer0 ) ; Boolean boolean1 = ( Boolean ) dataTypeBoolean0 . validateAndConvertInPopup ( "dc : Y~" , ( Object ) boolean0 , stringBuffer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test8 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; Object [ ] [ ] objectArray0 = new Object [ 3 ] [ 5 ] ; Object [ ] objectArray1 = new Object [ 4 ] ; objectArray1 [ 0 ] = ( Object ) xYDatasetTableModel0 ; objectArray1 [ 1 ] = ( Object ) xYDatasetTableModel0 ; objectArray1 [ 2 ] = ( Object ) xYDatasetTableModel0 ; objectArray1 [ 3 ] = ( Object ) xYDatasetTableModel0 ; objectArray0 [ 0 ] = objectArray1 ; JTable jTable0 = new JTable ( objectArray0 , objectArray0 [ 0 ] ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 607 ) , "" ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBoolean0 . needToReRead ( objectArray1 [ 3 ] ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean needToReRead ( int col , Object originalValue ) { / / call the DataType object for this column and have it check the current value return CellComponentFactory . needToReRead ( _colDefs [ col ] , originalValue ) ; }
void test9 ( ) throws Throwable { JTable jTable0 = new JTable ( 732 , 732 ) ; DialectType dialectType0 = DialectType . MSSQL ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 732 , " < null > " , " < null > " , " < null > " , ( - 1470 ) , " < null > " , false , 0 , ( - 518 ) , 0 , false , false , false , dialectType0 ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( jTable0 , columnDisplayDefinition0 ) ; StringBuffer stringBuffer0 = new StringBuffer ( 732 ) ; Boolean boolean0 = ( Boolean ) dataTypeBoolean0 . validateAndConvert ( " < null > " , ( Object ) "NOID" , stringBuffer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test10 ( ) throws Throwable { DialectType dialectType0 = DialectType . POSTGRES ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" , "" , "" , 0 , "" , false , ( - 143 ) , 101 , 0 , true , true , false , dialectType0 ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( ( JTable ) null , columnDisplayDefinition0 ) ; Boolean boolean0 = ( Boolean ) dataTypeBoolean0 . getDefaultValue ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test11 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "dc : Y~" ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( ( JTable ) null , columnDisplayDefinition0 ) ; StringBuffer stringBuffer0 = new StringBuffer ( 0 ) ; Boolean boolean0 = ( Boolean ) dataTypeBoolean0 . validateAndConvert ( "dc : Y~" , ( Object ) "contentAreaFilled" , stringBuffer0 ) ; ParameterWhereClausePart parameterWhereClausePart0 = ( ParameterWhereClausePart ) dataTypeBoolean0 . getWhereClauseValue ( ( Object ) boolean0 , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean shouldBeUsed ( ) { return false ; }
void test14 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . GENERIC ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1882 ) , ( String ) null , ( String ) null , ( String ) null , 1678 , ( String ) null , false , 27 , 2019 , 2019 , true , true , true , dialectType0 ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( jTable0 , columnDisplayDefinition0 ) ; Boolean boolean0 = ( Boolean ) dataTypeBoolean0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test15 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . GENERIC ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1882 ) , ( String ) null , ( String ) null , ( String ) null , 1958 , ( String ) null , true , 1958 , 27 , 786 , false , true , false , dialectType0 ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( jTable0 , columnDisplayDefinition0 ) ; Boolean boolean0 = ( Boolean ) dataTypeBoolean0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { DialectType dialectType0 = DialectType . SYBASEASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 31 ) , "C & Pued [ > | L . " , "C & Pued [ > | L . " , "C & Pued [ > | L . " , ( - 31 ) , "C & Pued [ > | L . " , false , ( - 31 ) , ( - 31 ) , ( - 31 ) , false , false , false , dialectType0 ) ; JTable jTable0 = new JTable ( ( TableModel ) null ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; dataTypeBinary0 . setTable ( jTable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test1 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1409 , "" ) ; DataTypeInteger dataTypeInteger0 = new DataTypeInteger ( jTable0 , columnDisplayDefinition0 ) ; dataTypeInteger0 . setColumnDisplayDefinition ( columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test2 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , ( String ) null ) ; DataTypeBoolean dataTypeBoolean0 = new DataTypeBoolean ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextArea restorableJTextArea0 = new RestorableJTextArea ( ) ; KeyListener keyListener0 = dataTypeBoolean0 . getKeyListener ( ( IRestorableTextComponent ) restorableJTextArea0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" KeyListener getKeyListener ( IRestorableTextComponent component ) { return null ; }
void test3 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1409 , "" ) ; DataTypeByte dataTypeByte0 = new DataTypeByte ( jTable0 , columnDisplayDefinition0 ) ; ToolkitBeepHelper toolkitBeepHelper0 = new ToolkitBeepHelper ( ) ; dataTypeByte0 . setBeepHelper ( ( IToolkitBeepHelper ) toolkitBeepHelper0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test4 ( ) throws Throwable { DialectType dialectType0 = DialectType . SYBASEASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 31 ) , "C & Pued [ > | L . " , "C & Pued [ > | L . " , "C & Pued [ > | L . " , ( - 31 ) , "C & Pued [ > | L . " , false , ( - 31 ) , ( - 31 ) , ( - 31 ) , false , false , false , dialectType0 ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeClob0 . areEqual ( ( Object ) null , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean areEqual ( Object obj1 , Object obj2 ) ; / * * Cell related methods come next . * / / * * * Convert the given object into its printable String value for use in Text * output and the in - cell representations ( CellRenderer and CellEditor ) . * / String renderObject ( Object object ) ; / * * * Returns true if data type may be edited within a table cell , false if * not . * / boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test5 ( ) throws Throwable { DialectType dialectType0 = DialectType . SYBASEASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 31 ) , "C & Pued [ > | L . " , "C & Pued [ > | L . " , "C & Pued [ > | L . " , ( - 31 ) , "C & Pued [ > | L . " , false , ( - 31 ) , ( - 31 ) , ( - 31 ) , false , false , false , dialectType0 ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( ( JTable ) null , columnDisplayDefinition0 ) ; JTable jTable0 = new JTable ( ( TableModel ) null ) ; DataTypeInteger dataTypeInteger0 = new DataTypeInteger ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeInteger0 . areEqual ( ( Object ) "SYBASEASE" , ( Object ) dataTypeClob0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean areEqual ( Object obj1 , Object obj2 ) ; / * * Cell related methods come next . * / / * * * Convert the given object into its printable String value for use in Text * output and the in - cell representations ( CellRenderer and CellEditor ) . * / String renderObject ( Object object ) ; / * * * Returns true if data type may be edited within a table cell , false if * not . * / boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test6 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1409 , "" ) ; DataTypeString dataTypeString0 = new DataTypeString ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeString0 . areEqual ( ( Object ) null , ( Object ) "LOWER_RIGHT_CORNER" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean areEqual ( Object obj1 , Object obj2 ) ; / * * Cell related methods come next . * / / * * * Convert the given object into its printable String value for use in Text * output and the in - cell representations ( CellRenderer and CellEditor ) . * / String renderObject ( Object object ) ; / * * * Returns true if data type may be edited within a table cell , false if * not . * / boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test2 ( ) throws Throwable { String string0 = DTProperties . get ( "" , "U ( 3" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test3 ( ) throws Throwable { String string0 = DTProperties . get ( "ubt8~L [ C^ik\"e1" , "ubt8~L [ C^ik\"e1" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test0 ( ) throws Throwable { OkJPanel okJPanel0 = DataTypeJavaObject . getControlPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" OkJPanel getControlPanel ( ) { / * * If you add this method to one of the standard DataTypes in the * fw / datasetviewer / cellcomponent directory , you must also add the name * of that DataType class to the list in CellComponentFactory , method * getControlPanels , variable named initialClassNameList . * If the class is being registered with the factory using registerDataType , * then you should not include the class name in the list ( it will be found * automatically ) , but if the DataType is part of the case statement in the * factory method getDataTypeObject , then it does need to be explicitly listed * in the getControlPanels method also . * / / / if this panel is called before any instances of the class have been / / created , we need to load the properties from the DTProperties . loadProperties ( ) ; return new UnknownOkJPanel ( ) ; }
void test1 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "'" ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( ( JTable ) null , columnDisplayDefinition0 ) ; BigDecimal bigDecimal0 = BigDecimal . ZERO ; boolean boolean0 = dataTypeJavaObject0 . isEditableInCell ( ( Object ) bigDecimal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test3 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 5 ] ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( objectArray0 , 64 ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 ) ; DialectType dialectType0 = DialectType . FIREBIRD ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 64 , "" , "" , "" , 64 , "" , false , 64 , 64 , 64 , false , false , false , dialectType0 ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeJavaObject0 . useBinaryEditingPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test4 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . INTERBASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" , "" , "" , 0 , "" , true , 0 , 0 , 0 , true , true , true , dialectType0 ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeJavaObject0 . canDoFileIO ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test5 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 5 ] ; Object object0 = RenderingHints . VALUE_DITHER_DEFAULT ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( objectArray0 , 64 ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 ) ; DialectType dialectType0 = DialectType . FIREBIRD ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 64 , "" , "" , "" , 64 , "" , false , 64 , 64 , 64 , false , false , false , dialectType0 ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) dataTypeJavaObject0 . getJTextArea ( object0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test6 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "'" ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeJavaObject0 . needToReRead ( ( Object ) "layeredPane" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean needToReRead ( int col , Object originalValue ) { / / call the DataType object for this column and have it check the current value return CellComponentFactory . needToReRead ( _colDefs [ col ] , originalValue ) ; }
void test7 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) xYDatasetTableModel0 , ( TableColumnModel ) null ) ; DialectType dialectType0 = DialectType . MCKOI ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1787 , "" , "" , "" , 1787 , "" , false , 1787 , 1787 , 1787 , false , false , false , dialectType0 ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeJavaObject0 . isEditableInPopup ( ( Object ) "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test8 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . DERBY ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1318 ) , "" , "" , "" , ( - 1318 ) , "" , false , ( - 1318 ) , ( - 1318 ) , ( - 1318 ) , false , false , false , dialectType0 ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( jTable0 , columnDisplayDefinition0 ) ; Object object0 = dataTypeJavaObject0 . getDefaultValue ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test9 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1335 ) , "1h3 | , VHJ@cDP8 - %J" ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( ( JTable ) null , columnDisplayDefinition0 ) ; String string0 = dataTypeJavaObject0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test10 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "'" ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( ( JTable ) null , columnDisplayDefinition0 ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeJavaObject0 . getJTextField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test13 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1335 ) , "1h3 | , VHJ@cDP8 - %J" ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( ( JTable ) null , columnDisplayDefinition0 ) ; ParameterWhereClausePart parameterWhereClausePart0 = ( ParameterWhereClausePart ) dataTypeJavaObject0 . getWhereClauseValue ( ( Object ) "1h3 | , VHJ@cDP8 - %J" , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean shouldBeUsed ( ) { return false ; }
void test15 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 ) ; DialectType dialectType0 = DialectType . ORACLE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 996 , ( String ) null , ( String ) null , ( String ) null , 996 , ( String ) null , false , 996 , 996 , 996 , false , false , false , dialectType0 ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( jTable0 , columnDisplayDefinition0 ) ; Object object0 = dataTypeJavaObject0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test16 ( ) throws Throwable { JTable jTable0 = new JTable ( 0 , 0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , ( String ) null ) ; DataTypeJavaObject dataTypeJavaObject0 = new DataTypeJavaObject ( jTable0 , columnDisplayDefinition0 ) ; Object object0 = dataTypeJavaObject0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { RestorableJTextArea restorableJTextArea0 = new RestorableJTextArea ( ) ; restorableJTextArea0 . updateText ( "t . o ) _ = iQ5L^ - x = : ] vO$" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test1 ( ) throws Throwable { RestorableJTextArea restorableJTextArea0 = new RestorableJTextArea ( ) ; restorableJTextArea0 . restoreText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test2 ( ) throws Throwable { RestorableJTextArea restorableJTextArea0 = new RestorableJTextArea ( ) ; restorableJTextArea0 . setText ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test3 ( ) throws Throwable { RestorableJTextArea restorableJTextArea0 = new RestorableJTextArea ( ) ; restorableJTextArea0 . setText ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test0 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1840 , "04s5 | k" ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeLong0 . needToReRead ( ( Object ) "increment" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean needToReRead ( int col , Object originalValue ) { / / call the DataType object for this column and have it check the current value return CellComponentFactory . needToReRead ( _colDefs [ col ] , originalValue ) ; }
void test1 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( 1517 , 255 ) ; DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 , ( TableColumnModel ) defaultTableColumnModel0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1517 , "'n^z" ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeLong0 . getJTextField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test2 ( ) throws Throwable { JTable jTable0 = new JTable ( 0 , 0 ) ; DialectType dialectType0 = DialectType . MAXDB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" , "" , "" , 0 , "" , false , 0 , 0 , 0 , false , false , false , dialectType0 ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeLong0 . isEditableInCell ( ( Object ) "chromaticity" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test3 ( ) throws Throwable { DialectType dialectType0 = DialectType . AXION ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 960 , " > ] v1Y ( SO~IP + 1" , " > ] v1Y ( SO~IP + 1" , " > ] v1Y ( SO~IP + 1" , 0 , " > ] v1Y ( SO~IP + 1" , true , 0 , 960 , 0 , true , true , false , dialectType0 ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeLong0 . canDoFileIO ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test4 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "04s5 | k" ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeLong0 . useBinaryEditingPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test5 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1840 , "04s5 | k" ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( jTable0 , columnDisplayDefinition0 ) ; String string0 = dataTypeLong0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test6 ( ) throws Throwable { JTable jTable0 = new JTable ( ( TableModel ) null ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( jTable0 , columnDisplayDefinition0 ) ; Object object0 = dataTypeLong0 . validateAndConvertInPopup ( "" , ( Object ) "AccessibleDescription" , ( StringBuffer ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test7 ( ) throws Throwable { JTable jTable0 = new JTable ( 0 , 0 ) ; DialectType dialectType0 = DialectType . MAXDB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" , "" , "" , 0 , "" , false , 0 , 0 , 0 , false , false , false , dialectType0 ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeLong0 . isEditableInPopup ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test8 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , ( String ) null ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) dataTypeLong0 . getJTextArea ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test9 ( ) throws Throwable { DialectType dialectType0 = DialectType . MCKOI ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1713 , "H2" , "H2" , "H2" , 1713 , "H2" , false , 1713 , 1713 , 1713 , false , false , false , dialectType0 ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( ( JTable ) null , columnDisplayDefinition0 ) ; ParameterWhereClausePart parameterWhereClausePart0 = ( ParameterWhereClausePart ) dataTypeLong0 . getWhereClauseValue ( ( Object ) "selectedIcon" , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean shouldBeUsed ( ) { return false ; }
void test11 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "04s5 | k" ) ; columnDisplayDefinition0 . setIsNullable ( false ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( jTable0 , columnDisplayDefinition0 ) ; Long long0 = ( Long ) dataTypeLong0 . getDefaultValue ( "increment" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test13 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , ( String ) null ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( jTable0 , columnDisplayDefinition0 ) ; Long long0 = ( Long ) dataTypeLong0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test14 ( ) throws Throwable { JTable jTable0 = new JTable ( 0 , 0 ) ; DialectType dialectType0 = DialectType . MAXDB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" , "" , "" , 0 , "" , false , 0 , 0 , 0 , false , false , false , dialectType0 ) ; DataTypeLong dataTypeLong0 = new DataTypeLong ( jTable0 , columnDisplayDefinition0 ) ; Long long0 = ( Long ) dataTypeLong0 . getDefaultValue ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1957 ) , "NN ( Tb ! Ic & 9W'C6YkT" ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeOther0 . getJTextField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test1 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1957 ) , "NN ( Tb ! Ic & 9W'C6YkT" ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeOther0 . isEditableInPopup ( ( Object ) "37777774133" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test2 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1957 ) , "NN ( Tb ! Ic & 9W'C6YkT" ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) dataTypeOther0 . getJTextArea ( ( Object ) "37777774133" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test3 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , " } V6^" ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeOther0 . needToReRead ( ( Object ) jTable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean needToReRead ( int col , Object originalValue ) { / / call the DataType object for this column and have it check the current value return CellComponentFactory . needToReRead ( _colDefs [ col ] , originalValue ) ; }
void test4 ( ) throws Throwable { DialectType dialectType0 = DialectType . INFORMIX ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1530 ) , ( String ) null , ( String ) null , ( String ) null , 0 , ( String ) null , false , ( - 1530 ) , ( - 1530 ) , ( - 1530 ) , false , false , false , dialectType0 ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( ( JTable ) null , columnDisplayDefinition0 ) ; StringBuffer stringBuffer0 = new StringBuffer ( ( CharSequence ) "" ) ; Object object0 = dataTypeOther0 . validateAndConvertInPopup ( "" , ( Object ) "comboBoxChanged" , stringBuffer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test5 ( ) throws Throwable { DialectType dialectType0 = DialectType . FIREBIRD ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 983 , "B19f ! al } e\"4 ? > , " , "B19f ! al } e\"4 ? > , " , "B19f ! al } e\"4 ? > , " , 983 , "B19f ! al } e\"4 ? > , " , true , 983 , 983 , 983 , true , true , true , dialectType0 ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeOther0 . useBinaryEditingPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test6 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1957 ) , "NN ( Tb ! Ic & 9W'C6YkT" ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( jTable0 , columnDisplayDefinition0 ) ; String string0 = dataTypeOther0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test7 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "Argument 'd' outside valid range . " ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeOther0 . canDoFileIO ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test9 ( ) throws Throwable { OkJPanel okJPanel0 = DataTypeOther . getControlPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" OkJPanel getControlPanel ( ) { / * * If you add this method to one of the standard DataTypes in the * fw / datasetviewer / cellcomponent directory , you must also add the name * of that DataType class to the list in CellComponentFactory , method * getControlPanels , variable named initialClassNameList . * If the class is being registered with the factory using registerDataType , * then you should not include the class name in the list ( it will be found * automatically ) , but if the DataType is part of the case statement in the * factory method getDataTypeObject , then it does need to be explicitly listed * in the getControlPanels method also . * / / / if this panel is called before any instances of the class have been / / created , we need to load the properties from the DTProperties . loadProperties ( ) ; return new UnknownOkJPanel ( ) ; }
void test10 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 33 , "DatabaseObjectType . sequence" ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeOther0 . isEditableInCell ( ( Object ) "French" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test14 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1957 ) , "NN ( Tb ! Ic & 9W'C6YkT" ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( jTable0 , columnDisplayDefinition0 ) ; ParameterWhereClausePart parameterWhereClausePart0 = ( ParameterWhereClausePart ) dataTypeOther0 . getWhereClauseValue ( ( Object ) "37777774133" , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isParameterUsed ( ) { throw new IllegalStateException ( "A NopWhereClauseParte does not support a whereClause" ) ; }
void test17 ( ) throws Throwable { DialectType dialectType0 = DialectType . MCKOI ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1093 ) , ( String ) null , ( String ) null , ( String ) null , ( - 1093 ) , ( String ) null , true , ( - 1093 ) , ( - 1093 ) , ( - 1093 ) , true , true , true , dialectType0 ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( ( JTable ) null , columnDisplayDefinition0 ) ; Object object0 = dataTypeOther0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test18 ( ) throws Throwable { DialectType dialectType0 = DialectType . FIREBIRD ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 983 , "B19f ! al } e\"4 ? > , " , "B19f ! al } e\"4 ? > , " , "B19f ! al } e\"4 ? > , " , 983 , "B19f ! al } e\"4 ? > , " , true , 983 , 983 , 983 , true , true , true , dialectType0 ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( ( JTable ) null , columnDisplayDefinition0 ) ; Object object0 = dataTypeOther0 . getDefaultValue ( "B19f ! al } e\"4 ? > , " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test19 ( ) throws Throwable { DialectType dialectType0 = DialectType . INFORMIX ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1530 ) , ( String ) null , ( String ) null , ( String ) null , 0 , ( String ) null , false , ( - 1530 ) , ( - 1530 ) , ( - 1530 ) , false , false , false , dialectType0 ) ; DataTypeOther dataTypeOther0 = new DataTypeOther ( ( JTable ) null , columnDisplayDefinition0 ) ; Object object0 = dataTypeOther0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 956 ) , "r" ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( ( JTable ) null , columnDisplayDefinition0 ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeBinary0 . getJTextField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test1 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 437 , "" ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBinary0 . isEditableInCell ( ( Object ) "icon" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test2 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1 , "SQLD2 ( B" , "SQLD2 ( B" , "SQLD2 ( B" , 1 , "SQLD2 ( B" , true , 1 , 1 , 1000 , true , false , false , dialectType0 ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( ( JTable ) null , columnDisplayDefinition0 ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) dataTypeBinary0 . getJTextArea ( ( Object ) "sides" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test3 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . DB2 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1432 , "" , "" , "" , 1432 , "" , true , 1432 , 1432 , 1432 , true , false , true , dialectType0 ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBinary0 . isEditableInPopup ( ( Object ) "1142" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test4 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 437 , "" ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBinary0 . useBinaryEditingPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test5 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 437 , "" ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBinary0 . needToReRead ( ( Object ) "AccessibleSelection" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean needToReRead ( int col , Object originalValue ) { / / call the DataType object for this column and have it check the current value return CellComponentFactory . needToReRead ( _colDefs [ col ] , originalValue ) ; }
void test6 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . DB2 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1432 , "" , "" , "" , 1432 , "" , true , 1432 , 1432 , 1432 , true , false , true , dialectType0 ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; String string0 = dataTypeBinary0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test8 ( ) throws Throwable { JTable jTable0 = new JTable ( 123 , 123 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 123 , "orientation" ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBinary0 . canDoFileIO ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test9 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 437 , "" ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBinary0 . areEqual ( ( Object ) "AccessibleSelection" , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean areEqual ( Object obj1 , Object obj2 ) ; / * * Cell related methods come next . * / / * * * Convert the given object into its printable String value for use in Text * output and the in - cell representations ( CellRenderer and CellEditor ) . * / String renderObject ( Object object ) ; / * * * Returns true if data type may be edited within a table cell , false if * not . * / boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test10 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1 , "SQLD2 ( B" , "SQLD2 ( B" , "SQLD2 ( B" , 1 , "SQLD2 ( B" , true , 1 , 1 , 1000 , true , false , false , dialectType0 ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBinary0 . areEqual ( ( Object ) null , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean areEqual ( Object obj1 , Object obj2 ) ; / * * Cell related methods come next . * / / * * * Convert the given object into its printable String value for use in Text * output and the in - cell representations ( CellRenderer and CellEditor ) . * / String renderObject ( Object object ) ; / * * * Returns true if data type may be edited within a table cell , false if * not . * / boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test11 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . DB2 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1432 , "" , "" , "" , 1432 , "" , true , 1432 , 1432 , 1432 , true , false , true , dialectType0 ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBinary0 . areEqual ( ( Object ) null , ( Object ) "selection - end - word" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean areEqual ( Object obj1 , Object obj2 ) ; / * * Cell related methods come next . * / / * * * Convert the given object into its printable String value for use in Text * output and the in - cell representations ( CellRenderer and CellEditor ) . * / String renderObject ( Object object ) ; / * * * Returns true if data type may be edited within a table cell , false if * not . * / boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test12 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . DB2 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1432 , "" , "" , "" , 1432 , "" , true , 1432 , 1432 , 1432 , true , false , true , dialectType0 ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBinary0 . areEqual ( ( Object ) "selection - end - word" , ( Object ) "selection - end - word" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean areEqual ( Object obj1 , Object obj2 ) ; / * * Cell related methods come next . * / / * * * Convert the given object into its printable String value for use in Text * output and the in - cell representations ( CellRenderer and CellEditor ) . * / String renderObject ( Object object ) ; / * * * Returns true if data type may be edited within a table cell , false if * not . * / boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test13 ( ) throws Throwable { JTable jTable0 = new JTable ( 123 , 123 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 123 , "orientation" ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeBinary0 . areEqual ( ( Object ) "selection - end - word" , ( Object ) "selection - backward" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean areEqual ( Object obj1 , Object obj2 ) ; / * * Cell related methods come next . * / / * * * Convert the given object into its printable String value for use in Text * output and the in - cell representations ( CellRenderer and CellEditor ) . * / String renderObject ( Object object ) ; / * * * Returns true if data type may be edited within a table cell , false if * not . * / boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test14 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 32 ) , "content - length" ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) dataTypeBinary0 . getJTextArea ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test15 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1520 ) , ( String ) null ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; StringBuffer stringBuffer0 = new StringBuffer ( "ControlButtonsAreShownChangedProperty" ) ; Object object0 = dataTypeBinary0 . validateAndConvertInPopup ( ( String ) null , ( Object ) "ControlButtonsAreShownChangedProperty" , stringBuffer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test17 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . H2 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , " ] using ClassLoader . gePSystemResource ( ) . " , " ] using ClassLoader . gePSystemResource ( ) . " , " ] using ClassLoader . gePSystemResource ( ) . " , 1 , " ] using ClassLoader . gePSystemResource ( ) . " , true , 216 , ( - 1118 ) , ( - 1118 ) , true , true , true , dialectType0 ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; IsNullWhereClausePart isNullWhereClausePart0 = ( IsNullWhereClausePart ) dataTypeBinary0 . getWhereClauseValue ( ( Object ) null , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isParameterUsed ( ) { throw new IllegalStateException ( "A NopWhereClauseParte does not support a whereClause" ) ; }
void test18 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; Vector < Object > vector0 = defaultTableModel0 . getDataVector ( ) ; DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel ( ) ; DefaultListSelectionModel defaultListSelectionModel0 = new DefaultListSelectionModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 , ( TableColumnModel ) defaultTableColumnModel0 , ( ListSelectionModel ) defaultListSelectionModel0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 135 , "Requires start > = 0 . " ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; dataTypeBinary0 . getWhereClauseValue ( ( Object ) vector0 , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test21 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1520 ) , ( String ) null ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; Object object0 = dataTypeBinary0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test22 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 437 , "" ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( ( JTable ) null , columnDisplayDefinition0 ) ; Object object0 = dataTypeBinary0 . getDefaultValue ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test23 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . FIREBIRD ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 32 ) , "content - length" , "zKOl / - | 7T & cr" , "zKOl / - | 7T & cr" , 0 , "zKOl / - | 7T & cr" , false , 0 , 110 , 1 , false , false , true , dialectType0 ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( jTable0 , columnDisplayDefinition0 ) ; Object object0 = dataTypeBinary0 . getDefaultValue ( "content - length" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test24 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" ) ; DataTypeBinary dataTypeBinary0 = new DataTypeBinary ( ( JTable ) null , columnDisplayDefinition0 ) ; FileDescriptor fileDescriptor0 = FileDescriptor . out ; FileInputStream fileInputStream0 = new FileInputStream ( fileDescriptor0 ) ; String string0 = dataTypeBinary0 . importObject ( fileInputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { RestorableJTextField restorableJTextField0 = new RestorableJTextField ( ) ; restorableJTextField0 . restoreText ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test1 ( ) throws Throwable { RestorableJTextField restorableJTextField0 = new RestorableJTextField ( ) ; restorableJTextField0 . updateText ( "k" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test2 ( ) throws Throwable { RestorableJTextField restorableJTextField0 = new RestorableJTextField ( ) ; restorableJTextField0 . setText ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test3 ( ) throws Throwable { RestorableJTextField restorableJTextField0 = new RestorableJTextField ( ) ; restorableJTextField0 . setText ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test0 ( ) throws Throwable { BinaryDisplayConverter . ConversionConstants binaryDisplayConverter_ConversionConstants0 = new BinaryDisplayConverter . ConversionConstants ( ( - 504 ) , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" BinaryDisplayConverter ( ) { }
void test1 ( ) throws Throwable { Byte [ ] byteArray0 = BinaryDisplayConverter . convertToBytes ( "" , 0 , false ) ; String string0 = BinaryDisplayConverter . convertToString ( byteArray0 , ( - 286 ) , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String convertToString ( Byte [ ] data , int base , boolean showAscii ) { / / handle null if ( data = = null ) return null ; StringBuffer buf = new StringBuffer ( ) ; ConversionConstants convConst = getConstants ( base ) ; / / Convert each byte and put into string buffer for ( int i = 0 ; i < data . length ; i + + ) { int value = data [ i ] . byteValue ( ) ; String s = null ; / / if user wants to see ASCII chars as characters , / / see if this is one that should be displayed that way if ( showAscii ) { if ( printable . indexOf ( ( char ) value ) > - 1 ) { s = Character . valueOf ( ( char ) value ) + " " . substring ( 10 - ( convConst . width - 1 ) ) ; } } / / if use is not looking for ASCII chars , or if this one is one that / / is not printable , then convert it into numeric form if ( s = = null ) { switch ( base ) { case DECIMAL : / / convert signed to unsigned if ( value < 0 ) value = 256 + value ; s = Integer . toString ( value ) ; break ; case OCTAL : s = Integer . toOctalString ( value ) ; break ; case BINARY : s = Integer . toBinaryString ( value ) ; break ; case HEX : / / fall through to default default : s = Integer . toHexString ( value ) ; } / / some formats ( e . g . hex & octal ) extend a negative number to multiple places / / ( e . g . FC becomes FFFC ) , so chop off extra stuff in front if ( s . length ( ) > convConst . width ) s = s . substring ( s . length ( ) - convConst . width ) ; / / front pad with zeros and add to output if ( s . length ( ) < convConst . width ) buf . append ( "00000000" . substring ( 8 - ( convConst . width - s . length ( ) ) ) ) ; } buf . append ( s ) ; buf . append ( " " ) ; / / always add spaces at end for consistancy } return buf . toString ( ) ; }
void test2 ( ) throws Throwable { String string0 = BinaryDisplayConverter . convertToString ( ( Byte [ ] ) null , ( - 392 ) , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String convertToString ( Byte [ ] data , int base , boolean showAscii ) { / / handle null if ( data = = null ) return null ; StringBuffer buf = new StringBuffer ( ) ; ConversionConstants convConst = getConstants ( base ) ; / / Convert each byte and put into string buffer for ( int i = 0 ; i < data . length ; i + + ) { int value = data [ i ] . byteValue ( ) ; String s = null ; / / if user wants to see ASCII chars as characters , / / see if this is one that should be displayed that way if ( showAscii ) { if ( printable . indexOf ( ( char ) value ) > - 1 ) { s = Character . valueOf ( ( char ) value ) + " " . substring ( 10 - ( convConst . width - 1 ) ) ; } } / / if use is not looking for ASCII chars , or if this one is one that / / is not printable , then convert it into numeric form if ( s = = null ) { switch ( base ) { case DECIMAL : / / convert signed to unsigned if ( value < 0 ) value = 256 + value ; s = Integer . toString ( value ) ; break ; case OCTAL : s = Integer . toOctalString ( value ) ; break ; case BINARY : s = Integer . toBinaryString ( value ) ; break ; case HEX : / / fall through to default default : s = Integer . toHexString ( value ) ; } / / some formats ( e . g . hex & octal ) extend a negative number to multiple places / / ( e . g . FC becomes FFFC ) , so chop off extra stuff in front if ( s . length ( ) > convConst . width ) s = s . substring ( s . length ( ) - convConst . width ) ; / / front pad with zeros and add to output if ( s . length ( ) < convConst . width ) buf . append ( "00000000" . substring ( 8 - ( convConst . width - s . length ( ) ) ) ) ; } buf . append ( s ) ; buf . append ( " " ) ; / / always add spaces at end for consistancy } return buf . toString ( ) ; }
void test3 ( ) throws Throwable { Byte [ ] byteArray0 = new Byte [ 1 ] ; Byte byte0 = new Byte ( ( byte ) 29 ) ; byteArray0 [ 0 ] = byte0 ; String string0 = BinaryDisplayConverter . convertToString ( byteArray0 , 8 , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String convertToString ( Byte [ ] data , int base , boolean showAscii ) { / / handle null if ( data = = null ) return null ; StringBuffer buf = new StringBuffer ( ) ; ConversionConstants convConst = getConstants ( base ) ; / / Convert each byte and put into string buffer for ( int i = 0 ; i < data . length ; i + + ) { int value = data [ i ] . byteValue ( ) ; String s = null ; / / if user wants to see ASCII chars as characters , / / see if this is one that should be displayed that way if ( showAscii ) { if ( printable . indexOf ( ( char ) value ) > - 1 ) { s = Character . valueOf ( ( char ) value ) + " " . substring ( 10 - ( convConst . width - 1 ) ) ; } } / / if use is not looking for ASCII chars , or if this one is one that / / is not printable , then convert it into numeric form if ( s = = null ) { switch ( base ) { case DECIMAL : / / convert signed to unsigned if ( value < 0 ) value = 256 + value ; s = Integer . toString ( value ) ; break ; case OCTAL : s = Integer . toOctalString ( value ) ; break ; case BINARY : s = Integer . toBinaryString ( value ) ; break ; case HEX : / / fall through to default default : s = Integer . toHexString ( value ) ; } / / some formats ( e . g . hex & octal ) extend a negative number to multiple places / / ( e . g . FC becomes FFFC ) , so chop off extra stuff in front if ( s . length ( ) > convConst . width ) s = s . substring ( s . length ( ) - convConst . width ) ; / / front pad with zeros and add to output if ( s . length ( ) < convConst . width ) buf . append ( "00000000" . substring ( 8 - ( convConst . width - s . length ( ) ) ) ) ; } buf . append ( s ) ; buf . append ( " " ) ; / / always add spaces at end for consistancy } return buf . toString ( ) ; }
void test7 ( ) throws Throwable { Byte [ ] byteArray0 = BinaryDisplayConverter . convertToBytes ( ( String ) null , ( - 1 ) , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Byte [ ] convertToBytes ( String data , int base , boolean showAscii ) throws NumberFormatException { ConversionConstants convConst = getConstants ( base ) ; if ( data = = null ) return null ; if ( data . length ( ) = = 0 ) return new Byte [ 0 ] ; if ( data . equals ( " < null > " ) ) return null ; int stringIndex = 0 ; int byteIndex = 0 ; Byte [ ] bytes = new Byte [ ( data . length ( ) + 2 ) / ( convConst . width + 2 ) ] ; while ( stringIndex < data . length ( ) ) { / / get the text to be converted String s = data . substring ( stringIndex , stringIndex + convConst . width ) ; / / handle ASCII chars / / Irrespective of the radix , the second byte will always / / be a space when the data is displayed as a single ASCII character . if ( showAscii & & s . charAt ( 1 ) = = ' ' ) { / / convert the char into its numeric value bytes [ byteIndex + + ] = Byte . valueOf ( ( byte ) s . charAt ( 0 ) ) ; } else { / / The following ugly conversion from text to Byte is necessary because / / the Byte class is inconsistant . When asked to output as Hex , it does / / so as an UNSIGNED byte , but when asked to read back the same thing / / using the Hex radix , it insists that the input must be SIGNED . / / To get around this , we up - size the conversion to Integer , then / / truncate that to a byte , and finally convert the byte to a Byte . Yech . bytes [ byteIndex + + ] = Byte . valueOf ( ( byte ) ( Integer . valueOf ( s , convConst . radix ) ) . intValue ( ) ) ; } stringIndex + = convConst . width + 2 ; } return bytes ; }
void test8 ( ) throws Throwable { Byte [ ] byteArray0 = BinaryDisplayConverter . convertToBytes ( " < null > " , ( - 1151 ) , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Byte [ ] convertToBytes ( String data , int base , boolean showAscii ) throws NumberFormatException { ConversionConstants convConst = getConstants ( base ) ; if ( data = = null ) return null ; if ( data . length ( ) = = 0 ) return new Byte [ 0 ] ; if ( data . equals ( " < null > " ) ) return null ; int stringIndex = 0 ; int byteIndex = 0 ; Byte [ ] bytes = new Byte [ ( data . length ( ) + 2 ) / ( convConst . width + 2 ) ] ; while ( stringIndex < data . length ( ) ) { / / get the text to be converted String s = data . substring ( stringIndex , stringIndex + convConst . width ) ; / / handle ASCII chars / / Irrespective of the radix , the second byte will always / / be a space when the data is displayed as a single ASCII character . if ( showAscii & & s . charAt ( 1 ) = = ' ' ) { / / convert the char into its numeric value bytes [ byteIndex + + ] = Byte . valueOf ( ( byte ) s . charAt ( 0 ) ) ; } else { / / The following ugly conversion from text to Byte is necessary because / / the Byte class is inconsistant . When asked to output as Hex , it does / / so as an UNSIGNED byte , but when asked to read back the same thing / / using the Hex radix , it insists that the input must be SIGNED . / / To get around this , we up - size the conversion to Integer , then / / truncate that to a byte , and finally convert the byte to a Byte . Yech . bytes [ byteIndex + + ] = Byte . valueOf ( ( byte ) ( Integer . valueOf ( s , convConst . radix ) ) . intValue ( ) ) ; } stringIndex + = convConst . width + 2 ; } return bytes ; }
void test9 ( ) throws Throwable { Byte [ ] byteArray0 = BinaryDisplayConverter . convertToBytes ( " " , 8 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Byte [ ] convertToBytes ( String data , int base , boolean showAscii ) throws NumberFormatException { ConversionConstants convConst = getConstants ( base ) ; if ( data = = null ) return null ; if ( data . length ( ) = = 0 ) return new Byte [ 0 ] ; if ( data . equals ( " < null > " ) ) return null ; int stringIndex = 0 ; int byteIndex = 0 ; Byte [ ] bytes = new Byte [ ( data . length ( ) + 2 ) / ( convConst . width + 2 ) ] ; while ( stringIndex < data . length ( ) ) { / / get the text to be converted String s = data . substring ( stringIndex , stringIndex + convConst . width ) ; / / handle ASCII chars / / Irrespective of the radix , the second byte will always / / be a space when the data is displayed as a single ASCII character . if ( showAscii & & s . charAt ( 1 ) = = ' ' ) { / / convert the char into its numeric value bytes [ byteIndex + + ] = Byte . valueOf ( ( byte ) s . charAt ( 0 ) ) ; } else { / / The following ugly conversion from text to Byte is necessary because / / the Byte class is inconsistant . When asked to output as Hex , it does / / so as an UNSIGNED byte , but when asked to read back the same thing / / using the Hex radix , it insists that the input must be SIGNED . / / To get around this , we up - size the conversion to Integer , then / / truncate that to a byte , and finally convert the byte to a Byte . Yech . bytes [ byteIndex + + ] = Byte . valueOf ( ( byte ) ( Integer . valueOf ( s , convConst . radix ) ) . intValue ( ) ) ; } stringIndex + = convConst . width + 2 ; } return bytes ; }
void test0 ( ) throws Throwable { Object [ ] [ ] objectArray0 = new Object [ 9 ] [ 9 ] ; Object object0 = RenderingHints . VALUE_TEXT_ANTIALIAS_DEFAULT ; Object [ ] objectArray1 = new Object [ 1 ] ; objectArray1 [ 0 ] = object0 ; objectArray0 [ 8 ] = objectArray1 ; JTable jTable0 = new JTable ( objectArray0 , objectArray0 [ 8 ] ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , " . = eC%$" ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( jTable0 , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long length ( ) { return _wrappedFile . length ( ) ; }
void test1 ( ) throws Throwable { DialectType dialectType0 = DialectType . SYBASEASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1005 ) , "\u0003EyYTw" , "\u0003EyYTw" , "\u0003EyYTw" , ( - 1005 ) , "\u0003EyYTw" , false , ( - 1005 ) , ( - 1005 ) , ( - 1005 ) , false , false , false , dialectType0 ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test2 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( 1 , 1 ) ; Vector < Object > vector0 = defaultTableModel0 . getDataVector ( ) ; JTable jTable0 = new JTable ( vector0 , vector0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1 , "" ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( jTable0 , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean needToReRead ( int col , Object originalValue ) { / / call the DataType object for this column and have it check the current value return CellComponentFactory . needToReRead ( _colDefs [ col ] , originalValue ) ; }
void test3 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( 17 , 17 ) ; Vector < Object > vector0 = defaultTableModel0 . getDataVector ( ) ; JTable jTable0 = new JTable ( vector0 , vector0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 17 , "org . jfree . data . time . Second" ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeFloat0 . getJTextField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getX ( ) { return _x ; }
void test4 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( 17 , 17 ) ; Vector < Object > vector0 = defaultTableModel0 . getDataVector ( ) ; JTable jTable0 = new JTable ( vector0 , vector0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 17 , "org . jfree . data . time . Second" ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( jTable0 , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test5 ( ) throws Throwable { DialectType dialectType0 = DialectType . SYBASEASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1005 ) , "\u0003EyYTw" , "\u0003EyYTw" , "\u0003EyYTw" , ( - 1005 ) , "\u0003EyYTw" , false , ( - 1005 ) , ( - 1005 ) , ( - 1005 ) , false , false , false , dialectType0 ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test6 ( ) throws Throwable { DialectType dialectType0 = DialectType . SYBASEASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1005 ) , "\u0003EyYTw" , "\u0003EyYTw" , "\u0003EyYTw" , ( - 1005 ) , "\u0003EyYTw" , false , ( - 1005 ) , ( - 1005 ) , ( - 1005 ) , false , false , false , dialectType0 ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test7 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 655 ) , "" ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( jTable0 , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test8 ( ) throws Throwable { Vector < DataTypeFloat > vector0 = new Vector < DataTypeFloat > ( ) ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ( Vector ) vector0 , 1498 ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 ) ; DialectType dialectType0 = DialectType . MYSQL5 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1498 , "First" , "First" , "First" , 1498 , "First" , true , 1498 , 1498 , 1498 , true , true , true , dialectType0 ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( jTable0 , columnDisplayDefinition0 ) ; String string0 = dataTypeFloat0 . renderObject ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String renderObject ( Object o ) { return CellComponentFactory . renderObject ( o , _colDef ) ; }
void test9 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 2 ] ; Object object0 = RenderingHints . VALUE_ANTIALIAS_DEFAULT ; objectArray0 [ 1 ] = object0 ; JTable jTable0 = new JTable ( ( Vector ) null , ( Vector ) null ) ; DialectType dialectType0 = DialectType . MYSQL5 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" , "" , "" , 0 , "" , true , 0 , 0 , 0 , true , true , true , dialectType0 ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( jTable0 , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test10 ( ) throws Throwable { Vector < DataTypeFloat > vector0 = new Vector < DataTypeFloat > ( ) ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ( Vector ) vector0 , 1498 ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 ) ; DialectType dialectType0 = DialectType . MYSQL5 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1498 , "First" , "First" , "First" , 1498 , "First" , true , 1498 , 1498 , 1498 , true , true , true , dialectType0 ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( jTable0 , columnDisplayDefinition0 ) ; Object object0 = dataTypeFloat0 . getDefaultValue ( " < null > " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test11 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( ( JTable ) null , columnDisplayDefinition0 ) ; Object object0 = dataTypeFloat0 . getDefaultValue ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test12 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "Finalizing appender named [ " ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( jTable0 , columnDisplayDefinition0 ) ; IsNullWhereClausePart isNullWhereClausePart0 = ( IsNullWhereClausePart ) dataTypeFloat0 . getWhereClauseValue ( ( Object ) null , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isParameterUsed ( ) { throw new IllegalStateException ( "A NopWhereClauseParte does not support a whereClause" ) ; }
void test13 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( ( JTable ) null , columnDisplayDefinition0 ) ; EmptyWhereClausePart emptyWhereClausePart0 = ( EmptyWhereClausePart ) dataTypeFloat0 . getWhereClauseValue ( ( Object ) "SmallIcon" , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean shouldBeUsed ( ) { return false ; }
void test17 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 6 ) , ( String ) null ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( ( JTable ) null , columnDisplayDefinition0 ) ; Float float0 = ( Float ) dataTypeFloat0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test18 ( ) throws Throwable { DialectType dialectType0 = DialectType . SYBASEASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1005 ) , "\u0003EyYTw" , "\u0003EyYTw" , "\u0003EyYTw" , ( - 1005 ) , "\u0003EyYTw" , false , ( - 1005 ) , ( - 1005 ) , ( - 1005 ) , false , false , false , dialectType0 ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { String string0 = DatabaseSpecificBooleanValue . getBooleanValue ( ( String ) null , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getBooleanValue ( String orig , ISQLDatabaseMetaData md ) { for ( int i = 0 ; i < _booleans . length ; i + + ) { if ( _booleans [ i ] . productMatches ( md ) ) { return _booleans [ i ] . getBooleanValue ( orig ) ; } } return orig ; }
void test1 ( ) throws Throwable { DatabaseSpecificBooleanValue databaseSpecificBooleanValue0 = new DatabaseSpecificBooleanValue ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { DialectType dialectType0 = DialectType . NETEZZA ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1438 ) , "`MBt6I9Q = _ ( F * ReA ( = " , "`MBt6I9Q = _ ( F * ReA ( = " , "`MBt6I9Q = _ ( F * ReA ( = " , ( - 886 ) , "" , false , 45 , ( - 886 ) , 15 , true , false , false , dialectType0 ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( ( JTable ) null , columnDisplayDefinition0 ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeDouble0 . getJTextField ( ) ; CellEditorUsingRenderer cellEditorUsingRenderer0 = new CellEditorUsingRenderer ( ( JTextField ) restorableJTextField0 , ( IDataTypeComponent ) dataTypeDouble0 ) ; RestorableJTextField restorableJTextField1 = ( RestorableJTextField ) cellEditorUsingRenderer0 . getTableCellEditorComponent ( ( JTable ) null , ( Object ) null , false , ( - 7 ) , ( - 886 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test1 ( ) throws Throwable { JPasswordField jPasswordField0 = new JPasswordField ( ) ; CellEditorUsingRenderer cellEditorUsingRenderer0 = new CellEditorUsingRenderer ( ( JTextField ) jPasswordField0 , ( IDataTypeComponent ) null ) ; String string0 = ( String ) cellEditorUsingRenderer0 . getCellEditorValue ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getCellEditorValue ( ) { return _dataScale ; }
void test2 ( ) throws Throwable { JPasswordField jPasswordField0 = new JPasswordField ( ) ; CellEditorUsingRenderer cellEditorUsingRenderer0 = new CellEditorUsingRenderer ( ( JTextField ) jPasswordField0 , ( IDataTypeComponent ) null ) ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( ) ; Vector < Object > vector0 = defaultTableModel0 . getDataVector ( ) ; JTree jTree0 = new JTree ( vector0 ) ; cellEditorUsingRenderer0 . getTreeCellEditorComponent ( jTree0 , ( Object ) "SwingLargeIconKey" , true , true , true , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test3 ( ) throws Throwable { JPasswordField jPasswordField0 = new JPasswordField ( ) ; CellEditorUsingRenderer cellEditorUsingRenderer0 = new CellEditorUsingRenderer ( ( JTextField ) jPasswordField0 , ( IDataTypeComponent ) null ) ; JTable jTable0 = new JTable ( ) ; cellEditorUsingRenderer0 . getTableCellEditorComponent ( jTable0 , ( Object ) null , true , 0 , 1391 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test0 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 11 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , true , true , ( int ) ( byte ) 59 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeBlobRead ( ) { return _wholeBlobRead ; }
void test1 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 9 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , true , true , ( int ) ( byte ) 0 ) ; blobDescriptor0 . setData ( byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getBlobRead ( ) { return _blobRead ; }
void test2 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 9 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , true , true , 247 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getBlobRead ( ) { return _blobRead ; }
void test3 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 9 ] ; BlobImpl blobImpl0 = new BlobImpl ( byteArray0 ) ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) blobImpl0 , byteArray0 , true , true , ( int ) ( byte ) 0 ) ; boolean boolean0 = blobDescriptor0 . getWholeBlobRead ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetBlobLimit ( ) { return _userSetBlobLimit ; }
void test4 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 24 ] ; BlobImpl blobImpl0 = new BlobImpl ( byteArray0 ) ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) blobImpl0 , byteArray0 , false , false , ( int ) ( byte ) 0 ) ; boolean boolean0 = blobDescriptor0 . equals ( blobDescriptor0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetBlobLimit ( ) { return _userSetBlobLimit ; }
void test5 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 9 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , true , true , 247 ) ; blobDescriptor0 . getBlob ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetBlobLimit ( ) { return _userSetBlobLimit ; }
void test6 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 19 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , false , false , ( int ) ( byte ) ( - 9 ) ) ; int int0 = blobDescriptor0 . getUserSetBlobLimit ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeBlobRead ( ) { return _wholeBlobRead ; }
void test7 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 9 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , true , true , ( int ) ( byte ) 0 ) ; blobDescriptor0 . setBlob ( ( Blob ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetBlobLimit ( ) { return _userSetBlobLimit ; }
void test8 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 9 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , true , true , ( int ) ( byte ) 0 ) ; blobDescriptor0 . setUserSetBlobLimit ( ( int ) ( byte ) 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetBlobLimit ( ) { return _userSetBlobLimit ; }
void test9 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 9 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , true , true , ( int ) ( byte ) 0 ) ; boolean boolean0 = blobDescriptor0 . equals ( blobDescriptor0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeBlobRead ( ) { return _wholeBlobRead ; }
void test10 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 19 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , false , false , ( int ) ( byte ) ( - 9 ) ) ; boolean boolean0 = blobDescriptor0 . equals ( ( BlobDescriptor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeBlobRead ( ) { return _wholeBlobRead ; }
void test11 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 9 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , true , true , 247 ) ; boolean boolean0 = blobDescriptor0 . equals ( ( BlobDescriptor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeBlobRead ( ) { return _wholeBlobRead ; }
void test12 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 9 ] ; BlobImpl blobImpl0 = new BlobImpl ( byteArray0 ) ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) blobImpl0 , byteArray0 , true , true , ( int ) ( byte ) 0 ) ; BlobDescriptor blobDescriptor1 = new BlobDescriptor ( ( Blob ) blobImpl0 , byteArray0 , false , true , ( int ) ( byte ) 0 ) ; boolean boolean0 = blobDescriptor0 . equals ( blobDescriptor1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetBlobLimit ( ) { return _userSetBlobLimit ; }
void test13 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 9 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , true , true , 247 ) ; BlobDescriptor blobDescriptor1 = new BlobDescriptor ( ( Blob ) null , byteArray0 , false , true , ( int ) ( byte ) 0 ) ; boolean boolean0 = blobDescriptor1 . equals ( blobDescriptor0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeBlobRead ( ) { return _wholeBlobRead ; }
void test14 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 11 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , true , true , ( int ) ( byte ) 59 ) ; String string0 = blobDescriptor0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeBlobRead ( ) { return _wholeBlobRead ; }
void test15 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 9 ] ; BlobDescriptor blobDescriptor0 = new BlobDescriptor ( ( Blob ) null , byteArray0 , true , true , ( int ) ( byte ) 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeBlobRead ( ) { return _wholeBlobRead ; }
void test0 ( ) throws Throwable { OkJPanel okJPanel0 = FloatingPointBase . getControlPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" OkJPanel getControlPanel ( ) { / * * If you add this method to one of the standard DataTypes in the * fw / datasetviewer / cellcomponent directory , you must also add the name * of that DataType class to the list in CellComponentFactory , method * getControlPanels , variable named initialClassNameList . * If the class is being registered with the factory using registerDataType , * then you should not include the class name in the list ( it will be found * automatically ) , but if the DataType is part of the case statement in the * factory method getDataTypeObject , then it does need to be explicitly listed * in the getControlPanels method also . * / / / if this panel is called before any instances of the class have been / / created , we need to load the properties from the DTProperties . loadProperties ( ) ; return new UnknownOkJPanel ( ) ; }
void test1 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 2 ) , "" ) ; DataTypeFloat dataTypeFloat0 = new DataTypeFloat ( jTable0 , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { DefaultColumnRenderer defaultColumnRenderer0 = DefaultColumnRenderer . getInstance ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ApplicationArguments getInstance ( ) { if ( s_instance = = null ) { try { s_instance = new ApplicationArguments ( new String [ ] { } ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } } return s_instance ; }
void test1 ( ) throws Throwable { DefaultColumnRenderer defaultColumnRenderer0 = new DefaultColumnRenderer ( ) ; String string0 = ( String ) defaultColumnRenderer0 . renderObject ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String renderObject ( Object o ) { return CellComponentFactory . renderObject ( o , _colDef ) ; }
void test2 ( ) throws Throwable { DefaultColumnRenderer defaultColumnRenderer0 = new DefaultColumnRenderer ( ) ; Object object0 = new Object ( ) ; String string0 = ( String ) defaultColumnRenderer0 . renderObject ( object0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String renderObject ( Object o ) { return CellComponentFactory . renderObject ( o , _colDef ) ; }
void test0 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1652 ) , " } = @F , ! . 7f$s ) m8 | " ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test2 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 335 ) , " . 27dPO%6pIll8 = Ri3" ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test3 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 6 , "@qB * yA & rMkUp - '%n / j" ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( ( JTable ) null , columnDisplayDefinition0 ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeDouble0 . getJTextField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test4 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 6 , "@qB * yA & rMkUp - '%n / j" ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test5 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 335 ) , " . 27dPO%6pIll8 = Ri3" ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean needToReRead ( int col , Object originalValue ) { / / call the DataType object for this column and have it check the current value return CellComponentFactory . needToReRead ( _colDefs [ col ] , originalValue ) ; }
void test6 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1652 ) , " } = @F , ! . 7f$s ) m8 | " ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test7 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1652 ) , " } = @F , ! . 7f$s ) m8 | " ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test8 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 335 ) , " . 27dPO%6pIll8 = Ri3" ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test9 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 25 , " + f ? zyJRK = " ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( jTable0 , columnDisplayDefinition0 ) ; String string0 = dataTypeDouble0 . renderObject ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String renderObject ( Object o ) { return CellComponentFactory . renderObject ( o , _colDef ) ; }
void test10 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 25 , " + f ? zyJRK = " ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( jTable0 , columnDisplayDefinition0 ) ; Object object0 = dataTypeDouble0 . getDefaultValue ( " < null > " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test11 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 14 , "" ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( jTable0 , columnDisplayDefinition0 ) ; Object object0 = dataTypeDouble0 . getDefaultValue ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test12 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "^" ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( jTable0 , columnDisplayDefinition0 ) ; IsNullWhereClausePart isNullWhereClausePart0 = ( IsNullWhereClausePart ) dataTypeDouble0 . getWhereClauseValue ( ( Object ) null , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isParameterUsed ( ) { throw new IllegalStateException ( "A NopWhereClauseParte does not support a whereClause" ) ; }
void test13 ( ) throws Throwable { DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel ( ) ; DefaultListSelectionModel defaultListSelectionModel0 = new DefaultListSelectionModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) null , ( TableColumnModel ) defaultTableColumnModel0 , ( ListSelectionModel ) defaultListSelectionModel0 ) ; DialectType dialectType0 = DialectType . H2 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , " + CL | B" , " + CL | B" , " + CL | B" , 0 , " + CL | B" , false , 0 , 0 , 0 , false , false , false , dialectType0 ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( jTable0 , columnDisplayDefinition0 ) ; dataTypeDouble0 . getWhereClauseValue ( ( Object ) 4L , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test16 ( ) throws Throwable { DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel ( ) ; DefaultListSelectionModel defaultListSelectionModel0 = new DefaultListSelectionModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) null , ( TableColumnModel ) defaultTableColumnModel0 , ( ListSelectionModel ) defaultListSelectionModel0 ) ; DialectType dialectType0 = DialectType . H2 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , " + CL | B" , " + CL | B" , " + CL | B" , 0 , " + CL | B" , false , 0 , 0 , 0 , false , false , false , dialectType0 ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( jTable0 , columnDisplayDefinition0 ) ; Double double0 = ( Double ) dataTypeDouble0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test17 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 25 , " + f ? zyJRK = " ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( jTable0 , columnDisplayDefinition0 ) ; Double double0 = ( Double ) dataTypeDouble0 . getDefaultValue ( " + f ? zyJRK = " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { CellComponentFactory cellComponentFactory0 = new CellComponentFactory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" ) ; TableCellRenderer tableCellRenderer0 = CellComponentFactory . getTableCellRenderer ( columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TableCellRenderer getTableCellRenderer ( ColumnDisplayDefinition colDef ) { return new CellRenderer ( getDataTypeObject ( null , colDef ) ) ; }
void test2 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "" ) ; String string0 = columnDisplayDefinition0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test3 ( ) throws Throwable { DialectType dialectType0 = DialectType . AXION ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 263 , " * a" , " * a" , " * a" , 5 , " * a" , true , 263 , 5 , 5 , true , true , true , dialectType0 ) ; String string0 = columnDisplayDefinition0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test4 ( ) throws Throwable { DialectType dialectType0 = DialectType . DERBY ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 7 ) , "Blobs may not beaccessed after serLalization" , "Blobs may not beaccessed after serLalization" , "Blobs may not beaccessed after serLalization" , ( - 7 ) , "Blobs may not beaccessed after serLalization" , true , ( - 7 ) , ( - 7 ) , ( - 7 ) , true , true , true , dialectType0 ) ; boolean boolean0 = CellComponentFactory . areEqual ( columnDisplayDefinition0 , ( Object ) "North" , ( Object ) "North" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean areEqual ( Object obj1 , Object obj2 ) ; / * * Cell related methods come next . * / / * * * Convert the given object into its printable String value for use in Text * output and the in - cell representations ( CellRenderer and CellEditor ) . * / String renderObject ( Object object ) ; / * * * Returns true if data type may be edited within a table cell , false if * not . * / boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test5 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , ( String ) null ) ; String string0 = CellComponentFactory . renderObject ( ( Object ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String renderObject ( Object o ) { return CellComponentFactory . renderObject ( o , _colDef ) ; }
void test6 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "CancelSelection" ) ; String string0 = CellComponentFactory . renderObject ( ( Object ) "CancelSelection" , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String renderObject ( Object o ) { return CellComponentFactory . renderObject ( o , _colDef ) ; }
void test7 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1 ) , "MAXDB" ) ; boolean boolean0 = CellComponentFactory . isEditableInCell ( columnDisplayDefinition0 , ( Object ) "borderPainted" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test8 ( ) throws Throwable { DialectType dialectType0 = DialectType . DERBY ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , ( String ) null , ( String ) null , ( String ) null , 7 , ( String ) null , true , 0 , 7 , 0 , true , true , true , dialectType0 ) ; boolean boolean0 = CellComponentFactory . isEditableInCell ( columnDisplayDefinition0 , ( Object ) "Name" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test9 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1 ) , "MAXDB" ) ; columnDisplayDefinition0 . setSqlType ( ( - 1 ) ) ; boolean boolean0 = CellComponentFactory . isEditableInCell ( columnDisplayDefinition0 , ( Object ) "borderPainted" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test10 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1923 ) , "" ) ; Integer integer0 = JLayeredPane . FRAME_CONTENT_LAYER ; boolean boolean0 = CellComponentFactory . needToReRead ( columnDisplayDefinition0 , ( Object ) integer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean needToReRead ( int col , Object originalValue ) { / / call the DataType object for this column and have it check the current value return CellComponentFactory . needToReRead ( _colDefs [ col ] , originalValue ) ; }
void test11 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 950 ) , "e2J & o1 * = 38 ( + " , "e2J & o1 * = 38 ( + " , "e2J & o1 * = 38 ( + " , 631 , "f - `f" , true , ( - 950 ) , ( - 950 ) , 631 , true , true , true , dialectType0 ) ; CellComponentFactory . needToReRead ( columnDisplayDefinition0 , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test12 ( ) throws Throwable { JTable jTable0 = new JTable ( 0 , 0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "S / VP ? u ] " ) ; CellEditorUsingRenderer cellEditorUsingRenderer0 = ( CellEditorUsingRenderer ) CellComponentFactory . getInCellEditor ( jTable0 , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DefaultCellEditor getInCellEditor ( JTable table , ColumnDisplayDefinition colDef ) { DefaultCellEditor ed ; IDataTypeComponent dataTypeObject = getDataTypeObject ( table , colDef ) ; JTextField textField ; / / Default behavior if no data type found is to use a restorable text field / / with no other special behavior and hope the object has a toString ( ) . if ( dataTypeObject ! = null ) { textField = dataTypeObject . getJTextField ( ) ; } else { textField = new RestorableJTextField ( ) ; } / / When changing the backgroud color , it helps to set the inner component's border to zero . Otherwise , / / the border can obscure the text and make it hard to see . This is especially seen when using the / / kunstoff l & f . textField . setBackground ( Color . yellow ) ; textField . setBorder ( new EmptyBorder ( 0 , 0 , 0 , 0 ) ) ; ed = new CellEditorUsingRenderer ( textField , dataTypeObject ) ; ed . setClickCountToStart ( 1 ) ; return ed ; }
void test13 ( ) throws Throwable { DialectType dialectType0 = DialectType . AXION ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "\"16'k9 ! " , "\"16'k9 ! " , "\"16'k9 ! " , 0 , "d9^j`L" , false , 0 , 1932 , 1318 , false , false , false , dialectType0 ) ; String string0 = ( String ) CellComponentFactory . validateAndConvert ( columnDisplayDefinition0 , ( Object ) "document - name" , "document - name" , ( StringBuffer ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test15 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , ( String ) null ) ; boolean boolean0 = CellComponentFactory . useBinaryEditingPanel ( columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test16 ( ) throws Throwable { DialectType dialectType0 = DialectType . AXION ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 263 , " * a" , " * a" , " * a" , 5 , " * a" , true , 263 , 5 , 5 , true , true , true , dialectType0 ) ; boolean boolean0 = CellComponentFactory . isEditableInPopup ( columnDisplayDefinition0 , ( Object ) "default" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test17 ( ) throws Throwable { DialectType dialectType0 = DialectType . POSTGRES ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 238 , " < null > " , " < null > " , " < null > " , ( - 16 ) , " < null > " , false , 238 , 238 , 238 , false , false , false , dialectType0 ) ; boolean boolean0 = CellComponentFactory . isEditableInPopup ( columnDisplayDefinition0 , ( Object ) "default" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test18 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 8 ) , "CancelSelection" ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) CellComponentFactory . getJTextArea ( columnDisplayDefinition0 , ( Object ) "CancelSelection" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test19 ( ) throws Throwable { DialectType dialectType0 = DialectType . DERBY ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , ( String ) null , ( String ) null , ( String ) null , 7 , ( String ) null , true , 0 , 7 , 0 , true , true , true , dialectType0 ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) CellComponentFactory . getJTextArea ( columnDisplayDefinition0 , ( Object ) "Name" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test20 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "CancelSelection" ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) CellComponentFactory . getJTextArea ( columnDisplayDefinition0 , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test21 ( ) throws Throwable { DialectType dialectType0 = DialectType . FRONTBASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 950 ) , "e2J & o1 * = 38 ( + " , "" , "e2J & o1 * = 38 ( + " , 0 , "" , true , ( - 950 ) , ( - 950 ) , 0 , true , true , true , dialectType0 ) ; StringBuffer stringBuffer0 = new StringBuffer ( 151 ) ; String string0 = ( String ) CellComponentFactory . validateAndConvertInPopup ( columnDisplayDefinition0 , ( Object ) "LOWER_TRAILING_CORNER" , "" , stringBuffer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test22 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 950 ) , "e2J & o1 * = 38 ( + " , "e2J & o1 * = 38 ( + " , "e2J & o1 * = 38 ( + " , 631 , "f - `f" , true , ( - 950 ) , ( - 950 ) , 631 , true , true , true , dialectType0 ) ; StringBuffer stringBuffer0 = new StringBuffer ( 169 ) ; String string0 = ( String ) CellComponentFactory . validateAndConvertInPopup ( columnDisplayDefinition0 , ( Object ) "LOWER_TRAILING_CORNER" , "f - `f" , stringBuffer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test23 ( ) throws Throwable { DialectType dialectType0 = DialectType . MSSQL ; Object object0 = CellComponentFactory . readResultWithPluginRegisteredDataType ( ( ResultSet ) null , 1915 , " * Z > Z = " , 1915 , dialectType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object readResultWithPluginRegisteredDataType ( ResultSet rs , int sqlType , String sqlTypeName , int index , DialectType dialectType ) throws Exception { Object result = null ; String typeNameKey = getRegDataTypeKey ( dialectType , sqlType , sqlTypeName ) ; if ( _pluginDataTypeFactories . containsKey ( typeNameKey ) ) { IDataTypeComponentFactory factory = _pluginDataTypeFactories . get ( typeNameKey ) ; IDataTypeComponent dtComp = factory . constructDataTypeComponent ( ) ; ColumnDisplayDefinition colDef = new ColumnDisplayDefinition ( rs , index , factory . getDialectType ( ) ) ; dtComp . setColumnDisplayDefinition ( colDef ) ; dtComp . setTable ( _table ) ; result = dtComp . readResultSet ( rs , index , false ) ; } return result ; }
void test24 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1115 , " < " ) ; IWhereClausePart iWhereClausePart0 = CellComponentFactory . getWhereClauseValue ( columnDisplayDefinition0 , ( Object ) null , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test25 ( ) throws Throwable { HashMap < ColumnDisplayDefinition , IDataTypeComponent > hashMap0 = CellComponentFactory . _colDataTypeObjects ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1108 , "" ) ; XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) xYDatasetTableModel0 ) ; DataTypeDouble dataTypeDouble0 = new DataTypeDouble ( jTable0 , columnDisplayDefinition0 ) ; hashMap0 . put ( columnDisplayDefinition0 , ( IDataTypeComponent ) dataTypeDouble0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test26 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 475 , " { X [ ^h ) ! F / kN" ) ; Object object0 = CellComponentFactory . getDefaultValue ( columnDisplayDefinition0 , " { X [ ^h ) ! F / kN" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test27 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 488 , " { X [ ^h ) ! F / kN" ) ; columnDisplayDefinition0 . setSqlType ( 488 ) ; CellComponentFactory . getDefaultValue ( columnDisplayDefinition0 , " { X [ ^h ) ! F / kN" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test28 ( ) throws Throwable { DialectType dialectType0 = DialectType . INFORMIX ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 92 , "ViewportUI" , "ViewportUI" , "ViewportUI" , 92 , "ViewportUI" , false , 92 , 92 , 92 , false , false , false , dialectType0 ) ; boolean boolean0 = CellComponentFactory . canDoFileIO ( columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test29 ( ) throws Throwable { OkJPanel [ ] okJPanelArray0 = CellComponentFactory . getControlPanels ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" OkJPanel [ ] getControlPanels ( ) { ArrayList < OkJPanel > panelList = new ArrayList < OkJPanel > ( ) ; / * * This is the list of names of classes that : * - support standard SQL type codes and thus do not need to be registered * - provide the getControlPanel method to allow manipulation of properties * These classes should all be named * net . sourceforge . squirrel_sql . fw . datasetviewer . cellcomponent . DataTypeXXXX * because they are part of the standard delivery of the product , and thus should * be local to this directory . * / String [ ] initialClassNameList = { net . sourceforge . squirrel_sql . fw . datasetviewer . cellcomponent . DataTypeGeneral . class . getName ( ) , net . sourceforge . squirrel_sql . fw . datasetviewer . cellcomponent . DataTypeBlob . class . getName ( ) , net . sourceforge . squirrel_sql . fw . datasetviewer . cellcomponent . DataTypeClob . class . getName ( ) , net . sourceforge . squirrel_sql . fw . datasetviewer . cellcomponent . DataTypeString . class . getName ( ) , net . sourceforge . squirrel_sql . fw . datasetviewer . cellcomponent . DataTypeOther . class . getName ( ) , net . sourceforge . squirrel_sql . fw . datasetviewer . cellcomponent . DataTypeUnknown . class . getName ( ) , net . sourceforge . squirrel_sql . fw . datasetviewer . cellcomponent . DataTypeDate . class . getName ( ) , net . sourceforge . squirrel_sql . fw . datasetviewer . cellcomponent . DataTypeTime . class . getName ( ) , net . sourceforge . squirrel_sql . fw . datasetviewer . cellcomponent . DataTypeTimestamp . class . getName ( ) , net . sourceforge . squirrel_sql . fw . datasetviewer . cellcomponent . FloatingPointBase . class . getName ( ) , } ; / / make a single list of all class names that we need to check . / / Start with the names of known , standard classes that provide Control Panels ArrayList < String > classNameList = new ArrayList < String > ( Arrays . asList ( initialClassNameList ) ) ; / / add to that the list of all names that have been registered by plugins / / Iterator < IDataTypeComponentFactory > pluginDataTypeFactories = / / _registeredDataTypes . values ( ) . iterator ( ) ; / / while ( pluginDataTypeFactories . hasNext ( ) ) { / / TODO : add support for plugin - registered data - type preferences panels / / when it is needed . / / } / / Now go through the list in the given order to get the panels for ( int i = 0 ; i < classNameList . size ( ) ; i + + ) { String className = classNameList . get ( i ) ; Class < ? > [ ] parameterTypes = new Class < ? > [ 0 ] ; try { Method panelMethod = Class . forName ( className ) . getMethod ( "getControlPanel" , parameterTypes ) ; OkJPanel panel = ( OkJPanel ) panelMethod . invoke ( null , ( Object [ ] ) null ) ; panelList . add ( panel ) ; } catch ( Exception e ) { s_log . error ( "Unexpected exception : " + e . getMessage ( ) , e ) ; } } return panelList . toArray ( new OkJPanel [ 0 ] ) ; }
void test30 ( ) throws Throwable { DialectType dialectType0 = DialectType . AXION ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1 , "04W ( | 9" , "vR_ ; " , "04W ( | 9" , ( - 102 ) , "vR_ ; " , true , 1 , 1 , ( - 102 ) , true , true , true , dialectType0 ) ; boolean boolean0 = CellComponentFactory . canDoFileIO ( columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test31 ( ) throws Throwable { DialectType dialectType0 = DialectType . TIMESTEN ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 228 , "pfS6Q\"E" , "pfS6Q\"E" , "pfS6Q\"E" , ( - 4 ) , "pfS6Q\"E" , false , 228 , 228 , 228 , false , false , false , dialectType0 ) ; boolean boolean0 = CellComponentFactory . isEditableInPopup ( columnDisplayDefinition0 , ( Object ) "default" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test32 ( ) throws Throwable { DialectType dialectType0 = DialectType . MCKOI ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 3 , "1FY } " , "1FY } " , "1FY } " , 3 , "1FY } " , false , 3 , 3 , 3 , false , false , false , dialectType0 ) ; String string0 = CellComponentFactory . getClassName ( columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test33 ( ) throws Throwable { DialectType dialectType0 = DialectType . TIMESTEN ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 244 , " * a" , " * a" , " * a" , 12 , " * a" , false , 244 , 12 , 244 , false , false , false , dialectType0 ) ; boolean boolean0 = CellComponentFactory . isEditableInPopup ( columnDisplayDefinition0 , ( Object ) "default" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test34 ( ) throws Throwable { DialectType dialectType0 = DialectType . INFORMIX ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 16 , "" , "" , "" , 16 , "" , true , 16 , 16 , 16 , true , true , true , dialectType0 ) ; boolean boolean0 = CellComponentFactory . canDoFileIO ( columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { RestorableJTextArea restorableJTextArea0 = new RestorableJTextArea ( ) ; ToolkitBeepHelper toolkitBeepHelper0 = new ToolkitBeepHelper ( ) ; StringFieldKeyTextHandler stringFieldKeyTextHandler0 = new StringFieldKeyTextHandler ( ( IRestorableTextComponent ) restorableJTextArea0 , 0 , true , ( IToolkitBeepHelper ) toolkitBeepHelper0 ) ; StringFieldKeyTextHandler stringFieldKeyTextHandler1 = new StringFieldKeyTextHandler ( ( IRestorableTextComponent ) restorableJTextArea0 , 1 , true , ( IToolkitBeepHelper ) toolkitBeepHelper0 ) ; MenuElement [ ] menuElementArray0 = new MenuElement [ 1 ] ; MenuSelectionManager menuSelectionManager0 = MenuSelectionManager . defaultManager ( ) ; MenuKeyEvent menuKeyEvent0 = new MenuKeyEvent ( ( Component ) restorableJTextArea0 , 937 , ( - 8L ) , 1159 , 1159 , '' , menuElementArray0 , menuSelectionManager0 ) ; stringFieldKeyTextHandler0 . keyTyped ( ( KeyEvent ) menuKeyEvent0 ) ; stringFieldKeyTextHandler1 . keyTyped ( ( KeyEvent ) menuKeyEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void keyTyped ( KeyEvent e ) { char c = e . getKeyChar ( ) ; / / as a coding convenience , create a reference to the text component / / that is typecast to JTextComponent . this is not essential , as we / / could typecast every reference , but this makes the code cleaner JTextComponent _theComponent = ( JTextComponent ) _textComponent ; String text = _theComponent . getText ( ) ; / / ? ? Is there any way to check for invalid input ? Valid input includes / / ? ? at least any printable character , but could it also include unprintable / / ? ? characters ? / / check for max size reached ( only works when DB provides non - zero scale info if ( _columnSize > 0 & & text . length ( ) > = _columnSize & & c ! = KeyEvent . VK_BACK_SPACE & & c ! = KeyEvent . VK_DELETE ) { / / max size reached e . consume ( ) ; _beepHelper . beep ( _theComponent ) ; / / Note : tabs and newlines are allowed in string fields , even though they are unusual . } / / handle cases of null / / The processing is different when nulls are allowed and when they are not . / / if ( _isNullable ) { / / user enters something when field is null if ( text . equals ( BaseDataTypeComponent . NULL_VALUE_PATTERN ) ) { if ( ( c = = KeyEvent . VK_BACK_SPACE ) | | ( c = = KeyEvent . VK_DELETE ) ) { / / delete when null = > original value _textComponent . restoreText ( ) ; e . consume ( ) ; } else { / / non - delete when null = > clear field and add text _textComponent . updateText ( "" ) ; / / fall through to normal processing of this key stroke } } else { / / for strings , a "blank" field is allowed , so only / / switch to null when there is nothing left in the field / / and user does delete if ( ( c = = KeyEvent . VK_BACK_SPACE ) | | ( c = = KeyEvent . VK_DELETE ) ) { if ( text . length ( ) = = 0 ) { / / about to delete last thing in field , so replace with null _textComponent . updateText ( BaseDataTypeComponent . NULL_VALUE_PATTERN ) ; e . consume ( ) ; } } } } else { / / field is not nullable / / handleNotNullableField ( text , c , e , _textComponent ) ; } }
void test1 ( ) throws Throwable { RestorableJTextArea restorableJTextArea0 = new RestorableJTextArea ( ) ; ToolkitBeepHelper toolkitBeepHelper0 = new ToolkitBeepHelper ( ) ; StringFieldKeyTextHandler stringFieldKeyTextHandler0 = new StringFieldKeyTextHandler ( ( IRestorableTextComponent ) restorableJTextArea0 , 0 , true , ( IToolkitBeepHelper ) toolkitBeepHelper0 ) ; StringFieldKeyTextHandler stringFieldKeyTextHandler1 = new StringFieldKeyTextHandler ( ( IRestorableTextComponent ) restorableJTextArea0 , 1 , true , ( IToolkitBeepHelper ) toolkitBeepHelper0 ) ; MenuElement [ ] menuElementArray0 = new MenuElement [ 1 ] ; MenuSelectionManager menuSelectionManager0 = MenuSelectionManager . defaultManager ( ) ; MenuKeyEvent menuKeyEvent0 = new MenuKeyEvent ( ( Component ) restorableJTextArea0 , 937 , ( - 8L ) , 1159 , 1159 , '' , menuElementArray0 , menuSelectionManager0 ) ; stringFieldKeyTextHandler0 . keyTyped ( ( KeyEvent ) menuKeyEvent0 ) ; KeyEvent keyEvent0 = new KeyEvent ( ( Component ) restorableJTextArea0 , 744 , ( - 496L ) , 0 , 0 , '\r' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void keyTyped ( KeyEvent e ) { char c = e . getKeyChar ( ) ; / / as a coding convenience , create a reference to the text component / / that is typecast to JTextComponent . this is not essential , as we / / could typecast every reference , but this makes the code cleaner JTextComponent _theComponent = ( JTextComponent ) _textComponent ; String text = _theComponent . getText ( ) ; / / ? ? Is there any way to check for invalid input ? Valid input includes / / ? ? at least any printable character , but could it also include unprintable / / ? ? characters ? / / check for max size reached ( only works when DB provides non - zero scale info if ( _columnSize > 0 & & text . length ( ) > = _columnSize & & c ! = KeyEvent . VK_BACK_SPACE & & c ! = KeyEvent . VK_DELETE ) { / / max size reached e . consume ( ) ; _beepHelper . beep ( _theComponent ) ; / / Note : tabs and newlines are allowed in string fields , even though they are unusual . } / / handle cases of null / / The processing is different when nulls are allowed and when they are not . / / if ( _isNullable ) { / / user enters something when field is null if ( text . equals ( BaseDataTypeComponent . NULL_VALUE_PATTERN ) ) { if ( ( c = = KeyEvent . VK_BACK_SPACE ) | | ( c = = KeyEvent . VK_DELETE ) ) { / / delete when null = > original value _textComponent . restoreText ( ) ; e . consume ( ) ; } else { / / non - delete when null = > clear field and add text _textComponent . updateText ( "" ) ; / / fall through to normal processing of this key stroke } } else { / / for strings , a "blank" field is allowed , so only / / switch to null when there is nothing left in the field / / and user does delete if ( ( c = = KeyEvent . VK_BACK_SPACE ) | | ( c = = KeyEvent . VK_DELETE ) ) { if ( text . length ( ) = = 0 ) { / / about to delete last thing in field , so replace with null _textComponent . updateText ( BaseDataTypeComponent . NULL_VALUE_PATTERN ) ; e . consume ( ) ; } } } } else { / / field is not nullable / / handleNotNullableField ( text , c , e , _textComponent ) ; } }
void test2 ( ) throws Throwable { RestorableJTextField restorableJTextField0 = new RestorableJTextField ( ) ; ToolkitBeepHelper toolkitBeepHelper0 = new ToolkitBeepHelper ( ) ; Panel panel0 = new Panel ( ( LayoutManager ) null ) ; KeyEvent keyEvent0 = new KeyEvent ( ( Component ) panel0 , 463 , 1308L , ( int ) 'I' , 0 , 'I' ) ; StringFieldKeyTextHandler stringFieldKeyTextHandler0 = new StringFieldKeyTextHandler ( ( IRestorableTextComponent ) restorableJTextField0 , 676 , false , ( IToolkitBeepHelper ) toolkitBeepHelper0 ) ; stringFieldKeyTextHandler0 . keyTyped ( keyEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { RestorableJTextField restorableJTextField0 = new RestorableJTextField ( ) ; ToolkitBeepHelper toolkitBeepHelper0 = new ToolkitBeepHelper ( ) ; StringFieldKeyTextHandler stringFieldKeyTextHandler0 = new StringFieldKeyTextHandler ( ( IRestorableTextComponent ) restorableJTextField0 , ( - 1989 ) , true , ( IToolkitBeepHelper ) toolkitBeepHelper0 ) ; KeyEvent keyEvent0 = new KeyEvent ( ( Component ) restorableJTextField0 , ( - 1989 ) , ( long ) ( - 1989 ) , 0 , 1447 , '\r' ) ; stringFieldKeyTextHandler0 . keyTyped ( keyEvent0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void keyTyped ( KeyEvent e ) { char c = e . getKeyChar ( ) ; / / as a coding convenience , create a reference to the text component / / that is typecast to JTextComponent . this is not essential , as we / / could typecast every reference , but this makes the code cleaner JTextComponent _theComponent = ( JTextComponent ) _textComponent ; String text = _theComponent . getText ( ) ; / / ? ? Is there any way to check for invalid input ? Valid input includes / / ? ? at least any printable character , but could it also include unprintable / / ? ? characters ? / / check for max size reached ( only works when DB provides non - zero scale info if ( _columnSize > 0 & & text . length ( ) > = _columnSize & & c ! = KeyEvent . VK_BACK_SPACE & & c ! = KeyEvent . VK_DELETE ) { / / max size reached e . consume ( ) ; _beepHelper . beep ( _theComponent ) ; / / Note : tabs and newlines are allowed in string fields , even though they are unusual . } / / handle cases of null / / The processing is different when nulls are allowed and when they are not . / / if ( _isNullable ) { / / user enters something when field is null if ( text . equals ( BaseDataTypeComponent . NULL_VALUE_PATTERN ) ) { if ( ( c = = KeyEvent . VK_BACK_SPACE ) | | ( c = = KeyEvent . VK_DELETE ) ) { / / delete when null = > original value _textComponent . restoreText ( ) ; e . consume ( ) ; } else { / / non - delete when null = > clear field and add text _textComponent . updateText ( "" ) ; / / fall through to normal processing of this key stroke } } else { / / for strings , a "blank" field is allowed , so only / / switch to null when there is nothing left in the field / / and user does delete if ( ( c = = KeyEvent . VK_BACK_SPACE ) | | ( c = = KeyEvent . VK_DELETE ) ) { if ( text . length ( ) = = 0 ) { / / about to delete last thing in field , so replace with null _textComponent . updateText ( BaseDataTypeComponent . NULL_VALUE_PATTERN ) ; e . consume ( ) ; } } } } else { / / field is not nullable / / handleNotNullableField ( text , c , e , _textComponent ) ; } }
void test1 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; StringBuffer stringBuffer0 = new StringBuffer ( ) ; String string0 = ( String ) dataTypeString0 . validateAndConvertInPopup ( "" , ( Object ) "acceptAllFileFilterUsedChanged" , stringBuffer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test2 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; boolean boolean0 = dataTypeString0 . useBinaryEditingPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test3 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeString0 . getJTextField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getColumns ( ) { return COLUMNS ; }
void test4 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) dataTypeString0 . getJTextArea ( ( Object ) "javax . swing . JCheckBoxMenuItem [ , 0 , 0 , 0x0 , invalid , alignmentX = 0 . 0 , alignmentY = 0 . 0 , border = javax . swing . plaf . metal . MetalBorders$MenuItemBorder@7bc74b3 , flags = 264 , maximumSize = , minimumSize = , preferredSize = , defaultIcon = , disabledIcon = , disabledSelectedIcon = , margin = javax . swing . plaf . InsetsUIResource [ top = 2 , left = 2 , bottom = 2 , right = 2 ] , paintBorder = true , paintFocus = false , pressedIcon = , rolloverEnabled = false , rolloverIcon = , rolloverSelectedIcon = , selectedIcon = , text = ] " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test5 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; boolean boolean0 = dataTypeString0 . canDoFileIO ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test6 ( ) throws Throwable { OkJPanel okJPanel0 = DataTypeString . getControlPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" OkJPanel getControlPanel ( ) { / * * If you add this method to one of the standard DataTypes in the * fw / datasetviewer / cellcomponent directory , you must also add the name * of that DataType class to the list in CellComponentFactory , method * getControlPanels , variable named initialClassNameList . * If the class is being registered with the factory using registerDataType , * then you should not include the class name in the list ( it will be found * automatically ) , but if the DataType is part of the case statement in the * factory method getDataTypeObject , then it does need to be explicitly listed * in the getControlPanels method also . * / / / if this panel is called before any instances of the class have been / / created , we need to load the properties from the DTProperties . loadProperties ( ) ; return new UnknownOkJPanel ( ) ; }
void test7 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; String string0 = dataTypeString0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test8 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1997 , ( String ) null ) ; DataTypeString dataTypeString0 = new DataTypeString ( ( JTable ) null , columnDisplayDefinition0 ) ; String string0 = ( String ) dataTypeString0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test9 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; String string0 = dataTypeString0 . renderObject ( ( Object ) "acceptAllFileFilterUsedChanged" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String renderObject ( Object o ) { return CellComponentFactory . renderObject ( o , _colDef ) ; }
void test10 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; boolean boolean0 = dataTypeString0 . isEditableInCell ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test11 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; boolean boolean0 = dataTypeString0 . isEditableInCell ( ( Object ) "Default" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test12 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; boolean boolean0 = dataTypeString0 . isEditableInPopup ( ( Object ) "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test13 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1 ) , "acceptAllFileFilterUsedChanged" ) ; dataTypeString0 . setColumnDisplayDefinition ( columnDisplayDefinition0 ) ; ParameterWhereClausePart parameterWhereClausePart0 = ( ParameterWhereClausePart ) dataTypeString0 . getWhereClauseValue ( ( Object ) "acceptAllFileFilterUsedChanged" , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean shouldBeUsed ( ) { return false ; }
void test14 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1185 , "acceptAllFileFilterUsedChanged" ) ; dataTypeString0 . setColumnDisplayDefinition ( columnDisplayDefinition0 ) ; IsNullWhereClausePart isNullWhereClausePart0 = ( IsNullWhereClausePart ) dataTypeString0 . getWhereClauseValue ( ( Object ) null , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumn ( ) { return _column ; }
void test17 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; String string0 = ( String ) dataTypeString0 . getDefaultValue ( "acceptAllFileFilterUsedChanged" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test18 ( ) throws Throwable { DataTypeString dataTypeString0 = new DataTypeString ( ) ; String string0 = ( String ) dataTypeString0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "" , false , false , ( - 1377 ) ) ; int int0 = clobDescriptor0 . getUserSetClobLimit ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "AX" , false , false , 0 ) ; clobDescriptor0 . setClob ( ( Clob ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeClobRead ( ) { return _wholeClobRead ; }
void test2 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "" , false , false , ( - 1377 ) ) ; clobDescriptor0 . setWholeClobRead ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getClobRead ( ) { return _clobRead ; }
void test3 ( ) throws Throwable { ClobImpl clobImpl0 = new ClobImpl ( "" ) ; ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) clobImpl0 , "" , true , false , 0 ) ; clobDescriptor0 . setData ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test4 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "" , false , false , ( - 1377 ) ) ; clobDescriptor0 . getClob ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test5 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "" , false , false , ( - 1377 ) ) ; boolean boolean0 = clobDescriptor0 . getWholeClobRead ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetClobLimit ( ) { return _userSetClobLimit ; }
void test6 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "" , false , true , 243 ) ; clobDescriptor0 . setClobRead ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getClobRead ( ) { return _clobRead ; }
void test7 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "" , true , false , 1109 ) ; boolean boolean0 = clobDescriptor0 . equals ( clobDescriptor0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getClobRead ( ) { return _clobRead ; }
void test8 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "" , false , false , ( - 1377 ) ) ; clobDescriptor0 . setUserSetClobLimit ( ( - 1304 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetClobLimit ( ) { return _userSetClobLimit ; }
void test9 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "AX" , false , false , 0 ) ; boolean boolean0 = clobDescriptor0 . equals ( ( ClobDescriptor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeClobRead ( ) { return _wholeClobRead ; }
void test10 ( ) throws Throwable { ClobImpl clobImpl0 = new ClobImpl ( "AX" ) ; ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) clobImpl0 , "AX" , true , true , 0 ) ; boolean boolean0 = clobDescriptor0 . equals ( ( ClobDescriptor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getClobRead ( ) { return _clobRead ; }
void test11 ( ) throws Throwable { ClobImpl clobImpl0 = new ClobImpl ( "AX" ) ; ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) clobImpl0 , ( String ) null , true , true , 0 ) ; boolean boolean0 = clobDescriptor0 . equals ( ( ClobDescriptor ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetClobLimit ( ) { return _userSetClobLimit ; }
void test12 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "sV\" = Oe#soW | p4 ? , zLm" , true , true , 0 ) ; ClobDescriptor clobDescriptor1 = new ClobDescriptor ( ( Clob ) null , "sV\" = Oe#soW | p4 ? , zLm" , false , false , 0 ) ; boolean boolean0 = clobDescriptor0 . equals ( clobDescriptor1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeClobRead ( ) { return _wholeClobRead ; }
void test13 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "" , false , false , 1775 ) ; boolean boolean0 = clobDescriptor0 . equals ( clobDescriptor0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test14 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "" , false , false , ( - 1377 ) ) ; ClobDescriptor clobDescriptor1 = new ClobDescriptor ( ( Clob ) null , "" , true , false , ( - 1304 ) ) ; boolean boolean0 = clobDescriptor0 . equals ( clobDescriptor1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test15 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "" , false , false , ( - 1377 ) ) ; String string0 = clobDescriptor0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetClobLimit ( ) { return _userSetClobLimit ; }
void test16 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "" , true , false , 1073 ) ; String string0 = clobDescriptor0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetClobLimit ( ) { return _userSetClobLimit ; }
void test17 ( ) throws Throwable { ClobImpl clobImpl0 = new ClobImpl ( "AX" ) ; ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) clobImpl0 , ( String ) null , true , true , 0 ) ; String string0 = clobDescriptor0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetClobLimit ( ) { return _userSetClobLimit ; }
void test18 ( ) throws Throwable { ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) null , "J { vd = zh < BQ . Hrvo" , true , true , ( - 1 ) ) ; String string0 = clobDescriptor0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getWholeClobRead ( ) { return _wholeClobRead ; }
void test19 ( ) throws Throwable { ClobImpl clobImpl0 = new ClobImpl ( "" ) ; ClobDescriptor clobDescriptor0 = new ClobDescriptor ( ( Clob ) clobImpl0 , "" , true , false , 0 ) ; String string0 = clobDescriptor0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getClobRead ( ) { return _clobRead ; }
void test0 ( ) throws Throwable { DataTypeDate . DateFormatTypeCombo dataTypeDate_DateFormatTypeCombo0 = new DataTypeDate . DateFormatTypeCombo ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { JTable jTable0 = new JTable ( 151 , 151 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 151 , "LNM ? , y% , N - v0I = | 5TK" ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeDate0 . getJTextField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getReadDateAsTimestamp ( ) { propertiesAlreadyLoaded = false ; loadProperties ( ) ; return readDateAsTimestamp ; }
void test2 ( ) throws Throwable { OkJPanel okJPanel0 = DataTypeDate . getControlPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" OkJPanel getControlPanel ( ) { / * * If you add this method to one of the standard DataTypes in the * fw / datasetviewer / cellcomponent directory , you must also add the name * of that DataType class to the list in CellComponentFactory , method * getControlPanels , variable named initialClassNameList . * If the class is being registered with the factory using registerDataType , * then you should not include the class name in the list ( it will be found * automatically ) , but if the DataType is part of the case statement in the * factory method getDataTypeObject , then it does need to be explicitly listed * in the getControlPanels method also . * / / / if this panel is called before any instances of the class have been / / created , we need to load the properties from the DTProperties . loadProperties ( ) ; return new UnknownOkJPanel ( ) ; }
void test3 ( ) throws Throwable { JTable jTable0 = new JTable ( 0 , 1597 ) ; DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "j13k~0Cw9k" , "j13k~0Cw9k" , "j13k~0Cw9k" , 1597 , "j13k~0Cw9k" , false , 1597 , 0 , 2001 , false , false , false , dialectType0 ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeDate0 . canDoFileIO ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test4 ( ) throws Throwable { JTable jTable0 = new JTable ( 151 , 151 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 151 , "LNM ? , y% , N - v0I = | 5TK" ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) dataTypeDate0 . getJTextArea ( ( Object ) jTable0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test5 ( ) throws Throwable { JTable jTable0 = new JTable ( 0 , 1597 ) ; DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "j13k~0Cw9k" , "j13k~0Cw9k" , "j13k~0Cw9k" , 1597 , "j13k~0Cw9k" , false , 1597 , 0 , 2001 , false , false , false , dialectType0 ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( jTable0 , columnDisplayDefinition0 ) ; StringBuffer stringBuffer0 = new StringBuffer ( ) ; dataTypeDate0 . validateAndConvertInPopup ( "j13k~0Cw9k" , ( Object ) null , stringBuffer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test6 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 153 , "M - '" ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeDate0 . isEditableInPopup ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test7 ( ) throws Throwable { JTable jTable0 = new JTable ( 151 , 151 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 151 , "LNM ? , y% , N - v0I = | 5TK" ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeDate0 . isEditableInCell ( ( Object ) "jis - b0" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getReadDateAsTimestamp ( ) { propertiesAlreadyLoaded = false ; loadProperties ( ) ; return readDateAsTimestamp ; }
void test8 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . GENERIC ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 31 , " { ! H8 ? 0TP$9~ ; e" , " { ! H8 ? 0TP$9~ ; e" , " { ! H8 ? 0TP$9~ ; e" , 31 , " { ! H8 ? 0TP$9~ ; e" , false , 2003 , 642 , 2003 , false , false , false , dialectType0 ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeDate0 . needToReRead ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean needToReRead ( int col , Object originalValue ) { / / call the DataType object for this column and have it check the current value return CellComponentFactory . needToReRead ( _colDefs [ col ] , originalValue ) ; }
void test9 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . GENERIC ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1 , "1Wg9Bx * qtJk / Q ; 3 < " , "1Wg9Bx * qtJk / Q ; 3 < " , "1Wg9Bx * qtJk / Q ; 3 < " , 1 , "1Wg9Bx * qtJk / Q ; 3 < " , false , ( - 1 ) , 1 , 1 , false , false , true , dialectType0 ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( jTable0 , columnDisplayDefinition0 ) ; String string0 = dataTypeDate0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test10 ( ) throws Throwable { JTable jTable0 = new JTable ( 0 , 1597 ) ; DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "j13k~0Cw9k" , "j13k~0Cw9k" , "j13k~0Cw9k" , 1597 , "j13k~0Cw9k" , false , 1597 , 0 , 2001 , false , false , false , dialectType0 ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeDate0 . useBinaryEditingPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test11 ( ) throws Throwable { boolean boolean0 = DataTypeDate . getReadDateAsTimestamp ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getReadDateAsTimestamp ( ) { propertiesAlreadyLoaded = false ; loadProperties ( ) ; return readDateAsTimestamp ; }
void test12 ( ) throws Throwable { DialectType dialectType0 = DialectType . AXION ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1694 ) , "" , "" , "" , ( - 1694 ) , "" , true , ( - 1694 ) , ( - 1694 ) , ( - 1694 ) , true , true , true , dialectType0 ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( ( JTable ) null , columnDisplayDefinition0 ) ; Object object0 = dataTypeDate0 . getDefaultValue ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test14 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 153 , "M - '" ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( ( JTable ) null , columnDisplayDefinition0 ) ; Date date0 = ( Date ) dataTypeDate0 . getDefaultValue ( "M - '" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test16 ( ) throws Throwable { DataTypeDate . DateFormatTypeCombo dataTypeDate_DateFormatTypeCombo0 = new DataTypeDate . DateFormatTypeCombo ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 928 ) , "jP^VT95qt = + ~TZK ] " ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( ( JTable ) null , columnDisplayDefinition0 ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeClob0 . getJTextField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test1 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( 1000 , 1470 ) ; DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 , ( TableColumnModel ) defaultTableColumnModel0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1470 , "K" ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextArea restorableJTextArea0 = ( RestorableJTextArea ) dataTypeClob0 . getJTextArea ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test2 ( ) throws Throwable { JTable jTable0 = new JTable ( 0 , 439 ) ; DialectType dialectType0 = DialectType . SYBASEASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "d & 6Q / vA . X# | ` > " , "d & 6Q / vA . X# | ` > " , "d & 6Q / vA . X# | ` > " , 0 , "d & 6Q / vA . X# | ` > " , false , ( - 1 ) , 0 , 0 , true , false , false , dialectType0 ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeClob0 . useBinaryEditingPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test3 ( ) throws Throwable { OkJPanel okJPanel0 = DataTypeClob . getControlPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" OkJPanel getControlPanel ( ) { / * * If you add this method to one of the standard DataTypes in the * fw / datasetviewer / cellcomponent directory , you must also add the name * of that DataType class to the list in CellComponentFactory , method * getControlPanels , variable named initialClassNameList . * If the class is being registered with the factory using registerDataType , * then you should not include the class name in the list ( it will be found * automatically ) , but if the DataType is part of the case statement in the * factory method getDataTypeObject , then it does need to be explicitly listed * in the getControlPanels method also . * / / / if this panel is called before any instances of the class have been / / created , we need to load the properties from the DTProperties . loadProperties ( ) ; return new UnknownOkJPanel ( ) ; }
void test4 ( ) throws Throwable { JTable jTable0 = new JTable ( 0 , 439 ) ; DialectType dialectType0 = DialectType . SYBASEASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "d & 6Q / vA . X# | ` > " , "d & 6Q / vA . X# | ` > " , "d & 6Q / vA . X# | ` > " , 0 , "d & 6Q / vA . X# | ` > " , false , ( - 1 ) , 0 , 0 , true , false , false , dialectType0 ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( jTable0 , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeClob0 . canDoFileIO ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test7 ( ) throws Throwable { DialectType dialectType0 = DialectType . TIMESTEN ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1177 , "GNCWUN : ( zQ" , "GNCWUN : ( zQ" , "GNCWUN : ( zQ" , 1177 , "GNCWUN : ( zQ" , false , 1177 , 1177 , 1177 , false , false , false , dialectType0 ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( ( JTable ) null , columnDisplayDefinition0 ) ; String string0 = dataTypeClob0 . getClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test8 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 481 , "9 < 'SktNcfb" ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( ( JTable ) null , columnDisplayDefinition0 ) ; ClobDescriptor clobDescriptor0 = ( ClobDescriptor ) dataTypeClob0 . getDefaultValue ( "9 < 'SktNcfb" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test10 ( ) throws Throwable { boolean boolean0 = DataTypeClob . getReadCompleteClob ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getReadCompleteClob ( ) { return _readCompleteClobs ; }
void test11 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 481 , "9 < 'SktNcfb" ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeClob0 . needToReRead ( ( Object ) "CancelSelection" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean needToReRead ( int col , Object originalValue ) { / / call the DataType object for this column and have it check the current value return CellComponentFactory . needToReRead ( _colDefs [ col ] , originalValue ) ; }
void test12 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( 1000 , 1470 ) ; DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 , ( TableColumnModel ) defaultTableColumnModel0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1470 , "K" ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( jTable0 , columnDisplayDefinition0 ) ; String string0 = dataTypeClob0 . renderObject ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String renderObject ( Object o ) { return CellComponentFactory . renderObject ( o , _colDef ) ; }
void test13 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 481 , "9 < 'SktNcfb" ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( ( JTable ) null , columnDisplayDefinition0 ) ; ClobDescriptor clobDescriptor0 = ( ClobDescriptor ) dataTypeClob0 . getDefaultValue ( "9 < 'SktNcfb" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetClobLimit ( ) { return _userSetClobLimit ; }
void test14 ( ) throws Throwable { DialectType dialectType0 = DialectType . HADB ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1177 , "You are attempting to add an observation for " , "You are attempting to add an observation for " , "You are attempting to add an observation for " , 1177 , "You are attempting to add an observation for " , false , 1177 , 1177 , 1177 , false , false , false , dialectType0 ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( ( JTable ) null , columnDisplayDefinition0 ) ; boolean boolean0 = dataTypeClob0 . isEditableInCell ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test15 ( ) throws Throwable { DefaultTableModel defaultTableModel0 = new DefaultTableModel ( 1000 , 1470 ) ; DefaultTableColumnModel defaultTableColumnModel0 = new DefaultTableColumnModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 , ( TableColumnModel ) defaultTableColumnModel0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1470 , "K" ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( jTable0 , columnDisplayDefinition0 ) ; ClobDescriptor clobDescriptor0 = ( ClobDescriptor ) dataTypeClob0 . getDefaultValue ( " < null > " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test16 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 481 , "9 < 'SktNcfb" ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( ( JTable ) null , columnDisplayDefinition0 ) ; ClobDescriptor clobDescriptor0 = ( ClobDescriptor ) dataTypeClob0 . getDefaultValue ( "9 < 'SktNcfb" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getUserSetClobLimit ( ) { return _userSetClobLimit ; }
void test19 ( ) throws Throwable { DialectType dialectType0 = DialectType . TIMESTEN ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1177 , "GNCWUN : ( zQ" , "GNCWUN : ( zQ" , "GNCWUN : ( zQ" , 1177 , "GNCWUN : ( zQ" , false , 1177 , 1177 , 1177 , false , false , false , dialectType0 ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( ( JTable ) null , columnDisplayDefinition0 ) ; Object object0 = dataTypeClob0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test20 ( ) throws Throwable { Object [ ] [ ] objectArray0 = new Object [ 4 ] [ 10 ] ; Object [ ] objectArray1 = new Object [ 9 ] ; Object object0 = RenderingHints . VALUE_STROKE_NORMALIZE ; objectArray1 [ 1 ] = object0 ; objectArray1 [ 6 ] = object0 ; Object [ ] objectArray2 = new Object [ 8 ] ; objectArray2 [ 0 ] = objectArray1 [ 6 ] ; objectArray2 [ 1 ] = objectArray1 [ 6 ] ; objectArray2 [ 2 ] = object0 ; objectArray2 [ 3 ] = objectArray1 [ 1 ] ; objectArray2 [ 4 ] = object0 ; objectArray2 [ 5 ] = ( Object ) "uninitializedValue" ; objectArray2 [ 6 ] = objectArray1 [ 6 ] ; objectArray2 [ 7 ] = objectArray1 [ 1 ] ; JTable jTable0 = new JTable ( objectArray0 , objectArray2 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , ( String ) null ) ; DataTypeClob dataTypeClob0 = new DataTypeClob ( jTable0 , columnDisplayDefinition0 ) ; Object object1 = dataTypeClob0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { OkJPanel okJPanel0 = DataTypeGeneral . getControlPanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" OkJPanel getControlPanel ( ) { / * * If you add this method to one of the standard DataTypes in the * fw / datasetviewer / cellcomponent directory , you must also add the name * of that DataType class to the list in CellComponentFactory , method * getControlPanels , variable named initialClassNameList . * If the class is being registered with the factory using registerDataType , * then you should not include the class name in the list ( it will be found * automatically ) , but if the DataType is part of the case statement in the * factory method getDataTypeObject , then it does need to be explicitly listed * in the getControlPanels method also . * / / / if this panel is called before any instances of the class have been / / created , we need to load the properties from the DTProperties . loadProperties ( ) ; return new UnknownOkJPanel ( ) ; }
void test1 ( ) throws Throwable { DataTypeGeneral dataTypeGeneral0 = new DataTypeGeneral ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUseColumnLabelInsteadColumnName ( ) { loadProperties ( ) ; return _useColumnLabelInsteadColumnName ; }
void test2 ( ) throws Throwable { boolean boolean0 = DataTypeGeneral . isUseColumnLabelInsteadColumnName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUseColumnLabelInsteadColumnName ( ) { loadProperties ( ) ; return _useColumnLabelInsteadColumnName ; }
void test0 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 8 ] ; DefaultTableModel defaultTableModel0 = new DefaultTableModel ( objectArray0 , 7 ) ; JTable jTable0 = new JTable ( ( TableModel ) defaultTableModel0 ) ; DialectType dialectType0 = DialectType . PROGRESS ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 7 , "supportsSavepoints" , "supportsSavepoints" , "supportsSavepoints" , 7 , "supportsSavepoints" , true , 7 , 7 , 7 , true , true , true , dialectType0 ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( jTable0 , columnDisplayDefinition0 ) ; RestorableJTextField restorableJTextField0 = ( RestorableJTextField ) dataTypeBigDecimal0 . getJTextField ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getToolTipText ( MouseEvent event ) { JButton button = getButtonAt ( event . getX ( ) ) ; if ( null = = button ) { return super . getToolTipText ( event ) ; } else { return button . getToolTipText ( ) ; } }
void test1 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1341 , ( String ) null ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean needToReRead ( int col , Object originalValue ) { / / call the DataType object for this column and have it check the current value return CellComponentFactory . needToReRead ( _colDefs [ col ] , originalValue ) ; }
void test2 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 32 , "0" ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassName ( ) { return CellComponentFactory . getClassName ( this ) ; }
void test3 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1281 ) , ( String ) null ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test4 ( ) throws Throwable { JTable jTable0 = new JTable ( 1294 , 1294 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1294 , "0O6" ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( jTable0 , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test5 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "wwu" ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test6 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "YQ * 'AEvmvfl$ ! , S" ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( jTable0 , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEditableInCell ( Object originalValue ) ; / * * * See if a value in a column has been limited in some way and needs to be * re - read before being used for editing . For read - only tables this may * actually return true since we want to be able to view the entire contents * of the cell even if it was not completely loaded during the initial table * setup . * / boolean needToReRead ( Object originalValue ) ; / * * * Get the JTextField component for this data type to be used in a * CellEditor . The value of the text field is set by the JTable mechanism * using the same mechanism as the renderer . The Assumption here is that the * CellEditor uses the same string representation as the CellRenderer . * / JTextField getJTextField ( ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * * If true , this tells the PopupEditableIOPanel to use the binary editing * panel rather than a pure text panel . The binary editing panel assumes the * data is an array of bytes , converts it into text form , allows the user to * change how that data is displayed ( e . g . Hex , Decimal , etc . ) , and converts * the data back from text to bytes when the user editing is completed . If * this returns false , this DataType class must convert the internal data * into a text string that can be displayed ( and edited , if allowed ) in a * TextField or TextArea , and must handle all user key strokes related to * editing of that data . * / boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test7 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "wwu" ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test8 ( ) throws Throwable { Object [ ] [ ] objectArray0 = new Object [ 3 ] [ 9 ] ; Object [ ] objectArray1 = new Object [ 1 ] ; objectArray0 [ 1 ] = objectArray1 ; objectArray1 [ 0 ] = ( Object ) 0 ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "jWSKG - u2" ) ; JTable jTable0 = new JTable ( objectArray0 , objectArray0 [ 1 ] ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( jTable0 , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean useBinaryEditingPanel ( ) ; / * * Now the Popup - related methods . These are not quite symmetric with the * in - cell calls because the conversion of the object into the text to * display in the popup is handled internally to the DataType object inside * getJTextArea ( ) , so we do not need a "renderObjectInPopup" function * visible to the rest of the world . * / / * * * Returns true if data type may be edited in the popup , false if not . * / boolean isEditableInPopup ( Object originalValue ) ; / * * * Get the JTextArea component for this data type to be used in the * CellPopupDialog and fill in the initial value in the appropriate * representation . That representation may be the same as is renderObject ( ) , * or it may be different ( e . g . a BLOB may have renderObject = > " < BLOB > " but * fill in the actual value in the Popup TextArea ) . * / JTextArea getJTextArea ( Object value ) ; / * * * Validate that the contents of a cell is in the right form for this data * type and convert that text into an object of the correct ( Java ) type for * the column Ideally this should be a function , but the mechanics of * using CellComponentFactory and the constraints of the Java language make * that difficult . * / Object validateAndConvertInPopup ( String value , Object originalValue , StringBuffer messageBuffer ) ; / * * DataBase - related functions * / / * * * On input from the DB , read the data from the ResultSet into the * appropriate type of object to be stored in the table cell . * / Object readResultSet ( ResultSet rs , int index , boolean limitDataRead ) throws java . sql . SQLException ; / * * * When updating the database , generate a string form of this object value * that can be used in the WHERE clause to match the value in the database . * A return value of null means that this column cannot be used in the WHERE * clause , while a return of "null" ( or "is null" , etc ) means that the * column can be used in the WHERE clause and the value is actually a null * value . This function must also include the column label so that its * output is of the form : "columnName = value" or "columnName is null" or * whatever is appropriate for this column in the database . * @see IWhereClausePart * / IWhereClausePart getWhereClauseValue ( Object value , ISQLDatabaseMetaData md ) ; / * * * When updating the database , insert the appropriate datatype into the * prepared statement at the given variable position . * / void setPreparedStatementValue ( PreparedStatement pstmt , Object value , int position ) throws java . sql . SQLException ; / * * * Get a default value for the table used to input data for a new row to be * inserted into the DB . * / Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test9 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1341 , ( String ) null ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( ( JTable ) null , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getText ( ) { return _comp . getText ( ) ; }
void test10 ( ) throws Throwable { XYDatasetTableModel xYDatasetTableModel0 = new XYDatasetTableModel ( ) ; DefaultListSelectionModel defaultListSelectionModel0 = new DefaultListSelectionModel ( ) ; JTable jTable0 = new JTable ( ( TableModel ) xYDatasetTableModel0 , ( TableColumnModel ) null , ( ListSelectionModel ) defaultListSelectionModel0 ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 10 , "" ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( jTable0 , columnDisplayDefinition0 ) ; dataTypeBigDecimal0 . getDefaultValue ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test11 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . INFORMIX ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1619 ) , "8 . 8" , "8 . 8" , "8 . 8" , 90 , "8 . 8" , true , 90 , 90 , ( - 1619 ) , true , true , true , dialectType0 ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( jTable0 , columnDisplayDefinition0 ) ; BigDecimal bigDecimal0 = ( BigDecimal ) dataTypeBigDecimal0 . getDefaultValue ( "8 . 8" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void precision ( ) { Expect ( 2 ) ; ItemSeparator ( ) ; Expect ( 2 ) ; }
void test12 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1341 , ( String ) null ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( ( JTable ) null , columnDisplayDefinition0 ) ; BigDecimal bigDecimal0 = ( BigDecimal ) dataTypeBigDecimal0 . getDefaultValue ( "6 - wwV" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test13 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; DialectType dialectType0 = DialectType . INFORMIX ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1 , "8X" , "8X" , "8X" , 1 , "8X" , false , 1 , 1 , 1 , false , false , false , dialectType0 ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( jTable0 , columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test14 ( ) throws Throwable { JTable jTable0 = new JTable ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "a { z = 05 | . aW ! VV } aRNRD" ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( jTable0 , columnDisplayDefinition0 ) ; ParameterWhereClausePart parameterWhereClausePart0 = ( ParameterWhereClausePart ) dataTypeBigDecimal0 . getWhereClauseValue ( ( Object ) "CLUSTERED" , ( ISQLDatabaseMetaData ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < IWhereClausePart > getWhereClause ( Object [ ] values , ColumnDisplayDefinition [ ] colDefs , int col , Object colValue ) { try { / / For tables that have a lot of columns , the user may have limited the set of columns / / to use in the where clause , so see if there is a table of col names HashMap < String , String > colNames = ( EditWhereCols . get ( getFullTableName ( ) ) ) ; ColumnDisplayDefinition editedCol = null ; if ( - 1 ! = col ) { editedCol = colDefs [ col ] ; } List < IWhereClausePart > clauseParts = new ArrayList < IWhereClausePart > ( ) ; for ( int i = 0 ; i < colDefs . length ; i + + ) { if ( i ! = col & & null ! = editedCol & & colDefs [ i ] . getFullTableColumnName ( ) . equalsIgnoreCase ( editedCol . getFullTableColumnName ( ) ) ) { / / The edited column is in the resultset twice ( example : SELECT MyName , * FROM MyTable ) . / / We won't add the this col to the where clause . continue ; } / / if the user has said to not use this column , then skip it if ( colNames ! = null ) { / / the user has restricted the set of columns to use . / / If this name is NOT in the list , then skip it ; otherwise we fall through / / and use the column in the WHERE clause if ( colNames . get ( colDefs [ i ] . getColumnName ( ) ) = = null ) continue ; / / go on to the next item } / / for the column that is being changed , use the value / / passed in by the caller ( which may be either the / / current value or the new replacement value ) Object value = values [ i ] ; if ( i = = col ) value = colValue ; / / convert user representation of null into an actual null if ( value ! = null & & value . toString ( ) . equals ( " < null > " ) ) value = null ; / / do different things depending on data type ISQLDatabaseMetaData md = _session . getMetaData ( ) ; IWhereClausePart clausePart = CellComponentFactory . getWhereClauseValue ( colDefs [ i ] , value , md ) ; if ( clausePart . shouldBeUsed ( ) ) / / Now we know that the part should not we ignoredshould clauseParts . add ( clausePart ) ; } return clauseParts ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
void test17 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1341 , ( String ) null ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( ( JTable ) null , columnDisplayDefinition0 ) ; BigDecimal bigDecimal0 = ( BigDecimal ) dataTypeBigDecimal0 . getDefaultValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test0 ( ) throws Throwable { BaseKeyTextHandler baseKeyTextHandler0 = new BaseKeyTextHandler ( ) ; baseKeyTextHandler0 . handleNotNullableField ( "s < Wt6`y~r { Kg#~s } " , ' + ' , ( KeyEvent ) null , ( IRestorableTextComponent ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleNotNullableField ( String text , char c , KeyEvent e , IRestorableTextComponent _textComponent ) { if ( text . length ( ) = = 0 ) { / / We want to detect two empty text values in a row before / / we decide to restore the original value . Since 'text' / / contains the new value , we want to allow the first empty / / 'text' so that the user can clear the field , and on the / / second one we will set it to the original value . if ( firstBlankText ) { firstBlankText = false ; return ; } else { firstBlankText = true ; } if ( c = = KeyEvent . VK_BACK_SPACE | | c = = KeyEvent . VK_DELETE ) { / / delete when null = > original value _textComponent . restoreText ( ) ; e . consume ( ) ; } } }
void test1 ( ) throws Throwable { BaseKeyTextHandler baseKeyTextHandler0 = new BaseKeyTextHandler ( ) ; JToolBar jToolBar0 = new JToolBar ( "" ) ; KeyEvent keyEvent0 = new KeyEvent ( ( Component ) jToolBar0 , 938 , 1480L , ( int ) ' [ ' , 0 , ' [ ' ) ; RestorableJTextArea restorableJTextArea0 = new RestorableJTextArea ( ) ; baseKeyTextHandler0 . handleNotNullableField ( "" , ' [ ' , keyEvent0 , ( IRestorableTextComponent ) restorableJTextArea0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void handleNotNullableField ( String text , char c , KeyEvent e , IRestorableTextComponent _textComponent ) { if ( text . length ( ) = = 0 ) { / / We want to detect two empty text values in a row before / / we decide to restore the original value . Since 'text' / / contains the new value , we want to allow the first empty / / 'text' so that the user can clear the field , and on the / / second one we will set it to the original value . if ( firstBlankText ) { firstBlankText = false ; return ; } else { firstBlankText = true ; } if ( c = = KeyEvent . VK_BACK_SPACE | | c = = KeyEvent . VK_DELETE ) { / / delete when null = > original value _textComponent . restoreText ( ) ; e . consume ( ) ; } } }
void test2 ( ) throws Throwable { BaseKeyTextHandler baseKeyTextHandler0 = new BaseKeyTextHandler ( ) ; JToolBar jToolBar0 = new JToolBar ( "" ) ; KeyEvent keyEvent0 = new KeyEvent ( ( Component ) jToolBar0 , 938 , 1480L , ( int ) ' [ ' , 0 , ' [ ' ) ; RestorableJTextArea restorableJTextArea0 = new RestorableJTextArea ( ) ; ToolkitBeepHelper toolkitBeepHelper0 = new ToolkitBeepHelper ( ) ; baseKeyTextHandler0 . checkSignCharacter ( keyEvent0 , ( JTextComponent ) restorableJTextArea0 , ( ColumnDisplayDefinition ) null , ( IToolkitBeepHelper ) toolkitBeepHelper0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void checkSignCharacter ( KeyEvent keyEvent , JTextComponent textComponent , ColumnDisplayDefinition colDef , IToolkitBeepHelper beepHelper ) { char c = keyEvent . getKeyChar ( ) ; String text = textComponent . getText ( ) ; if ( isSignCharacter ( c ) ) { boolean ok = true ; if ( colDef . isSigned ( ) = = false ) { ok = false ; } else if ( ! text . equals ( " < null > " ) & & text . length ( ) ! = 0 ) { int caretPosition = textComponent . getCaretPosition ( ) ; if ( caretPosition ! = 0 | | isSignCharacter ( text . charAt ( 0 ) ) ) { ok = false ; } } if ( ok = = false ) { / * * user entered ' + ' or ' - ' at a bad place , * Maybe not at the first position , or there is not a numeric char at the beginning - maybe we have already a sign * / beepHelper . beep ( textComponent ) ; keyEvent . consume ( ) ; } } }
void test0 ( ) throws Throwable { WhereClausePartUtil whereClausePartUtil0 = new WhereClausePartUtil ( ) ; LinkedList < IWhereClausePart > linkedList0 = new LinkedList < IWhereClausePart > ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1506 ) , "b ! J9h^" ) ; NoParameterWhereClausePart noParameterWhereClausePart0 = new NoParameterWhereClausePart ( columnDisplayDefinition0 , "b ! J9h^" ) ; linkedList0 . add ( ( IWhereClausePart ) noParameterWhereClausePart0 ) ; String string0 = whereClausePartUtil0 . createWhereClause ( ( List < IWhereClausePart > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String createWhereClause ( List < IWhereClausePart > whereClauseParts ) { StringBuilder sb = new StringBuilder ( "" ) ; for ( IWhereClausePart whereClausePart : whereClauseParts ) { if ( whereClausePart . shouldBeUsed ( ) ) { whereClausePart . appendToClause ( sb ) ; } } if ( sb . length ( ) > 0 ) { return sb . toString ( ) ; } else { return null ; } }
void test1 ( ) throws Throwable { WhereClausePartUtil whereClausePartUtil0 = new WhereClausePartUtil ( ) ; Vector < IWhereClausePart > vector0 = new Vector < IWhereClausePart > ( ) ; EmptyWhereClausePart emptyWhereClausePart0 = new EmptyWhereClausePart ( ) ; vector0 . add ( ( IWhereClausePart ) emptyWhereClausePart0 ) ; String string0 = whereClausePartUtil0 . createWhereClause ( ( List < IWhereClausePart > ) vector0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String createWhereClause ( List < IWhereClausePart > whereClauseParts ) { StringBuilder sb = new StringBuilder ( "" ) ; for ( IWhereClausePart whereClausePart : whereClauseParts ) { if ( whereClausePart . shouldBeUsed ( ) ) { whereClausePart . appendToClause ( sb ) ; } } if ( sb . length ( ) > 0 ) { return sb . toString ( ) ; } else { return null ; } }
void test2 ( ) throws Throwable { WhereClausePartUtil whereClausePartUtil0 = new WhereClausePartUtil ( ) ; LinkedList < IWhereClausePart > linkedList0 = new LinkedList < IWhereClausePart > ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1506 ) , "b ! J9h^" ) ; NoParameterWhereClausePart noParameterWhereClausePart0 = new NoParameterWhereClausePart ( columnDisplayDefinition0 , "b ! J9h^" ) ; linkedList0 . add ( ( IWhereClausePart ) noParameterWhereClausePart0 ) ; int int0 = whereClausePartUtil0 . setParameters ( ( PreparedStatement ) null , ( List < IWhereClausePart > ) linkedList0 , ( - 1506 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int setParameters ( PreparedStatement pstmt , List < IWhereClausePart > whereClauseParts , int firstPosition ) throws SQLException { int position = firstPosition ; for ( IWhereClausePart whereClausePart : whereClauseParts ) { if ( whereClausePart . shouldBeUsed ( ) ) { if ( whereClausePart . isParameterUsed ( ) ) { whereClausePart . setParameter ( pstmt , position ) ; position + + ; } } } return position + + ; }
void test3 ( ) throws Throwable { WhereClausePartUtil whereClausePartUtil0 = new WhereClausePartUtil ( ) ; Vector < IWhereClausePart > vector0 = new Vector < IWhereClausePart > ( ) ; EmptyWhereClausePart emptyWhereClausePart0 = new EmptyWhereClausePart ( ) ; vector0 . add ( ( IWhereClausePart ) emptyWhereClausePart0 ) ; int int0 = whereClausePartUtil0 . setParameters ( ( PreparedStatement ) null , ( List < IWhereClausePart > ) vector0 , ( - 1108 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int setParameters ( PreparedStatement pstmt , List < IWhereClausePart > whereClauseParts , int firstPosition ) throws SQLException { int position = firstPosition ; for ( IWhereClausePart whereClausePart : whereClauseParts ) { if ( whereClausePart . shouldBeUsed ( ) ) { if ( whereClausePart . isParameterUsed ( ) ) { whereClausePart . setParameter ( pstmt , position ) ; position + + ; } } } return position + + ; }
void test4 ( ) throws Throwable { WhereClausePartUtil whereClausePartUtil0 = new WhereClausePartUtil ( ) ; boolean boolean0 = whereClausePartUtil0 . hasUsableWhereClause ( ( List < IWhereClausePart > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasUsableWhereClause ( List < IWhereClausePart > whereClauseParts ) { if ( whereClauseParts = = null | | whereClauseParts . isEmpty ( ) ) { return false ; } for ( IWhereClausePart whereClausePart : whereClauseParts ) { if ( whereClausePart . shouldBeUsed ( ) ) { return true ; } } return false ; }
void test5 ( ) throws Throwable { WhereClausePartUtil whereClausePartUtil0 = new WhereClausePartUtil ( ) ; LinkedList < IWhereClausePart > linkedList0 = new LinkedList < IWhereClausePart > ( ) ; boolean boolean0 = whereClausePartUtil0 . hasUsableWhereClause ( ( List < IWhereClausePart > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasUsableWhereClause ( List < IWhereClausePart > whereClauseParts ) { if ( whereClauseParts = = null | | whereClauseParts . isEmpty ( ) ) { return false ; } for ( IWhereClausePart whereClausePart : whereClauseParts ) { if ( whereClausePart . shouldBeUsed ( ) ) { return true ; } } return false ; }
void test6 ( ) throws Throwable { WhereClausePartUtil whereClausePartUtil0 = new WhereClausePartUtil ( ) ; LinkedList < IWhereClausePart > linkedList0 = new LinkedList < IWhereClausePart > ( ) ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 1506 ) , "b ! J9h^" ) ; NoParameterWhereClausePart noParameterWhereClausePart0 = new NoParameterWhereClausePart ( columnDisplayDefinition0 , "b ! J9h^" ) ; linkedList0 . add ( ( IWhereClausePart ) noParameterWhereClausePart0 ) ; boolean boolean0 = whereClausePartUtil0 . hasUsableWhereClause ( ( List < IWhereClausePart > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasUsableWhereClause ( List < IWhereClausePart > whereClauseParts ) { if ( whereClauseParts = = null | | whereClauseParts . isEmpty ( ) ) { return false ; } for ( IWhereClausePart whereClausePart : whereClauseParts ) { if ( whereClausePart . shouldBeUsed ( ) ) { return true ; } } return false ; }
void test7 ( ) throws Throwable { WhereClausePartUtil whereClausePartUtil0 = new WhereClausePartUtil ( ) ; Vector < IWhereClausePart > vector0 = new Vector < IWhereClausePart > ( ) ; EmptyWhereClausePart emptyWhereClausePart0 = new EmptyWhereClausePart ( ) ; vector0 . add ( ( IWhereClausePart ) emptyWhereClausePart0 ) ; boolean boolean0 = whereClausePartUtil0 . hasUsableWhereClause ( ( List < IWhereClausePart > ) vector0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasUsableWhereClause ( List < IWhereClausePart > whereClauseParts ) { if ( whereClauseParts = = null | | whereClauseParts . isEmpty ( ) ) { return false ; } for ( IWhereClausePart whereClausePart : whereClauseParts ) { if ( whereClausePart . shouldBeUsed ( ) ) { return true ; } } return false ; }
void test4 ( ) throws Throwable { EmptyWhereClausePart emptyWhereClausePart0 = new EmptyWhereClausePart ( ) ; boolean boolean0 = emptyWhereClausePart0 . shouldBeUsed ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean shouldBeUsed ( ) { return false ; }
void test0 ( ) throws Throwable { DialectType dialectType0 = DialectType . INTERBASE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 394 , "m + { i = " , "m + { i = " , "m + { i = " , 151 , ( String ) null , false , 151 , ( - 611 ) , ( - 611 ) , true , true , true , dialectType0 ) ; IsNullWhereClausePart isNullWhereClausePart0 = new IsNullWhereClausePart ( columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < IWhereClausePart > getWhereClause ( Object [ ] values , ColumnDisplayDefinition [ ] colDefs , int col , Object colValue ) { try { / / For tables that have a lot of columns , the user may have limited the set of columns / / to use in the where clause , so see if there is a table of col names HashMap < String , String > colNames = ( EditWhereCols . get ( getFullTableName ( ) ) ) ; ColumnDisplayDefinition editedCol = null ; if ( - 1 ! = col ) { editedCol = colDefs [ col ] ; } List < IWhereClausePart > clauseParts = new ArrayList < IWhereClausePart > ( ) ; for ( int i = 0 ; i < colDefs . length ; i + + ) { if ( i ! = col & & null ! = editedCol & & colDefs [ i ] . getFullTableColumnName ( ) . equalsIgnoreCase ( editedCol . getFullTableColumnName ( ) ) ) { / / The edited column is in the resultset twice ( example : SELECT MyName , * FROM MyTable ) . / / We won't add the this col to the where clause . continue ; } / / if the user has said to not use this column , then skip it if ( colNames ! = null ) { / / the user has restricted the set of columns to use . / / If this name is NOT in the list , then skip it ; otherwise we fall through / / and use the column in the WHERE clause if ( colNames . get ( colDefs [ i ] . getColumnName ( ) ) = = null ) continue ; / / go on to the next item } / / for the column that is being changed , use the value / / passed in by the caller ( which may be either the / / current value or the new replacement value ) Object value = values [ i ] ; if ( i = = col ) value = colValue ; / / convert user representation of null into an actual null if ( value ! = null & & value . toString ( ) . equals ( " < null > " ) ) value = null ; / / do different things depending on data type ISQLDatabaseMetaData md = _session . getMetaData ( ) ; IWhereClausePart clausePart = CellComponentFactory . getWhereClauseValue ( colDefs [ i ] , value , md ) ; if ( clausePart . shouldBeUsed ( ) ) / / Now we know that the part should not we ignoredshould clauseParts . add ( clausePart ) ; } return clauseParts ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
void test0 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 24 ) , "A connection ustbe upplie . " ) ; NoParameterWhereClausePart noParameterWhereClausePart0 = new NoParameterWhereClausePart ( columnDisplayDefinition0 , "A connection ustbe upplie . " ) ; boolean boolean0 = noParameterWhereClausePart0 . isParameterUsed ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isParameterUsed ( ) { throw new IllegalStateException ( "A NopWhereClauseParte does not support a whereClause" ) ; }
void test0 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 516 ) , "z_e & PLS7 + 3" ) ; IsNullWhereClausePart isNullWhereClausePart0 = new IsNullWhereClausePart ( columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 4 , "K | KADZ } ; n , = UNhn" ) ; IsNullWhereClausePart isNullWhereClausePart0 = new IsNullWhereClausePart ( columnDisplayDefinition0 ) ; String string0 = isNullWhereClausePart0 . getColumn ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumn ( ) { return _column ; }
void test4 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( ( - 516 ) , "z_e & PLS7 + 3" ) ; IsNullWhereClausePart isNullWhereClausePart0 = new IsNullWhereClausePart ( columnDisplayDefinition0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { DialectType dialectType0 = DialectType . ORACLE ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , "#N } " , "#N } " , "#N } " , 0 , "#N } " , true , 993 , 841 , 0 , true , true , false , dialectType0 ) ; Object [ ] [ ] objectArray0 = new Object [ 3 ] [ 5 ] ; Object [ ] objectArray1 = new Object [ 7 ] ; objectArray1 [ 0 ] = ( Object ) false ; objectArray1 [ 1 ] = ( Object ) true ; objectArray1 [ 2 ] = ( Object ) false ; objectArray1 [ 3 ] = ( Object ) "#N } " ; objectArray1 [ 4 ] = ( Object ) 0 ; objectArray1 [ 5 ] = ( Object ) 841 ; objectArray1 [ 6 ] = ( Object ) 993 ; objectArray0 [ 0 ] = objectArray1 ; objectArray0 [ 1 ] = objectArray0 [ 0 ] ; JTable jTable0 = new JTable ( objectArray0 , objectArray0 [ 1 ] ) ; DataTypeBigDecimal dataTypeBigDecimal0 = new DataTypeBigDecimal ( jTable0 , columnDisplayDefinition0 ) ; ParameterWhereClausePart parameterWhereClausePart0 = new ParameterWhereClausePart ( columnDisplayDefinition0 , ( Object ) "bidi level" , ( IDataTypeComponent ) dataTypeBigDecimal0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void setParameter ( PreparedStatement pstmt , int position ) throws SQLException { throw new IllegalStateException ( "A NopWhereClausePart can't set an parameter" ) ; }
void test1 ( ) throws Throwable { DialectType dialectType0 = DialectType . GENERIC ; ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 0 , " & 4rOuH^ } Tn61 } } g~#k" , "zT@BbQdNv ! YW ) KX" , " & 4rOuH^ } Tn61 } } g~#k" , 1824 , "zT@BbQdNv ! YW ) KX" , true , ( - 288 ) , 1343 , 0 , false , false , true , dialectType0 ) ; JTable jTable0 = new JTable ( 1824 , 1714 ) ; DataTypeUnknown dataTypeUnknown0 = new DataTypeUnknown ( jTable0 , columnDisplayDefinition0 ) ; ParameterWhereClausePart parameterWhereClausePart0 = new ParameterWhereClausePart ( columnDisplayDefinition0 , ( Object ) "# , ##0 . ###" , ( IDataTypeComponent ) dataTypeUnknown0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < IWhereClausePart > getWhereClause ( Object [ ] values , ColumnDisplayDefinition [ ] colDefs , int col , Object colValue ) { try { / / For tables that have a lot of columns , the user may have limited the set of columns / / to use in the where clause , so see if there is a table of col names HashMap < String , String > colNames = ( EditWhereCols . get ( getFullTableName ( ) ) ) ; ColumnDisplayDefinition editedCol = null ; if ( - 1 ! = col ) { editedCol = colDefs [ col ] ; } List < IWhereClausePart > clauseParts = new ArrayList < IWhereClausePart > ( ) ; for ( int i = 0 ; i < colDefs . length ; i + + ) { if ( i ! = col & & null ! = editedCol & & colDefs [ i ] . getFullTableColumnName ( ) . equalsIgnoreCase ( editedCol . getFullTableColumnName ( ) ) ) { / / The edited column is in the resultset twice ( example : SELECT MyName , * FROM MyTable ) . / / We won't add the this col to the where clause . continue ; } / / if the user has said to not use this column , then skip it if ( colNames ! = null ) { / / the user has restricted the set of columns to use . / / If this name is NOT in the list , then skip it ; otherwise we fall through / / and use the column in the WHERE clause if ( colNames . get ( colDefs [ i ] . getColumnName ( ) ) = = null ) continue ; / / go on to the next item } / / for the column that is being changed , use the value / / passed in by the caller ( which may be either the / / current value or the new replacement value ) Object value = values [ i ] ; if ( i = = col ) value = colValue ; / / convert user representation of null into an actual null if ( value ! = null & & value . toString ( ) . equals ( " < null > " ) ) value = null ; / / do different things depending on data type ISQLDatabaseMetaData md = _session . getMetaData ( ) ; IWhereClausePart clausePart = CellComponentFactory . getWhereClauseValue ( colDefs [ i ] , value , md ) ; if ( clausePart . shouldBeUsed ( ) ) / / Now we know that the part should not we ignoredshould clauseParts . add ( clausePart ) ; } return clauseParts ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
void test2 ( ) throws Throwable { ColumnDisplayDefinition columnDisplayDefinition0 = new ColumnDisplayDefinition ( 1227 , "r { D | 5A < a" ) ; DataTypeDate dataTypeDate0 = new DataTypeDate ( ( JTable ) null , columnDisplayDefinition0 ) ; ParameterWhereClausePart parameterWhereClausePart0 = new ParameterWhereClausePart ( columnDisplayDefinition0 , ( Object ) "AccessibleCaret" , ( IDataTypeComponent ) dataTypeDate0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < IWhereClausePart > getWhereClause ( Object [ ] values , ColumnDisplayDefinition [ ] colDefs , int col , Object colValue ) { try { / / For tables that have a lot of columns , the user may have limited the set of columns / / to use in the where clause , so see if there is a table of col names HashMap < String , String > colNames = ( EditWhereCols . get ( getFullTableName ( ) ) ) ; ColumnDisplayDefinition editedCol = null ; if ( - 1 ! = col ) { editedCol = colDefs [ col ] ; } List < IWhereClausePart > clauseParts = new ArrayList < IWhereClausePart > ( ) ; for ( int i = 0 ; i < colDefs . length ; i + + ) { if ( i ! = col & & null ! = editedCol & & colDefs [ i ] . getFullTableColumnName ( ) . equalsIgnoreCase ( editedCol . getFullTableColumnName ( ) ) ) { / / The edited column is in the resultset twice ( example : SELECT MyName , * FROM MyTable ) . / / We won't add the this col to the where clause . continue ; } / / if the user has said to not use this column , then skip it if ( colNames ! = null ) { / / the user has restricted the set of columns to use . / / If this name is NOT in the list , then skip it ; otherwise we fall through / / and use the column in the WHERE clause if ( colNames . get ( colDefs [ i ] . getColumnName ( ) ) = = null ) continue ; / / go on to the next item } / / for the column that is being changed , use the value / / passed in by the caller ( which may be either the / / current value or the new replacement value ) Object value = values [ i ] ; if ( i = = col ) value = colValue ; / / convert user representation of null into an actual null if ( value ! = null & & value . toString ( ) . equals ( " < null > " ) ) value = null ; / / do different things depending on data type ISQLDatabaseMetaData md = _session . getMetaData ( ) ; IWhereClausePart clausePart = CellComponentFactory . getWhereClauseValue ( colDefs [ i ] , value , md ) ; if ( clausePart . shouldBeUsed ( ) ) / / Now we know that the part should not we ignoredshould clauseParts . add ( clausePart ) ; } return clauseParts ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
void test0 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "j . , " , "j . , " , "j . , " , "j . , " , 1023 , "j . , " , 1023 , 2 , 1716 , 0 , "" , "%4E [ ^$wAV * 1e" , ( - 971 ) , 44 , "%4E [ ^$wAV * 1e" ) ; int int0 = tableColumnInfo0 . getOrdinalPosition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getTypeName ( int code , int length , int precision , int scale ) throws HibernateException { return _dialect . getTypeName ( code , length , precision , scale ) ; }
void test1 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " + / T~" , " + / T~" , " + / T~" , " + / T~" , 9 , " + / T~" , 317 , 1 , 395 , 9 , " + / T~" , " + / T~" , 1 , ( - 533 ) , " + / T~" ) ; int int0 = tableColumnInfo0 . getColumnSize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" short getOrdinalPosition ( ) { return ordinalPosition ; }
void test2 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , ( - 315 ) , "" , ( - 315 ) , ( - 315 ) , 0 , 0 , "" , "" , ( - 315 ) , 0 , "" ) ; int int0 = tableColumnInfo0 . getOctetLength ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRadix ( ) { return _radix ; }
void test3 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , ( - 1734 ) , "" , ( - 1734 ) , 0 , ( - 1734 ) , 1362 , "" , "" , 1 , 0 , "" ) ; String string0 = tableColumnInfo0 . getColumnName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDataType ( ) { return _dataType ; }
void test4 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , ( - 1734 ) , "" , ( - 1734 ) , 0 , ( - 1734 ) , 1362 , "" , "" , 1 , 0 , "" ) ; String string0 = tableColumnInfo0 . getTableName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getDataType ( ) { return _dataType ; }
void test5 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "jRr% = dX ) tba ! IMyX2d5" , "" , "" , "" , ( - 1 ) , "jRr% = dX ) tba ! IMyX2d5" , 1296 , ( - 2016 ) , ( - 771 ) , ( - 771 ) , "" , "jRr% = dX ) tba ! IMyX2d5" , 0 , 1296 , "jRr% = dX ) tba ! IMyX2d5" ) ; int int0 = tableColumnInfo0 . getDataType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNullable ( ) { return _nullable ; }
void test6 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "j . , " , "j . , " , "j . , " , "j . , " , 1023 , "j . , " , 1023 , 2 , 1716 , 0 , "" , "%4E [ ^$wAV * 1e" , ( - 971 ) , 44 , "%4E [ ^$wAV * 1e" ) ; String string0 = tableColumnInfo0 . isNullable ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDefaultValue ( String dbDefaultValue ) ; / * * File IO related functions * / / * * * Say whether or not object can be exported to and imported from a file . We * put both export and import together in one test on the assumption that * all conversions can be done both ways . * / boolean canDoFileIO ( ) ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the imported data can be * converted to an object , and then must return a text string that can be * used in the Popup window text area . This object - to - text conversion is the * same as is done by the DataType object internally in the getJTextArea ( ) * method . * / String importObject ( FileInputStream inStream ) throws IOException ; / * * * Read a file and construct a valid object from its contents . Errors are * returned by throwing an IOException containing the cause of the problem * as its message . * < P > * DataType is responsible for validating that the given text text from a * Popup JTextArea can be converted to an object . This text - to - object * conversion is the same as validateAndConvertInPopup , which may be used * internally by the object to do the validation . * < P > * The DataType object must flush and close the output stream before * returning . Typically it will create another object ( e . g . an * OutputWriter ) , and that is the object that must be flushed and closed . * / void exportObject ( FileOutputStream outStream , String text ) throws IOException ; / * * * Sets the display definition of the Column being operated upon . * * @param def the ColumnDisplayDefinition that describes the column in the * db table . * / void setColumnDisplayDefinition ( ColumnDisplayDefinition def ) ; / * * * Sets the JTable of which holds data rendered by this DataTypeComponent . * * @param table a JTable component * / void setTable ( JTable table ) ; / * * * Sets the utility that allows the component to notify the user audibly when there is a * problem with input data . * * @param helper * / void setBeepHelper ( IToolkitBeepHelper helper ) ; }
void test7 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , ( - 1734 ) , "" , ( - 1734 ) , 0 , ( - 1734 ) , 1362 , "" , "" , 1 , 0 , "" ) ; String string0 = tableColumnInfo0 . getDefaultValue ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" short getOrdinalPosition ( ) { return ordinalPosition ; }
void test8 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " + / T~" , " + / T~" , " + / T~" , " + / T~" , 9 , " + / T~" , 317 , 1 , 395 , 9 , " + / T~" , " + / T~" , 1 , ( - 533 ) , " + / T~" ) ; int int0 = tableColumnInfo0 . getDecimalDigits ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnSize ( ) { return _columnSize ; }
void test9 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " + / T~" , " + / T~" , " + / T~" , " + / T~" , 9 , " + / T~" , 317 , 1 , 395 , 9 , " + / T~" , " + / T~" , 1 , ( - 533 ) , " + / T~" ) ; int int0 = tableColumnInfo0 . getRadix ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnSize ( ) { return _columnSize ; }
void test10 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "jRr% = dX ) tba ! IMyX2d5" , "" , "" , "" , ( - 1 ) , "jRr% = dX ) tba ! IMyX2d5" , 1296 , ( - 2016 ) , ( - 771 ) , ( - 771 ) , "" , "jRr% = dX ) tba ! IMyX2d5" , 0 , 1296 , "jRr% = dX ) tba ! IMyX2d5" ) ; int int0 = tableColumnInfo0 . isNullAllowed ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getRemarks ( ) { return _remarks ; }
void test11 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "" , "" , "" , "" , ( - 1734 ) , "" , ( - 1734 ) , 0 , ( - 1734 ) , 1362 , "" , "" , 1 , 0 , "" ) ; String string0 = tableColumnInfo0 . getTypeName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" short getOrdinalPosition ( ) { return ordinalPosition ; }
void test12 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " [ ; Y0K ) rss } B" , " [ ; Y0K ) rss } B" , " [ ; Y0K ) rss } B" , " [ ; Y0K ) rss } B" , 0 , " [ ; Y0K ) rss } B" , 193 , ( - 1 ) , ( - 1 ) , ( - 1 ) , " [ ; Y0K ) rss } B" , " [ ; Y0K ) rss } B" , ( - 1 ) , 0 , " [ ; Y0K ) rss } B" ) ; String string0 = tableColumnInfo0 . getRemarks ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" short getOrdinalPosition ( ) { return ordinalPosition ; }
void test0 ( ) throws Throwable { Vector < ITableInfo > vector0 = new Vector < ITableInfo > ( ) ; ProgressCallBackAdaptor progressCallBackAdaptor0 = new ProgressCallBackAdaptor ( ) ; List < ITableInfo > list0 = SQLUtilities . getDeletionOrder ( ( List < ITableInfo > ) vector0 , ( SQLDatabaseMetaData ) null , ( ProgressCallBack ) progressCallBackAdaptor0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test1 ( ) throws Throwable { SQLUtilities sQLUtilities0 = new SQLUtilities ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test3 ( ) throws Throwable { String string0 = SQLUtilities . quoteIdentifier ( "8 { Zc\" = H | VI" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String quoteIdentifier ( String s ) { if ( s = = null ) { return null ; } StringBuilder buff = null ; buff = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; if ( c = = '"' & & i ! = 0 & & i ! = s . length ( ) - 1 ) { buff . append ( c ) ; } buff . append ( c ) ; } String result = buff . toString ( ) ; return result ; }
void test4 ( ) throws Throwable { String string0 = SQLUtilities . quoteIdentifier ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String quoteIdentifier ( String s ) { if ( s = = null ) { return null ; } StringBuilder buff = null ; buff = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; if ( c = = '"' & & i ! = 0 & & i ! = s . length ( ) - 1 ) { buff . append ( c ) ; } buff . append ( c ) ; } String result = buff . toString ( ) ; return result ; }
void test5 ( ) throws Throwable { String string0 = SQLUtilities . quoteIdentifier ( "K\"" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String quoteIdentifier ( String s ) { if ( s = = null ) { return null ; } StringBuilder buff = null ; buff = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; if ( c = = '"' & & i ! = 0 & & i ! = s . length ( ) - 1 ) { buff . append ( c ) ; } buff . append ( c ) ; } String result = buff . toString ( ) ; return result ; }
void test6 ( ) throws Throwable { ProgressCallBackAdaptor progressCallBackAdaptor0 = new ProgressCallBackAdaptor ( ) ; List < ITableInfo > list0 = SQLUtilities . getInsertionOrder ( ( List < ITableInfo > ) null , ( SQLDatabaseMetaData ) null , ( ProgressCallBack ) progressCallBackAdaptor0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < ITableInfo > getInsertionOrder ( List < ITableInfo > tables , SQLDatabaseMetaData md , ProgressCallBack callback ) throws SQLException { List < ITableInfo > result = new ArrayList < ITableInfo > ( ) ; / / tables that are netiher children nor parents - utility tables List < ITableInfo > unattached = new ArrayList < ITableInfo > ( ) ; / / tables that have at least one parent table List < ITableInfo > children = new ArrayList < ITableInfo > ( ) ; / / tables that have at least one child table List < ITableInfo > parents = new ArrayList < ITableInfo > ( ) ; / / tables that have at least one child table and have a least one parent table List < ITableInfo > sandwiches = new ArrayList < ITableInfo > ( ) ; ITableInfo lastTable = null ; try { for ( ITableInfo table : tables ) { lastTable = table ; callback . currentlyLoading ( table . getSimpleName ( ) ) ; ForeignKeyInfo [ ] importedKeys = getImportedKeys ( table , md ) ; ForeignKeyInfo [ ] exportedKeys = getExportedKeys ( table , md ) ; if ( importedKeys ! = null & & importedKeys . length = = 0 & & exportedKeys . length = = 0 ) { unattached . add ( table ) ; continue ; } if ( exportedKeys ! = null & & exportedKeys . length > 0 ) { if ( importedKeys ! = null & & importedKeys . length > 0 ) { sandwiches . add ( table ) ; } else { parents . add ( table ) ; } continue ; } if ( importedKeys ! = null & & importedKeys . length > 0 ) { children . add ( table ) ; } } reorderTables ( sandwiches ) ; for ( ITableInfo info : unattached ) { result . add ( info ) ; } for ( ITableInfo info : parents ) { result . add ( info ) ; } for ( ITableInfo info : sandwiches ) { result . add ( info ) ; } for ( ITableInfo info : children ) { result . add ( info ) ; } if ( result . size ( ) ! = tables . size ( ) ) { s_log . error ( "getInsertionOrder ( ) : failed to obtain a result table list " + " ( " + result . size ( ) + " ) that is the same size as the input table " + "list ( " + tables . size ( ) + " ) - returning the original unordered " + "list" ) ; result = tables ; } } catch ( Exception e ) { if ( lastTable ! = null ) { String tablename = lastTable . getSimpleName ( ) ; s_log . error ( "Unexpected exception while getting foreign key info for " + "table " + tablename , e ) ; } else { s_log . error ( "Unexpected exception while getting foreign key info " , e ) ; } result = tables ; } return result ; }
void test7 ( ) throws Throwable { Vector < ITableInfo > vector0 = new Vector < ITableInfo > ( ) ; List < String > list0 = SQLUtilities . getExtFKParents ( ( SQLDatabaseMetaData ) null , ( List < ITableInfo > ) vector0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test8 ( ) throws Throwable { Vector < ITableInfo > vector0 = new Vector < ITableInfo > ( ) ; List < String > list0 = SQLUtilities . getExtFKChildren ( ( SQLDatabaseMetaData ) null , ( List < ITableInfo > ) vector0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test10 ( ) throws Throwable { String string0 = SQLUtilities . getQualifiedTableName ( ( String ) null , ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedTableName ( String catalog , String schema , String tableName ) { String ret = "" ; if ( null ! = catalog ) { ret + = catalog + " . " ; } if ( null ! = schema ) { ret + = schema + " . " ; } ret + = tableName ; return ret ; }
void test11 ( ) throws Throwable { String string0 = SQLUtilities . getQualifiedTableName ( "K\"" , "K\"" , "8 { Zc\" = H | VI" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQualifiedTableName ( String catalog , String schema , String tableName ) { String ret = "" ; if ( null ! = catalog ) { ret + = catalog + " . " ; } if ( null ! = schema ) { ret + = schema + " . " ; } ret + = tableName ; return ret ; }
void test0 ( ) throws Throwable { ForeignKeyColumnInfo foreignKeyColumnInfo0 = new ForeignKeyColumnInfo ( "" , "" , ( - 1987 ) ) ; String string0 = foreignKeyColumnInfo0 . getPrimaryKeyColumnName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getKeySequence ( ) { return _keySeq ; }
void test1 ( ) throws Throwable { ForeignKeyColumnInfo foreignKeyColumnInfo0 = new ForeignKeyColumnInfo ( "" , "" , ( - 1987 ) ) ; String string0 = foreignKeyColumnInfo0 . getForeignKeyColumnName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getKeySequence ( ) { return _keySeq ; }
void test2 ( ) throws Throwable { ForeignKeyColumnInfo foreignKeyColumnInfo0 = new ForeignKeyColumnInfo ( "" , "" , ( - 1987 ) ) ; int int0 = foreignKeyColumnInfo0 . getKeySequence ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getKeySequence ( ) { return _keySeq ; }
void test3 ( ) throws Throwable { SQLDriverManager sQLDriverManager0 = new SQLDriverManager ( ) ; UidIdentifier uidIdentifier0 = new UidIdentifier ( ) ; sQLDriverManager0 . getJDBCDriver ( ( IIdentifier ) uidIdentifier0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test5 ( ) throws Throwable { SQLDriverManager sQLDriverManager0 = new SQLDriverManager ( ) ; SQLDriver sQLDriver0 = new SQLDriver ( ) ; SQLDriverClassLoader sQLDriverClassLoader0 = sQLDriverManager0 . getSQLDriverClassLoader ( ( ISQLDriver ) sQLDriver0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLDriverClassLoader getSQLDriverClassLoader ( ISQLDriver driver ) { if ( driver = = null ) { throw new IllegalArgumentException ( "SQLDriverClassLoader = = null" ) ; } return _classLoaders . get ( driver . getIdentifier ( ) ) ; }
void test0 ( ) throws Throwable { DatabaseObjectType databaseObjectType0 = DatabaseObjectType . createNewDatabaseObjectType ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test1 ( ) throws Throwable { DatabaseObjectType databaseObjectType0 = DatabaseObjectType . createNewDatabaseObjectType ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { DatabaseObjectType databaseObjectType0 = DatabaseObjectType . TABLE_TYPE_DBO ; String string0 = databaseObjectType0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { DatabaseObjectType databaseObjectType0 = DatabaseObjectType . TABLE_TYPE_DBO ; IntegerIdentifier integerIdentifier0 = ( IntegerIdentifier ) databaseObjectType0 . getIdentifier ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test4 ( ) throws Throwable { DatabaseObjectType databaseObjectType0 = DatabaseObjectType . createNewDatabaseObjectType ( "Table Type" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test0 ( ) throws Throwable { ProgressCallBackAdaptor progressCallBackAdaptor0 = new ProgressCallBackAdaptor ( ) ; progressCallBackAdaptor0 . setLoadingPrefix ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean finishedLoading ( ) { return progressBar . getValue ( ) = = itemCount ; }
void test1 ( ) throws Throwable { ProgressCallBackAdaptor progressCallBackAdaptor0 = new ProgressCallBackAdaptor ( ) ; progressCallBackAdaptor0 . dispose ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean finishedLoading ( ) { return progressBar . getValue ( ) = = itemCount ; }
void test2 ( ) throws Throwable { ProgressCallBackAdaptor progressCallBackAdaptor0 = new ProgressCallBackAdaptor ( ) ; boolean boolean0 = progressCallBackAdaptor0 . finishedLoading ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean finishedLoading ( ) { return progressBar . getValue ( ) = = itemCount ; }
void test3 ( ) throws Throwable { ProgressCallBackAdaptor progressCallBackAdaptor0 = new ProgressCallBackAdaptor ( ) ; progressCallBackAdaptor0 . setTotalItems ( ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean finishedLoading ( ) { return progressBar . getValue ( ) = = itemCount ; }
void test4 ( ) throws Throwable { ProgressCallBackAdaptor progressCallBackAdaptor0 = new ProgressCallBackAdaptor ( ) ; progressCallBackAdaptor0 . setVisible ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean finishedLoading ( ) { return progressBar . getValue ( ) = = itemCount ; }
void test5 ( ) throws Throwable { ProgressCallBackAdaptor progressCallBackAdaptor0 = new ProgressCallBackAdaptor ( ) ; progressCallBackAdaptor0 . currentlyLoading ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean finishedLoading ( ) { return progressBar . getValue ( ) = = itemCount ; }
void test0 ( ) throws Throwable { ForeignKeyInfoBeanInfo foreignKeyInfoBeanInfo0 = new ForeignKeyInfoBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = foreignKeyInfoBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { TokenizerSessPropsInteractions tokenizerSessPropsInteractions0 = new TokenizerSessPropsInteractions ( ) ; tokenizerSessPropsInteractions0 . setTokenizerDefinesRemoveMultiLineComment ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTokenizerDefinesStatementSeparator ( ) { return _tokenizerDefinesStatementSeparator ; }
void test1 ( ) throws Throwable { TokenizerSessPropsInteractions tokenizerSessPropsInteractions0 = new TokenizerSessPropsInteractions ( ) ; boolean boolean0 = tokenizerSessPropsInteractions0 . isTokenizerDefinesStartOfLineComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTokenizerDefinesStartOfLineComment ( ) { return _tokenizerDefinesStartOfLineComment ; }
void test2 ( ) throws Throwable { TokenizerSessPropsInteractions tokenizerSessPropsInteractions0 = new TokenizerSessPropsInteractions ( ) ; boolean boolean0 = tokenizerSessPropsInteractions0 . isTokenizerDefinesRemoveMultiLineComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTokenizerDefinesRemoveMultiLineComment ( ) { return _tokenizerDefinesRemoveMultiLineComment ; }
void test3 ( ) throws Throwable { TokenizerSessPropsInteractions tokenizerSessPropsInteractions0 = new TokenizerSessPropsInteractions ( ) ; boolean boolean0 = tokenizerSessPropsInteractions0 . isTokenizerDefinesStatementSeparator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTokenizerDefinesStatementSeparator ( ) { return _tokenizerDefinesStatementSeparator ; }
void test4 ( ) throws Throwable { TokenizerSessPropsInteractions tokenizerSessPropsInteractions0 = new TokenizerSessPropsInteractions ( ) ; tokenizerSessPropsInteractions0 . setTokenizerDefinesStartOfLineComment ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTokenizerDefinesStartOfLineComment ( ) { return _tokenizerDefinesStartOfLineComment ; }
void test5 ( ) throws Throwable { TokenizerSessPropsInteractions tokenizerSessPropsInteractions0 = new TokenizerSessPropsInteractions ( ) ; tokenizerSessPropsInteractions0 . setTokenizerDefinesStatementSeparator ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isTokenizerDefinesStatementSeparator ( ) { return _tokenizerDefinesStatementSeparator ; }
void test1 ( ) throws Throwable { SQLConnectionState sQLConnectionState0 = new SQLConnectionState ( ) ; SQLDriverPropertyCollection sQLDriverPropertyCollection0 = sQLConnectionState0 . getConnectionProperties ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLAliasConnectionProperties getConnectionProperties ( ) { return _connectionProperties ; }
void test2 ( ) throws Throwable { SQLConnectionState sQLConnectionState0 = new SQLConnectionState ( ) ; boolean boolean0 = sQLConnectionState0 . getAutoCommit ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getAutoCommit ( ) { return _autoCommit ; }
void test1 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( " ] K' { Qw { " , " ] K' { Qw { " , " ] K' { Qw { " ) ; int int0 = databaseObjectInfo0 . compareTo ( ( IDatabaseObjectInfo ) databaseObjectInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compareTo ( CaseInsensitiveString anotherString ) { int len1 = count ; int len2 = anotherString . count ; int n = Math . min ( len1 , len2 ) ; char v1 [ ] = value ; char v2 [ ] = anotherString . value ; int i = offset ; int j = anotherString . offset ; if ( i = = j ) { int k = i ; int lim = n + i ; while ( k < lim ) { char c1 = v1 [ k ] ; char c2 = v2 [ k ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } k + + ; } } else { while ( n - - ! = 0 ) { char c1 = v1 [ i + + ] ; char c2 = v2 [ j + + ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } } } return len1 - len2 ; }
void test2 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "supportsSchemaInTbleDefiniti ] ns" , "supportsSchemaInTbleDefiniti ] ns" , "supportsSchemaInTbleDefiniti ] ns" ) ; String string0 = databaseObjectInfo0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "supportsSchemaInTbleDefiniti ] ns" , "supportsSchemaInTbleDefiniti ] ns" , "supportsSchemaInTbleDefiniti ] ns" ) ; DatabaseObjectType databaseObjectType0 = databaseObjectInfo0 . getDatabaseObjectType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getKeyForSerializationReplace ( ) { return _keyForSerializationReplace ; }
void test4 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "supportsSchemaInTbleDefiniti ] ns" , "supportsSchemaInTbleDefiniti ] ns" , "supportsSchemaInTbleDefiniti ] ns" ) ; String string0 = databaseObjectInfo0 . getCatalogName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCatalogName ( ) ; String getSchemaName ( ) ; String getSimpleName ( ) ; String getQualifiedName ( ) ; / * * * Return the type for this object . @see DatabaseObjectType . * / DatabaseObjectType getDatabaseObjectType ( ) ; }
void test5 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "" , "" , "" ) ; DatabaseObjectType databaseObjectType0 = DatabaseObjectType . CATALOG ; databaseObjectInfo0 . replaceDatabaseObjectTypeConstantObjectsByConstantObjectsOfThisVM ( databaseObjectType0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSimpleName ( ) ; String getQualifiedName ( ) ; / * * * Return the type for this object . @see DatabaseObjectType . * / DatabaseObjectType getDatabaseObjectType ( ) ; }
void test6 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "supportsSchemaInTbleDefiniti ] ns" , "supportsSchemaInTbleDefiniti ] ns" , "supportsSchemaInTbleDefiniti ] ns" ) ; int int0 = databaseObjectInfo0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test7 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( " ] K' { Qw { " , " ] K' { Qw { " , " ] K' { Qw { " ) ; String string0 = databaseObjectInfo0 . getSchemaName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSchemaName ( ) { return _schemaName ; }
void test11 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "" , "" , "" ) ; boolean boolean0 = databaseObjectInfo0 . equals ( ( Object ) databaseObjectInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test12 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( " ] K' { Qw { " , " ] K' { Qw { " , " ] K' { Qw { " ) ; boolean boolean0 = databaseObjectInfo0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test13 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( "" , "" , "" ) ; boolean boolean0 = databaseObjectInfo0 . equals ( ( Object ) "\u221E" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test14 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( ( String ) null , ( String ) null , ( String ) null ) ; boolean boolean0 = databaseObjectInfo0 . equals ( ( Object ) databaseObjectInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test0 ( ) throws Throwable { SQLDriverPropertyCollection sQLDriverPropertyCollection0 = new SQLDriverPropertyCollection ( ) ; DriverPropertyInfo [ ] driverPropertyInfoArray0 = new DriverPropertyInfo [ 1 ] ; DriverPropertyInfo driverPropertyInfo0 = new DriverPropertyInfo ( "TimePeriodA = nchor . EN" , "TimePeriodA = nchor . EN" ) ; driverPropertyInfoArray0 [ 0 ] = driverPropertyInfo0 ; sQLDriverPropertyCollection0 . applyDriverPropertynfo ( driverPropertyInfoArray0 ) ; sQLDriverPropertyCollection0 . applyTo ( ( Properties ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test1 ( ) throws Throwable { SQLDriverPropertyCollection sQLDriverPropertyCollection0 = new SQLDriverPropertyCollection ( ) ; DriverPropertyInfo [ ] driverPropertyInfoArray0 = new DriverPropertyInfo [ 1 ] ; DriverPropertyInfo driverPropertyInfo0 = new DriverPropertyInfo ( "TimePeriodA = nchor . EN" , "TimePeriodA = nchor . EN" ) ; driverPropertyInfoArray0 [ 0 ] = driverPropertyInfo0 ; sQLDriverPropertyCollection0 . applyDriverPropertynfo ( driverPropertyInfoArray0 ) ; SQLDriverProperty sQLDriverProperty0 = sQLDriverPropertyCollection0 . getDriverProperty ( 0 ) ; sQLDriverPropertyCollection0 . addDriverProperty ( sQLDriverProperty0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test2 ( ) throws Throwable { SQLDriverPropertyCollection sQLDriverPropertyCollection0 = new SQLDriverPropertyCollection ( ) ; SQLDriverProperty [ ] sQLDriverPropertyArray0 = sQLDriverPropertyCollection0 . getDriverProperties ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLDriverProperty [ ] getDriverProperties ( ) { SQLDriverProperty [ ] ar = new SQLDriverProperty [ _objectsList . size ( ) ] ; return _objectsList . toArray ( ar ) ; }
void test3 ( ) throws Throwable { SQLDriverPropertyCollection sQLDriverPropertyCollection0 = new SQLDriverPropertyCollection ( ) ; sQLDriverPropertyCollection0 . clear ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test4 ( ) throws Throwable { SQLDriverPropertyCollection sQLDriverPropertyCollection0 = new SQLDriverPropertyCollection ( ) ; DriverPropertyInfo [ ] driverPropertyInfoArray0 = new DriverPropertyInfo [ 1 ] ; DriverPropertyInfo driverPropertyInfo0 = new DriverPropertyInfo ( "TimePeriodA = nchor . EN" , "TimePeriodA = nchor . EN" ) ; driverPropertyInfoArray0 [ 0 ] = driverPropertyInfo0 ; sQLDriverPropertyCollection0 . applyDriverPropertynfo ( driverPropertyInfoArray0 ) ; SQLDriverProperty sQLDriverProperty0 = sQLDriverPropertyCollection0 . getDriverProperty ( 0 ) ; sQLDriverPropertyCollection0 . setDriverProperty ( 0 , sQLDriverProperty0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test5 ( ) throws Throwable { SQLDriverPropertyCollection sQLDriverPropertyCollection0 = new SQLDriverPropertyCollection ( ) ; sQLDriverPropertyCollection0 . removeDriverProperty ( "TimePeriodA = nchor . EN" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test6 ( ) throws Throwable { SQLDriverPropertyCollection sQLDriverPropertyCollection0 = new SQLDriverPropertyCollection ( ) ; DriverPropertyInfo driverPropertyInfo0 = new DriverPropertyInfo ( " ? : 6q`P , + / $ . , " , " ? : 6q`P , + / $ . , " ) ; SQLDriverProperty sQLDriverProperty0 = new SQLDriverProperty ( driverPropertyInfo0 ) ; SQLDriverProperty [ ] sQLDriverPropertyArray0 = new SQLDriverProperty [ 2 ] ; sQLDriverPropertyArray0 [ 0 ] = sQLDriverProperty0 ; sQLDriverPropertyArray0 [ 1 ] = sQLDriverProperty0 ; sQLDriverPropertyArray0 [ 1 ] . setIsSpecified ( true ) ; sQLDriverPropertyCollection0 . setDriverProperties ( sQLDriverPropertyArray0 ) ; Properties properties0 = new Properties ( ) ; sQLDriverPropertyCollection0 . applyTo ( properties0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test7 ( ) throws Throwable { SQLDriverPropertyCollection sQLDriverPropertyCollection0 = new SQLDriverPropertyCollection ( ) ; sQLDriverPropertyCollection0 . applyDriverPropertynfo ( ( DriverPropertyInfo [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test0 ( ) throws Throwable { int int0 = JDBCTypeMapper . getJdbcType ( "date" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getJdbcType ( String jdbcTypeName , int defaultVal ) { if ( jdbcTypeName = = null ) { return Types . NULL ; } int result = defaultVal ; try { Field [ ] fields = java . sql . Types . class . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i + + ) { Field field = fields [ i ] ; if ( field . getName ( ) . equalsIgnoreCase ( jdbcTypeName ) ) { result = field . getInt ( null ) ; } } } catch ( IllegalArgumentException e ) { s_log . error ( "getJdbcTypeName : unexpected exception : " + e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { s_log . error ( "getJdbcTypeName : unexpected exception : " + e . getMessage ( ) , e ) ; } return result ; }
void test1 ( ) throws Throwable { JDBCTypeMapper jDBCTypeMapper0 = new JDBCTypeMapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test2 ( ) throws Throwable { String [ ] stringArray0 = JDBCTypeMapper . getJdbcTypeList ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getJdbcTypeList ( ) { ArrayList < String > result = new ArrayList < String > ( ) ; Field [ ] fields = java . sql . Types . class . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i + + ) { Field field = fields [ i ] ; result . add ( field . getName ( ) ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; }
void test3 ( ) throws Throwable { String string0 = JDBCTypeMapper . getJdbcTypeName ( 1297 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getJdbcTypeName ( int jdbcType ) { String result = "UNKNOWN" ; try { Field [ ] fields = java . sql . Types . class . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i + + ) { Field field = fields [ i ] ; if ( field . getInt ( null ) = = jdbcType ) { result = field . getName ( ) ; break ; } } } catch ( SecurityException e ) { s_log . error ( "getJdbcTypeName : unexpected exception : " + e . getMessage ( ) , e ) ; } catch ( IllegalArgumentException e ) { s_log . error ( "getJdbcTypeName : unexpected exception : " + e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { s_log . error ( "getJdbcTypeName : unexpected exception : " + e . getMessage ( ) , e ) ; } return result ; }
void test4 ( ) throws Throwable { String string0 = JDBCTypeMapper . getJdbcTypeName ( ( int ) ( short ) 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getJdbcTypeName ( int jdbcType ) { String result = "UNKNOWN" ; try { Field [ ] fields = java . sql . Types . class . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i + + ) { Field field = fields [ i ] ; if ( field . getInt ( null ) = = jdbcType ) { result = field . getName ( ) ; break ; } } } catch ( SecurityException e ) { s_log . error ( "getJdbcTypeName : unexpected exception : " + e . getMessage ( ) , e ) ; } catch ( IllegalArgumentException e ) { s_log . error ( "getJdbcTypeName : unexpected exception : " + e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { s_log . error ( "getJdbcTypeName : unexpected exception : " + e . getMessage ( ) , e ) ; } return result ; }
void test5 ( ) throws Throwable { int int0 = JDBCTypeMapper . getJdbcType ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getJdbcType ( String jdbcTypeName , int defaultVal ) { if ( jdbcTypeName = = null ) { return Types . NULL ; } int result = defaultVal ; try { Field [ ] fields = java . sql . Types . class . getDeclaredFields ( ) ; for ( int i = 0 ; i < fields . length ; i + + ) { Field field = fields [ i ] ; if ( field . getName ( ) . equalsIgnoreCase ( jdbcTypeName ) ) { result = field . getInt ( null ) ; } } } catch ( IllegalArgumentException e ) { s_log . error ( "getJdbcTypeName : unexpected exception : " + e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { s_log . error ( "getJdbcTypeName : unexpected exception : " + e . getMessage ( ) , e ) ; } return result ; }
void test6 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( ( - 5 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test7 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test8 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( ( - 4 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test9 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( ( - 3 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test10 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( ( - 2 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test11 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test12 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( ( int ) ( short ) 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test13 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( ( int ) ( short ) 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test14 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( ( int ) ( short ) 3 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test15 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( 4 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test16 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( 5 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test17 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( 6 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test18 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( 7 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test19 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( 8 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test20 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isNumberType ( ( - 1294 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isNumberType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . NUMERIC : result = true ; break ; default : result = false ; } return result ; }
void test21 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isDateType ( 91 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDateType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . DATE : case Types . TIME : case Types . TIMESTAMP : result = true ; break ; default : result = false ; } return result ; }
void test22 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isDateType ( ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDateType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . DATE : case Types . TIME : case Types . TIMESTAMP : result = true ; break ; default : result = false ; } return result ; }
void test23 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isDateType ( 92 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDateType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . DATE : case Types . TIME : case Types . TIMESTAMP : result = true ; break ; default : result = false ; } return result ; }
void test24 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isDateType ( 93 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDateType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . DATE : case Types . TIME : case Types . TIMESTAMP : result = true ; break ; default : result = false ; } return result ; }
void test25 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isLongType ( ( - 4 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLongType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . LONGVARBINARY : case Types . LONGVARCHAR : case Types . BLOB : case Types . CLOB : result = true ; break ; default : result = false ; } return result ; }
void test26 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isLongType ( ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLongType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . LONGVARBINARY : case Types . LONGVARCHAR : case Types . BLOB : case Types . CLOB : result = true ; break ; default : result = false ; } return result ; }
void test27 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isLongType ( 2004 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLongType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . LONGVARBINARY : case Types . LONGVARCHAR : case Types . BLOB : case Types . CLOB : result = true ; break ; default : result = false ; } return result ; }
void test28 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isLongType ( 2005 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLongType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . LONGVARBINARY : case Types . LONGVARCHAR : case Types . BLOB : case Types . CLOB : result = true ; break ; default : result = false ; } return result ; }
void test29 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isLongType ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isLongType ( int jdbcType ) { boolean result = false ; switch ( jdbcType ) { case Types . LONGVARBINARY : case Types . LONGVARCHAR : case Types . BLOB : case Types . CLOB : result = true ; break ; default : result = false ; } return result ; }
void test30 ( ) throws Throwable { IndexInfo . IndexType indexInfo_IndexType0 = JDBCTypeMapper . getIndexType ( ( short ) 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IndexType getIndexType ( ) { return indexType ; }
void test31 ( ) throws Throwable { IndexInfo . IndexType indexInfo_IndexType0 = JDBCTypeMapper . getIndexType ( ( short ) 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IndexType getIndexType ( ) { return indexType ; }
void test32 ( ) throws Throwable { IndexInfo . IndexType indexInfo_IndexType0 = JDBCTypeMapper . getIndexType ( ( short ) 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IndexType getIndexType ( ) { return indexType ; }
void test33 ( ) throws Throwable { IndexInfo . IndexType indexInfo_IndexType0 = JDBCTypeMapper . getIndexType ( ( short ) 3 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IndexType getIndexType ( ) { return indexType ; }
void test35 ( ) throws Throwable { IndexInfo . SortOrder indexInfo_SortOrder0 = JDBCTypeMapper . getIndexSortOrder ( "a" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IndexInfo . SortOrder getIndexSortOrder ( String sortOrder ) { if ( sortOrder = = null ) { return IndexInfo . SortOrder . NONE ; } if ( sortOrder . equalsIgnoreCase ( "A" ) ) { return IndexInfo . SortOrder . ASC ; } if ( sortOrder . equalsIgnoreCase ( "D" ) ) { return IndexInfo . SortOrder . DESC ; } throw new IllegalArgumentException ( "Unknown index sort order : " + sortOrder ) ; }
void test36 ( ) throws Throwable { IndexInfo . SortOrder indexInfo_SortOrder0 = JDBCTypeMapper . getIndexSortOrder ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IndexInfo . SortOrder getIndexSortOrder ( String sortOrder ) { if ( sortOrder = = null ) { return IndexInfo . SortOrder . NONE ; } if ( sortOrder . equalsIgnoreCase ( "A" ) ) { return IndexInfo . SortOrder . ASC ; } if ( sortOrder . equalsIgnoreCase ( "D" ) ) { return IndexInfo . SortOrder . DESC ; } throw new IllegalArgumentException ( "Unknown index sort order : " + sortOrder ) ; }
void test38 ( ) throws Throwable { IndexInfo . SortOrder indexInfo_SortOrder0 = JDBCTypeMapper . getIndexSortOrder ( "d" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IndexInfo . SortOrder getIndexSortOrder ( String sortOrder ) { if ( sortOrder = = null ) { return IndexInfo . SortOrder . NONE ; } if ( sortOrder . equalsIgnoreCase ( "A" ) ) { return IndexInfo . SortOrder . ASC ; } if ( sortOrder . equalsIgnoreCase ( "D" ) ) { return IndexInfo . SortOrder . DESC ; } throw new IllegalArgumentException ( "Unknown index sort order : " + sortOrder ) ; }
void test39 ( ) throws Throwable { boolean boolean0 = JDBCTypeMapper . isStandardType ( 7 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isStandardType ( int typeCode ) { boolean result = false ; Field [ ] fields = Types . class . getDeclaredFields ( ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; try { int fieldValue = field . getInt ( null ) ; if ( fieldValue = = typeCode ) { result = true ; } } catch ( Exception e ) { s_log . error ( "isStandardType : unable to get value for java . sql . Types . " + fieldName + " : " + e . getMessage ( ) , e ) ; } } return result ; }
void test0 ( ) throws Throwable { SQLDriverPropertyCollectionBeanInfo sQLDriverPropertyCollectionBeanInfo0 = new SQLDriverPropertyCollectionBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = sQLDriverPropertyCollectionBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; boolean boolean0 = sQLDriver0 . isJDBCDriverClassLoaded ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJDBCDriverClassLoaded ( ) { return _jdbcDriverClassLoaded ; }
void test1 ( ) throws Throwable { IntegerIdentifier integerIdentifier0 = new IntegerIdentifier ( ( - 1 ) ) ; SQLDriver sQLDriver0 = new SQLDriver ( ( IIdentifier ) integerIdentifier0 ) ; String string0 = sQLDriver0 . getUrl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUrl ( ) { return _url ; }
void test2 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ( IIdentifier ) null ) ; SQLDriver sQLDriver1 = ( SQLDriver ) sQLDriver0 . clone ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test3 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; String string0 = sQLDriver0 . getWebSiteUrl ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWebSiteUrl ( ) { return _websiteUrl ; }
void test4 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; sQLDriver0 . setJDBCDriverClassLoaded ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJDBCDriverClassLoaded ( ) { return _jdbcDriverClassLoaded ; }
void test5 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ( IIdentifier ) null ) ; int int0 = sQLDriver0 . compareTo ( ( ISQLDriver ) sQLDriver0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compareTo ( CaseInsensitiveString anotherString ) { int len1 = count ; int len2 = anotherString . count ; int n = Math . min ( len1 , len2 ) ; char v1 [ ] = value ; char v2 [ ] = anotherString . value ; int i = offset ; int j = anotherString . offset ; if ( i = = j ) { int k = i ; int lim = n + i ; while ( k < lim ) { char c1 = v1 [ k ] ; char c2 = v2 [ k ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } k + + ; } } else { while ( n - - ! = 0 ) { char c1 = v1 [ i + + ] ; char c2 = v2 [ j + + ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } } } return len1 - len2 ; }
void test8 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; String string0 = sQLDriver0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test9 ( ) throws Throwable { IntegerIdentifier integerIdentifier0 = new IntegerIdentifier ( 16 ) ; SQLDriver sQLDriver0 = new SQLDriver ( ( IIdentifier ) integerIdentifier0 ) ; sQLDriver0 . addPropertyChangeListener ( ( PropertyChangeListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test10 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ( IIdentifier ) null ) ; String string0 = sQLDriver0 . getDriverClassName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDriverClassName ( ) { return _driverClassName ; }
void test11 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; sQLDriver0 . setReportPropertyChanges ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDriverClassName ( ) { return _driverClassName ; }
void test14 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; String [ ] stringArray0 = sQLDriver0 . getJarFileNames ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getJarFileNames ( ) { return _jarFileNamesList . toArray ( new String [ _jarFileNamesList . size ( ) ] ) ; }
void test15 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; sQLDriver0 . removePropertyChangeListener ( ( PropertyChangeListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isJDBCDriverClassLoaded ( ) { return _jdbcDriverClassLoaded ; }
void test16 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ( IIdentifier ) null ) ; sQLDriver0 . setIdentifier ( ( IIdentifier ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUrl ( ) { return _url ; }
void test17 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; boolean boolean0 = sQLDriver0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test19 ( ) throws Throwable { UidIdentifier uidIdentifier0 = new UidIdentifier ( ) ; SQLDriver sQLDriver0 = new SQLDriver ( ( IIdentifier ) uidIdentifier0 ) ; boolean boolean0 = sQLDriver0 . equals ( ( Object ) "984" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test20 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; sQLDriver0 . setDriverClassName ( "Wk0i$ckF = h | Z ; " ) ; sQLDriver0 . setDriverClassName ( "Wk0i$ckF = h | Z ; " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWebSiteUrl ( ) { return _websiteUrl ; }
void test22 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ( IIdentifier ) null ) ; sQLDriver0 . setJarFileName ( "" ) ; sQLDriver0 . setJarFileName ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDriverClassName ( ) { return _driverClassName ; }
void test23 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; sQLDriver0 . setJarFileName ( " ] C" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getJarFileName ( ) { return _jarFileName ; }
void test24 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; String [ ] stringArray0 = new String [ 6 ] ; sQLDriver0 . setJarFileNames ( stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUrl ( ) { return _url ; }
void test25 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; sQLDriver0 . setJarFileNames ( ( String [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getJarFileName ( ) { return _jarFileName ; }
void test27 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; sQLDriver0 . setUrl ( "Lli7aK9 > " ) ; sQLDriver0 . setUrl ( "Lli7aK9 > " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getJarFileName ( ) { return _jarFileName ; }
void test28 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ( IIdentifier ) null ) ; sQLDriver0 . setName ( "e UYb@fpx\"M" ) ; sQLDriver0 . setName ( "e UYb@fpx\"M" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getUrl ( ) { return _url ; }
void test29 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; StringWrapper [ ] stringWrapperArray0 = new StringWrapper [ 3 ] ; StringWrapper stringWrapper0 = new StringWrapper ( ) ; stringWrapperArray0 [ 0 ] = stringWrapper0 ; stringWrapperArray0 [ 1 ] = stringWrapperArray0 [ 0 ] ; stringWrapperArray0 [ 2 ] = stringWrapper0 ; sQLDriver0 . setJarFileNameWrappers ( stringWrapperArray0 ) ; StringWrapper [ ] stringWrapperArray1 = sQLDriver0 . getJarFileNameWrappers ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test30 ( ) throws Throwable { UidIdentifier uidIdentifier0 = new UidIdentifier ( ) ; SQLDriver sQLDriver0 = new SQLDriver ( ( IIdentifier ) uidIdentifier0 ) ; sQLDriver0 . setJarFileNameWrappers ( ( StringWrapper [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test31 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ( IIdentifier ) null ) ; sQLDriver0 . setWebSiteUrl ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDriverClassName ( ) { return _driverClassName ; }
void test32 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; sQLDriver0 . setWebSiteUrl ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDriverClassName ( ) { return _driverClassName ; }
void test0 ( ) throws Throwable { TableInfoDataSet tableInfoDataSet0 = new TableInfoDataSet ( ) ; DataSetDefinition dataSetDefinition0 = tableInfoDataSet0 . getDataSetDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataSetDefinition getDataSetDefinition ( ) throws DataSetException { return new DataSetDefinition ( _columnDisplayDefinitions ) ; }
void test2 ( ) throws Throwable { TableInfoDataSet tableInfoDataSet0 = new TableInfoDataSet ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean next ( IMessageHandler msgHandler ) throws DataSetException { return + + _curIx < _allRows . size ( ) ; }
void test0 ( ) throws Throwable { SQLDriverBeanInfo sQLDriverBeanInfo0 = new SQLDriverBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = sQLDriverBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { TableQualifier tableQualifier0 = new TableQualifier ( "jt^zW & 3 / ] F . ( . 1 * n" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSchema ( ) { return _schem ; }
void test1 ( ) throws Throwable { TableQualifier tableQualifier0 = new TableQualifier ( "jt^zW & 3 / ] F . ( . 1 * n" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCatalog ( ) { return _cat ; }
void test2 ( ) throws Throwable { TableQualifier tableQualifier0 = new TableQualifier ( "''dvYOE . dd7 l" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TableInfo getTableName ( String tableNameFromSQL ) { ITableInfo [ ] tables = _session . getSchemaInfo ( ) . getITableInfos ( ) ; / / filter the list of all DB objects looking for things with the given name for ( int i = 0 ; i < tables . length ; + + i ) { String simpleName = tables [ i ] . getSimpleName ( ) . toUpperCase ( ) ; String nameWithSchema = simpleName ; String nameWithSchemaAndCatalog = simpleName ; if ( null ! = tables [ i ] . getSchemaName ( ) & & 0 < tables [ i ] . getSchemaName ( ) . length ( ) ) { nameWithSchema = tables [ i ] . getSchemaName ( ) . toUpperCase ( ) + " . " + nameWithSchema ; nameWithSchemaAndCatalog = nameWithSchema ; } if ( null ! = tables [ i ] . getCatalogName ( ) & & 0 < tables [ i ] . getCatalogName ( ) . length ( ) ) { nameWithSchemaAndCatalog = tables [ i ] . getCatalogName ( ) . toUpperCase ( ) + " . " + nameWithSchema ; } if ( simpleName . equals ( tableNameFromSQL ) | | nameWithSchema . equals ( tableNameFromSQL ) | | nameWithSchemaAndCatalog . equals ( tableNameFromSQL ) ) { return ( TableInfo ) tables [ i ] ; } } / / ok , that didn't work - let's see if the table looks fully qualified . / / if so , we'll split the name from the schema / catalog and try that . String [ ] parts = tableNameFromSQL . split ( "\\ . " ) ; if ( parts . length = = 2 ) { String catalog = parts [ 0 ] ; String simpleName = parts [ 1 ] ; tables = _session . getSchemaInfo ( ) . getITableInfos ( catalog , null , simpleName ) ; if ( tables ! = null & & tables . length > 0 ) { return ( TableInfo ) tables [ 0 ] ; } / / Ok , maybe catalog was really a schema instead . tables = _session . getSchemaInfo ( ) . getITableInfos ( null , catalog , simpleName ) ; if ( tables ! = null & & tables . length > 0 ) { return ( TableInfo ) tables [ 0 ] ; } } return null ; }
void test0 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; QueryTokenizer queryTokenizer0 = new QueryTokenizer ( ( IQueryTokenizerPreferenceBean ) baseQueryTokenizerPreferenceBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComment ( ) { return _removeMultiLineComment ; }
void test1 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; QueryTokenizer queryTokenizer0 = new QueryTokenizer ( ( IQueryTokenizerPreferenceBean ) baseQueryTokenizerPreferenceBean0 ) ; queryTokenizer0 . setRemoveMultiLineComment ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQuerySep ( ) { return _querySep ; }
void test2 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; QueryTokenizer queryTokenizer0 = new QueryTokenizer ( ( IQueryTokenizerPreferenceBean ) baseQueryTokenizerPreferenceBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getQuerySep ( ) { return _querySep ; }
void test3 ( ) throws Throwable { QueryTokenizer queryTokenizer0 = new QueryTokenizer ( ) ; queryTokenizer0 . getQuerySep ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComment ( ) { return _removeMultiLineComment ; }
void test4 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; QueryTokenizer queryTokenizer0 = new QueryTokenizer ( ( IQueryTokenizerPreferenceBean ) baseQueryTokenizerPreferenceBean0 ) ; String string0 = queryTokenizer0 . getLineCommentBegin ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComment ( ) { return _removeMultiLineComment ; }
void test5 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; QueryTokenizer queryTokenizer0 = new QueryTokenizer ( ( IQueryTokenizerPreferenceBean ) baseQueryTokenizerPreferenceBean0 ) ; String string0 = queryTokenizer0 . getSQLStatementSeparator ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLineCommentBegin ( ) { return _lineCommentBegin ; }
void test6 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; QueryTokenizer queryTokenizer0 = new QueryTokenizer ( ( IQueryTokenizerPreferenceBean ) baseQueryTokenizerPreferenceBean0 ) ; boolean boolean0 = queryTokenizer0 . isRemoveMultiLineComment ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLineCommentBegin ( ) { return _lineCommentBegin ; }
void test7 ( ) throws Throwable { QueryTokenizer queryTokenizer0 = new QueryTokenizer ( "H^hHYX , ; BVZmqoy'" , "H^hHYX , ; BVZmqoy'" , true ) ; queryTokenizer0 . getTokenizerSessPropsInteractions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComment ( ) { return _removeMultiLineComment ; }
void test11 ( ) throws Throwable { QueryTokenizer queryTokenizer0 = new QueryTokenizer ( " / * } jp * / X = " , " / * } jp * / X = " , true ) ; queryTokenizer0 . setScriptToTokenize ( " / * } jp * / X = " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasQuery ( ) { return _queryIterator . hasNext ( ) ; }
void test13 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; QueryTokenizer queryTokenizer0 = new QueryTokenizer ( ( IQueryTokenizerPreferenceBean ) baseQueryTokenizerPreferenceBean0 ) ; queryTokenizer0 . getQueryCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComment ( ) { return _removeMultiLineComment ; }
void test14 ( ) throws Throwable { BaseQueryTokenizerPreferenceBean baseQueryTokenizerPreferenceBean0 = new BaseQueryTokenizerPreferenceBean ( ) ; QueryTokenizer queryTokenizer0 = new QueryTokenizer ( ( IQueryTokenizerPreferenceBean ) baseQueryTokenizerPreferenceBean0 ) ; queryTokenizer0 . expandFileIncludes ( " - ] 8 > 1" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSQLStatementSeparator ( ) { return _sqlStmtSep ; }
void test15 ( ) throws Throwable { QueryTokenizer queryTokenizer0 = new QueryTokenizer ( ) ; queryTokenizer0 . expandFileIncludes ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComment ( ) { return _removeMultiLineComment ; }
void test16 ( ) throws Throwable { QueryTokenizer queryTokenizer0 = new QueryTokenizer ( "H^hHYX , ; BVZmqoy'" , "H^hHYX , ; BVZmqoy'" , true ) ; List < String > list0 = queryTokenizer0 . getStatementsFromIncludeFile ( "H^hHYX , ; BVZmqoy'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComment ( ) { return _removeMultiLineComment ; }
void test17 ( ) throws Throwable { QueryTokenizer queryTokenizer0 = new QueryTokenizer ( ) ; List < String > list0 = queryTokenizer0 . getStatementsFromIncludeFile ( "'$\n" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRemoveMultiLineComment ( ) { return _removeMultiLineComment ; }
void test0 ( ) throws Throwable { SQLDriverPropertyBeanInfo sQLDriverPropertyBeanInfo0 = new SQLDriverPropertyBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = sQLDriverPropertyBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { DatabaseObjectInfoBeanInfo databaseObjectInfoBeanInfo0 = new DatabaseObjectInfoBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = databaseObjectInfoBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { SQLDriver sQLDriver0 = new SQLDriver ( ) ; SQLDriverClassLoader sQLDriverClassLoader0 = new SQLDriverClassLoader ( ( ISQLDriver ) sQLDriver0 ) ; Class < ? > [ ] classArray0 = sQLDriverClassLoader0 . getDriverClasses ( ( ILogger ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Class < ? > [ ] getDriverClasses ( ILogger logger ) { Class < ? > [ ] classes = getAssignableClasses ( Driver . class , logger ) ; List < Class < ? > > list = new ArrayList < Class < ? > > ( ) ; for ( int i = 0 ; i < classes . length ; + + i ) { Class < ? > clazz = classes [ i ] ; if ( ! Modifier . isAbstract ( clazz . getModifiers ( ) ) ) { list . add ( clazz ) ; } } return list . toArray ( new Class [ list . size ( ) ] ) ; }
void test1 ( ) throws Throwable { SQLDriverClassLoader sQLDriverClassLoader0 = new SQLDriverClassLoader ( ( URL ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLDriverClassLoader ( ISQLDriver sqlDriver ) throws MalformedURLException { super ( createURLs ( sqlDriver . getName ( ) , sqlDriver . getJarFileNames ( ) ) ) ; }
void test2 ( ) throws Throwable { URL [ ] uRLArray0 = new URL [ 6 ] ; SQLDriverClassLoader sQLDriverClassLoader0 = new SQLDriverClassLoader ( uRLArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SQLDriverClassLoader ( ISQLDriver sqlDriver ) throws MalformedURLException { super ( createURLs ( sqlDriver . getName ( ) , sqlDriver . getJarFileNames ( ) ) ) ; }
void test0 ( ) throws Throwable { SQLDriverProperty sQLDriverProperty0 = new SQLDriverProperty ( " - KF59 ] nH" , " - KF59 ] nH" ) ; DriverPropertyInfo driverPropertyInfo0 = sQLDriverProperty0 . getDriverPropertyInfo ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DriverPropertyInfo getDriverPropertyInfo ( ) { return _driverPropInfo ; }
void test1 ( ) throws Throwable { SQLDriverProperty sQLDriverProperty0 = new SQLDriverProperty ( " - KF59 ] nH" , " - KF59 ] nH" ) ; boolean boolean0 = sQLDriverProperty0 . isSpecified ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSpecified ( ) { return _isSpecified ; }
void test2 ( ) throws Throwable { SQLDriverProperty sQLDriverProperty0 = new SQLDriverProperty ( " - KF59 ] nH" , " - KF59 ] nH" ) ; SQLDriverProperty sQLDriverProperty1 = ( SQLDriverProperty ) sQLDriverProperty0 . clone ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test3 ( ) throws Throwable { DriverPropertyInfo driverPropertyInfo0 = new DriverPropertyInfo ( " ] is not a subclass of org . apache . log4j . Level" , " ] is not a subclass of org . apache . log4j . Level" ) ; SQLDriverProperty sQLDriverProperty0 = new SQLDriverProperty ( driverPropertyInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSpecified ( ) { return _isSpecified ; }
void test5 ( ) throws Throwable { SQLDriverProperty sQLDriverProperty0 = new SQLDriverProperty ( " - KF59 ] nH" , " - KF59 ] nH" ) ; String string0 = sQLDriverProperty0 . getValue ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getValue ( ) { return _value ; }
void test7 ( ) throws Throwable { DriverPropertyInfo driverPropertyInfo0 = new DriverPropertyInfo ( " ] is not a subclass of org . apache . log4j . Level" , " ] is not a subclass of org . apache . log4j . Level" ) ; SQLDriverProperty sQLDriverProperty0 = new SQLDriverProperty ( driverPropertyInfo0 ) ; sQLDriverProperty0 . setName ( " ] is not a subclass of org . apache . log4j . Level" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isSpecified ( ) { return _isSpecified ; }
void test8 ( ) throws Throwable { DriverPropertyInfo driverPropertyInfo0 = new DriverPropertyInfo ( " ] is not a subclass of org . apache . log4j . Level" , " ] is not a subclass of org . apache . log4j . Level" ) ; SQLDriverProperty sQLDriverProperty0 = new SQLDriverProperty ( driverPropertyInfo0 ) ; sQLDriverProperty0 . setValue ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getValue ( ) { return _value ; }
void test0 ( ) throws Throwable { MetaDataListDataSet metaDataListDataSet0 = new MetaDataListDataSet ( "H | ? h" ) ; DataSetDefinition dataSetDefinition0 = metaDataListDataSet0 . getDataSetDefinition ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" DataSetDefinition getDataSetDefinition ( ) throws DataSetException { return new DataSetDefinition ( _columnDisplayDefinitions ) ; }
void test1 ( ) throws Throwable { MetaDataListDataSet metaDataListDataSet0 = new MetaDataListDataSet ( "L & * & ! < t" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean next ( IMessageHandler msgHandler ) throws DataSetException { return + + _curIx < _allRows . size ( ) ; }
void test2 ( ) throws Throwable { MetaDataListDataSet metaDataListDataSet0 = new MetaDataListDataSet ( "L & * & ! < t" ) ; Object object0 = metaDataListDataSet0 . get ( ( - 1000 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test3 ( ) throws Throwable { MetaDataListDataSet metaDataListDataSet0 = new MetaDataListDataSet ( "H | ? h" ) ; Object object0 = metaDataListDataSet0 . get ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test4 ( ) throws Throwable { MetaDataListDataSet metaDataListDataSet0 = new MetaDataListDataSet ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnCount ( ) throws DataSetException { return _columnDisplayDefinitions . length ; }
void test0 ( ) throws Throwable { BestRowIdentifierAdapterBeanInfo bestRowIdentifierAdapterBeanInfo0 = new BestRowIdentifierAdapterBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = bestRowIdentifierAdapterBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { ObjectCache < IHasIdentifier > objectCache0 = new ObjectCache < IHasIdentifier > ( ) ; Class < ? > class0 = Icon . class ; Iterator < IHasIdentifier > iterator0 = objectCache0 . getAllForClass ( class0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasNext ( ) { return false ; }
void test1 ( ) throws Throwable { ObjectCache < IHasIdentifier > objectCache0 = new ObjectCache < IHasIdentifier > ( ) ; Class < ? > class0 = Icon . class ; objectCache0 . removeChangesListener ( ( IObjectCacheChangeListener ) null , class0 ) ; Class < IHasIdentifier > [ ] classArray0 = objectCache0 . getAllClasses ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Class < E > [ ] getAllClasses ( ) { return _cache . getAllClasses ( ) ; }
void test3 ( ) throws Throwable { ObjectCache < IHasIdentifier > objectCache0 = new ObjectCache < IHasIdentifier > ( ) ; Class < ? > class0 = Icon . class ; IntegerIdentifier integerIdentifier0 = new IntegerIdentifier ( 2014 ) ; IHasIdentifier iHasIdentifier0 = objectCache0 . get ( class0 , ( IIdentifier ) integerIdentifier0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test5 ( ) throws Throwable { ObjectCache < IHasIdentifier > objectCache0 = new ObjectCache < IHasIdentifier > ( ) ; Class < ? > class0 = Icon . class ; IntegerIdentifier integerIdentifier0 = new IntegerIdentifier ( 2014 ) ; objectCache0 . remove ( class0 , ( IIdentifier ) integerIdentifier0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test6 ( ) throws Throwable { ObjectCache < IHasIdentifier > objectCache0 = new ObjectCache < IHasIdentifier > ( ) ; Class < IHasIdentifier > [ ] classArray0 = objectCache0 . getAllClasses ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Class < E > [ ] getAllClasses ( ) { return _cache . getAllClasses ( ) ; }
void test1 ( ) throws Throwable { EmptyEnumeration < Object > emptyEnumeration0 = new EmptyEnumeration < Object > ( ) ; boolean boolean0 = emptyEnumeration0 . hasMoreElements ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasMoreElements ( ) { return false ; }
void test0 ( ) throws Throwable { FileWrapperFactoryImpl fileWrapperFactoryImpl0 = new FileWrapperFactoryImpl ( ) ; File file0 = new File ( "" , "" ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) fileWrapperFactoryImpl0 . create ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean mkdirs ( ) { return _wrappedFile . mkdirs ( ) ; }
void test3 ( ) throws Throwable { FileWrapperFactoryImpl fileWrapperFactoryImpl0 = new FileWrapperFactoryImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) fileWrapperFactoryImpl0 . create ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAbsolutePath ( ) { return _wrappedFile . getAbsolutePath ( ) ; }
void test5 ( ) throws Throwable { FileWrapperFactoryImpl fileWrapperFactoryImpl0 = new FileWrapperFactoryImpl ( ) ; FileWrapperImpl fileWrapperImpl0 = ( FileWrapperImpl ) fileWrapperFactoryImpl0 . create ( "" , "" ) ; FileWrapperImpl fileWrapperImpl1 = ( FileWrapperImpl ) fileWrapperFactoryImpl0 . create ( ( FileWrapper ) fileWrapperImpl0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canRead ( ) { return _wrappedFile . canRead ( ) ; }
void test0 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( ( FileWrapper ) null , " , PZ . . 1E ! ; zV" ) ; String string0 = fileWrapperImpl0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "" , "" ) ; int int0 = fileWrapperImpl0 . compareTo ( fileWrapperImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int compareTo ( CaseInsensitiveString anotherString ) { int len1 = count ; int len2 = anotherString . count ; int n = Math . min ( len1 , len2 ) ; char v1 [ ] = value ; char v2 [ ] = anotherString . value ; int i = offset ; int j = anotherString . offset ; if ( i = = j ) { int k = i ; int lim = n + i ; while ( k < lim ) { char c1 = v1 [ k ] ; char c2 = v2 [ k ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } k + + ; } } else { while ( n - - ! = 0 ) { char c1 = v1 [ i + + ] ; char c2 = v2 [ j + + ] ; if ( toLowerCase ( c1 ) ! = toLowerCase ( c2 ) ) { return toLowerCase ( c1 ) - toLowerCase ( c2 ) ; } } } return len1 - len2 ; }
void test3 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Khz : t'Xpq" , "Khz : t'Xpq" ) ; URI uRI0 = fileWrapperImpl0 . toURI ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAbsolute ( ) { return _wrappedFile . isAbsolute ( ) ; }
void test4 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "N" , "N" ) ; long long0 = fileWrapperImpl0 . lastModified ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long lastModified ( ) { return _wrappedFile . lastModified ( ) ; }
void test5 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "n { 7s" ) ; FileWrapperImpl fileWrapperImpl1 = ( FileWrapperImpl ) fileWrapperImpl0 . getCanonicalFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean exists ( ) { return _wrappedFile . exists ( ) ; }
void test6 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Ki2G4^BrQI^ ; b" , "Ki2G4^BrQI^ ; b" ) ; boolean boolean0 = fileWrapperImpl0 . isFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFile ( ) { return _wrappedFile . isFile ( ) ; }
void test7 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "" ) ; FileWrapperImpl fileWrapperImpl1 = new FileWrapperImpl ( fileWrapperImpl0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test8 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Khz : t'Xpq" , "Khz : t'Xpq" ) ; String [ ] stringArray0 = fileWrapperImpl0 . list ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] list ( ) { return _wrappedFile . list ( ) ; }
void test9 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "antlr" , "antlr" ) ; boolean boolean0 = fileWrapperImpl0 . exists ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean exists ( ) { return _wrappedFile . exists ( ) ; }
void test11 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Khz : t'Xpq" , "Khz : t'Xpq" ) ; String string0 = fileWrapperImpl0 . getCanonicalPath ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getCanonicalPath ( ) throws IOException { return _wrappedFile . getCanonicalPath ( ) ; }
void test12 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "antlr" , "antlr" ) ; String string0 = fileWrapperImpl0 . getName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test13 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "k" ) ; FileWrapperImpl fileWrapperImpl1 = ( FileWrapperImpl ) fileWrapperImpl0 . getAbsoluteFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDirectory ( ) { return _wrappedFile . isDirectory ( ) ; }
void test14 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Khz : t'Xpq" , "Khz : t'Xpq" ) ; String string0 = fileWrapperImpl0 . getParent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getParent ( ) { return _wrappedFile . getParent ( ) ; }
void test15 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Khz : t'Xpq" , "Khz : t'Xpq" ) ; boolean boolean0 = fileWrapperImpl0 . isAbsolute ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAbsolute ( ) { return _wrappedFile . isAbsolute ( ) ; }
void test16 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( " * J~e79lbz ) WP#" , " * J~e79lbz ) WP#" ) ; FileWrapper [ ] fileWrapperArray0 = fileWrapperImpl0 . listFiles ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FileWrapper [ ] listFiles ( ) { return wrapFiles ( _wrappedFile . listFiles ( ) ) ; }
void test17 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( " * J~e79lbz ) WP#" , " * J~e79lbz ) WP#" ) ; String [ ] stringArray0 = new String [ 1 ] ; FilesystemFilter filesystemFilter0 = new FilesystemFilter ( stringArray0 , " * J~e79lbz ) WP#" , false ) ; String [ ] stringArray1 = fileWrapperImpl0 . list ( ( FilenameFilter ) filesystemFilter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] list ( ) { return _wrappedFile . list ( ) ; }
void test18 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Khz : t'Xpq" , "Khz : t'Xpq" ) ; FilesystemFilter filesystemFilter0 = new FilesystemFilter ( "Khz : t'Xpq" , "Khz : t'Xpq" , true ) ; FileWrapper [ ] fileWrapperArray0 = fileWrapperImpl0 . listFiles ( ( FilenameFilter ) filesystemFilter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FileWrapper [ ] listFiles ( ) { return wrapFiles ( _wrappedFile . listFiles ( ) ) ; }
void test19 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Ki2G4^BrQI^ ; b" , "Ki2G4^BrQI^ ; b" ) ; URL uRL0 = fileWrapperImpl0 . toURL ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" URL toURL ( ) throws MalformedURLException { return _wrappedFile . toURI ( ) . toURL ( ) ; }
void test22 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "" ) ; long long0 = fileWrapperImpl0 . length ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long length ( ) { return _wrappedFile . length ( ) ; }
void test25 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "antlr" , "antlr" ) ; boolean boolean0 = fileWrapperImpl0 . isHidden ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isHidden ( ) { return _wrappedFile . isHidden ( ) ; }
void test31 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Khz : t'Xpq" , "Khz : t'Xpq" ) ; String string0 = fileWrapperImpl0 . getAbsolutePath ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAbsolutePath ( ) { return _wrappedFile . getAbsolutePath ( ) ; }
void test33 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "" ) ; boolean boolean0 = fileWrapperImpl0 . canRead ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean canRead ( ) { return _wrappedFile . canRead ( ) ; }
void test34 ( ) throws Throwable { FileWrapper [ ] fileWrapperArray0 = FileWrapperImpl . listRoots ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FileWrapper [ ] listRoots ( ) { return wrapFiles ( File . listRoots ( ) ) ; }
void test36 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Ki2G4^BrQI^ ; b" , "Ki2G4^BrQI^ ; b" ) ; String [ ] stringArray0 = new String [ 2 ] ; FileSuffixFilter fileSuffixFilter0 = new FileSuffixFilter ( stringArray0 , false ) ; FileWrapper [ ] fileWrapperArray0 = fileWrapperImpl0 . listFiles ( ( FileFilter ) fileSuffixFilter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FileWrapper [ ] listFiles ( ) { return wrapFiles ( _wrappedFile . listFiles ( ) ) ; }
void test38 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( " * J~e79lbz ) WP#" , " * J~e79lbz ) WP#" ) ; boolean boolean0 = fileWrapperImpl0 . isDirectory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDirectory ( ) { return _wrappedFile . isDirectory ( ) ; }
void test41 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Ki2G4^BrQI^ ; b" , "Ki2G4^BrQI^ ; b" ) ; FileWrapperImpl fileWrapperImpl1 = new FileWrapperImpl ( ( FileWrapper ) fileWrapperImpl0 , "Ki2G4^BrQI^ ; b" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPath ( ) { return _path ; }
void test42 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Khz : t'Xpq" , "Khz : t'Xpq" ) ; FileWrapperImpl fileWrapperImpl1 = ( FileWrapperImpl ) fileWrapperImpl0 . getParentFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" long length ( ) { return _wrappedFile . length ( ) ; }
void test43 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( " - ~nF6wkj" ) ; FileWrapperImpl fileWrapperImpl1 = ( FileWrapperImpl ) fileWrapperImpl0 . getParentFile ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" FileWrapper getParentFile ( ) { if ( _wrappedFile . getParentFile ( ) = = null ) { return null ; } return new FileWrapperImpl ( _wrappedFile . getParentFile ( ) ) ; }
void test46 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "N" , "N" ) ; int int0 = fileWrapperImpl0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test47 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( ( File ) null ) ; int int0 = fileWrapperImpl0 . hashCode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int hashCode ( ) { int prime = 31 ; int result = 1 ; result = prime * result + ( ( _qualifiedName = = null ) ? 0 : _qualifiedName . hashCode ( ) ) ; return result ; }
void test48 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( " * J~e79lbz ) WP#" , " * J~e79lbz ) WP#" ) ; boolean boolean0 = fileWrapperImpl0 . equals ( ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test49 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "7W#rQUXA | t50\" * UJka" , "7W#rQUXA | t50\" * UJka" ) ; FileWrapperImpl fileWrapperImpl1 = new FileWrapperImpl ( "7W#rQUXA | t50\" * UJka" , "7W#rQUXA | t50\" * UJka" ) ; boolean boolean0 = fileWrapperImpl0 . equals ( ( Object ) fileWrapperImpl1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test50 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "Khz : t'Xpq" , "Khz : t'Xpq" ) ; boolean boolean0 = fileWrapperImpl0 . equals ( ( Object ) " / mnt / fastdata / ac1gf / SF110 / dist / 102_squirrel - sql / Khz : t'Xpq / Khz : t'Xpq" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test51 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( ( File ) null ) ; FileWrapperImpl fileWrapperImpl1 = new FileWrapperImpl ( " < { + TF`eFK" ) ; boolean boolean0 = fileWrapperImpl0 . equals ( ( Object ) fileWrapperImpl1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; ExtendedColumnInfo other = ( ExtendedColumnInfo ) obj ; if ( _qualifiedName = = null ) { if ( other . _qualifiedName ! = null ) return false ; } else if ( ! _qualifiedName . equals ( other . _qualifiedName ) ) return false ; return true ; }
void test52 ( ) throws Throwable { FileWrapperImpl fileWrapperImpl0 = new FileWrapperImpl ( "antlr" , "antlr" ) ; FileWrapperImpl fileWrapperImpl1 = new FileWrapperImpl ( "hEjN . wVHZU" , "antlr" ) ; boolean boolean0 = fileWrapperImpl0 . equals ( ( Object ) fileWrapperImpl1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getName ( ) ; / / ? ? Need to associate a panel with an object type somehow . IPluginDatabaseObjectPanelWrapper createPanel ( ) ; / * * * Return all the objects in the database for the current type . * / IPluginDatabaseObject [ ] getObjects ( ISession session , ISQLConnection conn , Statement stmt ) throws SQLException ; }
void test0 ( ) throws Throwable { String [ ] stringArray0 = StringUtilities . split ( "\n" , 'D' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] split ( String str , char delimiter ) { return split ( str , delimiter , false ) ; }
void test1 ( ) throws Throwable { String string0 = StringUtilities . escapeHtmlChars ( " & lt ; " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String escapeHtmlChars ( String sql ) { String buf = sql . replaceAll ( " & " , " & amp ; " ) ; buf = buf . replaceAll ( " < " , " & lt ; " ) ; buf = buf . replaceAll ( " < " , " & gt ; " ) ; buf = buf . replaceAll ( "\"" , " & quot ; " ) ; return buf ; }
void test2 ( ) throws Throwable { String string0 = StringUtilities . getEolStr ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEolStr ( ) { return System . getProperty ( "line . separator" , "\n" ) ; }
void test3 ( ) throws Throwable { StringUtilities stringUtilities0 = new StringUtilities ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getEolStr ( ) { return System . getProperty ( "line . separator" , "\n" ) ; }
void test4 ( ) throws Throwable { String string0 = StringUtilities . cleanString ( " * " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String cleanString ( String str ) { return StringUtilities . cleanString ( str ) ; }
void test5 ( ) throws Throwable { String string0 = StringUtilities . cleanString ( "u3 EqwZX@5c0c" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String cleanString ( String str ) { return StringUtilities . cleanString ( str ) ; }
void test6 ( ) throws Throwable { int int0 = StringUtilities . countOccurences ( "DaUC^O8e ( aMqYzn > 4Eo" , ( int ) 'D' ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int countOccurences ( String str , int ch ) { if ( StringUtils . isEmpty ( str ) ) { return 0 ; } int count = 0 ; int idx = - 1 ; do { idx = str . indexOf ( ch , + + idx ) ; if ( idx ! = - 1 ) { + + count ; } } while ( idx ! = - 1 ) ; return count ; }
void test7 ( ) throws Throwable { int int0 = StringUtilities . countOccurences ( "" , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int countOccurences ( String str , int ch ) { if ( StringUtils . isEmpty ( str ) ) { return 0 ; } int count = 0 ; int idx = - 1 ; do { idx = str . indexOf ( ch , + + idx ) ; if ( idx ! = - 1 ) { + + count ; } } while ( idx ! = - 1 ) ; return count ; }
void test8 ( ) throws Throwable { String [ ] stringArray0 = StringUtilities . split ( ( String ) null , 'v' , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] split ( String str , char delimiter ) { return split ( str , delimiter , false ) ; }
void test9 ( ) throws Throwable { String [ ] stringArray0 = StringUtilities . split ( "DaUC_O8e_aMqYzn_4Eo" , 'D' , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] split ( String str , char delimiter ) { return split ( str , delimiter , false ) ; }
void test10 ( ) throws Throwable { String [ ] stringArray0 = new String [ 3 ] ; String string0 = StringUtilities . join ( stringArray0 , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String join ( String [ ] parts , String delim ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < parts . length ; i + + ) { String part = parts [ i ] ; result . append ( part ) ; if ( delim ! = null & & i < parts . length - 1 ) { result . append ( delim ) ; } } return result . toString ( ) ; }
void test11 ( ) throws Throwable { String [ ] stringArray0 = new String [ 4 ] ; String string0 = StringUtilities . join ( stringArray0 , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String join ( String [ ] parts , String delim ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < parts . length ; i + + ) { String part = parts [ i ] ; result . append ( part ) ; if ( delim ! = null & & i < parts . length - 1 ) { result . append ( delim ) ; } } return result . toString ( ) ; }
void test12 ( ) throws Throwable { String [ ] stringArray0 = StringUtilities . segment ( " * " , 1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] segment ( String source , int maxSegmentSize ) { ArrayList < String > tmp = new ArrayList < String > ( ) ; if ( source . length ( ) < = maxSegmentSize ) { return new String [ ] { source } ; } boolean done = false ; int currBeginIdx = 0 ; int currEndIdx = maxSegmentSize ; while ( ! done ) { String segment = source . substring ( currBeginIdx , currEndIdx ) ; tmp . add ( segment ) ; if ( currEndIdx > = source . length ( ) ) { done = true ; continue ; } currBeginIdx = currEndIdx ; currEndIdx + = maxSegmentSize ; if ( currEndIdx > source . length ( ) ) { currEndIdx = source . length ( ) ; } } return tmp . toArray ( new String [ tmp . size ( ) ] ) ; }
void test13 ( ) throws Throwable { String [ ] stringArray0 = StringUtilities . segment ( "@Uem ; * 2 . rVu0 , / M [ wzf" , ( int ) ( byte ) 6 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] segment ( String source , int maxSegmentSize ) { ArrayList < String > tmp = new ArrayList < String > ( ) ; if ( source . length ( ) < = maxSegmentSize ) { return new String [ ] { source } ; } boolean done = false ; int currBeginIdx = 0 ; int currEndIdx = maxSegmentSize ; while ( ! done ) { String segment = source . substring ( currBeginIdx , currEndIdx ) ; tmp . add ( segment ) ; if ( currEndIdx > = source . length ( ) ) { done = true ; continue ; } currBeginIdx = currEndIdx ; currEndIdx + = maxSegmentSize ; if ( currEndIdx > source . length ( ) ) { currEndIdx = source . length ( ) ; } } return tmp . toArray ( new String [ tmp . size ( ) ] ) ; }
void test14 ( ) throws Throwable { int int0 = StringUtilities . getTokenBeginIndex ( " ( & fOvH = 0 | SaC4r < 1#y" , " ( & fOvH = 0 | SaC4r < 1#y" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTokenBeginIndex ( String selectSQL , String token ) { String lowerSel = selectSQL . toLowerCase ( ) ; String lowerToken = token . toLowerCase ( ) . trim ( ) ; int curPos = 0 ; int count = 0 ; while ( - 1 ! = curPos ) { curPos = lowerSel . indexOf ( lowerToken , curPos + lowerToken . length ( ) ) ; if ( - 1 < curPos & & ( 0 = = curPos | | Character . isWhitespace ( lowerSel . charAt ( curPos - 1 ) ) ) & & ( lowerSel . length ( ) = = curPos + lowerToken . length ( ) | | Character . isWhitespace ( lowerSel . charAt ( curPos + lowerToken . length ( ) ) ) ) ) { return curPos ; } / / If we've loop through one time for each character in the string , / / then something must be wrong . Get out ! if ( count + + > selectSQL . length ( ) ) { break ; } } return curPos ; }
void test15 ( ) throws Throwable { int int0 = StringUtilities . getTokenBeginIndex ( "\n" , "\n" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTokenBeginIndex ( String selectSQL , String token ) { String lowerSel = selectSQL . toLowerCase ( ) ; String lowerToken = token . toLowerCase ( ) . trim ( ) ; int curPos = 0 ; int count = 0 ; while ( - 1 ! = curPos ) { curPos = lowerSel . indexOf ( lowerToken , curPos + lowerToken . length ( ) ) ; if ( - 1 < curPos & & ( 0 = = curPos | | Character . isWhitespace ( lowerSel . charAt ( curPos - 1 ) ) ) & & ( lowerSel . length ( ) = = curPos + lowerToken . length ( ) | | Character . isWhitespace ( lowerSel . charAt ( curPos + lowerToken . length ( ) ) ) ) ) { return curPos ; } / / If we've loop through one time for each character in the string , / / then something must be wrong . Get out ! if ( count + + > selectSQL . length ( ) ) { break ; } } return curPos ; }
void test16 ( ) throws Throwable { int int0 = StringUtilities . getTokenBeginIndex ( " * " , " * " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTokenBeginIndex ( String selectSQL , String token ) { String lowerSel = selectSQL . toLowerCase ( ) ; String lowerToken = token . toLowerCase ( ) . trim ( ) ; int curPos = 0 ; int count = 0 ; while ( - 1 ! = curPos ) { curPos = lowerSel . indexOf ( lowerToken , curPos + lowerToken . length ( ) ) ; if ( - 1 < curPos & & ( 0 = = curPos | | Character . isWhitespace ( lowerSel . charAt ( curPos - 1 ) ) ) & & ( lowerSel . length ( ) = = curPos + lowerToken . length ( ) | | Character . isWhitespace ( lowerSel . charAt ( curPos + lowerToken . length ( ) ) ) ) ) { return curPos ; } / / If we've loop through one time for each character in the string , / / then something must be wrong . Get out ! if ( count + + > selectSQL . length ( ) ) { break ; } } return curPos ; }
void test17 ( ) throws Throwable { int int0 = StringUtilities . getTokenBeginIndex ( " & lt ; " , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTokenBeginIndex ( String selectSQL , String token ) { String lowerSel = selectSQL . toLowerCase ( ) ; String lowerToken = token . toLowerCase ( ) . trim ( ) ; int curPos = 0 ; int count = 0 ; while ( - 1 ! = curPos ) { curPos = lowerSel . indexOf ( lowerToken , curPos + lowerToken . length ( ) ) ; if ( - 1 < curPos & & ( 0 = = curPos | | Character . isWhitespace ( lowerSel . charAt ( curPos - 1 ) ) ) & & ( lowerSel . length ( ) = = curPos + lowerToken . length ( ) | | Character . isWhitespace ( lowerSel . charAt ( curPos + lowerToken . length ( ) ) ) ) ) { return curPos ; } / / If we've loop through one time for each character in the string , / / then something must be wrong . Get out ! if ( count + + > selectSQL . length ( ) ) { break ; } } return curPos ; }
void test18 ( ) throws Throwable { Byte [ ] byteArray0 = StringUtilities . getByteArray ( ( byte [ ] ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Byte [ ] getByteArray ( byte [ ] bytes ) { if ( bytes = = null | | bytes . length = = 0 ) { return new Byte [ 0 ] ; } Byte [ ] result = new Byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i + + ) { result [ i ] = Byte . valueOf ( bytes [ i ] ) ; } return result ; }
void test19 ( ) throws Throwable { byte [ ] byteArray0 = new byte [ 7 ] ; Byte [ ] byteArray1 = StringUtilities . getByteArray ( byteArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Byte [ ] getByteArray ( byte [ ] bytes ) { if ( bytes = = null | | bytes . length = = 0 ) { return new Byte [ 0 ] ; } Byte [ ] result = new Byte [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i + + ) { result [ i ] = Byte . valueOf ( bytes [ i ] ) ; } return result ; }
void test20 ( ) throws Throwable { String string0 = StringUtilities . chop ( "\n" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String chop ( String aString ) { if ( aString = = null ) { return null ; } if ( aString . length ( ) = = 0 ) { return "" ; } if ( aString . length ( ) = = 1 ) { return "" ; } return aString . substring ( 0 , aString . length ( ) - 1 ) ; }
void test21 ( ) throws Throwable { String string0 = StringUtilities . chop ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String chop ( String aString ) { if ( aString = = null ) { return null ; } if ( aString . length ( ) = = 0 ) { return "" ; } if ( aString . length ( ) = = 1 ) { return "" ; } return aString . substring ( 0 , aString . length ( ) - 1 ) ; }
void test22 ( ) throws Throwable { String string0 = StringUtilities . chop ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String chop ( String aString ) { if ( aString = = null ) { return null ; } if ( aString . length ( ) = = 0 ) { return "" ; } if ( aString . length ( ) = = 1 ) { return "" ; } return aString . substring ( 0 , aString . length ( ) - 1 ) ; }
void test23 ( ) throws Throwable { String string0 = StringUtilities . chop ( " - J / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String chop ( String aString ) { if ( aString = = null ) { return null ; } if ( aString . length ( ) = = 0 ) { return "" ; } if ( aString . length ( ) = = 1 ) { return "" ; } return aString . substring ( 0 , aString . length ( ) - 1 ) ; }
void test24 ( ) throws Throwable { String string0 = StringUtilities . javaNormalize ( " - J / " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String javaNormalize ( String text ) { StringBuffer buf = new StringBuffer ( text . length ( ) ) ; if ( Character . isJavaIdentifierStart ( text . charAt ( 0 ) ) ) { buf . append ( text . charAt ( 0 ) ) ; } else { buf . append ( '_' ) ; } for ( int i = 1 ; i < text . length ( ) ; + + i ) { if ( Character . isLetterOrDigit ( text . charAt ( i ) ) ) { buf . append ( text . charAt ( i ) ) ; } else { buf . append ( '_' ) ; } } String ret = buf . toString ( ) ; return ret ; }
void test25 ( ) throws Throwable { String string0 = StringUtilities . javaNormalize ( "DaUC^O8e ( aMqYzn > 4Eo" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String javaNormalize ( String text ) { StringBuffer buf = new StringBuffer ( text . length ( ) ) ; if ( Character . isJavaIdentifierStart ( text . charAt ( 0 ) ) ) { buf . append ( text . charAt ( 0 ) ) ; } else { buf . append ( '_' ) ; } for ( int i = 1 ; i < text . length ( ) ; + + i ) { if ( Character . isLetterOrDigit ( text . charAt ( i ) ) ) { buf . append ( text . charAt ( i ) ) ; } else { buf . append ( '_' ) ; } } String ret = buf . toString ( ) ; return ret ; }
void test0 ( ) throws Throwable { DefaultExceptionFormatter defaultExceptionFormatter0 = new DefaultExceptionFormatter ( ) ; boolean boolean0 = defaultExceptionFormatter0 . formatsException ( ( Throwable ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean formatsException ( Throwable t ) { return true ; }
void test0 ( ) throws Throwable { String string0 = Utilities . escapeHtmlChars ( " < span > " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String escapeHtmlChars ( String sql ) { String buf = sql . replaceAll ( " & " , " & amp ; " ) ; buf = buf . replaceAll ( " < " , " & lt ; " ) ; buf = buf . replaceAll ( " < " , " & gt ; " ) ; buf = buf . replaceAll ( "\"" , " & quot ; " ) ; return buf ; }
void test2 ( ) throws Throwable { String string0 = Utilities . formatSize ( 0L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String formatSize ( long longSize ) { return formatSize ( longSize , - 1 ) ; }
void test3 ( ) throws Throwable { String string0 = ( String ) Utilities . cast ( ( Object ) " : " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" < T > T cast ( Object x ) { return ( T ) x ; }
void test4 ( ) throws Throwable { ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; Long long0 = ( Long ) Utilities . cloneObject ( ( Object ) 0L , classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object cloneObject ( Object toClone , ClassLoader classLoader ) { if ( null = = toClone ) { return null ; } else { try { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream oOut = new ObjectOutputStream ( bOut ) ; oOut . writeObject ( toClone ) ; oOut . close ( ) ; ByteArrayInputStream bIn = new ByteArrayInputStream ( bOut . toByteArray ( ) ) ; bOut . close ( ) ; ObjectInputStream oIn = new ObjectInputStream ( bIn ) { Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { return Class . forName ( desc . getName ( ) , false , classLoader ) ; } } ; bIn . close ( ) ; Object copy = oIn . readObject ( ) ; oIn . close ( ) ; return copy ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } }
void test5 ( ) throws Throwable { ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( 1855 ) ; PrintStream printStream0 = new PrintStream ( ( OutputStream ) byteArrayOutputStream0 , false ) ; Utilities . printStackTrace ( printStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test8 ( ) throws Throwable { String string0 = Utilities . changeClassNameToFileName ( "ZK1^ { > qi" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String changeClassNameToFileName ( String name ) { if ( name = = null ) { throw new IllegalArgumentException ( "Class Name = = null" ) ; } return name . replace ( ' . ' , ' / ' ) . concat ( " . class" ) ; }
void test10 ( ) throws Throwable { String string0 = Utilities . changeFileNameToClassName ( "ZK1^ { > qi . class" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String changeFileNameToClassName ( String name ) { if ( name = = null ) { throw new IllegalArgumentException ( "File Name = = null" ) ; } String className = null ; if ( name . toLowerCase ( ) . endsWith ( " . class" ) ) { className = name . replace ( ' / ' , ' . ' ) ; className = className . replace ( '\\' , ' . ' ) ; className = className . substring ( 0 , className . length ( ) - 6 ) ; } return className ; }
void test11 ( ) throws Throwable { String string0 = Utilities . changeFileNameToClassName ( "Unexpected char [ " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String changeFileNameToClassName ( String name ) { if ( name = = null ) { throw new IllegalArgumentException ( "File Name = = null" ) ; } String className = null ; if ( name . toLowerCase ( ) . endsWith ( " . class" ) ) { className = name . replace ( ' / ' , ' . ' ) ; className = className . replace ( '\\' , ' . ' ) ; className = className . substring ( 0 , className . length ( ) - 6 ) ; } return className ; }
void test12 ( ) throws Throwable { String string0 = Utilities . getFileNameSuffix ( "VWtZji . lut + . " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFileNameSuffix ( String fileName ) { if ( fileName = = null ) { throw new IllegalArgumentException ( "file name = = null" ) ; } int pos = fileName . lastIndexOf ( ' . ' ) ; if ( pos > 0 & & pos < fileName . length ( ) - 1 ) { return fileName . substring ( pos + 1 ) ; } return "" ; }
void test14 ( ) throws Throwable { String string0 = Utilities . getFileNameSuffix ( "ZK1^ { > qi" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFileNameSuffix ( String fileName ) { if ( fileName = = null ) { throw new IllegalArgumentException ( "file name = = null" ) ; } int pos = fileName . lastIndexOf ( ' . ' ) ; if ( pos > 0 & & pos < fileName . length ( ) - 1 ) { return fileName . substring ( pos + 1 ) ; } return "" ; }
void test15 ( ) throws Throwable { String string0 = Utilities . getFileNameSuffix ( "VM 5R ] . U" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getFileNameSuffix ( String fileName ) { if ( fileName = = null ) { throw new IllegalArgumentException ( "file name = = null" ) ; } int pos = fileName . lastIndexOf ( ' . ' ) ; if ( pos > 0 & & pos < fileName . length ( ) - 1 ) { return fileName . substring ( pos + 1 ) ; } return "" ; }
void test16 ( ) throws Throwable { boolean boolean0 = Utilities . equalsRespectNull ( ( Object ) "" , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equalsRespectNull ( Object o1 , Object o2 ) { if ( null = = o1 & & null = = o2 ) { return true ; } else if ( null = = o1 | | null = = o2 ) { return false ; } else { return o1 . equals ( o2 ) ; } }
void test17 ( ) throws Throwable { boolean boolean0 = Utilities . equalsRespectNull ( ( Object ) null , ( Object ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equalsRespectNull ( Object o1 , Object o2 ) { if ( null = = o1 & & null = = o2 ) { return true ; } else if ( null = = o1 | | null = = o2 ) { return false ; } else { return o1 . equals ( o2 ) ; } }
void test18 ( ) throws Throwable { boolean boolean0 = Utilities . equalsRespectNull ( ( Object ) null , ( Object ) "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equalsRespectNull ( Object o1 , Object o2 ) { if ( null = = o1 & & null = = o2 ) { return true ; } else if ( null = = o1 | | null = = o2 ) { return false ; } else { return o1 . equals ( o2 ) ; } }
void test19 ( ) throws Throwable { boolean boolean0 = Utilities . equalsRespectNull ( ( Object ) "Korean" , ( Object ) "ZK1^ { > qi" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equalsRespectNull ( Object o1 , Object o2 ) { if ( null = = o1 & & null = = o2 ) { return true ; } else if ( null = = o1 | | null = = o2 ) { return false ; } else { return o1 . equals ( o2 ) ; } }
void test20 ( ) throws Throwable { String string0 = Utilities . removeFileNameSuffix ( "VM 5R ] . U" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String removeFileNameSuffix ( String fileName ) { if ( fileName = = null ) { throw new IllegalArgumentException ( "file name = = null" ) ; } int pos = fileName . lastIndexOf ( ' . ' ) ; if ( pos > 0 & & pos < fileName . length ( ) - 1 ) { return fileName . substring ( 0 , pos ) ; } return fileName ; }
void test22 ( ) throws Throwable { String string0 = Utilities . removeFileNameSuffix ( "pgXCZuWxZ" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String removeFileNameSuffix ( String fileName ) { if ( fileName = = null ) { throw new IllegalArgumentException ( "file name = = null" ) ; } int pos = fileName . lastIndexOf ( ' . ' ) ; if ( pos > 0 & & pos < fileName . length ( ) - 1 ) { return fileName . substring ( 0 , pos ) ; } return fileName ; }
void test23 ( ) throws Throwable { String string0 = Utilities . formatSize ( 1073741824L , 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String formatSize ( long longSize ) { return formatSize ( longSize , - 1 ) ; }
void test24 ( ) throws Throwable { ClassLoader classLoader0 = ClassLoader . getSystemClassLoader ( ) ; Object object0 = Utilities . cloneObject ( ( Object ) null , classLoader0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object cloneObject ( Object toClone , ClassLoader classLoader ) { if ( null = = toClone ) { return null ; } else { try { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream oOut = new ObjectOutputStream ( bOut ) ; oOut . writeObject ( toClone ) ; oOut . close ( ) ; ByteArrayInputStream bIn = new ByteArrayInputStream ( bOut . toByteArray ( ) ) ; bOut . close ( ) ; ObjectInputStream oIn = new ObjectInputStream ( bIn ) { Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { return Class . forName ( desc . getName ( ) , false , classLoader ) ; } } ; bIn . close ( ) ; Object copy = oIn . readObject ( ) ; oIn . close ( ) ; return copy ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } }
void test25 ( ) throws Throwable { String string0 = Utilities . replaceI18NSpanLine ( "DATE" , ( StringManager ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String replaceI18NSpanLine ( String line , StringManager s_stringMgr ) { String result = line ; Matcher start = spanStartPattern . matcher ( line ) ; Matcher end = spanEndPattern . matcher ( line ) ; if ( start . matches ( ) & & end . matches ( ) ) { / / line should look like : / / / / This is a line with an < span > embedded key < / span > in it . / / StringBuffer tmp = new StringBuffer ( ) ; String [ ] startparts = spanStartSplitPattern . split ( line ) ; tmp . append ( startparts [ 0 ] ) ; / / startparts [ 1 ] contains our I18n string key followed by < / span > String [ ] endparts = spanEndSplitPattern . split ( startparts [ 1 ] ) ; String key = endparts [ 0 ] ; String value = s_stringMgr . getString ( key ) ; tmp . append ( value ) ; tmp . append ( endparts [ 1 ] ) ; result = tmp . toString ( ) ; } return result ; }
void test26 ( ) throws Throwable { String string0 = Utilities . replaceI18NSpanLine ( " < span > " , ( StringManager ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String replaceI18NSpanLine ( String line , StringManager s_stringMgr ) { String result = line ; Matcher start = spanStartPattern . matcher ( line ) ; Matcher end = spanEndPattern . matcher ( line ) ; if ( start . matches ( ) & & end . matches ( ) ) { / / line should look like : / / / / This is a line with an < span > embedded key < / span > in it . / / StringBuffer tmp = new StringBuffer ( ) ; String [ ] startparts = spanStartSplitPattern . split ( line ) ; tmp . append ( startparts [ 0 ] ) ; / / startparts [ 1 ] contains our I18n string key followed by < / span > String [ ] endparts = spanEndSplitPattern . split ( startparts [ 1 ] ) ; String key = endparts [ 0 ] ; String value = s_stringMgr . getString ( key ) ; tmp . append ( value ) ; tmp . append ( endparts [ 1 ] ) ; result = tmp . toString ( ) ; } return result ; }
void test0 ( ) throws Throwable { String [ ] stringArray0 = new String [ 3 ] ; FileExtensionFilter fileExtensionFilter0 = new FileExtensionFilter ( "" , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDescription ( ) { if ( null = = _description ) { if ( null ! = _action . getValue ( Action . SHORT_DESCRIPTION ) ) { _description = _action . getValue ( Action . SHORT_DESCRIPTION ) . toString ( ) ; } else { _description = "" ; } if ( false = = _action instanceof SquirrelAction / / SquirrelAction descriptions already contain the accelerator & & null ! = _action . getValue ( Resources . ACCELERATOR_STRING ) & & 0 ! = _action . getValue ( Resources . ACCELERATOR_STRING ) . toString ( ) . trim ( ) . length ( ) ) { _description + = " ( " + _action . getValue ( Resources . ACCELERATOR_STRING ) + " ) " ; } } return _description ; }
void test1 ( ) throws Throwable { String [ ] stringArray0 = new String [ 6 ] ; FileExtensionFilter fileExtensionFilter0 = new FileExtensionFilter ( "eE2 { " , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void accept ( CharacterIterator chars ) { _workingBuffer . waitChars ( ) ; / / wait for pending chars to be processed _workingBuffer . accept ( chars ) ; / / post new characters }
void test2 ( ) throws Throwable { String [ ] stringArray0 = new String [ 3 ] ; FileExtensionFilter fileExtensionFilter0 = new FileExtensionFilter ( "" , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDescription ( ) { if ( null = = _description ) { if ( null ! = _action . getValue ( Action . SHORT_DESCRIPTION ) ) { _description = _action . getValue ( Action . SHORT_DESCRIPTION ) . toString ( ) ; } else { _description = "" ; } if ( false = = _action instanceof SquirrelAction / / SquirrelAction descriptions already contain the accelerator & & null ! = _action . getValue ( Resources . ACCELERATOR_STRING ) & & 0 ! = _action . getValue ( Resources . ACCELERATOR_STRING ) . toString ( ) . trim ( ) . length ( ) ) { _description + = " ( " + _action . getValue ( Resources . ACCELERATOR_STRING ) + " ) " ; } } return _description ; }
void test3 ( ) throws Throwable { String [ ] stringArray0 = new String [ 1 ] ; stringArray0 [ 0 ] = "0u ~" ; FileExtensionFilter fileExtensionFilter0 = new FileExtensionFilter ( "0u ~" , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDescription ( ) { if ( null = = _description ) { if ( null ! = _action . getValue ( Action . SHORT_DESCRIPTION ) ) { _description = _action . getValue ( Action . SHORT_DESCRIPTION ) . toString ( ) ; } else { _description = "" ; } if ( false = = _action instanceof SquirrelAction / / SquirrelAction descriptions already contain the accelerator & & null ! = _action . getValue ( Resources . ACCELERATOR_STRING ) & & 0 ! = _action . getValue ( Resources . ACCELERATOR_STRING ) . toString ( ) . trim ( ) . length ( ) ) { _description + = " ( " + _action . getValue ( Resources . ACCELERATOR_STRING ) + " ) " ; } } return _description ; }
void test4 ( ) throws Throwable { String [ ] stringArray0 = new String [ 4 ] ; stringArray0 [ 0 ] = "" ; FileExtensionFilter fileExtensionFilter0 = new FileExtensionFilter ( "" , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDescription ( ) { if ( null = = _description ) { if ( null ! = _action . getValue ( Action . SHORT_DESCRIPTION ) ) { _description = _action . getValue ( Action . SHORT_DESCRIPTION ) . toString ( ) ; } else { _description = "" ; } if ( false = = _action instanceof SquirrelAction / / SquirrelAction descriptions already contain the accelerator & & null ! = _action . getValue ( Resources . ACCELERATOR_STRING ) & & 0 ! = _action . getValue ( Resources . ACCELERATOR_STRING ) . toString ( ) . trim ( ) . length ( ) ) { _description + = " ( " + _action . getValue ( Resources . ACCELERATOR_STRING ) + " ) " ; } } return _description ; }
void test1 ( ) throws Throwable { LibraryResources libraryResources0 = new LibraryResources ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JCheckBoxMenuItem addToMenuAsCheckBoxMenuItem ( Resources rsrc , Class actionClass , JMenu menu ) { Action act = _actions . get ( actionClass ) ; if ( act ! = null ) { JCheckBoxMenuItem mnu = rsrc . addToMenuAsCheckBoxMenuItem ( act , menu ) ; if ( act instanceof IToggleAction ) { ( ( IToggleAction ) act ) . getToggleComponentHolder ( ) . addToggleableComponent ( mnu ) ; } return mnu ; } s_log . error ( "Could not retrieve instance of " + actionClass . getName ( ) + " ) in MainFrameMenuBar . addToMenu" ) ; return null ; }
void test2 ( ) throws Throwable { LibraryResources libraryResources0 = new LibraryResources ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addToMenu ( int menuId , JMenu menu ) ; / * * * Add an < TT > Action < / TT > to a menu . * * @param menuId ID of menu to add to . @see #IMenuIDs * @param action The action to be added . * / void addToMenu ( int menuId , Action action ) ; / * * * Add component to the main frames status bar . * * @param comp Component to add . * / void addToStatusBar ( JComponent comp ) ; / * * * Remove component to the main frames status bar . * * @param comp Component to remove . * / void removeFromStatusBar ( JComponent comp ) ; / * * * Application startup processing . * / void startup ( ) ; / * * * Application shutdown processing . * * @param whether or not to update the launch script before shutdown . * / boolean shutdown ( boolean updateLaunchScript ) ; / * * * Launches the specified url in the system default web - browser * * @param url the URL of the web page to display . * / void openURL ( String url ) ; / * * * Saves off preferences and all state present in the application . * / void saveApplicationState ( ) ; / * * * Persists the specified category of preferences to file . * * @param preferenceType the enumerated type that indicates what category * of preferences to be persisted . * / void savePreferences ( PreferenceType preferenceType ) ; void addApplicationListener ( ApplicationListener l ) ; void removeApplicationListener ( ApplicationListener l ) ; / * * * Returns a factory for WIKI table configurations . * This factory is managing the system and user - specific configurations for WIKI tables . * @return A factory for WIKI table configurations . * @see IWikiTableConfigurationFactory * / IWikiTableConfigurationFactory getWikiTableConfigFactory ( ) ; MultipleWindowsHandler getMultipleWindowsHandler ( ) ; }
void test4 ( ) throws Throwable { LibraryResources libraryResources0 = new LibraryResources ( ) ; PropertyResourceBundle propertyResourceBundle0 = ( PropertyResourceBundle ) libraryResources0 . getBundle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ResourceBundle getBundle ( ) { return _bundle ; }
void test7 ( ) throws Throwable { LibraryResources libraryResources0 = new LibraryResources ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JMenuItem addToPopupMenu ( Action action , javax . swing . JPopupMenu menu ) throws MissingResourceException { Utilities . checkNull ( "addToPopupMenu" , "action" , action , "menu" , menu ) ; String fullKey = Keys . MENU_ITEM + " . " + action . getClass ( ) . getName ( ) ; JMenuItem item = menu . add ( action ) ; if ( action . getValue ( Action . MNEMONIC_KEY ) = = null ) { String mn = getResourceString ( fullKey , MenuItemProperties . MNEMONIC ) ; if ( mn . length ( ) > 0 ) { item . setMnemonic ( mn . charAt ( 0 ) ) ; } } if ( action . getValue ( Action . ACCELERATOR_KEY ) = = null ) { String accel = getResourceString ( fullKey , MenuItemProperties . ACCELERATOR ) ; if ( accel . length ( ) > 0 ) { item . setAccelerator ( KeyStroke . getKeyStroke ( accel ) ) ; } } String toolTipText = getToolTipTextWithAccelerator ( action , fullKey ) ; item . setToolTipText ( toolTipText ) ; return item ; }
void test1 ( ) throws Throwable { EnumerationIterator < Object > enumerationIterator0 = new EnumerationIterator < Object > ( ( Enumeration < Object > ) null ) ; boolean boolean0 = enumerationIterator0 . hasNext ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasNext ( ) { return false ; }
void test0 ( ) throws Throwable { ExtensionFilter extensionFilter0 = new ExtensionFilter ( ) ; File file0 = new File ( "" , "" ) ; boolean boolean0 = extensionFilter0 . accept ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void accept ( CharacterIterator chars ) { _workingBuffer . waitChars ( ) ; / / wait for pending chars to be processed _workingBuffer . accept ( chars ) ; / / post new characters }
void test1 ( ) throws Throwable { ExtensionFilter extensionFilter0 = new ExtensionFilter ( ) ; File file0 = new File ( " ( * . " ) ; extensionFilter0 . addExtension ( "" , "" ) ; boolean boolean0 = extensionFilter0 . accept ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDescription ( ) { if ( null = = _description ) { if ( null ! = _action . getValue ( Action . SHORT_DESCRIPTION ) ) { _description = _action . getValue ( Action . SHORT_DESCRIPTION ) . toString ( ) ; } else { _description = "" ; } if ( false = = _action instanceof SquirrelAction / / SquirrelAction descriptions already contain the accelerator & & null ! = _action . getValue ( Resources . ACCELERATOR_STRING ) & & 0 ! = _action . getValue ( Resources . ACCELERATOR_STRING ) . toString ( ) . trim ( ) . length ( ) ) { _description + = " ( " + _action . getValue ( Resources . ACCELERATOR_STRING ) + " ) " ; } } return _description ; }
void test2 ( ) throws Throwable { ExtensionFilter extensionFilter0 = new ExtensionFilter ( ) ; extensionFilter0 . addExtension ( "" , "" ) ; File file0 = new File ( ( File ) null , "" ) ; boolean boolean0 = extensionFilter0 . accept ( file0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDescription ( ) { if ( null = = _description ) { if ( null ! = _action . getValue ( Action . SHORT_DESCRIPTION ) ) { _description = _action . getValue ( Action . SHORT_DESCRIPTION ) . toString ( ) ; } else { _description = "" ; } if ( false = = _action instanceof SquirrelAction / / SquirrelAction descriptions already contain the accelerator & & null ! = _action . getValue ( Resources . ACCELERATOR_STRING ) & & 0 ! = _action . getValue ( Resources . ACCELERATOR_STRING ) . toString ( ) . trim ( ) . length ( ) ) { _description + = " ( " + _action . getValue ( Resources . ACCELERATOR_STRING ) + " ) " ; } } return _description ; }
void test3 ( ) throws Throwable { ExtensionFilter extensionFilter0 = new ExtensionFilter ( ) ; extensionFilter0 . addExtension ( "" , "" ) ; extensionFilter0 . addExtension ( " ( * . " , "92" ) ; String string0 = extensionFilter0 . getDescription ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Object getDescription ( ) { if ( null = = _description ) { if ( null ! = _action . getValue ( Action . SHORT_DESCRIPTION ) ) { _description = _action . getValue ( Action . SHORT_DESCRIPTION ) . toString ( ) ; } else { _description = "" ; } if ( false = = _action instanceof SquirrelAction / / SquirrelAction descriptions already contain the accelerator & & null ! = _action . getValue ( Resources . ACCELERATOR_STRING ) & & 0 ! = _action . getValue ( Resources . ACCELERATOR_STRING ) . toString ( ) . trim ( ) . length ( ) ) { _description + = " ( " + _action . getValue ( Resources . ACCELERATOR_STRING ) + " ) " ; } } return _description ; }
void test0 ( ) throws Throwable { StringManagerFactory stringManagerFactory0 = new StringManagerFactory ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { Class < ? > class0 = StringManager . class ; StringManager stringManager0 = StringManagerFactory . getStringManager ( class0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" StringManager getStringManager ( Class < ? > clazz ) { if ( clazz = = null ) { throw new IllegalArgumentException ( "clazz = = null" ) ; } String key = getKey ( clazz ) ; StringManager mgr = s_mgrs . get ( key ) ; if ( mgr = = null ) { mgr = new StringManager ( key , clazz . getClassLoader ( ) ) ; s_mgrs . put ( key , mgr ) ; } return mgr ; }
void test2 ( ) throws Throwable { IOUtilitiesImpl iOUtilitiesImpl0 = new IOUtilitiesImpl ( ) ; byte [ ] byteArray0 = new byte [ 7 ] ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 , ( int ) ( byte ) ( - 128 ) , ( int ) ( byte ) 0 ) ; iOUtilitiesImpl0 . closeInputStream ( ( InputStream ) byteArrayInputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void closeInputStream ( InputStream is ) ; void closeOutputStream ( OutputStream os ) ; / * * * Closes the specified Reader which can be null . Logs an error if an exception occurs while closing . * * @param reader * the Reader to close . * / void closeReader ( Reader reader ) ; / * * * Closes the specified writer which can be null . Logs an error if an exception occurs while closing . * * @param writer * the Writer to close . * / void closeWriter ( Writer writer ) ; / * * * Flushes the specified writer which can be null . Logs an error if an exception occurs while closing . * * @param writer * the Writer to flush . * / void flushWriter ( Writer writer ) ; / * * * Reads from the specified InputStream and copies bytes read to the specified OuputStream . * * @param is * the InputStream to read from * @param os * the OutputStream to write to * @throws IOException * in an exception occurs while reading / writing * / void copyBytes ( InputStream is , OutputStream os ) throws IOException ; / * * * Reads from the specified FileWrapper ( from ) and copies bytes read to the specified FileWrapper ( to ) . * * @param from * @param to * @throws IOException * / void copyFile ( FileWrapper from , FileWrapper to ) throws IOException ; / * * * Computes the CRC32 checksum for the specified file . This doesn't appear to be compatible with cksum . * * @param f * the file to compute a checksum for . * @return the checksum value for the file specified * / long getCheckSum ( File f ) throws IOException ; / * * * @param f * @return * @throws IOException * / long getCheckSum ( FileWrapper f ) throws IOException ; / * * * Copies bytes from the specified InputStream to the specified output file . This will create the file if * it doesn't already exist . The specified inputstream is not closed in this method . * * @param is * the InputStream to read from . * @param outputFile * the file to write to . * @return the number of bytes that were read and written to the file . * @throws IOException * / int copyBytesToFile ( InputStream is , FileWrapper outputFile ) throws IOException ; / * * * Downloads a file using HTTP . * * @param url * the URL of the file to be retrieved * @param destFile * the file to download the URL file into * @param proxySettings * the ProxySettings to use * @return the number of bytes that were read and written to the file . * @throws Exception * / int downloadHttpFile ( URL url , FileWrapper destFile , IProxySettings proxySettings ) throws IOException ; URL constructHttpUrl ( String host , int port , String fileToGet ) throws MalformedURLException ; / * * * Reads the file specified by filename and builds a list of lines , applying the line fixers specified . * * @param filename * the name of the file to read lines from . * @param lineFixers * a list of fixers to apply to each line . This can be null if no line manipulation is required . * @return a list of lines * @throws IOException * if an I / O error occurs . * / List < String > getLinesFromFile ( String filename , List < ScriptLineFixer > lineFixers ) throws IOException ; / * * * Writes the specified list of line to the specified filename . This will overrite the current contents of * the file . * * @param filename * the file to overwrite * @param lines * the lines to write to the file . * @throws FileNotFoundException * / void writeLinesToFile ( String filename , List < String > lines ) throws FileNotFoundException ; / * * * Copies the resource specified from the jarfile specified to the specified destination directory . * * @param jarFilename * the jarfile to look in . * @param resourceName * the resource to pull out . * @param destinationDir * the directory to write the resource to . * @throws IOException * @throws ZipException * / void copyResourceFromJarFile ( String jarFilename , String resourceName , String destinationDir ) throws ZipException , IOException ; }
void test3 ( ) throws Throwable { IOUtilitiesImpl iOUtilitiesImpl0 = new IOUtilitiesImpl ( ) ; PrintStream printStream0 = DebugGraphics . logStream ( ) ; iOUtilitiesImpl0 . closeOutputStream ( ( OutputStream ) printStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void closeOutputStream ( OutputStream os ) ; / * * * Closes the specified Reader which can be null . Logs an error if an exception occurs while closing . * * @param reader * the Reader to close . * / void closeReader ( Reader reader ) ; / * * * Closes the specified writer which can be null . Logs an error if an exception occurs while closing . * * @param writer * the Writer to close . * / void closeWriter ( Writer writer ) ; / * * * Flushes the specified writer which can be null . Logs an error if an exception occurs while closing . * * @param writer * the Writer to flush . * / void flushWriter ( Writer writer ) ; / * * * Reads from the specified InputStream and copies bytes read to the specified OuputStream . * * @param is * the InputStream to read from * @param os * the OutputStream to write to * @throws IOException * in an exception occurs while reading / writing * / void copyBytes ( InputStream is , OutputStream os ) throws IOException ; / * * * Reads from the specified FileWrapper ( from ) and copies bytes read to the specified FileWrapper ( to ) . * * @param from * @param to * @throws IOException * / void copyFile ( FileWrapper from , FileWrapper to ) throws IOException ; / * * * Computes the CRC32 checksum for the specified file . This doesn't appear to be compatible with cksum . * * @param f * the file to compute a checksum for . * @return the checksum value for the file specified * / long getCheckSum ( File f ) throws IOException ; / * * * @param f * @return * @throws IOException * / long getCheckSum ( FileWrapper f ) throws IOException ; / * * * Copies bytes from the specified InputStream to the specified output file . This will create the file if * it doesn't already exist . The specified inputstream is not closed in this method . * * @param is * the InputStream to read from . * @param outputFile * the file to write to . * @return the number of bytes that were read and written to the file . * @throws IOException * / int copyBytesToFile ( InputStream is , FileWrapper outputFile ) throws IOException ; / * * * Downloads a file using HTTP . * * @param url * the URL of the file to be retrieved * @param destFile * the file to download the URL file into * @param proxySettings * the ProxySettings to use * @return the number of bytes that were read and written to the file . * @throws Exception * / int downloadHttpFile ( URL url , FileWrapper destFile , IProxySettings proxySettings ) throws IOException ; URL constructHttpUrl ( String host , int port , String fileToGet ) throws MalformedURLException ; / * * * Reads the file specified by filename and builds a list of lines , applying the line fixers specified . * * @param filename * the name of the file to read lines from . * @param lineFixers * a list of fixers to apply to each line . This can be null if no line manipulation is required . * @return a list of lines * @throws IOException * if an I / O error occurs . * / List < String > getLinesFromFile ( String filename , List < ScriptLineFixer > lineFixers ) throws IOException ; / * * * Writes the specified list of line to the specified filename . This will overrite the current contents of * the file . * * @param filename * the file to overwrite * @param lines * the lines to write to the file . * @throws FileNotFoundException * / void writeLinesToFile ( String filename , List < String > lines ) throws FileNotFoundException ; / * * * Copies the resource specified from the jarfile specified to the specified destination directory . * * @param jarFilename * the jarfile to look in . * @param resourceName * the resource to pull out . * @param destinationDir * the directory to write the resource to . * @throws IOException * @throws ZipException * / void copyResourceFromJarFile ( String jarFilename , String resourceName , String destinationDir ) throws ZipException , IOException ; }
void test9 ( ) throws Throwable { IOUtilitiesImpl iOUtilitiesImpl0 = new IOUtilitiesImpl ( ) ; PrintStream printStream0 = DebugGraphics . logStream ( ) ; PrintWriter printWriter0 = new PrintWriter ( ( OutputStream ) printStream0 , true ) ; iOUtilitiesImpl0 . flushWriter ( ( Writer ) printWriter0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void flushWriter ( Writer writer ) ; / * * * Reads from the specified InputStream and copies bytes read to the specified OuputStream . * * @param is * the InputStream to read from * @param os * the OutputStream to write to * @throws IOException * in an exception occurs while reading / writing * / void copyBytes ( InputStream is , OutputStream os ) throws IOException ; / * * * Reads from the specified FileWrapper ( from ) and copies bytes read to the specified FileWrapper ( to ) . * * @param from * @param to * @throws IOException * / void copyFile ( FileWrapper from , FileWrapper to ) throws IOException ; / * * * Computes the CRC32 checksum for the specified file . This doesn't appear to be compatible with cksum . * * @param f * the file to compute a checksum for . * @return the checksum value for the file specified * / long getCheckSum ( File f ) throws IOException ; / * * * @param f * @return * @throws IOException * / long getCheckSum ( FileWrapper f ) throws IOException ; / * * * Copies bytes from the specified InputStream to the specified output file . This will create the file if * it doesn't already exist . The specified inputstream is not closed in this method . * * @param is * the InputStream to read from . * @param outputFile * the file to write to . * @return the number of bytes that were read and written to the file . * @throws IOException * / int copyBytesToFile ( InputStream is , FileWrapper outputFile ) throws IOException ; / * * * Downloads a file using HTTP . * * @param url * the URL of the file to be retrieved * @param destFile * the file to download the URL file into * @param proxySettings * the ProxySettings to use * @return the number of bytes that were read and written to the file . * @throws Exception * / int downloadHttpFile ( URL url , FileWrapper destFile , IProxySettings proxySettings ) throws IOException ; URL constructHttpUrl ( String host , int port , String fileToGet ) throws MalformedURLException ; / * * * Reads the file specified by filename and builds a list of lines , applying the line fixers specified . * * @param filename * the name of the file to read lines from . * @param lineFixers * a list of fixers to apply to each line . This can be null if no line manipulation is required . * @return a list of lines * @throws IOException * if an I / O error occurs . * / List < String > getLinesFromFile ( String filename , List < ScriptLineFixer > lineFixers ) throws IOException ; / * * * Writes the specified list of line to the specified filename . This will overrite the current contents of * the file . * * @param filename * the file to overwrite * @param lines * the lines to write to the file . * @throws FileNotFoundException * / void writeLinesToFile ( String filename , List < String > lines ) throws FileNotFoundException ; / * * * Copies the resource specified from the jarfile specified to the specified destination directory . * * @param jarFilename * the jarfile to look in . * @param resourceName * the resource to pull out . * @param destinationDir * the directory to write the resource to . * @throws IOException * @throws ZipException * / void copyResourceFromJarFile ( String jarFilename , String resourceName , String destinationDir ) throws ZipException , IOException ; }
void test10 ( ) throws Throwable { IOUtilitiesImpl iOUtilitiesImpl0 = new IOUtilitiesImpl ( ) ; byte [ ] byteArray0 = new byte [ 1 ] ; ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream ( byteArray0 ) ; PushbackInputStream pushbackInputStream0 = new PushbackInputStream ( ( InputStream ) byteArrayInputStream0 ) ; ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream ( ) ; ObjectOutputStream objectOutputStream0 = new ObjectOutputStream ( ( OutputStream ) byteArrayOutputStream0 ) ; iOUtilitiesImpl0 . copyBytes ( ( InputStream ) pushbackInputStream0 , ( OutputStream ) objectOutputStream0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void copyBytes ( InputStream is , OutputStream os ) throws IOException ; / * * * Reads from the specified FileWrapper ( from ) and copies bytes read to the specified FileWrapper ( to ) . * * @param from * @param to * @throws IOException * / void copyFile ( FileWrapper from , FileWrapper to ) throws IOException ; / * * * Computes the CRC32 checksum for the specified file . This doesn't appear to be compatible with cksum . * * @param f * the file to compute a checksum for . * @return the checksum value for the file specified * / long getCheckSum ( File f ) throws IOException ; / * * * @param f * @return * @throws IOException * / long getCheckSum ( FileWrapper f ) throws IOException ; / * * * Copies bytes from the specified InputStream to the specified output file . This will create the file if * it doesn't already exist . The specified inputstream is not closed in this method . * * @param is * the InputStream to read from . * @param outputFile * the file to write to . * @return the number of bytes that were read and written to the file . * @throws IOException * / int copyBytesToFile ( InputStream is , FileWrapper outputFile ) throws IOException ; / * * * Downloads a file using HTTP . * * @param url * the URL of the file to be retrieved * @param destFile * the file to download the URL file into * @param proxySettings * the ProxySettings to use * @return the number of bytes that were read and written to the file . * @throws Exception * / int downloadHttpFile ( URL url , FileWrapper destFile , IProxySettings proxySettings ) throws IOException ; URL constructHttpUrl ( String host , int port , String fileToGet ) throws MalformedURLException ; / * * * Reads the file specified by filename and builds a list of lines , applying the line fixers specified . * * @param filename * the name of the file to read lines from . * @param lineFixers * a list of fixers to apply to each line . This can be null if no line manipulation is required . * @return a list of lines * @throws IOException * if an I / O error occurs . * / List < String > getLinesFromFile ( String filename , List < ScriptLineFixer > lineFixers ) throws IOException ; / * * * Writes the specified list of line to the specified filename . This will overrite the current contents of * the file . * * @param filename * the file to overwrite * @param lines * the lines to write to the file . * @throws FileNotFoundException * / void writeLinesToFile ( String filename , List < String > lines ) throws FileNotFoundException ; / * * * Copies the resource specified from the jarfile specified to the specified destination directory . * * @param jarFilename * the jarfile to look in . * @param resourceName * the resource to pull out . * @param destinationDir * the directory to write the resource to . * @throws IOException * @throws ZipException * / void copyResourceFromJarFile ( String jarFilename , String resourceName , String destinationDir ) throws ZipException , IOException ; }
void test13 ( ) throws Throwable { IOUtilitiesImpl iOUtilitiesImpl0 = new IOUtilitiesImpl ( ) ; URL uRL0 = iOUtilitiesImpl0 . constructHttpUrl ( "FT = r : k9$'yJfB - ZY" , 80 , "FT = r : k9$'yJfB - ZY" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" URL constructHttpUrl ( String host , int port , String fileToGet ) throws MalformedURLException ; / * * * Reads the file specified by filename and builds a list of lines , applying the line fixers specified . * * @param filename * the name of the file to read lines from . * @param lineFixers * a list of fixers to apply to each line . This can be null if no line manipulation is required . * @return a list of lines * @throws IOException * if an I / O error occurs . * / List < String > getLinesFromFile ( String filename , List < ScriptLineFixer > lineFixers ) throws IOException ; / * * * Writes the specified list of line to the specified filename . This will overrite the current contents of * the file . * * @param filename * the file to overwrite * @param lines * the lines to write to the file . * @throws FileNotFoundException * / void writeLinesToFile ( String filename , List < String > lines ) throws FileNotFoundException ; / * * * Copies the resource specified from the jarfile specified to the specified destination directory . * * @param jarFilename * the jarfile to look in . * @param resourceName * the resource to pull out . * @param destinationDir * the directory to write the resource to . * @throws IOException * @throws ZipException * / void copyResourceFromJarFile ( String jarFilename , String resourceName , String destinationDir ) throws ZipException , IOException ; }
void test1 ( ) throws Throwable { EmptyIterator < Integer > emptyIterator0 = new EmptyIterator < Integer > ( ) ; boolean boolean0 = emptyIterator0 . hasNext ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean hasNext ( ) { return false ; }
void test1 ( ) throws Throwable { PropertyChangeReporter propertyChangeReporter0 = new PropertyChangeReporter ( ( Object ) "11$ = F" ) ; PropertyChangeListenerProxy propertyChangeListenerProxy0 = new PropertyChangeListenerProxy ( "40Bm" , ( PropertyChangeListener ) null ) ; propertyChangeReporter0 . addPropertyChangeListener ( ( PropertyChangeListener ) propertyChangeListenerProxy0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void addPropertyChangeListener ( PropertyChangeListener listener ) { getPropertyChangeReporter ( ) . addPropertyChangeListener ( listener ) ; }
void test0 ( ) throws Throwable { String string0 = SystemProperties . getClassPath ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClassPath ( ) { return get ( ) . getProperty ( "java . class . path" ) ; }
void test1 ( ) throws Throwable { boolean boolean0 = SystemProperties . isRunningOnOSX ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isRunningOnOSX ( ) { return true ; / / return get ( ) . getProperty ( "mrj . version" ) ! = null ; }
void test0 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; Properties properties0 = new Properties ( ) ; ProxyHandler proxyHandler0 = new ProxyHandler ( ) ; proxySettings0 . setHttpProxyUser ( " < pF = aD`" ) ; proxySettings0 . setHttpUseProxy ( true ) ; proxyHandler0 . apply ( ( IProxySettings ) proxySettings0 , properties0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setHttpUseProxy ( true ) ; proxySettings0 . setHttpProxyPassword ( "" ) ; ProxyHandler proxyHandler0 = new ProxyHandler ( ) ; proxyHandler0 . apply ( ( IProxySettings ) proxySettings0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getHttpUseProxy ( ) ; String getHttpProxyServer ( ) ; String getHttpProxyPort ( ) ; String getHttpProxyUser ( ) ; String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test3 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setHttpProxyUser ( "" ) ; proxySettings0 . setHttpUseProxy ( true ) ; ProxyHandler proxyHandler0 = new ProxyHandler ( ) ; proxyHandler0 . apply ( ( IProxySettings ) proxySettings0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getHttpUseProxy ( ) ; String getHttpProxyServer ( ) ; String getHttpProxyPort ( ) ; String getHttpProxyUser ( ) ; String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test4 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setSocksUseProxy ( true ) ; ProxyHandler proxyHandler0 = new ProxyHandler ( ) ; proxyHandler0 . apply ( ( IProxySettings ) proxySettings0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test5 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; Properties properties0 = new Properties ( ) ; ProxyHandler proxyHandler0 = new ProxyHandler ( ) ; proxySettings0 . setHttpProxyPort ( "" ) ; proxySettings0 . setHttpUseProxy ( true ) ; proxyHandler0 . apply ( ( IProxySettings ) proxySettings0 , properties0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test0 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; boolean boolean0 = proxySettings0 . getHttpUseProxy ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getHttpUseProxy ( ) ; String getHttpProxyServer ( ) ; String getHttpProxyPort ( ) ; String getHttpProxyUser ( ) ; String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test1 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setHttpProxyUser ( "x | " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHttpProxyServer ( ) ; String getHttpProxyPort ( ) ; String getHttpProxyUser ( ) ; String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test2 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; boolean boolean0 = proxySettings0 . getSocksUseProxy ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test3 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; String string0 = proxySettings0 . getSocksProxyPort ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSocksProxyPort ( ) ; }
void test4 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setSocksUseProxy ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test5 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setHttpProxyPort ( "x | " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test6 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; String string0 = proxySettings0 . getHttpProxyServer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHttpProxyServer ( ) ; String getHttpProxyPort ( ) ; String getHttpProxyUser ( ) ; String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test7 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setHttpNonProxyHosts ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test8 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; ProxySettings proxySettings1 = ( ProxySettings ) proxySettings0 . clone ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test9 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setHttpProxyServer ( "x | " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test10 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; String string0 = proxySettings0 . getHttpProxyPassword ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test11 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; String string0 = proxySettings0 . getHttpNonProxyHosts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test12 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; String string0 = proxySettings0 . getHttpProxyPort ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHttpProxyPort ( ) ; String getHttpProxyUser ( ) ; String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test13 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setSocksProxyPort ( " * NzA | e [ gvm'" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHttpProxyUser ( ) ; String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test14 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; String string0 = proxySettings0 . getHttpProxyUser ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHttpProxyUser ( ) ; String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test15 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setHttpProxyPassword ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getHttpUseProxy ( ) ; String getHttpProxyServer ( ) ; String getHttpProxyPort ( ) ; String getHttpProxyUser ( ) ; String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test16 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setSocksProxyServer ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSocksProxyPort ( ) ; }
void test17 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; String string0 = proxySettings0 . getSocksProxyServer ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test18 ( ) throws Throwable { ProxySettings proxySettings0 = new ProxySettings ( ) ; proxySettings0 . setHttpUseProxy ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean getHttpUseProxy ( ) ; String getHttpProxyServer ( ) ; String getHttpProxyPort ( ) ; String getHttpProxyUser ( ) ; String getHttpProxyPassword ( ) ; String getHttpNonProxyHosts ( ) ; boolean getSocksUseProxy ( ) ; String getSocksProxyServer ( ) ; String getSocksProxyPort ( ) ; }
void test0 ( ) throws Throwable { String [ ] stringArray0 = LocaleUtils . getAvailableLocaleStrings ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getAvailableLocaleStrings ( ) { Locale [ ] availableLocales = getAvailableLocales ( ) ; String [ ] result = new String [ availableLocales . length ] ; for ( int i = 0 ; i < availableLocales . length ; i + + ) { result [ i ] = availableLocales [ i ] . toString ( ) ; } return result ; }
void test1 ( ) throws Throwable { LocaleUtils localeUtils0 = new LocaleUtils ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { BareBonesBrowserLaunch bareBonesBrowserLaunch0 = new BareBonesBrowserLaunch ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { ListMessageHandler listMessageHandler0 = new ListMessageHandler ( ) ; String [ ] stringArray0 = listMessageHandler0 . getWarningMessages ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getWarningMessages ( ) { return _warningMsgs . toArray ( new String [ _warningMsgs . size ( ) ] ) ; }
void test2 ( ) throws Throwable { ListMessageHandler listMessageHandler0 = new ListMessageHandler ( ) ; String [ ] stringArray0 = listMessageHandler0 . getErrorMessages ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getErrorMessages ( ) { return _errMsgs . toArray ( new String [ _errMsgs . size ( ) ] ) ; }
void test3 ( ) throws Throwable { ListMessageHandler listMessageHandler0 = new ListMessageHandler ( ) ; Throwable [ ] throwableArray0 = listMessageHandler0 . getErrorExceptions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Throwable [ ] getErrorExceptions ( ) { return _errThrowables . toArray ( new Throwable [ _errThrowables . size ( ) ] ) ; }
void test5 ( ) throws Throwable { ListMessageHandler listMessageHandler0 = new ListMessageHandler ( ) ; Throwable [ ] throwableArray0 = listMessageHandler0 . getExceptions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Throwable [ ] getExceptions ( ) { return _throwables . toArray ( new Throwable [ _throwables . size ( ) ] ) ; }
void test7 ( ) throws Throwable { ListMessageHandler listMessageHandler0 = new ListMessageHandler ( ) ; String [ ] stringArray0 = listMessageHandler0 . getMessages ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String [ ] getMessages ( ) { return _msgs . toArray ( new String [ _msgs . size ( ) ] ) ; }
void test1 ( ) throws Throwable { Class < ? > class0 = LoggerController . class ; Log4jLogger log4jLogger0 = ( Log4jLogger ) LoggerController . createLogger ( class0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDebugEnabled ( ) { return _log . isDebugEnabled ( ) ; }
void test2 ( ) throws Throwable { LoggerController loggerController0 = new LoggerController ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { DimensionWrapper dimensionWrapper0 = new DimensionWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWidth ( ) { return _indexedColumn . calculateDist ( _beginData , _endData ) ; }
void test1 ( ) throws Throwable { DimensionWrapper dimensionWrapper0 = new DimensionWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getHeight ( ) ; }
void test2 ( ) throws Throwable { DimensionWrapper dimensionWrapper0 = new DimensionWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getHeight ( ) ; }
void test3 ( ) throws Throwable { DimensionWrapper dimensionWrapper0 = new DimensionWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWidth ( ) { return _indexedColumn . calculateDist ( _beginData , _endData ) ; }
void test4 ( ) throws Throwable { DimensionWrapper dimensionWrapper0 = new DimensionWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getHeight ( ) ; }
void test0 ( ) throws Throwable { RectangleWrapperBeanInfo rectangleWrapperBeanInfo0 = new RectangleWrapperBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = rectangleWrapperBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { Rectangle rectangle0 = new Rectangle ( ( - 598 ) , ( - 1794 ) , 0 , ( - 1566 ) ) ; RectangleWrapper rectangleWrapper0 = new RectangleWrapper ( rectangle0 ) ; Rectangle rectangle1 = rectangleWrapper0 . createRectangle ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { Rectangle rectangle0 = new Rectangle ( ( - 598 ) , ( - 1794 ) , 0 , ( - 1566 ) ) ; RectangleWrapper rectangleWrapper0 = new RectangleWrapper ( rectangle0 ) ; int int0 = rectangleWrapper0 . getX ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getY ( ) { return _y ; }
void test2 ( ) throws Throwable { Rectangle rectangle0 = new Rectangle ( ) ; RectangleWrapper rectangleWrapper0 = new RectangleWrapper ( rectangle0 ) ; int int0 = rectangleWrapper0 . getWidth ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWidth ( ) { return _indexedColumn . calculateDist ( _beginData , _endData ) ; }
void test3 ( ) throws Throwable { Rectangle rectangle0 = new Rectangle ( ( - 598 ) , ( - 1794 ) , 0 , ( - 1566 ) ) ; RectangleWrapper rectangleWrapper0 = new RectangleWrapper ( rectangle0 ) ; int int0 = rectangleWrapper0 . getHeight ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getY ( ) { return _y ; }
void test4 ( ) throws Throwable { RectangleWrapper rectangleWrapper0 = new RectangleWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getWidth ( ) { return _indexedColumn . calculateDist ( _beginData , _endData ) ; }
void test5 ( ) throws Throwable { Rectangle rectangle0 = new Rectangle ( ) ; RectangleWrapper rectangleWrapper0 = new RectangleWrapper ( rectangle0 ) ; rectangleWrapper0 . setHeight ( 0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getHeight ( ) ; }
void test6 ( ) throws Throwable { RectangleWrapper rectangleWrapper0 = new RectangleWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getY ( ) { return _y ; }
void test7 ( ) throws Throwable { RectangleWrapper rectangleWrapper0 = new RectangleWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getY ( ) { return _y ; }
void test8 ( ) throws Throwable { RectangleWrapper rectangleWrapper0 = new RectangleWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getX ( ) { return _x ; }
void test0 ( ) throws Throwable { PointWrapper pointWrapper0 = new PointWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getY ( ) { return _y ; }
void test1 ( ) throws Throwable { PointWrapper pointWrapper0 = new PointWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getX ( ) { return _x ; }
void test2 ( ) throws Throwable { PointWrapper pointWrapper0 = new PointWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getX ( ) { return _x ; }
void test3 ( ) throws Throwable { PointWrapper pointWrapper0 = new PointWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getY ( ) { return _y ; }
void test4 ( ) throws Throwable { PointWrapper pointWrapper0 = new PointWrapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getX ( ) { return _x ; }
void test0 ( ) throws Throwable { URLWrapperBeanInfo uRLWrapperBeanInfo0 = new URLWrapperBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = uRLWrapperBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { StringWrapperBeanInfo stringWrapperBeanInfo0 = new StringWrapperBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = stringWrapperBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { DimensionWrapperBeanInfo dimensionWrapperBeanInfo0 = new DimensionWrapperBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = dimensionWrapperBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test0 ( ) throws Throwable { StringWrapper stringWrapper0 = new StringWrapper ( ) ; String string0 = stringWrapper0 . getString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getString ( String data ) { return data ! = null ? data . trim ( ) : "" ; }
void test0 ( ) throws Throwable { PointWrapperBeanInfo pointWrapperBeanInfo0 = new PointWrapperBeanInfo ( ) ; PropertyDescriptor [ ] propertyDescriptorArray0 = pointWrapperBeanInfo0 . getPropertyDescriptors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PropertyDescriptor [ ] getPropertyDescriptors ( ) { try { PropertyDescriptor [ ] s_descr = new PropertyDescriptor [ 8 ] ; s_descr [ 0 ] = new PropertyDescriptor ( IPropNames . PLUGIN_CLASS_NAME , PluginInfo . class , "getPluginClassName" , null ) ; s_descr [ 1 ] = new PropertyDescriptor ( IPropNames . IS_LOADED , PluginInfo . class , "isLoaded" , null ) ; s_descr [ 2 ] = new PropertyDescriptor ( IPropNames . INTERNAL_NAME , PluginInfo . class , "getInternalName" , null ) ; s_descr [ 3 ] = new PropertyDescriptor ( IPropNames . DESCRIPTIVE_NAME , PluginInfo . class , "getDescriptiveName" , null ) ; s_descr [ 4 ] = new PropertyDescriptor ( IPropNames . AUTHOR , PluginInfo . class , "getAuthor" , null ) ; s_descr [ 5 ] = new PropertyDescriptor ( IPropNames . CONTRIBUTORS , PluginInfo . class , "getContributors" , null ) ; s_descr [ 6 ] = new PropertyDescriptor ( IPropNames . WEB_SITE , PluginInfo . class , "getWebSite" , null ) ; s_descr [ 7 ] = new PropertyDescriptor ( IPropNames . VERSION , PluginInfo . class , "getVersion" , null ) ; return s_descr ; } catch ( IntrospectionException e ) { throw new Error ( e ) ; } }
void test1 ( ) throws Throwable { URLWrapper uRLWrapper0 = new URLWrapper ( ) ; uRLWrapper0 . setExternalForm ( "Q " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getExternalForm ( ) { return _externalForm ; }
void test2 ( ) throws Throwable { URLWrapper uRLWrapper0 = new URLWrapper ( ) ; String string0 = uRLWrapper0 . getExternalForm ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getExternalForm ( ) { return _externalForm ; }
void test3 ( ) throws Throwable { Handler handler0 = new Handler ( ) ; URL uRL0 = new URL ( " | \" : T" , " | \" : T" , 1 , " | \" : T" , ( URLStreamHandler ) handler0 ) ; URLWrapper uRLWrapper0 = new URLWrapper ( uRL0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getExternalForm ( ) { return _externalForm ; }
void test0 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; dBCopyPlugin0 . unload ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test1 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; dBCopyPlugin0 . setCopyMenuEnabled ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAuthor ( ) { return "Colin Bell" ; }
void test2 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; List < IDatabaseObjectInfo > list0 = dBCopyPlugin0 . getSourceDatabaseObjects ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" List < IDatabaseObjectInfo > getSourceDatabaseObjects ( ) ; IDatabaseObjectInfo getDestDatabaseObject ( ) ; void setDestDatabaseObject ( IDatabaseObjectInfo info ) ; void setDestSession ( ISession session ) ; ISession getDestSession ( ) ; void setPasteToTableName ( String pasteToTableName ) ; String getPasteToTableName ( ) ; TableInfo getPasteToTableInfo ( ISQLConnection destConn , String destSchema , String destCatalog ) ; boolean isCopiedFormDestinationSession ( ) ; }
void test3 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; ISession iSession0 = dBCopyPlugin0 . getSourceSession ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ISession getSourceSession ( ) ; void setSourceDatabaseObjects ( List < IDatabaseObjectInfo > dbObjList ) ; List < IDatabaseObjectInfo > getSourceDatabaseObjects ( ) ; IDatabaseObjectInfo getDestDatabaseObject ( ) ; void setDestDatabaseObject ( IDatabaseObjectInfo info ) ; void setDestSession ( ISession session ) ; ISession getDestSession ( ) ; void setPasteToTableName ( String pasteToTableName ) ; String getPasteToTableName ( ) ; TableInfo getPasteToTableInfo ( ISQLConnection destConn , String destSchema , String destCatalog ) ; boolean isCopiedFormDestinationSession ( ) ; }
void test4 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; dBCopyPlugin0 . setDestSession ( ( ISession ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean allowsSessionStartedInBackground ( ) ; / * * * Called when a session started . * * @param session The session that is starting . * * @return An implementation of PluginSessionCallback that requires the plugin to * adequately work with multible session windows . * Returning null tells the that the plugin is not applicable to this Session . * * @see ISessionPlugin . sessionStarted ( ISession ) * * / PluginSessionCallback sessionStarted ( ISession session ) ; / * * * Called when a session shutdown . * / void sessionEnding ( ISession session ) ; / * * * Create panels for the Session Properties dialog . * * @param session The session that will be displayed in the properties dialog . * * @return Array of < TT > ISessionPropertiesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the Session Properties Dialog . * / ISessionPropertiesPanel [ ] getSessionPropertiesPanels ( ISession session ) ; / * * * Create panels for the Main Tabbed Pane . * * @param session The current session . * * @return Array of < TT > IMainPanelTab < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the Main Tabbed Pane . * / / / IMainPanelTab [ ] getMainTabbedPanePanels ( ISession session ) ; / * * * Let app know what extra types of objects in object tree that * plugin can handle . * / IPluginDatabaseObjectType [ ] getObjectTypes ( ISession session ) ; / * * * Return a node expander for the object tree for a particular default node type . * < p > A plugin could return non null here if they wish to override the default node * expander bahaviour . Most plugins should return null here . * < p > * An example of this methods use is the oracle plugin . This plugin * utilises this behaviour so that the procedure * node does not list functions or procedures withint packages . This is different * to the default bahaviour * @return * / INodeExpander getDefaultNodeExpander ( ISession session , DatabaseObjectType type ) ; }
void test6 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; dBCopyPlugin0 . setDestDatabaseObject ( ( IDatabaseObjectInfo ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPluginJarFilePath ( ) throws IllegalStateException ; / * * * @param applicationFiles the applicationFiles to set * / void setApplicationFiles ( ApplicationFileWrappers applicationFiles ) ; / * * * @param fileWrapperFactory the fileWrapperFactory to set * / void setFileWrapperFactory ( FileWrapperFactory fileWrapperFactory ) ; }
void test7 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; String string0 = dBCopyPlugin0 . getDescriptiveName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDescriptiveName ( ) { return "Dummy Application Plugin" ; }
void test8 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; String string0 = dBCopyPlugin0 . getPasteToTableName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getPasteToTableName ( ) ; TableInfo getPasteToTableInfo ( ISQLConnection destConn , String destSchema , String destCatalog ) ; boolean isCopiedFormDestinationSession ( ) ; }
void test11 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; String string0 = dBCopyPlugin0 . getHelpFileName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getHelpFileName ( ) ; / * * * Returns the name of the change log for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the changelog file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getChangeLogFileName ( ) ; / * * * Returns the name of the licence file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the licence file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getLicenceFileName ( ) ; / * * * Create panels for the Global Preferences dialog . * * @return Array of < TT > IGlobalPreferencesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the Global Preferences Dialog . * / IGlobalPreferencesPanel [ ] getGlobalPreferencePanels ( ) ; / * * * Creates Alias Prefs Controllers for this Plugin . * / IAliasPropertiesPanelController [ ] getAliasPropertiesPanelControllers ( SQLAlias alias ) ; / * * * Called when an Alias is copied . Should be overridden by Plugins * that work with Alias properties . * / void aliasCopied ( SQLAlias source , SQLAlias target ) ; / * * * Called when an Alias is removed . Should be overridden by Plugins * that work with Alias properties . * / void aliasRemoved ( SQLAlias alias ) ; / * * * Create panels for the New Session Properties dialog . * * @return Array of < TT > INewSessionPropertiesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the New Session Properties Dialog . * / INewSessionPropertiesPanel [ ] getNewSessionPropertiesPanels ( ) ; / * * * Return the folder with the Squirrel application folder * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; squirrel_app & gt ; / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins application folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginAppSettingsFolder ( ) throws IOException , IllegalStateException ; / * * * Return the folder with the users home directory * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; user_home & gt ; / . squirrel - sql / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins user folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginUserSettingsFolder ( ) throws IllegalStateException , IOException ; / * * * Allows a plugin to provide services to other plugins . * @see PluginManager . bindExternalPluginService ( ) ; * / Object getExternalService ( ) ; / * * * Returns the absolute path to the plugin jar file . * * @return the absolute path to the plugin jar file . * * @throws IllegalStateException if this plugin doesn't have a valid internal name . * / String getPluginJarFilePath ( ) throws IllegalStateException ; / * * * @param applicationFiles the applicationFiles to set * / void setApplicationFiles ( ApplicationFileWrappers applicationFiles ) ; / * * * @param fileWrapperFactory the fileWrapperFactory to set * / void setFileWrapperFactory ( FileWrapperFactory fileWrapperFactory ) ; }
void test12 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; String string0 = dBCopyPlugin0 . getContributors ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getContributors ( ) ; / * * * Returns the home page for this plugin . * * @return the home page for this plugin . * / String getWebSite ( ) ; / * * * Returns the current version of this plugin . * * @return the current version of this plugin . * / String getVersion ( ) ; / * * * Returns the name of the Help file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the Help file name or < TT > null < / TT > if plugin doesn't have * a help file . * / String getHelpFileName ( ) ; / * * * Returns the name of the change log for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the changelog file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getChangeLogFileName ( ) ; / * * * Returns the name of the licence file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the licence file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getLicenceFileName ( ) ; / * * * Create panels for the Global Preferences dialog . * * @return Array of < TT > IGlobalPreferencesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the Global Preferences Dialog . * / IGlobalPreferencesPanel [ ] getGlobalPreferencePanels ( ) ; / * * * Creates Alias Prefs Controllers for this Plugin . * / IAliasPropertiesPanelController [ ] getAliasPropertiesPanelControllers ( SQLAlias alias ) ; / * * * Called when an Alias is copied . Should be overridden by Plugins * that work with Alias properties . * / void aliasCopied ( SQLAlias source , SQLAlias target ) ; / * * * Called when an Alias is removed . Should be overridden by Plugins * that work with Alias properties . * / void aliasRemoved ( SQLAlias alias ) ; / * * * Create panels for the New Session Properties dialog . * * @return Array of < TT > INewSessionPropertiesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the New Session Properties Dialog . * / INewSessionPropertiesPanel [ ] getNewSessionPropertiesPanels ( ) ; / * * * Return the folder with the Squirrel application folder * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; squirrel_app & gt ; / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins application folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginAppSettingsFolder ( ) throws IOException , IllegalStateException ; / * * * Return the folder with the users home directory * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; user_home & gt ; / . squirrel - sql / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins user folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginUserSettingsFolder ( ) throws IllegalStateException , IOException ; / * * * Allows a plugin to provide services to other plugins . * @see PluginManager . bindExternalPluginService ( ) ; * / Object getExternalService ( ) ; / * * * Returns the absolute path to the plugin jar file . * * @return the absolute path to the plugin jar file . * * @throws IllegalStateException if this plugin doesn't have a valid internal name . * / String getPluginJarFilePath ( ) throws IllegalStateException ; / * * * @param applicationFiles the applicationFiles to set * / void setApplicationFiles ( ApplicationFileWrappers applicationFiles ) ; / * * * @param fileWrapperFactory the fileWrapperFactory to set * / void setFileWrapperFactory ( FileWrapperFactory fileWrapperFactory ) ; }
void test13 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; String string0 = dBCopyPlugin0 . getLicenceFileName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLicenceFileName ( ) ; / * * * Create panels for the Global Preferences dialog . * * @return Array of < TT > IGlobalPreferencesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the Global Preferences Dialog . * / IGlobalPreferencesPanel [ ] getGlobalPreferencePanels ( ) ; / * * * Creates Alias Prefs Controllers for this Plugin . * / IAliasPropertiesPanelController [ ] getAliasPropertiesPanelControllers ( SQLAlias alias ) ; / * * * Called when an Alias is copied . Should be overridden by Plugins * that work with Alias properties . * / void aliasCopied ( SQLAlias source , SQLAlias target ) ; / * * * Called when an Alias is removed . Should be overridden by Plugins * that work with Alias properties . * / void aliasRemoved ( SQLAlias alias ) ; / * * * Create panels for the New Session Properties dialog . * * @return Array of < TT > INewSessionPropertiesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the New Session Properties Dialog . * / INewSessionPropertiesPanel [ ] getNewSessionPropertiesPanels ( ) ; / * * * Return the folder with the Squirrel application folder * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; squirrel_app & gt ; / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins application folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginAppSettingsFolder ( ) throws IOException , IllegalStateException ; / * * * Return the folder with the users home directory * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; user_home & gt ; / . squirrel - sql / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins user folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginUserSettingsFolder ( ) throws IllegalStateException , IOException ; / * * * Allows a plugin to provide services to other plugins . * @see PluginManager . bindExternalPluginService ( ) ; * / Object getExternalService ( ) ; / * * * Returns the absolute path to the plugin jar file . * * @return the absolute path to the plugin jar file . * * @throws IllegalStateException if this plugin doesn't have a valid internal name . * / String getPluginJarFilePath ( ) throws IllegalStateException ; / * * * @param applicationFiles the applicationFiles to set * / void setApplicationFiles ( ApplicationFileWrappers applicationFiles ) ; / * * * @param fileWrapperFactory the fileWrapperFactory to set * / void setFileWrapperFactory ( FileWrapperFactory fileWrapperFactory ) ; }
void test14 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; ISession iSession0 = dBCopyPlugin0 . getDestSession ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" ISession getDestSession ( ) ; void setPasteToTableName ( String pasteToTableName ) ; String getPasteToTableName ( ) ; TableInfo getPasteToTableInfo ( ISQLConnection destConn , String destSchema , String destCatalog ) ; boolean isCopiedFormDestinationSession ( ) ; }
void test15 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; String string0 = dBCopyPlugin0 . getVersion ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getVersion ( ) { return "0 . 1" ; }
void test16 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; IDatabaseObjectInfo iDatabaseObjectInfo0 = dBCopyPlugin0 . getDestDatabaseObject ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IDatabaseObjectInfo getDestDatabaseObject ( ) ; void setDestDatabaseObject ( IDatabaseObjectInfo info ) ; void setDestSession ( ISession session ) ; ISession getDestSession ( ) ; void setPasteToTableName ( String pasteToTableName ) ; String getPasteToTableName ( ) ; TableInfo getPasteToTableInfo ( ISQLConnection destConn , String destSchema , String destCatalog ) ; boolean isCopiedFormDestinationSession ( ) ; }
void test17 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; String string0 = dBCopyPlugin0 . getChangeLogFileName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getChangeLogFileName ( ) ; / * * * Returns the name of the licence file for the plugin . This should * be a text or HTML file residing in the < TT > getPluginAppSettingsFolder < / TT > * directory . * * @return the licence file name or < TT > null < / TT > if plugin doesn't have * a change log . * / String getLicenceFileName ( ) ; / * * * Create panels for the Global Preferences dialog . * * @return Array of < TT > IGlobalPreferencesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the Global Preferences Dialog . * / IGlobalPreferencesPanel [ ] getGlobalPreferencePanels ( ) ; / * * * Creates Alias Prefs Controllers for this Plugin . * / IAliasPropertiesPanelController [ ] getAliasPropertiesPanelControllers ( SQLAlias alias ) ; / * * * Called when an Alias is copied . Should be overridden by Plugins * that work with Alias properties . * / void aliasCopied ( SQLAlias source , SQLAlias target ) ; / * * * Called when an Alias is removed . Should be overridden by Plugins * that work with Alias properties . * / void aliasRemoved ( SQLAlias alias ) ; / * * * Create panels for the New Session Properties dialog . * * @return Array of < TT > INewSessionPropertiesPanel < / TT > objects . Return * empty array of < TT > null < / TT > if this plugin doesn't require * any panels in the New Session Properties Dialog . * / INewSessionPropertiesPanel [ ] getNewSessionPropertiesPanels ( ) ; / * * * Return the folder with the Squirrel application folder * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; squirrel_app & gt ; / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins application folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginAppSettingsFolder ( ) throws IOException , IllegalStateException ; / * * * Return the folder with the users home directory * that belongs to this plugin . If it doesn't exist then * create it . This would normally be * < PRE > * & lt ; user_home & gt ; / . squirrel - sql / plugins / & lt ; plugin_internal_name & gt ; * < / PRE > * * @return Plugins user folder . * * @throws IllegalStateException * if plugin doesn't have an internal name . * * @throws IOException * An error occured retrieving / creating the folder . * / FileWrapper getPluginUserSettingsFolder ( ) throws IllegalStateException , IOException ; / * * * Allows a plugin to provide services to other plugins . * @see PluginManager . bindExternalPluginService ( ) ; * / Object getExternalService ( ) ; / * * * Returns the absolute path to the plugin jar file . * * @return the absolute path to the plugin jar file . * * @throws IllegalStateException if this plugin doesn't have a valid internal name . * / String getPluginJarFilePath ( ) throws IllegalStateException ; / * * * @param applicationFiles the applicationFiles to set * / void setApplicationFiles ( ApplicationFileWrappers applicationFiles ) ; / * * * @param fileWrapperFactory the fileWrapperFactory to set * / void setFileWrapperFactory ( FileWrapperFactory fileWrapperFactory ) ; }
void test19 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; String string0 = dBCopyPlugin0 . getAuthor ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAuthor ( ) { return "Colin Bell" ; }
void test20 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; dBCopyPlugin0 . setSourceDatabaseObjects ( ( List < IDatabaseObjectInfo > ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getAuthor ( ) { return "Colin Bell" ; }
void test22 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; dBCopyPlugin0 . setSourceSession ( ( ISession ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDescriptiveName ( ) { return "Dummy Application Plugin" ; }
void test23 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; TableInfo tableInfo0 = dBCopyPlugin0 . getPasteToTableInfo ( ( ISQLConnection ) null , ( String ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TableInfo getPasteToTableInfo ( ISQLConnection destConn , String destSchema , String destCatalog ) ; boolean isCopiedFormDestinationSession ( ) ; }
void test0 ( ) throws Throwable { ColTypeMapper colTypeMapper0 = new ColTypeMapper ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "JDesktopPa9e . drpgMo ; e" , "JDesktopPa9e . drpgMo ; e" , "JDesktopPa9e . drpgMo ; e" , "JDesktopPa9e . drpgMo ; e" , 93 , "JDesktopPa9e . drpgMo ; e" , 93 , 93 , 93 , 93 , "JDesktopPa9e . drpgMo ; e" , "JDesktopPa9e . drpgMo ; e" , 93 , 93 , "JDesktopPa9e . drpgMo ; e" ) ; int int0 = ColTypeMapper . getColumnLength ( ( ISession ) null , tableColumnInfo0 , "JDesktopPa9e . drpgMo ; e" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test2 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " * Yl - pQ & ? yjB" , " * Yl - pQ & ? yjB" , " * Yl - pQ & ? yjB" , " * Yl - pQ & ? yjB" , 91 , " * Yl - pQ & ? yjB" , 91 , 91 , 91 , 91 , " * Yl - pQ & ? yjB" , " * Yl - pQ & ? yjB" , 91 , 91 , " * Yl - pQ & ? yjB" ) ; int int0 = ColTypeMapper . getColumnLength ( ( ISession ) null , tableColumnInfo0 , " * Yl - pQ & ? yjB" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test3 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " . 2 > " , " . 2 > " , " . 2 > " , " . 2 > " , 92 , " . 2 > " , 92 , 92 , 92 , 92 , " . 2 > " , " . 2 > " , 92 , 92 , " . 2 > " ) ; int int0 = ColTypeMapper . getColumnLength ( ( ISession ) null , tableColumnInfo0 , " . 2 > " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getColumnLength ( int columnSize , int dataType ) { return columnSize ; }
void test0 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 4 ] ; String string0 = I18NBaseObject . getMessage ( "" , objectArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMessage ( String key ) { return s_stringMgr . getString ( key ) ; }
void test2 ( ) throws Throwable { String string0 = I18NBaseObject . getMessage ( "y : BFu2B : x" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMessage ( String key ) { return s_stringMgr . getString ( key ) ; }
void test3 ( ) throws Throwable { Object [ ] objectArray0 = new Object [ 4 ] ; String string0 = I18NBaseObject . getMessage ( "" , objectArray0 [ 1 ] ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getMessage ( String key ) { return s_stringMgr . getString ( key ) ; }
void test2 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; CopyExecutor copyExecutor0 = new CopyExecutor ( ( SessionInfoProvider ) dBCopyPlugin0 ) ; UICallbacks uICallbacks0 = copyExecutor0 . getPref ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" UICallbacks getPref ( ) { return pref ; }
void test3 ( ) throws Throwable { PreferencesManager preferencesManager0 = new PreferencesManager ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test4 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = PreferencesManager . getPreferences ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCopyData ( ) { return copyData ; }
void test0 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isTestColumnNames ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDelayBetweenObjects ( ) { return delayBetweenObjects ; }
void test1 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; int int0 = dBCopyPreferenceBean0 . getCommitCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDelayBetweenObjects ( ) { return delayBetweenObjects ; }
void test2 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isUseTruncate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCommitAfterTableDefs ( ) { return commitAfterTableDefs ; }
void test3 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; int int0 = dBCopyPreferenceBean0 . getSelectFetchSize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCommitAfterTableDefs ( ) { return commitAfterTableDefs ; }
void test4 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isCopyPrimaryKeys ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCommitAfterTableDefs ( ) { return commitAfterTableDefs ; }
void test5 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setAutoCommitEnabled ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCommitAfterTableDefs ( ) { return commitAfterTableDefs ; }
void test6 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isWriteScript ( ) { return writeScript ; }
void test7 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isAutoCommitEnabled ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPromptForDialect ( ) { return promptForDialect ; }
void test8 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isWriteScript ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFileCacheBufferSize ( ) { return fileCacheBufferSize ; }
void test9 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectFetchSize ( ) { return selectFetchSize ; }
void test10 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . getRecordDelayMillis ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isWriteScript ( ) { return writeScript ; }
void test11 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; String string0 = dBCopyPreferenceBean0 . getClientVersion ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCopyPrimaryKeys ( ) { return copyPrimaryKeys ; }
void test12 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setPromptForDialect ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneDuplicateIndexDefs ( ) { return pruneDuplicateIndexDefs ; }
void test13 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setClientVersion ( " - 7Ne } ] HX70S" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getClientVersion ( ) ; / * * * Set the client version . * * @param value * Client version * / void setClientVersion ( String value ) ; }
void test14 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectFetchSize ( ) { return selectFetchSize ; }
void test15 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setRecordDelayMillis ( ( long ) 100 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPromptForDialect ( ) { return promptForDialect ; }
void test16 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setWriteScript ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCopyIndexDefs ( ) { return copyIndexDefs ; }
void test17 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCheckKeywords ( ) { return checkKeywords ; }
void test18 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . isAppendRecordsToExisting ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCopyForeignKeys ( ) { return copyForeignKeys ; }
void test19 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isDelayBetweenObjects ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCheckKeywords ( ) { return checkKeywords ; }
void test20 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setCopyPrimaryKeys ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDelayBetweenObjects ( ) { return delayBetweenObjects ; }
void test21 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; String string0 = dBCopyPreferenceBean0 . getClientName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCommitCount ( ) { return commitCount ; }
void test22 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCommitCount ( ) { return commitCount ; }
void test23 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isCopyForeignKeys ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCopyIndexDefs ( ) { return copyIndexDefs ; }
void test24 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isPruneDuplicateIndexDefs ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPromptForDialect ( ) { return promptForDialect ; }
void test25 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . getTableDelayMillis ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDelayBetweenObjects ( ) { return delayBetweenObjects ; }
void test26 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDelayBetweenObjects ( ) { return delayBetweenObjects ; }
void test27 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setAppendRecordsToExisting ( false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAppendRecordsToExisting ( ) { return _appendRecordsToExisting ; }
void test28 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isUseFileCaching ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUseTruncate ( ) { return useTruncate ; }
void test29 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isPromptForDialect ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectFetchSize ( ) { return selectFetchSize ; }
void test30 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isCommitAfterTableDefs ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCopyPrimaryKeys ( ) { return copyPrimaryKeys ; }
void test31 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUseFileCaching ( ) { return useFileCaching ; }
void test32 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setTableDelayMillis ( ( long ) ( - 1 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPromptForDialect ( ) { return promptForDialect ; }
void test33 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setCommitAfterTableDefs ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCopyData ( ) { return copyData ; }
void test34 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isCopyData ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isAutoCommitEnabled ( ) { return autoCommitEnabled ; }
void test35 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setCopyIndexDefs ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isWriteScript ( ) { return writeScript ; }
void test36 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCopyIndexDefs ( ) { return copyIndexDefs ; }
void test37 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isCheckKeywords ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isWriteScript ( ) { return writeScript ; }
void test38 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setUseTruncate ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCopyForeignKeys ( ) { return copyForeignKeys ; }
void test39 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; DBCopyPreferenceBean dBCopyPreferenceBean1 = ( DBCopyPreferenceBean ) dBCopyPreferenceBean0 . clone ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isUseFileCaching ( ) { return useFileCaching ; }
void test40 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getFileCacheBufferSize ( ) { return fileCacheBufferSize ; }
void test41 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; boolean boolean0 = dBCopyPreferenceBean0 . isCopyIndexDefs ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getCommitCount ( ) { return commitCount ; }
void test42 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; int int0 = dBCopyPreferenceBean0 . getFileCacheBufferSize ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCommitAfterTableDefs ( ) { return commitAfterTableDefs ; }
void test43 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setPruneDuplicateIndexDefs ( true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPruneDuplicateIndexDefs ( ) { return pruneDuplicateIndexDefs ; }
void test44 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setClientName ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectFetchSize ( ) { return selectFetchSize ; }
void test0 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; ErrorEvent errorEvent0 = new ErrorEvent ( ( SessionInfoProvider ) dBCopyPlugin0 , ( - 2046 ) ) ; errorEvent0 . setType ( ( - 2046 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test1 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; ErrorEvent errorEvent0 = new ErrorEvent ( ( SessionInfoProvider ) dBCopyPlugin0 , ( - 2046 ) ) ; int int0 = errorEvent0 . getType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test2 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; ErrorEvent errorEvent0 = new ErrorEvent ( ( SessionInfoProvider ) dBCopyPlugin0 , ( - 2046 ) ) ; errorEvent0 . setException ( ( Exception ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" IPluginDatabaseObjectType getType ( ) ; / / ? ? Need to tell object to display itself in a panel . }
void test0 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; TableEvent tableEvent0 = new TableEvent ( ( SessionInfoProvider ) dBCopyPlugin0 ) ; String string0 = tableEvent0 . getTableName ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TableInfo getTableName ( String tableNameFromSQL ) { ITableInfo [ ] tables = _session . getSchemaInfo ( ) . getITableInfos ( ) ; / / filter the list of all DB objects looking for things with the given name for ( int i = 0 ; i < tables . length ; + + i ) { String simpleName = tables [ i ] . getSimpleName ( ) . toUpperCase ( ) ; String nameWithSchema = simpleName ; String nameWithSchemaAndCatalog = simpleName ; if ( null ! = tables [ i ] . getSchemaName ( ) & & 0 < tables [ i ] . getSchemaName ( ) . length ( ) ) { nameWithSchema = tables [ i ] . getSchemaName ( ) . toUpperCase ( ) + " . " + nameWithSchema ; nameWithSchemaAndCatalog = nameWithSchema ; } if ( null ! = tables [ i ] . getCatalogName ( ) & & 0 < tables [ i ] . getCatalogName ( ) . length ( ) ) { nameWithSchemaAndCatalog = tables [ i ] . getCatalogName ( ) . toUpperCase ( ) + " . " + nameWithSchema ; } if ( simpleName . equals ( tableNameFromSQL ) | | nameWithSchema . equals ( tableNameFromSQL ) | | nameWithSchemaAndCatalog . equals ( tableNameFromSQL ) ) { return ( TableInfo ) tables [ i ] ; } } / / ok , that didn't work - let's see if the table looks fully qualified . / / if so , we'll split the name from the schema / catalog and try that . String [ ] parts = tableNameFromSQL . split ( "\\ . " ) ; if ( parts . length = = 2 ) { String catalog = parts [ 0 ] ; String simpleName = parts [ 1 ] ; tables = _session . getSchemaInfo ( ) . getITableInfos ( catalog , null , simpleName ) ; if ( tables ! = null & & tables . length > 0 ) { return ( TableInfo ) tables [ 0 ] ; } / / Ok , maybe catalog was really a schema instead . tables = _session . getSchemaInfo ( ) . getITableInfos ( null , catalog , simpleName ) ; if ( tables ! = null & & tables . length > 0 ) { return ( TableInfo ) tables [ 0 ] ; } } return null ; }
void test1 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; TableEvent tableEvent0 = new TableEvent ( ( SessionInfoProvider ) dBCopyPlugin0 ) ; int int0 = tableEvent0 . getTableNumber ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTableNumber ( ) { return tableNumber ; }
void test2 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; TableEvent tableEvent0 = new TableEvent ( ( SessionInfoProvider ) dBCopyPlugin0 ) ; tableEvent0 . setTableNumber ( ( - 182 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTableNumber ( ) { return tableNumber ; }
void test3 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; TableEvent tableEvent0 = new TableEvent ( ( SessionInfoProvider ) dBCopyPlugin0 ) ; tableEvent0 . setTableCount ( ( - 786 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTableCount ( ) { return tableCount ; }
void test4 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; TableEvent tableEvent0 = new TableEvent ( ( SessionInfoProvider ) dBCopyPlugin0 ) ; tableEvent0 . setTableName ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTableCount ( ) { return tableCount ; }
void test5 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; TableEvent tableEvent0 = new TableEvent ( ( SessionInfoProvider ) dBCopyPlugin0 ) ; int int0 = tableEvent0 . getTableCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getTableCount ( ) { return tableCount ; }
void test0 ( ) throws Throwable { CopyEvent copyEvent0 = new CopyEvent ( ( SessionInfoProvider ) null ) ; SessionInfoProvider sessionInfoProvider0 = copyEvent0 . getSessionInfoProvider ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" SessionInfoProvider getSessionInfoProvider ( ) { return prov ; }
void test0 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; RecordEvent recordEvent0 = new RecordEvent ( ( SessionInfoProvider ) dBCopyPlugin0 , 181 , 0 ) ; int int0 = recordEvent0 . getRecordCount ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { RecordEvent recordEvent0 = new RecordEvent ( ( SessionInfoProvider ) null , ( - 1 ) , 93 ) ; String string0 = recordEvent0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test2 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; RecordEvent recordEvent0 = new RecordEvent ( ( SessionInfoProvider ) dBCopyPlugin0 , 0 , 1895 ) ; recordEvent0 . setRecordNumber ( 366 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test3 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; RecordEvent recordEvent0 = new RecordEvent ( ( SessionInfoProvider ) dBCopyPlugin0 , 181 , 0 ) ; int int0 = recordEvent0 . getRecordNumber ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getRecordCount ( ) { return recordCount ; }
void test4 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; RecordEvent recordEvent0 = new RecordEvent ( ( SessionInfoProvider ) dBCopyPlugin0 , 181 , 0 ) ; recordEvent0 . setRecordCount ( 1630 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test1 ( ) throws Throwable { CopyEvent copyEvent0 = new CopyEvent ( ( SessionInfoProvider ) null ) ; int [ ] intArray0 = copyEvent0 . getTableCounts ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int [ ] getTableCounts ( ) { int [ ] result = null ; ISession sourceSession = prov . getSourceSession ( ) ; List < IDatabaseObjectInfo > dbObjs = prov . getSourceDatabaseObjects ( ) ; if ( dbObjs ! = null ) { result = new int [ dbObjs . size ( ) ] ; selectedTableInfos = new ArrayList < ITableInfo > ( ) ; int sourceObjectCount = 0 ; for ( IDatabaseObjectInfo info : dbObjs ) { if ( ! ( info instanceof ITableInfo ) ) { continue ; } try { ITableInfo ti = ( ITableInfo ) info ; selectedTableInfos . add ( ti ) ; / / This doesn't appear to work for PROGRESS RDBMS / / result [ i ] = DBUtil . getTableCount ( con , ti . getSimpleName ( ) ) ; result [ sourceObjectCount ] = DBUtil . getTableCount ( sourceSession , ti . getCatalogName ( ) , ti . getSchemaName ( ) , ti . getSimpleName ( ) , DialectFactory . SOURCE_TYPE ) ; } catch ( Exception e ) { log . error ( "" , e ) ; result [ sourceObjectCount ] = 0 ; } sourceObjectCount + + ; } } return result ; }
void test0 ( ) throws Throwable { StatementEvent statementEvent0 = new StatementEvent ( "" , 423 ) ; statementEvent0 . setStatementType ( ( - 1979 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStatementType ( ) { return statementType ; }
void test1 ( ) throws Throwable { StatementEvent statementEvent0 = new StatementEvent ( "" , 423 ) ; statementEvent0 . getBindValues ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStatementType ( ) { return statementType ; }
void test2 ( ) throws Throwable { StatementEvent statementEvent0 = new StatementEvent ( "" , 423 ) ; int int0 = statementEvent0 . getStatementType ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStatementType ( ) { return statementType ; }
void test3 ( ) throws Throwable { StatementEvent statementEvent0 = new StatementEvent ( "" , 423 ) ; String string0 = statementEvent0 . getStatement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStatementType ( ) { return statementType ; }
void test4 ( ) throws Throwable { StatementEvent statementEvent0 = new StatementEvent ( "" , 1997 ) ; statementEvent0 . setStatement ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStatementType ( ) { return statementType ; }
void test5 ( ) throws Throwable { StatementEvent statementEvent0 = new StatementEvent ( " + i# ; " , 1 ) ; String string0 = statementEvent0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getStatementType ( ) { return statementType ; }
void test6 ( ) throws Throwable { StatementEvent statementEvent0 = new StatementEvent ( "" , 423 ) ; String [ ] stringArray0 = new String [ 7 ] ; stringArray0 [ 0 ] = " > aL > | @O | 7CI + _W } lf & " ; stringArray0 [ 1 ] = "" ; stringArray0 [ 2 ] = " > aL > | @O | 7CI + _W } lf & " ; stringArray0 [ 3 ] = "e3no6%1m" ; stringArray0 [ 4 ] = "" ; stringArray0 [ 5 ] = "" ; stringArray0 [ 6 ] = " > aL > | @O | 7CI + _W } lf & " ; statementEvent0 . setBindValues ( stringArray0 ) ; String string0 = statementEvent0 . toString ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String toString ( ) { return _displayName ; }
void test0 ( ) throws Throwable { Future < ? > future = executor . submit ( new Runnable ( ) { void run ( ) { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; PreferencesPanel preferencesPanel0 = new PreferencesPanel ( dBCopyPreferenceBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Action get ( Class < ? extends Action > actionClass ) { if ( actionClass = = null ) { throw new IllegalArgumentException ( "null Action Class passed . " ) ; } return get ( actionClass . getName ( ) ) ; }
void test1 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; PreferencesPanel preferencesPanel0 = new PreferencesPanel ( dBCopyPreferenceBean0 ) ; PreferencesPanel preferencesPanel1 = ( PreferencesPanel ) preferencesPanel0 . getPanelComponent ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isValid ( ) { return _name ! = null & & _name . length ( ) > 0 & & _driverId ! = null & & _url ! = null & & _url . length ( ) > 0 ; }
void test2 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setUseFileCaching ( false ) ; PreferencesPanel preferencesPanel0 = new PreferencesPanel ( dBCopyPreferenceBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PreferencesPanel ( DBCopyPreferenceBean prefs ) { super ( ) ; _prefs = prefs ; createGUI ( ) ; loadData ( ) ; }
void test3 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; dBCopyPreferenceBean0 . setAutoCommitEnabled ( false ) ; PreferencesPanel preferencesPanel0 = new PreferencesPanel ( dBCopyPreferenceBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" PreferencesPanel ( DBCopyPreferenceBean prefs ) { super ( ) ; _prefs = prefs ; createGUI ( ) ; loadData ( ) ; }
void test1 ( ) throws Throwable { DualProgressBarDialog dualProgressBarDialog0 = new DualProgressBarDialog ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test2 ( ) throws Throwable { JPanel jPanel0 = DualProgressBarDialog . buildTimePanel ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JPanel buildTimePanel ( ) { JPanel result = new JPanel ( ) ; result . setLayout ( new GridLayout ( 2 , 2 , 5 , 5 ) ) ; JLabel elapsedTimeLabel = new JLabel ( s_stringMgr . getString ( "DualProgressBarDialog . elapsedTimeLabel" ) ) ; elapsedTimeCounter = new TimeCounter ( ) ; elapsedTime = new JLabel ( elapsedTimeCounter . toString ( ) ) ; JLabel remainingTimeLabel = new JLabel ( s_stringMgr . getString ( "DualProgressBarDialog . remainingTimeLabel" ) ) ; remainingTimeCounter = new TimeCounter ( ) ; remainingTime = new JLabel ( remainingTimeCounter . toString ( ) ) ; elapsedTimeLabel . setHorizontalAlignment ( SwingConstants . RIGHT ) ; result . add ( elapsedTimeLabel ) ; elapsedTime . setHorizontalAlignment ( SwingConstants . LEFT ) ; result . add ( elapsedTime ) ; remainingTimeLabel . setHorizontalAlignment ( SwingConstants . RIGHT ) ; result . add ( remainingTimeLabel ) ; remainingTime . setHorizontalAlignment ( SwingConstants . LEFT ) ; result . add ( remainingTime ) ; return result ; }
void test6 ( ) throws Throwable { DefaultEditorKit . InsertTabAction defaultEditorKit_InsertTabAction0 = new DefaultEditorKit . InsertTabAction ( ) ; JDialog jDialog0 = DualProgressBarDialog . getDialog ( ( Frame ) null , "h < y" , true , ( ActionListener ) defaultEditorKit_InsertTabAction0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" TableExportCsvDlg getDialog ( ) { return this . _dlg ; }
void test11 ( ) throws Throwable { JPanel jPanel0 = DualProgressBarDialog . buildButtonPanel ( ( ActionListener ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JPanel buildButtonPanel ( ActionListener listener ) { JPanel buttonPanel = new JPanel ( new FlowLayout ( ) ) ; / / i18n [ DualProgressBarDialog . cancelButtonLabel = Cancel ] String buttonText = s_stringMgr . getString ( "DualProgressBarDialog . cancelButtonLabel" ) ; cancelButton = new JButton ( buttonText ) ; if ( listener ! = null ) { cancelButton . addActionListener ( listener ) ; } buttonPanel . add ( cancelButton ) ; return buttonPanel ; }
void test12 ( ) throws Throwable { Action action0 = TransferHandler . getCutAction ( ) ; JPanel jPanel0 = DualProgressBarDialog . buildButtonPanel ( ( ActionListener ) action0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JPanel buildButtonPanel ( ActionListener listener ) { JPanel buttonPanel = new JPanel ( new FlowLayout ( ) ) ; / / i18n [ DualProgressBarDialog . cancelButtonLabel = Cancel ] String buttonText = s_stringMgr . getString ( "DualProgressBarDialog . cancelButtonLabel" ) ; cancelButton = new JButton ( buttonText ) ; if ( listener ! = null ) { cancelButton . addActionListener ( listener ) ; } buttonPanel . add ( cancelButton ) ; return buttonPanel ; }
void test0 ( ) throws Throwable { PasteTableUtil pasteTableUtil0 = new PasteTableUtil ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test0 ( ) throws Throwable { ScriptWriter scriptWriter0 = new ScriptWriter ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { String [ ] stringArray0 = new String [ 2 ] ; stringArray0 [ 0 ] = "t , Hh ? d ? O - > | 7 , 0" ; String string0 = ScriptWriter . getBoundStatement ( "t , Hh ? d ? O - > | 7 , 0" , stringArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getBoundStatement ( String pstmt , String [ ] bindVars ) { String [ ] parts = pstmt . split ( "\\ ? " ) ; StringBuffer result = new StringBuffer ( parts [ 0 ] ) ; for ( int i = 0 ; i < bindVars . length ; i + + ) { String nextVal = bindVars [ i ] ; try { if ( nextVal ! = null ) { Double . parseDouble ( nextVal ) ; } else { nextVal = "null" ; } } catch ( NumberFormatException e ) { nextVal = "'" + nextVal + "'" ; } / / replace the next question mark with nextVal result . append ( nextVal ) ; result . append ( parts [ i + 1 ] ) ; } return result . toString ( ) ; }
void test2 ( ) throws Throwable { String string0 = DBUtil . getLastStatementValues ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLastStatementValues ( ) { return lastStatementValues ; }
void test4 ( ) throws Throwable { DBCopyPreferenceBean dBCopyPreferenceBean0 = new DBCopyPreferenceBean ( ) ; DBUtil . setPreferences ( dBCopyPreferenceBean0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int getSelectFetchSize ( ) { return selectFetchSize ; }
void test9 ( ) throws Throwable { DBUtil dBUtil0 = new DBUtil ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLastStatementValues ( ) { return lastStatementValues ; }
void test12 ( ) throws Throwable { String string0 = DBUtil . getLastStatement ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getLastStatement ( ) { return lastStatement ; }
void test14 ( ) throws Throwable { boolean boolean0 = DBUtil . typesAreEquivalent ( 574 , 132 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean typesAreEquivalent ( int sourceType , int destType ) { boolean result = false ; if ( sourceType = = destType ) { result = true ; } if ( sourceType = = Types . DECIMAL & & destType = = Types . NUMERIC ) { result = true ; } if ( sourceType = = Types . NUMERIC & & destType = = Types . DECIMAL ) { result = true ; } if ( sourceType = = Types . BOOLEAN & & destType = = Types . BIT ) { result = true ; } if ( sourceType = = Types . BIT & & destType = = Types . BOOLEAN ) { result = true ; } return result ; }
void test15 ( ) throws Throwable { boolean boolean0 = DBUtil . typesAreEquivalent ( 3 , 3 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean typesAreEquivalent ( int sourceType , int destType ) { boolean result = false ; if ( sourceType = = destType ) { result = true ; } if ( sourceType = = Types . DECIMAL & & destType = = Types . NUMERIC ) { result = true ; } if ( sourceType = = Types . NUMERIC & & destType = = Types . DECIMAL ) { result = true ; } if ( sourceType = = Types . BOOLEAN & & destType = = Types . BIT ) { result = true ; } if ( sourceType = = Types . BIT & & destType = = Types . BOOLEAN ) { result = true ; } return result ; }
void test16 ( ) throws Throwable { boolean boolean0 = DBUtil . typesAreEquivalent ( 2 , 2 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean typesAreEquivalent ( int sourceType , int destType ) { boolean result = false ; if ( sourceType = = destType ) { result = true ; } if ( sourceType = = Types . DECIMAL & & destType = = Types . NUMERIC ) { result = true ; } if ( sourceType = = Types . NUMERIC & & destType = = Types . DECIMAL ) { result = true ; } if ( sourceType = = Types . BOOLEAN & & destType = = Types . BIT ) { result = true ; } if ( sourceType = = Types . BIT & & destType = = Types . BOOLEAN ) { result = true ; } return result ; }
void test17 ( ) throws Throwable { boolean boolean0 = DBUtil . typesAreEquivalent ( 16 , 16 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean typesAreEquivalent ( int sourceType , int destType ) { boolean result = false ; if ( sourceType = = destType ) { result = true ; } if ( sourceType = = Types . DECIMAL & & destType = = Types . NUMERIC ) { result = true ; } if ( sourceType = = Types . NUMERIC & & destType = = Types . DECIMAL ) { result = true ; } if ( sourceType = = Types . BOOLEAN & & destType = = Types . BIT ) { result = true ; } if ( sourceType = = Types . BIT & & destType = = Types . BOOLEAN ) { result = true ; } return result ; }
void test18 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( ( String ) null , ( String ) null , ( String ) null , ( String ) null , 10 , ( String ) null , 10 , 10 , 10 , 10 , ( String ) null , ( String ) null , 10 , 10 , ( String ) null ) ; int int0 = DBUtil . replaceOtherDataType ( tableColumnInfo0 , ( ISession ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int replaceOtherDataType ( TableColumnInfo colInfo , ISession session ) throws MappingException { int colJdbcType = colInfo . getDataType ( ) ; if ( colJdbcType = = java . sql . Types . OTHER ) { try { HibernateDialect dialect = DialectFactory . getDialect ( session . getMetaData ( ) ) ; String typeName = colInfo . getTypeName ( ) . toUpperCase ( ) ; int parenIndex = typeName . indexOf ( " ( " ) ; if ( parenIndex ! = - 1 ) { typeName = typeName . substring ( 0 , parenIndex ) ; } colJdbcType = dialect . getJavaTypeForNativeType ( colInfo . getTypeName ( ) ) ; } catch ( Exception e ) { log . error ( "replaceOtherDataType : unexpected exception - " + e . getMessage ( ) ) ; } } return colJdbcType ; }
void test19 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( ( String ) null , ( String ) null , ( String ) null , ( String ) null , 686 , ( String ) null , 686 , 1 , 686 , 686 , ( String ) null , ( String ) null , 686 , 1 , ( String ) null ) ; int int0 = DBUtil . replaceDistinctDataType ( 686 , tableColumnInfo0 , ( ISession ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int replaceDistinctDataType ( int colJdbcType , TableColumnInfo colInfo , ISession session ) { if ( colJdbcType = = java . sql . Types . DISTINCT & & DialectFactory . isPostgreSQL ( session . getMetaData ( ) ) ) { Connection con = session . getSQLConnection ( ) . getConnection ( ) ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { String sql = "SELECT data_type " + "FROM information_schema . columns " + "where column_name = ? " ; if ( colInfo . getSchemaName ( ) ! = null ) { sql + = " and table_schema = ? " ; } pstmt = con . prepareStatement ( sql ) ; pstmt . setString ( 1 , colInfo . getColumnName ( ) ) ; if ( colInfo . getSchemaName ( ) ! = null ) { pstmt . setString ( 2 , colInfo . getSchemaName ( ) ) ; } rs = pstmt . executeQuery ( ) ; if ( rs . next ( ) ) { String nativeTypeName = rs . getString ( 1 ) ; colJdbcType = JDBCTypeMapper . getJdbcType ( nativeTypeName . toUpperCase ( ) , colJdbcType ) ; } } catch ( SQLException e ) { log . error ( "replaceDistinctDataType : Unexpected exception - " + e , e ) ; } finally { SQLUtilities . closeStatement ( pstmt ) ; } } return colJdbcType ; }
void test28 ( ) throws Throwable { int int0 = DBUtil . getColumnType ( ( ISQLConnection ) null , ( ITableInfo ) null , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnType ( ) { return _columnType ; }
void test29 ( ) throws Throwable { TableColumnInfo [ ] tableColumnInfoArray0 = new TableColumnInfo [ 1 ] ; TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( "FX + " , "FX + " , "FX + " , "FX + " , ( - 1 ) , "FX + " , 2 , 2 , ( - 1911 ) , 2 , "FX + " , "FX + " , 0 , ( - 1911 ) , "FX + " ) ; tableColumnInfoArray0 [ 0 ] = tableColumnInfo0 ; String string0 = DBUtil . getColumnList ( tableColumnInfoArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getColumnList ( TableColumnInfo [ ] colInfos , DatabaseObjectQualifier qualifier , SqlGenerationPreferences prefs , HibernateDialect dialect ) { StringBuilder result = new StringBuilder ( ) ; result . append ( " ( " ) ; for ( int i = 0 ; i < colInfos . length ; i + + ) { String shapedColumnName = colInfos [ i ] . getColumnName ( ) ; if ( prefs . isQuoteColumnNames ( ) ) { shapedColumnName = shapeIdentifier ( colInfos [ i ] . getColumnName ( ) , prefs , dialect ) ; } result . append ( shapedColumnName ) ; if ( i + 1 < colInfos . length ) { result . append ( " , " ) ; } } result . append ( " ) " ) ; return result . toString ( ) ; }
void test31 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " - 04 - " , " - 04 - " , " > " , " - 04 - " , 0 , " - 04 - " , 11 , 1511 , 1511 , 0 , " - 04 - " , " > " , 1 , 0 , " > " ) ; boolean boolean0 = DBUtil . isBinaryType ( tableColumnInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isBinaryType ( TableColumnInfo columnInfo ) { boolean result = false ; int type = columnInfo . getDataType ( ) ; if ( type = = Types . BINARY | | type = = Types . BLOB | | type = = Types . LONGVARBINARY | | type = = Types . VARBINARY ) { result = true ; } return result ; }
void test32 ( ) throws Throwable { TableColumnInfo tableColumnInfo0 = new TableColumnInfo ( " | 3R~J" , " | 3R~J" , " | 3R~J" , " | 3R~J" , ( - 4 ) , " | 3R~J" , ( - 4 ) , 1 , ( - 4 ) , ( - 4 ) , " | 3R~J" , " | 3R~J" , ( - 4 ) , ( - 4 ) , " | 3R~J" ) ; boolean boolean0 = DBUtil . isBinaryType ( tableColumnInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isBinaryType ( TableColumnInfo columnInfo ) { boolean result = false ; int type = columnInfo . getDataType ( ) ; if ( type = = Types . BINARY | | type = = Types . BLOB | | type = = Types . LONGVARBINARY | | type = = Types . VARBINARY ) { result = true ; } return result ; }
void test34 ( ) throws Throwable { String string0 = DBUtil . fixCase ( ( ISession ) null , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String fixCase ( ISession session , String identifier ) { if ( identifier = = null | | identifier . equals ( "" ) ) { return identifier ; } try { DatabaseMetaData md = session . getSQLConnection ( ) . getConnection ( ) . getMetaData ( ) ; / / Don't change the case of the identifier if database allows mixed / / case . if ( md . storesMixedCaseIdentifiers ( ) ) { return identifier ; } / / Fix the case according to what the database tells us . if ( md . storesUpperCaseIdentifiers ( ) ) { return identifier . toUpperCase ( ) ; } else { return identifier . toLowerCase ( ) ; } } catch ( SQLException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "fixCase : unexpected exception : " + e . getMessage ( ) ) ; } return identifier ; } }
void test35 ( ) throws Throwable { String string0 = DBUtil . fixCase ( ( ISession ) null , "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String fixCase ( ISession session , String identifier ) { if ( identifier = = null | | identifier . equals ( "" ) ) { return identifier ; } try { DatabaseMetaData md = session . getSQLConnection ( ) . getConnection ( ) . getMetaData ( ) ; / / Don't change the case of the identifier if database allows mixed / / case . if ( md . storesMixedCaseIdentifiers ( ) ) { return identifier ; } / / Fix the case according to what the database tells us . if ( md . storesUpperCaseIdentifiers ( ) ) { return identifier . toUpperCase ( ) ; } else { return identifier . toLowerCase ( ) ; } } catch ( SQLException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "fixCase : unexpected exception : " + e . getMessage ( ) ) ; } return identifier ; } }
void test36 ( ) throws Throwable { DBCopyPlugin dBCopyPlugin0 = new DBCopyPlugin ( ) ; DBUtil . validateColumnNames ( ( ITableInfo ) null , ( SessionInfoProvider ) dBCopyPlugin0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getDescriptiveName ( ) { return "Dummy Application Plugin" ; }
void test37 ( ) throws Throwable { IDatabaseObjectInfo [ ] iDatabaseObjectInfoArray0 = new IDatabaseObjectInfo [ 10 ] ; List < ITableInfo > list0 = DBUtil . convertObjectArrayToTableList ( iDatabaseObjectInfoArray0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int size ( ) { return _ix . size ( ) ; }
void test38 ( ) throws Throwable { LinkedList < ITableInfo > linkedList0 = new LinkedList < ITableInfo > ( ) ; linkedList0 . add ( ( ITableInfo ) null ) ; List < IDatabaseObjectInfo > list0 = DBUtil . convertTableToObjectList ( ( List < ITableInfo > ) linkedList0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isEmpty ( ) { return null = = _dataScaleTable & & null = = _simpleTable ; }
void test39 ( ) throws Throwable { DatabaseObjectInfo databaseObjectInfo0 = new DatabaseObjectInfo ( ( String ) null , ( String ) null , ( String ) null ) ; String string0 = DBUtil . getSchemaNameFromDbObject ( ( IDatabaseObjectInfo ) databaseObjectInfo0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String getSchemaNameFromDbObject ( IDatabaseObjectInfo dbObject ) { String destSchema ; if ( dbObject . getDatabaseObjectType ( ) . equals ( DatabaseObjectType . SCHEMA ) ) { destSchema = dbObject . getSimpleName ( ) ; } else { destSchema = dbObject . getSchemaName ( ) ; } return destSchema ; }
