void test0 ( ) throws Throwable { JSAllReduction jSAllReduction0 = new JSAllReduction ( ) ; boolean boolean0 = jSAllReduction0 . isDummy ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDummy ( ) { JSMethod met = this . selectedMethod ( ) ; return ! met . notDummy ( ) ; }
void test1 ( ) throws Throwable { JSAllReduction jSAllReduction0 = new JSAllReduction ( ) ; Vector < Object > vector0 = jSAllReduction0 . reductions ( ) ; JSAllReduction jSAllReduction1 = new JSAllReduction ( ( JSMethod ) null , ( Vector ) vector0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
void test2 ( ) throws Throwable { JSAllReduction jSAllReduction0 = new JSAllReduction ( ) ; jSAllReduction0 . printReductions ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDummy ( ) { JSMethod met = this . selectedMethod ( ) ; return ! met . notDummy ( ) ; }
void test0 ( ) throws Throwable { JSJshop jSJshop0 = new JSJshop ( ) ; JSJshopNode jSJshopNode0 = jSJshop0 . getTree ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSJshopNode getTree ( ) { return tree ; }
void test2 ( ) throws Throwable { JSJshop jSJshop0 = new JSJshop ( ) ; JSPlanningDomain jSPlanningDomain0 = jSJshop0 . dom ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSPlanningDomain dom ( ) { return dom ; }
void test4 ( ) throws Throwable { JSJshop jSJshop0 = new JSJshop ( ) ; JSJshopNode jSJshopNode0 = jSJshop0 . tree ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSJshopNode tree ( ) { return tree ; }
void test5 ( ) throws Throwable { JSJshop jSJshop0 = new JSJshop ( ) ; JSPlanningProblem jSPlanningProblem0 = jSJshop0 . prob ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSPlanningProblem prob ( ) { return prob ; }
void test7 ( ) throws Throwable { JSJshop jSJshop0 = new JSJshop ( ) ; JSPairPlanTSListNodes jSPairPlanTSListNodes0 = jSJshop0 . getSolution ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSPairPlanTSListNodes getSolution ( ) { return solution ; }
void test8 ( ) throws Throwable { JSJshop jSJshop0 = new JSJshop ( ) ; JSPlan jSPlan0 = jSJshop0 . sol ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSPlan sol ( ) { return sol ; }
void test10 ( ) throws Throwable { JSJshop jSJshop0 = new JSJshop ( ) ; JSListLogicalAtoms jSListLogicalAtoms0 = jSJshop0 . getAddList ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListLogicalAtoms getAddList ( ) { if ( tree = = null ) return null ; return solution . planS ( ) . tState ( ) . addList ( ) ; }
void test11 ( ) throws Throwable { JSJshop jSJshop0 = new JSJshop ( ) ; JSListLogicalAtoms jSListLogicalAtoms0 = jSJshop0 . getDeleteList ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListLogicalAtoms getDeleteList ( ) { if ( tree = = null ) return null ; return solution . planS ( ) . tState ( ) . deleteList ( ) ; }
void test12 ( ) throws Throwable { JSJshop jSJshop0 = new JSJshop ( ) ; BufferedReader bufferedReader0 = jSJshop0 . getBufferedReader ( "r" , "r" , ( JApplet ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" BufferedReader getBufferedReader ( String dir , String file ) { return getBufferedReader ( dir , file ) ; }
void test13 ( ) throws Throwable { JSJshop jSJshop0 = new JSJshop ( ) ; BufferedReader bufferedReader0 = jSJshop0 . getBufferedReader ( "r" , ( String ) null , ( JApplet ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" BufferedReader getBufferedReader ( String dir , String file ) { return getBufferedReader ( dir , file ) ; }
void test0 ( ) throws Throwable { JSPlanningDomain jSPlanningDomain0 = new JSPlanningDomain ( ) ; JSListMethods jSListMethods0 = jSPlanningDomain0 . methods ( ) ; jSListMethods0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test2 ( ) throws Throwable { JSTaskAtom jSTaskAtom0 = new JSTaskAtom ( ) ; JSPlanningDomain jSPlanningDomain0 = new JSPlanningDomain ( ) ; JSState jSState0 = new JSState ( ) ; JSReduction jSReduction0 = new JSReduction ( ) ; JSReduction jSReduction1 = jSTaskAtom0 . reduce ( jSPlanningDomain0 , jSState0 , jSReduction0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
void test3 ( ) throws Throwable { JSPlanningDomain jSPlanningDomain0 = new JSPlanningDomain ( ) ; JSListMethods jSListMethods0 = jSPlanningDomain0 . methods ( ) ; JSTaskAtom jSTaskAtom0 = new JSTaskAtom ( ) ; JSAllReduction jSAllReduction0 = new JSAllReduction ( ) ; JSListAxioms jSListAxioms0 = jSPlanningDomain0 . axioms ( ) ; JSAllReduction jSAllReduction1 = jSListMethods0 . findAllReduction ( jSTaskAtom0 , ( JSState ) null , jSAllReduction0 , jSListAxioms0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
void test0 ( ) throws Throwable { JSListIfThenElse jSListIfThenElse0 = new JSListIfThenElse ( ) ; jSListIfThenElse0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test6 ( ) throws Throwable { JSListIfThenElse jSListIfThenElse0 = new JSListIfThenElse ( ) ; JSSubstitution jSSubstitution0 = new JSSubstitution ( ) ; JSListAxioms jSListAxioms0 = new JSListAxioms ( ) ; JSTasks jSTasks0 = jSListIfThenElse0 . evalPrec ( ( JSState ) null , jSSubstitution0 , jSListAxioms0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSTasks evalPrec ( JSState s , JSSubstitution alpha , JSListAxioms axioms ) { JSPairIfThen pair ; JSTasks then ; JSSubstitution beta ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { pair = ( JSPairIfThen ) this . elementAt ( i ) ; beta = s . satisfies ( pair . ifPart ( ) , alpha , axioms ) ; if ( ! beta . fail ( ) ) { / / JSUtil . flag ( " * * * * Success * * * * * " ) ; / / beta . print ( ) ; then = pair . thenPart ( ) ; return then . applySubstitutionTasks ( beta ) ; } } then = new JSTasks ( ) ; then . makeFail ( ) ; / / JSUtil . flag ( "Failure" ) ; return then ; }
void test8 ( ) throws Throwable { JSListIfThenElse jSListIfThenElse0 = new JSListIfThenElse ( ) ; JSPlanningDomain jSPlanningDomain0 = new JSPlanningDomain ( ) ; JSListAxioms jSListAxioms0 = jSPlanningDomain0 . axioms ( ) ; Vector < Object > vector0 = jSListIfThenElse0 . evalPrecAll ( ( JSState ) null , ( JSSubstitution ) null , jSListAxioms0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" Vector evalPrecAll ( JSState s , JSSubstitution alpha , JSListAxioms axioms ) { JSPairIfThen pair ; JSTasks then ; JSListSubstitution beta ; Vector allReductions = new Vector ( ) ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { pair = ( JSPairIfThen ) this . elementAt ( i ) ; beta = s . satisfiesAll ( pair . ifPart ( ) , alpha , axioms ) ; if ( ! beta . fail ( ) ) { if ( JSJshopVars . flagLevel > 4 ) { JSUtil . print ( "Found an applicable method : " ) ; JSUtil . println ( pair . Name ( ) ) ; } then = ( JSTasks ) pair . thenPart ( ) . clone ( ) ; for ( int k = 0 ; k < beta . size ( ) ; k + + ) allReductions . addElement ( then . applySubstitutionTasks ( ( JSSubstitution ) beta . elementAt ( k ) ) ) ; return allReductions ; } } return allReductions ; }
void test10 ( ) throws Throwable { JSListIfThenElse jSListIfThenElse0 = new JSListIfThenElse ( ) ; JSListIfThenElse jSListIfThenElse1 = jSListIfThenElse0 . standarizerListIfTE ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListIfThenElse standarizerListIfTE ( ) { JSListIfThenElse newList = new JSListIfThenElse ( ) ; JSPairIfThen pair ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { pair = ( JSPairIfThen ) this . elementAt ( i ) ; newList . addElement ( pair . standarizerPIT ( ) ) ; } return newList ; }
void test0 ( ) throws Throwable { JSListOperators jSListOperators0 = new JSListOperators ( ) ; jSListOperators0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test0 ( ) throws Throwable { JSListAxioms jSListAxioms0 = new JSListAxioms ( ) ; jSListAxioms0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test2 ( ) throws Throwable { JSListAxioms jSListAxioms0 = new JSListAxioms ( ) ; JSPlan jSPlan0 = new JSPlan ( ) ; JSListSubstitution jSListSubstitution0 = jSListAxioms0 . TheoremProver ( ( JSListLogicalAtoms ) jSPlan0 , ( JSState ) null , ( JSSubstitution ) null , false ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListSubstitution TheoremProver ( JSListLogicalAtoms conds , JSState S , JSSubstitution alpha , boolean findall ) { JSSubstitution gamma , tetha , kappa ; JSListSubstitution answers , subanswers1 , subanswers2 ; JSPredicateForm e1 ; JSTerm p1 ; JSListLogicalAtoms Rest , conjunct , one ; JSListConjuncts TailAxiom ; JSAxiom axiom ; String str ; answers = new JSListSubstitution ( ) ; if ( conds . size ( ) = = 0 ) { answers . addElement ( new JSSubstitution ( ) ) ; if ( JSJshopVars . flagLevel > 5 ) JSUtil . println ( "Returning successfully from find - satisfiers : No more goals to satisfy" ) ; return answers ; } e1 = ( JSPredicateForm ) conds . elementAt ( 0 ) ; Rest = conds . Cdr ( ) ; str = ( String ) e1 . elementAt ( 0 ) ; if ( JSJshopVars . flagLevel > 6 ) { JSUtil . println ( " " ) ; JSUtil . print ( "Searching satisfiers for" ) ; e1 . applySubstitutionPF ( alpha ) . print ( ) ; } / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / / * If the first word is 'not' do the following * / / * * / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / if ( str . equalsIgnoreCase ( "not" ) ) { e1 = ( JSPredicateForm ) e1 . elementAt ( 1 ) ; one = new JSListLogicalAtoms ( ) ; one . addElement ( e1 ) ; subanswers1 = TheoremProver ( one , S , alpha , false ) ; if ( ! subanswers1 . fail ( ) ) { if ( JSJshopVars . flagLevel > 5 ) JSUtil . println ( "Returning failure from find - satisfiers : Can not find a satisfier" ) ; return answers ; } else return TheoremProver ( Rest , S , alpha , findall ) ; } / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / / * If the first word is 'eval' do the following * / / * * / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / else if ( str . equalsIgnoreCase ( "call" ) ) { p1 = ( ( JSTerm ) e1 . elementAt ( 1 ) ) . applySubstitutionT ( alpha ) ; if ( ! p1 . isGround ( ) ) { if ( JSJshopVars . flagLevel > 5 ) JSUtil . println ( "Returning failure from find - satisfiers : Can not find a satisfier" ) ; return answers ; } JSTerm t = p1 . call ( ) ; if ( t . size ( ) = = 0 ) { if ( JSJshopVars . flagLevel > 5 ) JSUtil . println ( "Returning failure from find - satisfiers : Can not find a satisfier" ) ; return answers ; } else return TheoremProver ( Rest , S , alpha , findall ) ; } / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / / * Else do the following * / / * * / / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / subanswers1 = S . satisfiesTAm ( e1 , alpha ) ; if ( ! subanswers1 . fail ( ) ) { for ( int i = 0 ; i < subanswers1 . size ( ) ; i + + ) { / * tetha = ( JSSubstitution ) alpha . clone ( ) ; tetha . addElements ( ( JSSubstitution ) subanswers1 . elementAt ( i ) ) ; * / tetha = ( JSSubstitution ) ( ( JSSubstitution ) subanswers1 . elementAt ( i ) ) . clone ( ) ; tetha . addElements ( ( JSSubstitution ) alpha . clone ( ) ) ; subanswers2 = TheoremProver ( Rest , S , tetha , findall ) ; if ( ! subanswers2 . fail ( ) ) for ( int j = 0 ; j < subanswers2 . size ( ) ; j + + ) { / * kappa = ( JSSubstitution ) ( ( JSSubstitution ) subanswers1 . elementAt ( i ) ) . clone ( ) ; kappa . addElements ( ( JSSubstitution ) subanswers2 . elementAt ( j ) ) ; * / kappa = ( JSSubstitution ) ( ( JSSubstitution ) subanswers2 . elementAt ( j ) ) . clone ( ) ; kappa . addElements ( ( JSSubstitution ) subanswers1 . elementAt ( i ) ) ; answers . addElement ( kappa ) ; if ( ( answers . size ( ) = = 1 ) & & ( ! findall ) ) return answers ; } } } for ( int i = 0 ; i < this . size ( ) ; i + + ) { axiom = ( ( JSAxiom ) this . elementAt ( i ) ) . standarizerAxiom ( ) ; gamma = axiom . head ( ) . matches ( e1 , alpha ) ; if ( ! gamma . fail ( ) ) { if ( JSJshopVars . flagLevel > 8 ) { JSUtil . println ( "Goal matches axiom : " ) ; axiom . print ( ) ; } JSJshopVars . VarCounter + + ; TailAxiom = ( JSListConjuncts ) axiom . tail ( ) . clone ( ) ; for ( int k = 0 ; k < TailAxiom . size ( ) ; k + + ) { conjunct = ( JSListLogicalAtoms ) TailAxiom . elementAt ( k ) ; conjunct . addElements ( Rest ) ; / * tetha = ( JSSubstitution ) alpha . clone ( ) ; tetha . addElements ( gamma ) ; * / tetha = ( JSSubstitution ) gamma . clone ( ) ; tetha . addElements ( alpha ) ; subanswers2 = TheoremProver ( conjunct , S , tetha , findall ) ; if ( ! subanswers2 . fail ( ) ) { for ( int j = 0 ; j < subanswers2 . size ( ) ; j + + ) { / * kappa = ( JSSubstitution ) gamma . clone ( ) ; kappa . addElements ( ( JSSubstitution ) subanswers2 . elementAt ( j ) ) ; * / kappa = ( JSSubstitution ) ( ( JSSubstitution ) subanswers2 . elementAt ( j ) ) . clone ( ) ; kappa . addElements ( ( JSSubstitution ) gamma . clone ( ) ) ; answers . addElement ( kappa ) ; if ( ( answers . size ( ) = = 0 ) & & ( ! findall ) ) return answers ; } break ; } } } } if ( JSJshopVars . flagLevel > 5 ) JSUtil . println ( "Returning failure from find - satisfiers : Can not find a satisfier" ) ; return answers ; }
void test0 ( ) throws Throwable { JSPairIfThen jSPairIfThen0 = new JSPairIfThen ( ) ; String string0 = jSPairIfThen0 . Name ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String Name ( ) { return name ; }
void test2 ( ) throws Throwable { JSPairIfThen jSPairIfThen0 = new JSPairIfThen ( ) ; jSPairIfThen0 . setName ( "" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String Name ( ) { return name ; }
void test2 ( ) throws Throwable { StringReader stringReader0 = new StringReader ( "lvF ) 03NHIRG2 [ Se4 [ " ) ; StreamTokenizer streamTokenizer0 = new StreamTokenizer ( ( Reader ) stringReader0 ) ; JSUtil . initParseTable ( streamTokenizer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void initParseTable ( StreamTokenizer tokenizer ) { tokenizer . ordinaryChar ( JSJshopVars . leftPar ) ; tokenizer . ordinaryChar ( JSJshopVars . rightPar ) ; tokenizer . ordinaryChar ( JSJshopVars . colon ) ; tokenizer . ordinaryChar ( JSJshopVars . apostrophe ) ; tokenizer . ordinaryChar ( JSJshopVars . exclamation ) ; tokenizer . ordinaryChar ( JSJshopVars . interrogation ) ; tokenizer . ordinaryChar ( JSJshopVars . percent ) ; tokenizer . ordinaryChar ( JSJshopVars . minus ) ; tokenizer . ordinaryChar ( JSJshopVars . equalT ) ; tokenizer . ordinaryChar ( JSJshopVars . greaterT ) ; tokenizer . ordinaryChar ( JSJshopVars . lessT ) ; tokenizer . ordinaryChar ( JSJshopVars . coma ) ; tokenizer . ordinaryChar ( JSJshopVars . dot ) ; tokenizer . ordinaryChar ( JSJshopVars . astherisk ) ; tokenizer . ordinaryChar ( JSJshopVars . rightBrac ) ; tokenizer . ordinaryChar ( JSJshopVars . leftBrac ) ; tokenizer . ordinaryChar ( JSJshopVars . verticalL ) ; tokenizer . ordinaryChar ( JSJshopVars . plus ) ; tokenizer . ordinaryChar ( JSJshopVars . backquote ) ; tokenizer . ordinaryChar ( JSJshopVars . slash ) ; tokenizer . commentChar ( JSJshopVars . semicolon ) ; }
void test3 ( ) throws Throwable { PipedReader pipedReader0 = new PipedReader ( ) ; BufferedReader bufferedReader0 = new BufferedReader ( ( Reader ) pipedReader0 , 381 ) ; StreamTokenizer streamTokenizer0 = new StreamTokenizer ( ( Reader ) bufferedReader0 ) ; JSUtil . printTokenizer ( streamTokenizer0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void printTokenizer ( StreamTokenizer tokenizer ) { if ( tokenizer . ttype = = StreamTokenizer . TT_NUMBER ) { System . out . print ( new Integer ( ( int ) tokenizer . nval ) . toString ( ) + " " ) ; } if ( tokenizer . ttype = = JSJshopVars . leftPar ) { System . out . print ( " ( " ) ; } if ( tokenizer . ttype = = JSJshopVars . rightPar ) { System . out . print ( " ) " ) ; } if ( tokenizer . ttype = = JSJshopVars . colon ) { System . out . print ( " : " ) ; } if ( tokenizer . ttype = = JSJshopVars . dot ) { System . out . print ( " . " ) ; } if ( tokenizer . ttype = = JSJshopVars . semicolon ) { System . out . print ( " ; " ) ; } if ( tokenizer . ttype = = JSJshopVars . apostrophe ) { System . out . print ( "' " ) ; } if ( tokenizer . ttype = = JSJshopVars . exclamation ) { System . out . print ( " ! " ) ; } if ( tokenizer . ttype = = JSJshopVars . interrogation ) { System . out . print ( " ? " ) ; } if ( tokenizer . ttype = = JSJshopVars . percent ) { System . out . print ( "% " ) ; } if ( tokenizer . ttype = = JSJshopVars . minus ) { System . out . print ( " - " ) ; } if ( tokenizer . ttype = = JSJshopVars . lessT ) { System . out . print ( " < " ) ; } if ( tokenizer . ttype = = JSJshopVars . equalT ) { System . out . print ( " = " ) ; } if ( tokenizer . ttype = = JSJshopVars . greaterT ) { System . out . print ( " > " ) ; } if ( tokenizer . ttype = = JSJshopVars . plus ) { System . out . print ( " + " ) ; } if ( tokenizer . ttype = = JSJshopVars . coma ) { System . out . print ( " , " ) ; } if ( tokenizer . ttype = = JSJshopVars . astherisk ) { System . out . print ( " * " ) ; } if ( tokenizer . ttype = = JSJshopVars . slash ) System . out . print ( " / " ) ; if ( tokenizer . ttype = = JSJshopVars . backquote ) System . out . print ( "` " ) ; if ( tokenizer . ttype = = JSJshopVars . rightBrac ) { System . out . print ( " ] " ) ; } if ( tokenizer . ttype = = JSJshopVars . leftBrac ) { System . out . print ( " [ " ) ; } if ( tokenizer . ttype = = JSJshopVars . verticalL ) { System . out . print ( " | " ) ; } if ( tokenizer . ttype = = tokenizer . TT_WORD ) { System . out . print ( tokenizer . sval + " " ) ; } JSUtil . flag ( "" ) ; / / flag }
void test10 ( ) throws Throwable { char [ ] charArray0 = new char [ 8 ] ; charArray0 [ 3 ] = ' & ' ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 ) ; StreamTokenizer streamTokenizer0 = new StreamTokenizer ( ( Reader ) charArrayReader0 ) ; String string0 = JSUtil . readWord ( streamTokenizer0 , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String readWord ( StreamTokenizer tokenizer , String name ) / / reads everything from the next token on until / / a white space is encountered . / / if the returned string is "%%%" means that an error occur { String w = "" ; String wT = "" ; tokenizer . ordinaryChar ( JSJshopVars . whiteSpace ) ; if ( ! JSUtil . readToken ( tokenizer , name ) ) return "%%%" ; while ( tokenizer . ttype ! = JSJshopVars . whiteSpace & & tokenizer . ttype ! = JSJshopVars . rightPar ) { wT = JSUtil . stringTokenizer ( tokenizer ) ; if ( ! wT . equals ( "%%%" ) ) { / / return "%%%" ; w = w . concat ( wT ) ; } if ( ! JSUtil . readToken ( tokenizer , name ) ) return "%%%" ; } if ( tokenizer . ttype = = JSJshopVars . rightPar ) tokenizer . pushBack ( ) ; tokenizer . whitespaceChars ( JSJshopVars . whiteSpace , JSJshopVars . whiteSpace ) ; / / JSUtil . initParseTable ( tokenizer ) ; / / JSUtil . flag ( "readWord : " + w + " < " ) ; return w ; }
void test11 ( ) throws Throwable { char [ ] charArray0 = new char [ 8 ] ; charArray0 [ 0 ] = 's' ; charArray0 [ 1 ] = ' [ ' ; CharArrayReader charArrayReader0 = new CharArrayReader ( charArray0 ) ; StreamTokenizer streamTokenizer0 = new StreamTokenizer ( ( Reader ) charArrayReader0 ) ; String string0 = JSUtil . readWord ( streamTokenizer0 , ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String readWord ( StreamTokenizer tokenizer , String name ) / / reads everything from the next token on until / / a white space is encountered . / / if the returned string is "%%%" means that an error occur { String w = "" ; String wT = "" ; tokenizer . ordinaryChar ( JSJshopVars . whiteSpace ) ; if ( ! JSUtil . readToken ( tokenizer , name ) ) return "%%%" ; while ( tokenizer . ttype ! = JSJshopVars . whiteSpace & & tokenizer . ttype ! = JSJshopVars . rightPar ) { wT = JSUtil . stringTokenizer ( tokenizer ) ; if ( ! wT . equals ( "%%%" ) ) { / / return "%%%" ; w = w . concat ( wT ) ; } if ( ! JSUtil . readToken ( tokenizer , name ) ) return "%%%" ; } if ( tokenizer . ttype = = JSJshopVars . rightPar ) tokenizer . pushBack ( ) ; tokenizer . whitespaceChars ( JSJshopVars . whiteSpace , JSJshopVars . whiteSpace ) ; / / JSUtil . initParseTable ( tokenizer ) ; / / JSUtil . flag ( "readWord : " + w + " < " ) ; return w ; }
void test0 ( ) throws Throwable { JSTaskAtom jSTaskAtom0 = new JSTaskAtom ( ) ; boolean boolean0 = jSTaskAtom0 . isCompound ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isCompound ( ) { return isCompound ; }
void test2 ( ) throws Throwable { JSTaskAtom jSTaskAtom0 = new JSTaskAtom ( ) ; JSPlanningDomain jSPlanningDomain0 = new JSPlanningDomain ( ) ; JSTState jSTState0 = new JSTState ( ) ; JSPairPlanTState jSPairPlanTState0 = jSTaskAtom0 . seekSimplePlan ( jSPlanningDomain0 , jSTState0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isGround ( ) { JSTerm ti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; if ( ! ti . isGround ( ) ) { return false ; } } return true ; }
void test3 ( ) throws Throwable { JSTaskAtom jSTaskAtom0 = new JSTaskAtom ( ) ; JSJshopNode jSJshopNode0 = new JSJshopNode ( ) ; jSTaskAtom0 . add ( ( Object ) jSJshopNode0 ) ; JSSubstitution jSSubstitution0 = new JSSubstitution ( ) ; JSTaskAtom jSTaskAtom1 = jSTaskAtom0 . applySubstitutionTA ( jSSubstitution0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
void test5 ( ) throws Throwable { JSTaskAtom jSTaskAtom0 = new JSTaskAtom ( ) ; jSTaskAtom0 . add ( ( Object ) "" ) ; JSTaskAtom jSTaskAtom1 = jSTaskAtom0 . cloneTA ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
void test9 ( ) throws Throwable { JSTaskAtom jSTaskAtom0 = new JSTaskAtom ( ) ; jSTaskAtom0 . add ( ( Object ) " [ ] " ) ; JSTaskAtom jSTaskAtom1 = jSTaskAtom0 . standarizerTA ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isPrimitive ( ) { return isPrimitive ; }
void test11 ( ) throws Throwable { JSTaskAtom jSTaskAtom0 = new JSTaskAtom ( ) ; JSJshopNode jSJshopNode0 = new JSJshopNode ( ) ; jSTaskAtom0 . add ( ( Object ) jSJshopNode0 ) ; JSJshopNode jSJshopNode1 = jSTaskAtom0 . findInList ( ( Vector ) jSTaskAtom0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSJshopNode findInList ( Vector list ) { JSJshopNode node ; for ( int i = 0 ; i < list . size ( ) ; i + + ) { node = ( JSJshopNode ) list . elementAt ( i ) ; if ( this . equals ( node . atom ( ) ) ) { return node ; } } return new JSJshopNode ( this , new Vector ( ) ) ; }
void test0 ( ) throws Throwable { JSReduction jSReduction0 = new JSReduction ( ) ; JSMethod jSMethod0 = jSReduction0 . selectedMethod ( ) ; JSTasks jSTasks0 = jSReduction0 . reduction ( ) ; JSReduction jSReduction1 = new JSReduction ( jSMethod0 , jSTasks0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSReduction ( ) { super ( ) ; selectedMethod = new JSMethod ( ) ; reduction = new JSTasks ( ) ; }
void test1 ( ) throws Throwable { JSReduction jSReduction0 = new JSReduction ( ) ; boolean boolean0 = jSReduction0 . isDummy ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isDummy ( ) { JSMethod met = this . selectedMethod ( ) ; return ! met . notDummy ( ) ; }
void test0 ( ) throws Throwable { JSSubstitution jSSubstitution0 = new JSSubstitution ( ) ; jSSubstitution0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test2 ( ) throws Throwable { JSSubstitution jSSubstitution0 = new JSSubstitution ( ) ; jSSubstitution0 . instance ( ( JSTerm ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSTerm instance ( JSTerm var ) { JSPairVarTerm pair ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { pair = ( JSPairVarTerm ) this . elementAt ( i ) ; if ( var . equals ( pair . var ) ) return pair . term ( ) ; } return var ; }
void test4 ( ) throws Throwable { JSSubstitution jSSubstitution0 = new JSSubstitution ( ) ; JSSubstitution jSSubstitution1 = jSSubstitution0 . standarizerSubs ( ) ; JSPairVarTerm jSPairVarTerm0 = new JSPairVarTerm ( ( JSTerm ) null , ( JSTerm ) null ) ; jSSubstitution1 . addElement ( ( Object ) jSPairVarTerm0 ) ; jSSubstitution0 . addElements ( jSSubstitution1 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
void test5 ( ) throws Throwable { JSSubstitution jSSubstitution0 = new JSSubstitution ( ) ; jSSubstitution0 . add ( ( Object ) jSSubstitution0 ) ; jSSubstitution0 . removeElements ( jSSubstitution0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void removeElements ( JSSubstitution l ) { for ( short i = 0 ; i < l . size ( ) ; i + + ) { this . removeElement ( l . elementAt ( i ) ) ; } }
void test6 ( ) throws Throwable { JSTerm jSTerm0 = new JSTerm ( ) ; JSSubstitution jSSubstitution0 = jSTerm0 . matches ( jSTerm0 , ( JSSubstitution ) null ) ; jSSubstitution0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test0 ( ) throws Throwable { JSListPairPlanTStateNodes jSListPairPlanTStateNodes0 = new JSListPairPlanTStateNodes ( ) ; jSListPairPlanTStateNodes0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test0 ( ) throws Throwable { JSListLogicalAtoms jSListLogicalAtoms0 = new JSListLogicalAtoms ( ) ; String string0 = jSListLogicalAtoms0 . Label ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String Label ( ) { return label ; }
void test1 ( ) throws Throwable { JSListLogicalAtoms jSListLogicalAtoms0 = new JSListLogicalAtoms ( ) ; jSListLogicalAtoms0 . setName ( " | " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String Label ( ) { return label ; }
void test2 ( ) throws Throwable { JSListLogicalAtoms jSListLogicalAtoms0 = new JSListLogicalAtoms ( ) ; String string0 = jSListLogicalAtoms0 . Name ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String Name ( ) { return name ; }
void test8 ( ) throws Throwable { JSListLogicalAtoms jSListLogicalAtoms0 = new JSListLogicalAtoms ( ) ; jSListLogicalAtoms0 . add ( ( Object ) null ) ; jSListLogicalAtoms0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test9 ( ) throws Throwable { JSListLogicalAtoms jSListLogicalAtoms0 = new JSListLogicalAtoms ( ) ; JSPredicateForm jSPredicateForm0 = new JSPredicateForm ( ) ; jSListLogicalAtoms0 . add ( ( Object ) jSPredicateForm0 ) ; jSListLogicalAtoms0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" String Label ( ) { return label ; }
void test10 ( ) throws Throwable { JSListLogicalAtoms jSListLogicalAtoms0 = new JSListLogicalAtoms ( ) ; JSListLogicalAtoms jSListLogicalAtoms1 = jSListLogicalAtoms0 . standarizerListLogicalAtoms ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListLogicalAtoms standarizerListLogicalAtoms ( ) { JSListLogicalAtoms newTs = new JSListLogicalAtoms ( ) ; JSTerm vart ; if ( varlist ) { vart = ( JSTerm ) this . elementAt ( 0 ) ; newTs . addElement ( vart . standardizerTerm ( ) ) ; newTs . varlist = true ; return newTs ; } JSPredicateForm t ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { t = ( JSPredicateForm ) this . elementAt ( i ) ; newTs . addElement ( t . standarizerPredicateForm ( ) ) ; } return newTs ; }
void test12 ( ) throws Throwable { JSListLogicalAtoms jSListLogicalAtoms0 = new JSListLogicalAtoms ( ) ; JSListLogicalAtoms jSListLogicalAtoms1 = jSListLogicalAtoms0 . applySubstitutionListLogicalAtoms ( ( JSSubstitution ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListLogicalAtoms applySubstitutionListLogicalAtoms ( JSSubstitution alpha ) { JSListLogicalAtoms nt = new JSListLogicalAtoms ( ) ; JSPredicateForm ti ; JSPredicateForm nti ; JSTerm t , newt ; / * if ( JSJshopVars . flagLevel > 8 ) { JSUtil . print ( "apply subs : " ) ; alpha . print ( ) ; JSUtil . print ( "On JSListLogicalAtoms : " ) ; this . print ( ) ; JSUtil . flag ( "stop" ) ; } * / if ( varlist ) { t = ( JSTerm ) this . elementAt ( 0 ) ; newt = alpha . instance ( t ) ; while ( ! newt . isEmpty ( ) ) { if ( ! ( ( String ) newt . elementAt ( 0 ) ) . equals ( " . " ) ) break ; / / / nti = ( JSPredicateForm ) newt . elementAt ( 1 ) ; nt . addElement ( newt . elementAt ( 1 ) ) ; newt = ( JSTerm ) newt . elementAt ( 2 ) ; } return nt ; } for ( short i = 0 ; i < this . size ( ) ; i + + ) { ti = ( JSPredicateForm ) this . elementAt ( i ) ; / / if ( JSJshopVars . flagLevel > 8 ) / / ti . print ( ) ; nti = ti . applySubstitutionPF ( alpha ) ; / / if ( JSJshopVars . flagLevel > 8 ) / / nti . print ( ) ; nt . addElement ( nti ) ; / * if ( JSJshopVars . flagLevel > 8 ) { nt . print ( ) ; JSUtil . flag ( " < - - applyJSListLogicalAtoms" ) ; } * / } / * if ( JSJshopVars . flagLevel > 8 ) { nt . print ( ) ; JSUtil . flag ( " < - - applyTasks" ) ; } * / return nt ; }
void test14 ( ) throws Throwable { JSListLogicalAtoms jSListLogicalAtoms0 = new JSListLogicalAtoms ( ) ; jSListLogicalAtoms0 . add ( ( Object ) "" ) ; jSListLogicalAtoms0 . add ( ( Object ) null ) ; JSListLogicalAtoms jSListLogicalAtoms1 = jSListLogicalAtoms0 . Cdr ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListLogicalAtoms Cdr ( ) { JSListLogicalAtoms newLA = new JSListLogicalAtoms ( ) ; JSPredicateForm t ; / / added newLA . varlist = this . varlist ; if ( this . varlist ) return newLA ; / / additions end for ( short i = 1 ; i < this . size ( ) ; i + + ) { t = ( JSPredicateForm ) this . elementAt ( i ) ; newLA . addElement ( t ) ; } return newLA ; }
void test2 ( ) throws Throwable { JSPlanningDomain jSPlanningDomain0 = new JSPlanningDomain ( ) ; JSListMethods jSListMethods0 = jSPlanningDomain0 . methods ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListMethods methods ( ) { return methods ; }
void test4 ( ) throws Throwable { JSPlanningDomain jSPlanningDomain0 = new JSPlanningDomain ( ) ; JSListAxioms jSListAxioms0 = jSPlanningDomain0 . axioms ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListAxioms axioms ( ) { return axioms ; }
void test3 ( ) throws Throwable { JSJshopVars jSJshopVars0 = new JSJshopVars ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test1 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; boolean boolean0 = jSPlan0 . isFailure ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFailure ( ) { return isFailure ; }
void test2 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFailure ( ) { return isFailure ; }
void test4 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; jSPlan0 . addWithCost ( ( JSTaskAtom ) null , ( - 353 . 9499437625844 ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFailure ( ) { return isFailure ; }
void test5 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; jSPlan0 . addElements ( jSPlan0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFailure ( ) { return isFailure ; }
void test6 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; jSPlan0 . printPlan ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isFailure ( ) { return isFailure ; }
void test0 ( ) throws Throwable { JSState jSState0 = new JSState ( ) ; JSSubstitution jSSubstitution0 = new JSSubstitution ( ) ; JSListAxioms jSListAxioms0 = new JSListAxioms ( ) ; JSSubstitution jSSubstitution1 = jSState0 . satisfies ( ( JSListLogicalAtoms ) jSState0 , jSSubstitution0 , jSListAxioms0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSSubstitution satisfies ( JSListLogicalAtoms conds , JSSubstitution alpha , JSListAxioms axioms ) / / Tests if conds can be infered from this ( the current state ) and axioms / / modulo the substitution alpha . / / / / If conds can be infered , it returns the first matching substitution / / / / else it returns the failure substitution ( i . e . , calling the method fail ( ) / / to the returned substitution succeeds ) { / / Calls Fusun's inferencing method with parameter all set to "false" JSListSubstitution satisfiers = axioms . TheoremProver ( conds , this , alpha , false ) ; JSSubstitution answer ; if ( satisfiers . fail ( ) ) { answer = new JSSubstitution ( ) ; answer . assignFailure ( ) ; } else { answer = ( JSSubstitution ) alpha . clone ( ) ; answer . addElements ( ( JSSubstitution ) satisfiers . elementAt ( 0 ) ) ; / * if ( conds . size ( ) > 0 ) { this . print ( ) ; } * / } return answer ; }
void test1 ( ) throws Throwable { JSState jSState0 = new JSState ( ) ; JSSubstitution jSSubstitution0 = new JSSubstitution ( ) ; JSListAxioms jSListAxioms0 = new JSListAxioms ( ) ; JSListSubstitution jSListSubstitution0 = jSState0 . satisfiesAll ( ( JSListLogicalAtoms ) jSState0 , jSSubstitution0 , jSListAxioms0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListSubstitution satisfiesAll ( JSListLogicalAtoms conds , JSSubstitution alpha , JSListAxioms axioms ) / / Tests if conds can be infered from this ( the current state ) and axioms / / modulo the substitution alpha . / / / / If conds can be infered , it returns all of the matching substitutions / / / / else it returns an empty list { / / Calls Fusun's inferencing method with parameter all set to "true" int i ; String first = conds . Label ( ) ; boolean findfirst = ! first . equalsIgnoreCase ( "first" ) ; JSSubstitution beta ; JSListSubstitution answers = new JSListSubstitution ( ) ; JSListSubstitution satisfiers = axioms . TheoremProver ( conds , this , alpha , findfirst ) ; for ( i = 0 ; i < satisfiers . size ( ) ; i + + ) { beta = ( JSSubstitution ) ( ( JSSubstitution ) satisfiers . elementAt ( i ) ) . clone ( ) ; beta . addElements ( ( JSSubstitution ) alpha . clone ( ) ) ; answers . addElement ( beta ) ; } return answers ; }
void test0 ( ) throws Throwable { JSPairPlanTState jSPairPlanTState0 = new JSPairPlanTState ( ( JSPlan ) null , ( JSTState ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSPairPlanTState ( ) { super ( ) ; }
void test1 ( ) throws Throwable { JSOperator jSOperator0 = new JSOperator ( ) ; double double0 = jSOperator0 . cost ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" double cost ( ) { return cost ; }
void test1 ( ) throws Throwable { JSPairPlanTSListNodes jSPairPlanTSListNodes0 = new JSPairPlanTSListNodes ( ( JSPairPlanTState ) null , ( Vector ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSPairPlanTSListNodes ( ) { super ( ) ; }
void test0 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; jSPlan0 . makeSucceed ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void makeSucceed ( ) { fail = false ; }
void test1 ( ) throws Throwable { JSTasks jSTasks0 = new JSTasks ( ) ; boolean boolean0 = jSTasks0 . fail ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSTasks ( ) { super ( ) ; }
void test2 ( ) throws Throwable { JSTasks jSTasks0 = new JSTasks ( ) ; jSTasks0 . makeFail ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void makeFail ( ) { fail = true ; }
void test7 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; JSTState jSTState0 = new JSTState ( ) ; JSPlanningDomain jSPlanningDomain0 = new JSPlanningDomain ( ) ; JSPairPlanTState jSPairPlanTState0 = jSPlan0 . seekPlan ( jSTState0 , jSPlanningDomain0 , jSPlan0 , ( Vector ) jSPlan0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSPairPlanTState seekPlan ( JSTState ts , JSPlanningDomain dom , JSPlan pl , Vector listNodes ) { JSPlan ans ; JSPairPlanTState pair ; JSPlan sol ; if ( this . isEmpty ( ) ) { return new JSPairPlanTState ( pl , ts ) ; } JSTaskAtom t = ( JSTaskAtom ) this . firstElement ( ) ; JSTasks rest = ( JSTasks ) this . cdr ( ) ; rest . removeElement ( t ) ; if ( t . isPrimitive ( ) ) { pair = t . seekSimplePlan ( dom , ts ) ; ans = pair . plan ( ) ; if ( ans . isFailure ( ) ) { return pair ; / / failure } else { pl . addElements ( ans ) ; listNodes . addElement ( new JSJshopNode ( t , new Vector ( ) ) ) ; return rest . seekPlan ( pair . tState ( ) , dom , pl , listNodes ) ; } } else { JSJshopNode node ; JSReduction red = new JSReduction ( ) ; red = t . reduce ( dom , ts . state ( ) , red ) ; / / counter to iterate / / on all reductions JSTasks newTasks ; JSMethod selMet = red . selectedMethod ( ) ; while ( ! red . isDummy ( ) ) { newTasks = ( JSTasks ) red . reduction ( ) ; node = new JSJshopNode ( t , newTasks . cloneTasks ( ) ) ; / / JSUtil . flag ( " < - tasks" ) ; newTasks . addElements ( rest ) ; pair = newTasks . seekPlan ( ts , dom , pl , listNodes ) ; if ( ! pair . plan ( ) . isFailure ( ) ) { / / JSUtil . flag ( "reduced" ) ; listNodes . addElement ( node ) ; return pair ; } / / JSUtil . flag ( "iterating" ) ; red = t . reduce ( dom , ts . state ( ) , red ) ; selMet = red . selectedMethod ( ) ; } } ans = new JSPlan ( ) ; ans . assignFailure ( ) ; return new JSPairPlanTState ( ans , new JSTState ( ) ) ; }
void test8 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; JSPlanningDomain jSPlanningDomain0 = new JSPlanningDomain ( ) ; JSListPairPlanTStateNodes jSListPairPlanTStateNodes0 = jSPlan0 . seekPlanAll ( ( JSTState ) null , jSPlanningDomain0 , true ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListPairPlanTStateNodes seekPlanAll ( JSTState ts , JSPlanningDomain dom , boolean All ) { JSListPairPlanTStateNodes results , plans = new JSListPairPlanTStateNodes ( ) ; JSPairPlanTSListNodes ptl ; JSPlan ans ; JSPairPlanTState pair ; JSPlan sol ; JSJshopNode node ; Vector listnodes ; JSTaskAtom ta ; JSTState tts ; if ( this . isEmpty ( ) ) { if ( JSJshopVars . flagLevel > 1 ) JSUtil . println ( "Returning successfully from find - plan : No more tasks to plan" ) ; pair = new JSPairPlanTState ( ( new JSPlan ( ) ) , ts ) ; ptl = new JSPairPlanTSListNodes ( pair , new Vector ( ) ) ; plans . addElement ( ptl ) ; return plans ; } JSTaskAtom t = ( JSTaskAtom ) this . firstElement ( ) ; if ( JSJshopVars . flagLevel > 2 ) { JSUtil . println ( " " ) ; JSUtil . print ( "Searching a plan for" ) ; t . print ( ) ; } JSTasks rest = ( JSTasks ) this . cdr ( ) ; if ( t . isPrimitive ( ) ) { pair = t . seekSimplePlan ( dom , ts ) ; ans = pair . plan ( ) ; if ( ans . isFailure ( ) ) { if ( JSJshopVars . flagLevel > 1 ) JSUtil . println ( "Returning failure from find - plan : Can not find an operator" ) ; return plans ; / / failure - empty list } results = rest . seekPlanAll ( pair . tState ( ) , dom , All ) ; if ( results . isEmpty ( ) ) return plans ; ta = ( JSTaskAtom ) ans . elementAt ( 0 ) ; node = new JSJshopNode ( t , new Vector ( ) ) ; for ( int i = 0 ; i < results . size ( ) ; i + + ) { ptl = ( JSPairPlanTSListNodes ) results . elementAt ( i ) ; ptl . planS ( ) . plan ( ) . insertWithCost ( 0 , ta , ans . elementCost ( 0 ) ) ; ptl . listNodes ( ) . insertElementAt ( node , 0 ) ; plans . addElement ( ptl ) ; } return plans ; } JSAllReduction red = new JSAllReduction ( ) ; red = dom . methods ( ) . findAllReduction ( t , ts . state ( ) , red , dom . axioms ( ) ) ; JSTasks newTasks ; JSMethod selMet = red . selectedMethod ( ) ; if ( JSJshopVars . flagLevel > 1 & & red . isDummy ( ) ) JSUtil . println ( "Returning failure from find - plan : Can not find an applicable method" ) ; while ( ! red . isDummy ( ) ) { if ( JSJshopVars . flagLevel > 4 ) { JSUtil . println ( "The reductions are : " ) ; red . printReductions ( ) ; } for ( int k = 0 ; k < red . reductions ( ) . size ( ) ; k + + ) { newTasks = ( JSTasks ) red . reductions ( ) . elementAt ( k ) ; node = new JSJshopNode ( ( JSTaskAtom ) t . clone ( ) , newTasks . cloneTasks ( ) ) ; newTasks . addElements ( rest ) ; results = newTasks . seekPlanAll ( new JSTState ( ts ) , dom , All ) ; if ( results . isEmpty ( ) ) continue ; for ( int j = 0 ; j < results . size ( ) ; j + + ) { ptl = ( JSPairPlanTSListNodes ) results . elementAt ( j ) ; ptl . listNodes ( ) . addElement ( node ) ; plans . addElement ( ptl ) ; if ( plans . size ( ) > = 1 & & ! All ) return plans ; } } red = dom . methods ( ) . findAllReduction ( t , ts . state ( ) , red , dom . axioms ( ) ) ; selMet = red . selectedMethod ( ) ; } return plans ; }
void test9 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; JSSubstitution jSSubstitution0 = new JSSubstitution ( ) ; JSTasks jSTasks0 = jSPlan0 . applySubstitutionTasks ( jSSubstitution0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSTasks applySubstitutionTasks ( JSSubstitution alpha ) { JSTasks nt = new JSTasks ( ) ; JSTaskAtom ti ; JSTaskAtom nti ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { ti = ( JSTaskAtom ) this . elementAt ( i ) ; / / ti . print ( ) ; nti = ti . applySubstitutionTA ( alpha ) ; / / nti . print ( ) ; nt . addElement ( nti ) ; / / nt . print ( ) ; / / JSUtil . flag ( " < - - applyJSTasks" ) ; } / * nt . print ( ) ; / / JSUtil . flag ( " < - - applyTasks" ) ; * / return nt ; }
void test11 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; jSPlan0 . add ( ( Object ) null ) ; JSTaskAtom jSTaskAtom0 = new JSTaskAtom ( ) ; boolean boolean0 = jSPlan0 . contains ( jSTaskAtom0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean contains ( JSTaskAtom t ) { JSTaskAtom el ; for ( int i = this . size ( ) - 1 ; i > - 1 ; i - - ) { el = ( JSTaskAtom ) this . elementAt ( i ) ; / * JSUtil . print ( "JSTaskAtom : " ) ; el . print ( ) ; JSUtil . print ( " equals : " ) ; t . print ( ) ; JSUtil . flag ( " ? " ) ; * / if ( t . equals ( el ) ) { / / JSUtil . flag ( "YES" ) ; return true ; } } / / JSUtil . flag ( "NO" ) ; return false ; }
void test12 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; JSTasks jSTasks0 = jSPlan0 . cloneTasks ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSTasks cloneTasks ( ) { JSTasks newTs = new JSTasks ( ) ; JSTaskAtom t ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { t = ( JSTaskAtom ) this . elementAt ( i ) ; newTs . addElement ( t . cloneTA ( ) ) ; } return newTs ; }
void test13 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; JSTasks jSTasks0 = jSPlan0 . cdr ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSTasks cdr ( ) { JSTasks newTs = new JSTasks ( ) ; JSTaskAtom t ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { t = ( JSTaskAtom ) this . elementAt ( i ) ; newTs . addElement ( t ) ; } return newTs ; }
void test14 ( ) throws Throwable { JSPlan jSPlan0 = new JSPlan ( ) ; JSTasks jSTasks0 = jSPlan0 . standarizerTasks ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSTasks standarizerTasks ( ) { JSTasks newTs = new JSTasks ( ) ; JSTaskAtom t ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { t = ( JSTaskAtom ) this . elementAt ( i ) ; newTs . addElement ( t . standarizerTA ( ) ) ; } return newTs ; }
void test0 ( ) throws Throwable { JSListPlanningProblem jSListPlanningProblem0 = new JSListPlanningProblem ( ) ; jSListPlanningProblem0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test0 ( ) throws Throwable { JSListConjuncts jSListConjuncts0 = new JSListConjuncts ( ) ; jSListConjuncts0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test1 ( ) throws Throwable { JSJshopNode jSJshopNode0 = new JSJshopNode ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSJshopNode ( ) { super ( ) ; }
void test3 ( ) throws Throwable { JSTaskAtom jSTaskAtom0 = new JSTaskAtom ( ) ; JSJshopNode jSJshopNode0 = new JSJshopNode ( jSTaskAtom0 , jSTaskAtom0 ) ; JSJshopNode jSJshopNode1 = new JSJshopNode ( jSJshopNode0 , ( Vector ) jSTaskAtom0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSJshopNode ( ) { super ( ) ; }
void test0 ( ) throws Throwable { JSTerm jSTerm0 = new JSTerm ( ) ; JSSubstitution jSSubstitution0 = jSTerm0 . matches ( jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSSubstitution matches ( JSPredicateForm t ) { return this . matches ( t , new JSSubstitution ( ) ) ; }
void test10 ( ) throws Throwable { JSTerm jSTerm0 = new JSTerm ( ) ; Object object0 = new Object ( ) ; jSTerm0 . insertElementAt ( object0 , 0 ) ; jSTerm0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test11 ( ) throws Throwable { JSTerm jSTerm0 = new JSTerm ( ) ; Object object0 = new Object ( ) ; jSTerm0 . add ( object0 ) ; JSTerm jSTerm1 = jSTerm0 . cloneT ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
void test12 ( ) throws Throwable { JSTerm jSTerm0 = new JSTerm ( ) ; jSTerm0 . makeVariable ( ) ; jSTerm0 . add ( ( Object ) "" ) ; jSTerm0 . matches ( jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isVariable ( ) { return isVariable ; }
void test13 ( ) throws Throwable { JSTerm jSTerm0 = new JSTerm ( ) ; jSTerm0 . add ( ( Object ) jSTerm0 ) ; JSTerm jSTerm1 = jSTerm0 . call ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSSubstitution matches ( JSPredicateForm t ) { return this . matches ( t , new JSSubstitution ( ) ) ; }
void test14 ( ) throws Throwable { JSTerm jSTerm0 = new JSTerm ( ) ; JSTerm jSTerm1 = new JSTerm ( ) ; jSTerm1 . add ( ( Object ) " - : wV" ) ; jSTerm0 . add ( ( Object ) jSTerm0 ) ; jSTerm1 . add ( ( Object ) jSTerm1 ) ; JSTerm jSTerm2 = jSTerm0 . call ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
void test15 ( ) throws Throwable { JSTerm jSTerm0 = new JSTerm ( ) ; boolean boolean0 = jSTerm0 . equals ( jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
void test17 ( ) throws Throwable { JSTerm jSTerm0 = new JSTerm ( ) ; boolean boolean0 = jSTerm0 . isGround ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isGround ( ) { JSTerm ti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; if ( ! ti . isGround ( ) ) { return false ; } } return true ; }
void test22 ( ) throws Throwable { JSTerm jSTerm0 = new JSTerm ( ) ; jSTerm0 . makeVariable ( ) ; JSTerm jSTerm1 = jSTerm0 . call ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isGround ( ) { JSTerm ti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; if ( ! ti . isGround ( ) ) { return false ; } } return true ; }
void test0 ( ) throws Throwable { JSListSubstitution jSListSubstitution0 = new JSListSubstitution ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSSubstitution ( ) { super ( ) ; fail = false ; }
void test1 ( ) throws Throwable { JSListSubstitution jSListSubstitution0 = new JSListSubstitution ( ) ; boolean boolean0 = jSListSubstitution0 . fail ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSListSubstitution ( ) { super ( ) ; }
void test2 ( ) throws Throwable { JSListSubstitution jSListSubstitution0 = new JSListSubstitution ( ) ; JSSubstitution jSSubstitution0 = new JSSubstitution ( ) ; jSListSubstitution0 . add ( ( Object ) jSSubstitution0 ) ; jSListSubstitution0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test3 ( ) throws Throwable { JSListSubstitution jSListSubstitution0 = new JSListSubstitution ( ) ; jSListSubstitution0 . add ( ( Object ) null ) ; jSListSubstitution0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test0 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . addsub ( ( float ) 1L , ( float ) 1L , 37 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test1 ( ) throws Throwable { JSEvaluate jSEvaluate0 = new JSEvaluate ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" <UnknownFocalMethodText>
void test2 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . mult ( ( float ) 0L , ( float ) 0L ) ; JSTerm jSTerm1 = JSEvaluate . applyOperatorUnary ( "not" , jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test3 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . floor ( ( float ) 1298L ) ; JSTerm jSTerm1 = JSEvaluate . applyOperator ( " > d" , jSTerm0 , jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test5 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . ceil ( 1 . 0F ) ; jSTerm0 . add ( ( Object ) jSTerm0 ) ; JSEvaluate . applyOperatorUnary ( "r" , jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSTerm applyOperatorUnary ( String op , JSTerm operant1t ) { if ( ! operant1t . isGround ( ) ) return new JSTerm ( ) ; if ( op . equals ( "not" ) ) return not ( operant1t ) ; / * if ( op . equals ( "Min" ) ) return minElement ( operant1t ) ; if ( op . equals ( "Max" ) ) return maxElement ( operant1t ) ; * / float operant1 = numericValue ( operant1t ) ; if ( fail ) return new JSTerm ( ) ; if ( op . equalsIgnoreCase ( "floor" ) ) return floor ( operant1 ) ; if ( op . equalsIgnoreCase ( "ceil" ) ) return ceil ( operant1 ) ; JSUtil . println ( "Undefined function to be evaluated in Call statement" ) ; return new JSTerm ( ) ; }
void test6 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . div ( 1677 . 4355F , ( - 1 . 0F ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test7 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . div ( ( float ) 0L , ( float ) 0L ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSTerm div ( float operant1 , float operant2 ) { if ( operant2 = = 0 ) return new JSTerm ( ) ; float sum = operant1 / operant2 ; JSTerm t = new JSTerm ( ) ; t . makeConstant ( ) ; t . addElement ( String . valueOf ( sum ) ) ; return t ; }
void test8 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . greater ( 1585 . 4467F , 1507 . 9133F ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test9 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . greater ( 221 . 29706F , 221 . 29706F ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSTerm greater ( float operant1 , float operant2 ) { JSTerm t = new JSTerm ( ) ; if ( operant1 < = operant2 ) return t ; t . makeConstant ( ) ; t . addElement ( "t" ) ; return t ; }
void test10 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . greaterequal ( ( - 3 . 1356442F ) , ( - 3 . 1356442F ) ) ; JSTerm jSTerm1 = JSEvaluate . applyOperator ( "r . Fxx & Ng7Un ( Rh ] : 9\"" , jSTerm0 , jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test11 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . equal ( 0 . 0F , 0 . 0F ) ; JSTerm jSTerm1 = JSEvaluate . minElement ( jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test12 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . equal ( ( - 1 . 0F ) , 1677 . 4355F ) ; JSTerm jSTerm1 = JSEvaluate . maxElement ( jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
void test13 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . notequal ( ( - 176 . 5001F ) , 10 . 539635F ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test14 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . maxOf ( ( - 1776 . 912F ) , ( - 1776 . 912F ) ) ; JSTerm jSTerm1 = JSEvaluate . applyOperator ( "notequal" , jSTerm0 , jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test15 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . minOf ( ( - 1560 . 3221F ) , ( - 1560 . 3221F ) ) ; JSTerm jSTerm1 = JSEvaluate . applyOperatorUnary ( "ceil" , jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test16 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . minOf ( ( - 176 . 5001F ) , 10 . 539635F ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test17 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . maxOf ( ( - 3 . 1356442F ) , ( - 446 . 88623F ) ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test18 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . ceil ( 1585 . 4467F ) ; JSTerm jSTerm1 = JSEvaluate . applyOperator ( " < " , jSTerm0 , jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test19 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . floor ( 3 . 4028235E38F ) ; JSTerm jSTerm1 = JSEvaluate . applyOperator ( "member" , jSTerm0 , jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test20 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . floor ( 221 . 29706F ) ; JSTerm jSTerm1 = JSEvaluate . maxElement ( jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test21 ( ) throws Throwable { int int0 = JSEvaluate . OperantNum ( "not" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int OperantNum ( String op ) { if ( op . equalsIgnoreCase ( "not" ) | | op . equalsIgnoreCase ( "floor" ) | | op . equalsIgnoreCase ( "ceil" ) ) return 1 ; else return 2 ; }
void test22 ( ) throws Throwable { int int0 = JSEvaluate . OperantNum ( "Line " ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int OperantNum ( String op ) { if ( op . equalsIgnoreCase ( "not" ) | | op . equalsIgnoreCase ( "floor" ) | | op . equalsIgnoreCase ( "ceil" ) ) return 1 ; else return 2 ; }
void test23 ( ) throws Throwable { int int0 = JSEvaluate . OperantNum ( "floor" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int OperantNum ( String op ) { if ( op . equalsIgnoreCase ( "not" ) | | op . equalsIgnoreCase ( "floor" ) | | op . equalsIgnoreCase ( "ceil" ) ) return 1 ; else return 2 ; }
void test24 ( ) throws Throwable { int int0 = JSEvaluate . OperantNum ( "ceil" ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" int OperantNum ( String op ) { if ( op . equalsIgnoreCase ( "not" ) | | op . equalsIgnoreCase ( "floor" ) | | op . equalsIgnoreCase ( "ceil" ) ) return 1 ; else return 2 ; }
void test25 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . floor ( 221 . 29706F ) ; JSTerm jSTerm1 = JSEvaluate . applyOperator ( "max" , jSTerm0 , jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test26 ( ) throws Throwable { JSTerm jSTerm0 = JSEvaluate . mult ( 0 . 0F , 0 . 0F ) ; JSTerm jSTerm1 = JSEvaluate . applyOperatorUnary ( "foFor" , jSTerm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean isConstant ( ) { return isConstant ; }
void test2 ( ) throws Throwable { JSTState jSTState0 = new JSTState ( ( JSState ) null , ( JSListLogicalAtoms ) null , ( JSListLogicalAtoms ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSTState ( ) { super ( ) ; }
void test1 ( ) throws Throwable { JSPredicateForm jSPredicateForm0 = new JSPredicateForm ( ( String ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" JSPredicateForm ( ) { super ( ) ; }
void test5 ( ) throws Throwable { JSPredicateForm jSPredicateForm0 = new JSPredicateForm ( ) ; jSPredicateForm0 . print ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" void print ( ) { JSPlanningProblem el ; for ( short i = 0 ; i < this . size ( ) ; i + + ) { el = ( JSPlanningProblem ) this . elementAt ( i ) ; el . print ( ) ; } }
void test6 ( ) throws Throwable { JSPredicateForm jSPredicateForm0 = new JSPredicateForm ( ) ; jSPredicateForm0 . add ( ( Object ) " [ ] " ) ; StringBuffer stringBuffer0 = jSPredicateForm0 . toStr ( ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" StringBuffer toStr ( ) { StringBuffer res = new StringBuffer ( ) ; if ( this . size ( ) = = 0 ) { JSUtil . println ( "Predicateform . print ( ) : 0 elements" ) ; return res ; } res . append ( " ( " ) ; / / Added 11 / 28 / 200 String str = ( String ) this . elementAt ( 0 ) ; res . append ( str ) ; if ( str . equalsIgnoreCase ( "not" ) ) { JSPredicateForm el ; el = ( JSPredicateForm ) this . elementAt ( 1 ) ; res . append ( el . toStr ( ) ) ; } else { / / Additions end JSTerm el ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { el = ( JSTerm ) this . elementAt ( i ) ; res . append ( el . toStr ( ) ) ; } } res . append ( " ) " ) ; / / JSUtil . flag10 ( "Atom : " + res ) ; return res ; }
void test11 ( ) throws Throwable { JSPredicateForm jSPredicateForm0 = new JSPredicateForm ( ) ; boolean boolean0 = jSPredicateForm0 . equals ( ( JSPredicateForm ) null ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
void test12 ( ) throws Throwable { JSPredicateForm jSPredicateForm0 = new JSPredicateForm ( ) ; jSPredicateForm0 . add ( ( Object ) " / " ) ; boolean boolean0 = jSPredicateForm0 . equals ( jSPredicateForm0 ) ; "<AssertPlaceHolder>" ; } "<FocalMethod>" boolean equals ( JSPredicateForm t ) / * t is a ground term * / { if ( t = = null ) return false ; String functor = ( String ) this . elementAt ( 0 ) ; if ( this . size ( ) ! = t . size ( ) ) { return false ; } String functor1 = ( String ) t . elementAt ( 0 ) ; if ( ! functor . equalsIgnoreCase ( functor1 ) ) { return false ; } / / Added 11 / 28 / 00 if ( functor . equalsIgnoreCase ( "not" ) ) { JSPredicateForm e1 = ( JSPredicateForm ) this . elementAt ( 1 ) ; JSPredicateForm e2 = ( JSPredicateForm ) t . elementAt ( 1 ) ; return e1 . equals ( e2 ) ; } / / Additions end JSTerm ti ; JSTerm oti ; for ( short i = 1 ; i < this . size ( ) ; i + + ) { ti = ( JSTerm ) this . elementAt ( i ) ; oti = ( JSTerm ) t . elementAt ( i ) ; if ( ! ti . equals ( oti ) ) { return false ; } } return true ; }
